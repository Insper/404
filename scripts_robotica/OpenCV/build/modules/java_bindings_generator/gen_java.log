
Remapped configured files (3):
{u'/home/borg/404/scripts_robotica/OpenCV/modules/core/misc/java/src/java/core+Core.jcode.in': u'/home/borg/404/scripts_robotica/OpenCV/build/configured/modules/core/misc/java/src/java/core+Core.jcode',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/java/generator/android/java/org/opencv/android/OpenCVLoader.java.in': u'/home/borg/404/scripts_robotica/OpenCV/build/configured/modules/java/generator/android/java/org/opencv/android/OpenCVLoader.java',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/java/generator/src/java/org/opencv/osgi/OpenCVNativeLoader.java.in': u'/home/borg/404/scripts_robotica/OpenCV/build/configured/modules/java/generator/src/java/org/opencv/osgi/OpenCVNativeLoader.java'}

=== MODULE: core (/home/borg/404/scripts_robotica/OpenCV/modules/core) ===


Files (4):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/core/include/opencv2/core/base.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/core/include/opencv2/core.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/core/include/opencv2/core/utility.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/core/misc/java/src/cpp/core_manual.hpp']

Common headers (0):
[]
ok: class CLASS ::.Core : , name: Core, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/core/include/opencv2/core/base.hpp =====
Namespaces: set([u'cv.ogl', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv'])

--- Incoming ---
[   u'enum cv.Error.Code',
    '',
    [],
    [   [u'const cv.Error.StsOk', u'0', [], [], None, ''],
        [u'const cv.Error.StsBackTrace', u'-1', [], [], None, ''],
        [u'const cv.Error.StsError', u'-2', [], [], None, ''],
        [u'const cv.Error.StsInternal', u'-3', [], [], None, ''],
        [u'const cv.Error.StsNoMem', u'-4', [], [], None, ''],
        [u'const cv.Error.StsBadArg', u'-5', [], [], None, ''],
        [u'const cv.Error.StsBadFunc', u'-6', [], [], None, ''],
        [u'const cv.Error.StsNoConv', u'-7', [], [], None, ''],
        [u'const cv.Error.StsAutoTrace', u'-8', [], [], None, ''],
        [u'const cv.Error.HeaderIsNull', u'-9', [], [], None, ''],
        [u'const cv.Error.BadImageSize', u'-10', [], [], None, ''],
        [u'const cv.Error.BadOffset', u'-11', [], [], None, ''],
        [u'const cv.Error.BadDataPtr', u'-12', [], [], None, ''],
        [u'const cv.Error.BadStep', u'-13', [], [], None, ''],
        [u'const cv.Error.BadModelOrChSeq', u'-14', [], [], None, ''],
        [u'const cv.Error.BadNumChannels', u'-15', [], [], None, ''],
        [u'const cv.Error.BadNumChannel1U', u'-16', [], [], None, ''],
        [u'const cv.Error.BadDepth', u'-17', [], [], None, ''],
        [u'const cv.Error.BadAlphaChannel', u'-18', [], [], None, ''],
        [u'const cv.Error.BadOrder', u'-19', [], [], None, ''],
        [u'const cv.Error.BadOrigin', u'-20', [], [], None, ''],
        [u'const cv.Error.BadAlign', u'-21', [], [], None, ''],
        [u'const cv.Error.BadCallBack', u'-22', [], [], None, ''],
        [u'const cv.Error.BadTileSize', u'-23', [], [], None, ''],
        [u'const cv.Error.BadCOI', u'-24', [], [], None, ''],
        [u'const cv.Error.BadROISize', u'-25', [], [], None, ''],
        [u'const cv.Error.MaskIsTiled', u'-26', [], [], None, ''],
        [u'const cv.Error.StsNullPtr', u'-27', [], [], None, ''],
        [u'const cv.Error.StsVecLengthErr', u'-28', [], [], None, ''],
        [   u'const cv.Error.StsFilterStructContentErr',
            u'-29',
            [],
            [],
            None,
            ''],
        [   u'const cv.Error.StsKernelStructContentErr',
            u'-30',
            [],
            [],
            None,
            ''],
        [u'const cv.Error.StsFilterOffsetErr', u'-31', [], [], None, ''],
        [u'const cv.Error.StsBadSize', u'-201', [], [], None, ''],
        [u'const cv.Error.StsDivByZero', u'-202', [], [], None, ''],
        [u'const cv.Error.StsInplaceNotSupported', u'-203', [], [], None, ''],
        [u'const cv.Error.StsObjectNotFound', u'-204', [], [], None, ''],
        [u'const cv.Error.StsUnmatchedFormats', u'-205', [], [], None, ''],
        [u'const cv.Error.StsBadFlag', u'-206', [], [], None, ''],
        [u'const cv.Error.StsBadPoint', u'-207', [], [], None, ''],
        [u'const cv.Error.StsBadMask', u'-208', [], [], None, ''],
        [u'const cv.Error.StsUnmatchedSizes', u'-209', [], [], None, ''],
        [u'const cv.Error.StsUnsupportedFormat', u'-210', [], [], None, ''],
        [u'const cv.Error.StsOutOfRange', u'-211', [], [], None, ''],
        [u'const cv.Error.StsParseError', u'-212', [], [], None, ''],
        [u'const cv.Error.StsNotImplemented', u'-213', [], [], None, ''],
        [u'const cv.Error.StsBadMemBlock', u'-214', [], [], None, ''],
        [u'const cv.Error.StsAssert', u'-215', [], [], None, ''],
        [u'const cv.Error.GpuNotSupported', u'-216', [], [], None, ''],
        [u'const cv.Error.GpuApiCallError', u'-217', [], [], None, ''],
        [u'const cv.Error.OpenGlNotSupported', u'-218', [], [], None, ''],
        [u'const cv.Error.OpenGlApiCallError', u'-219', [], [], None, ''],
        [u'const cv.Error.OpenCLApiCallError', u'-220', [], [], None, ''],
        [   u'const cv.Error.OpenCLDoubleNotSupported',
            u'-221',
            [],
            [],
            None,
            ''],
        [u'const cv.Error.OpenCLInitError', u'-222', [], [], None, ''],
        [u'const cv.Error.OpenCLNoAMDBlasFft', u'-223', [], [], None, '']],
    None]
ok: CONST StsOk=0
ok: CONST StsBackTrace=-1
ok: CONST StsError=-2
ok: CONST StsInternal=-3
ok: CONST StsNoMem=-4
ok: CONST StsBadArg=-5
ok: CONST StsBadFunc=-6
ok: CONST StsNoConv=-7
ok: CONST StsAutoTrace=-8
ok: CONST HeaderIsNull=-9
ok: CONST BadImageSize=-10
ok: CONST BadOffset=-11
ok: CONST BadDataPtr=-12
ok: CONST BadStep=-13
ok: CONST BadModelOrChSeq=-14
ok: CONST BadNumChannels=-15
ok: CONST BadNumChannel1U=-16
ok: CONST BadDepth=-17
ok: CONST BadAlphaChannel=-18
ok: CONST BadOrder=-19
ok: CONST BadOrigin=-20
ok: CONST BadAlign=-21
ok: CONST BadCallBack=-22
ok: CONST BadTileSize=-23
ok: CONST BadCOI=-24
ok: CONST BadROISize=-25
ok: CONST MaskIsTiled=-26
ok: CONST StsNullPtr=-27
ok: CONST StsVecLengthErr=-28
ok: CONST StsFilterStructContentErr=-29
ok: CONST StsKernelStructContentErr=-30
ok: CONST StsFilterOffsetErr=-31
ok: CONST StsBadSize=-201
ok: CONST StsDivByZero=-202
ok: CONST StsInplaceNotSupported=-203
ok: CONST StsObjectNotFound=-204
ok: CONST StsUnmatchedFormats=-205
ok: CONST StsBadFlag=-206
ok: CONST StsBadPoint=-207
ok: CONST StsBadMask=-208
ok: CONST StsUnmatchedSizes=-209
ok: CONST StsUnsupportedFormat=-210
ok: CONST StsOutOfRange=-211
ok: CONST StsParseError=-212
ok: CONST StsNotImplemented=-213
ok: CONST StsBadMemBlock=-214
ok: CONST StsAssert=-215
ok: CONST GpuNotSupported=-216
ok: CONST GpuApiCallError=-217
ok: CONST OpenGlNotSupported=-218
ok: CONST OpenGlApiCallError=-219
ok: CONST OpenCLApiCallError=-220
ok: CONST OpenCLDoubleNotSupported=-221
ok: CONST OpenCLInitError=-222
ok: CONST OpenCLNoAMDBlasFft=-223

--- Incoming ---
[   u'enum cv.DecompTypes',
    '',
    [],
    [   [u'const cv.DECOMP_LU', u'0', [], [], None, ''],
        [u'const cv.DECOMP_SVD', u'1', [], [], None, ''],
        [u'const cv.DECOMP_EIG', u'2', [], [], None, ''],
        [u'const cv.DECOMP_CHOLESKY', u'3', [], [], None, ''],
        [u'const cv.DECOMP_QR', u'4', [], [], None, ''],
        [u'const cv.DECOMP_NORMAL', u'16', [], [], None, '']],
    None]
ok: CONST DECOMP_LU=0
ok: CONST DECOMP_SVD=1
ok: CONST DECOMP_EIG=2
ok: CONST DECOMP_CHOLESKY=3
ok: CONST DECOMP_QR=4
ok: CONST DECOMP_NORMAL=16

--- Incoming ---
[   u'enum cv.NormTypes',
    '',
    [],
    [   [u'const cv.NORM_INF', u'1', [], [], None, ''],
        [u'const cv.NORM_L1', u'2', [], [], None, ''],
        [u'const cv.NORM_L2', u'4', [], [], None, ''],
        [u'const cv.NORM_L2SQR', u'5', [], [], None, ''],
        [u'const cv.NORM_HAMMING', u'6', [], [], None, ''],
        [u'const cv.NORM_HAMMING2', u'7', [], [], None, ''],
        [u'const cv.NORM_TYPE_MASK', u'7', [], [], None, ''],
        [u'const cv.NORM_RELATIVE', u'8', [], [], None, ''],
        [u'const cv.NORM_MINMAX', u'32', [], [], None, '']],
    None]
ok: CONST NORM_INF=1
ok: CONST NORM_L1=2
ok: CONST NORM_L2=4
ok: CONST NORM_L2SQR=5
ok: CONST NORM_HAMMING=6
ok: CONST NORM_HAMMING2=7
ok: CONST NORM_TYPE_MASK=7
ok: CONST NORM_RELATIVE=8
ok: CONST NORM_MINMAX=32

--- Incoming ---
[   u'enum cv.CmpTypes',
    '',
    [],
    [   [u'const cv.CMP_EQ', u'0', [], [], None, ''],
        [u'const cv.CMP_GT', u'1', [], [], None, ''],
        [u'const cv.CMP_GE', u'2', [], [], None, ''],
        [u'const cv.CMP_LT', u'3', [], [], None, ''],
        [u'const cv.CMP_LE', u'4', [], [], None, ''],
        [u'const cv.CMP_NE', u'5', [], [], None, '']],
    None]
ok: CONST CMP_EQ=0
ok: CONST CMP_GT=1
ok: CONST CMP_GE=2
ok: CONST CMP_LT=3
ok: CONST CMP_LE=4
ok: CONST CMP_NE=5

--- Incoming ---
[   u'enum cv.GemmFlags',
    '',
    [],
    [   [u'const cv.GEMM_1_T', u'1', [], [], None, ''],
        [u'const cv.GEMM_2_T', u'2', [], [], None, ''],
        [u'const cv.GEMM_3_T', u'4', [], [], None, '']],
    None]
ok: CONST GEMM_1_T=1
ok: CONST GEMM_2_T=2
ok: CONST GEMM_3_T=4

--- Incoming ---
[   u'enum cv.DftFlags',
    '',
    [],
    [   [u'const cv.DFT_INVERSE', u'1', [], [], None, ''],
        [u'const cv.DFT_SCALE', u'2', [], [], None, ''],
        [u'const cv.DFT_ROWS', u'4', [], [], None, ''],
        [u'const cv.DFT_COMPLEX_OUTPUT', u'16', [], [], None, ''],
        [u'const cv.DFT_REAL_OUTPUT', u'32', [], [], None, ''],
        [u'const cv.DFT_COMPLEX_INPUT', u'64', [], [], None, ''],
        [u'const cv.DCT_INVERSE', u'DFT_INVERSE', [], [], None, ''],
        [u'const cv.DCT_ROWS', u'DFT_ROWS', [], [], None, '']],
    None]
ok: CONST DFT_INVERSE=1
ok: CONST DFT_SCALE=2
ok: CONST DFT_ROWS=4
ok: CONST DFT_COMPLEX_OUTPUT=16
ok: CONST DFT_REAL_OUTPUT=32
ok: CONST DFT_COMPLEX_INPUT=64
ok: CONST DCT_INVERSE=DFT_INVERSE
ok: CONST DCT_ROWS=DFT_ROWS

--- Incoming ---
[   u'enum cv.BorderTypes',
    '',
    [],
    [   [u'const cv.BORDER_CONSTANT', u'0', [], [], None, ''],
        [u'const cv.BORDER_REPLICATE', u'1', [], [], None, ''],
        [u'const cv.BORDER_REFLECT', u'2', [], [], None, ''],
        [u'const cv.BORDER_WRAP', u'3', [], [], None, ''],
        [u'const cv.BORDER_REFLECT_101', u'4', [], [], None, ''],
        [u'const cv.BORDER_TRANSPARENT', u'5', [], [], None, ''],
        [   u'const cv.BORDER_REFLECT101',
            u'BORDER_REFLECT_101',
            [],
            [],
            None,
            ''],
        [u'const cv.BORDER_DEFAULT', u'BORDER_REFLECT_101', [], [], None, ''],
        [u'const cv.BORDER_ISOLATED', u'16', [], [], None, '']],
    None]
ok: CONST BORDER_CONSTANT=0
ok: CONST BORDER_REPLICATE=1
ok: CONST BORDER_REFLECT=2
ok: CONST BORDER_WRAP=3
ok: CONST BORDER_REFLECT_101=4
ok: CONST BORDER_TRANSPARENT=5
ok: CONST BORDER_REFLECT101=BORDER_REFLECT_101
ok: CONST BORDER_DEFAULT=BORDER_REFLECT_101
ok: CONST BORDER_ISOLATED=16

--- Incoming ---
[u'cv.cubeRoot', u'float', [], [[u'float', u'val', u'', []]], u'float']
ok: FUNC <float cv..cubeRoot [ARG float val=]>

--- Incoming ---
[   u'cv.fastAtan2',
    u'float',
    [],
    [[u'float', u'y', u'', []], [u'float', u'x', u'', []]],
    u'float']
ok: FUNC <float cv..fastAtan2 [ARG float y=, ARG float x=]>

--- Incoming ---
[u'cv.ipp.useIPP', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ipp..useIPP []>

--- Incoming ---
[u'cv.ipp.setUseIPP', u'void', [], [[u'bool', u'flag', u'', []]], u'void']
ok: FUNC <void cv.ipp..setUseIPP [ARG bool flag=]>

--- Incoming ---
[u'cv.ipp.getIppVersion', u'String', [], [], u'String']
ok: FUNC <String cv.ipp..getIppVersion []>

--- Incoming ---
[u'cv.ipp.useIPP_NotExact', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ipp..useIPP_NotExact []>

--- Incoming ---
[   u'cv.ipp.setUseIPP_NotExact',
    u'void',
    [],
    [[u'bool', u'flag', u'', []]],
    u'void']
ok: FUNC <void cv.ipp..setUseIPP_NotExact [ARG bool flag=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/core/include/opencv2/core.hpp =====
Namespaces: set([u'cv.ogl', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv'])

--- Incoming ---
[   u'enum cv.SortFlags',
    '',
    [],
    [   [u'const cv.SORT_EVERY_ROW', u'0', [], [], None, ''],
        [u'const cv.SORT_EVERY_COLUMN', u'1', [], [], None, ''],
        [u'const cv.SORT_ASCENDING', u'0', [], [], None, ''],
        [u'const cv.SORT_DESCENDING', u'16', [], [], None, '']],
    None]
ok: CONST SORT_EVERY_ROW=0
ok: CONST SORT_EVERY_COLUMN=1
ok: CONST SORT_ASCENDING=0
ok: CONST SORT_DESCENDING=16

--- Incoming ---
[   u'enum cv.CovarFlags',
    '',
    [],
    [   [u'const cv.COVAR_SCRAMBLED', u'0', [], [], None, ''],
        [u'const cv.COVAR_NORMAL', u'1', [], [], None, ''],
        [u'const cv.COVAR_USE_AVG', u'2', [], [], None, ''],
        [u'const cv.COVAR_SCALE', u'4', [], [], None, ''],
        [u'const cv.COVAR_ROWS', u'8', [], [], None, ''],
        [u'const cv.COVAR_COLS', u'16', [], [], None, '']],
    None]
ok: CONST COVAR_SCRAMBLED=0
ok: CONST COVAR_NORMAL=1
ok: CONST COVAR_USE_AVG=2
ok: CONST COVAR_SCALE=4
ok: CONST COVAR_ROWS=8
ok: CONST COVAR_COLS=16

--- Incoming ---
[   u'enum cv.KmeansFlags',
    '',
    [],
    [   [u'const cv.KMEANS_RANDOM_CENTERS', u'0', [], [], None, ''],
        [u'const cv.KMEANS_PP_CENTERS', u'2', [], [], None, ''],
        [u'const cv.KMEANS_USE_INITIAL_LABELS', u'1', [], [], None, '']],
    None]
ok: CONST KMEANS_RANDOM_CENTERS=0
ok: CONST KMEANS_PP_CENTERS=2
ok: CONST KMEANS_USE_INITIAL_LABELS=1

--- Incoming ---
[   u'enum cv.ReduceTypes',
    '',
    [],
    [   [u'const cv.REDUCE_SUM', u'0', [], [], None, ''],
        [u'const cv.REDUCE_AVG', u'1', [], [], None, ''],
        [u'const cv.REDUCE_MAX', u'2', [], [], None, ''],
        [u'const cv.REDUCE_MIN', u'3', [], [], None, '']],
    None]
manual: CONST REDUCE_SUM=0
manual: CONST REDUCE_AVG=1
manual: CONST REDUCE_MAX=2
manual: CONST REDUCE_MIN=3

--- Incoming ---
[   u'cv.borderInterpolate',
    u'int',
    [],
    [   [u'int', u'p', u'', []],
        [u'int', u'len', u'', []],
        [u'int', u'borderType', u'', []]],
    u'int']
ok: FUNC <int cv..borderInterpolate [ARG int p=, ARG int len=, ARG int borderType=]>

--- Incoming ---
[   u'cv.copyMakeBorder',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'top', u'', []],
        [u'int', u'bottom', u'', []],
        [u'int', u'left', u'', []],
        [u'int', u'right', u'', []],
        [u'int', u'borderType', u'', []],
        [u'Scalar', u'value', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..copyMakeBorder [ARG Mat src=, ARG Mat dst=, ARG int top=, ARG int bottom=, ARG int left=, ARG int right=, ARG int borderType=, ARG Scalar value=Scalar()]>

--- Incoming ---
[   u'cv.add',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..add [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.subtract',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..subtract [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.multiply',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..multiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..divide [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   [u'double', u'scale', u'', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..divide [ARG double scale=, ARG Mat src2=, ARG Mat dst=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.scaleAdd',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..scaleAdd [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.addWeighted',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src2', '', []],
        [u'double', u'beta', u'', []],
        [u'double', u'gamma', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..addWeighted [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG double beta=, ARG double gamma=, ARG Mat dst=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.convertScaleAbs',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []]],
    u'void']
ok: FUNC <void cv..convertScaleAbs [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0]>

--- Incoming ---
[   u'cv.convertFp16',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convertFp16 [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.LUT',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'lut', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..LUT [ARG Mat src=, ARG Mat lut=, ARG Mat dst=]>

--- Incoming ---
[u'cv.sum', u'Scalar', [u'=sumElems'], [['Mat', u'src', '', []]], u'Scalar']
ok: FUNC <Scalar cv..sum [ARG Mat src=]>

--- Incoming ---
[u'cv.countNonZero', u'int', [], [['Mat', u'src', '', []]], u'int']
ok: FUNC <int cv..countNonZero [ARG Mat src=]>

--- Incoming ---
[   u'cv.findNonZero',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'idx', '', ['/O']]],
    u'void']
ok: FUNC <void cv..findNonZero [ARG Mat src=, ARG Mat idx=]>

--- Incoming ---
[   u'cv.mean',
    u'Scalar',
    [],
    [['Mat', u'src', '', []], ['Mat', u'mask', u'Mat()', []]],
    u'Scalar']
ok: FUNC <Scalar cv..mean [ARG Mat src=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.meanStdDev',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mean', '', ['/O']],
        ['Mat', u'stddev', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..meanStdDev [ARG Mat src=, ARG vector_double mean=, ARG vector_double stddev=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.norm',
    u'double',
    [],
    [   ['Mat', u'src1', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'double']
ok: FUNC <double cv..norm [ARG Mat src1=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.norm',
    u'double',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'double']
ok: FUNC <double cv..norm [ARG Mat src1=, ARG Mat src2=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.PSNR',
    u'double',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        [u'double', u'R', u'255.', []]],
    u'double']
ok: FUNC <double cv..PSNR [ARG Mat src1=, ARG Mat src2=, ARG double R=255.]>

--- Incoming ---
[   u'cv.batchDistance',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dist', '', ['/O']],
        [u'int', u'dtype', u'', []],
        ['Mat', u'nidx', '', ['/O']],
        [u'int', u'normType', u'NORM_L2', []],
        [u'int', u'K', u'0', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'update', u'0', []],
        [u'bool', u'crosscheck', u'false', []]],
    u'void']
ok: FUNC <void cv..batchDistance [ARG Mat src1=, ARG Mat src2=, ARG Mat dist=, ARG int dtype=, ARG Mat nidx=, ARG int normType=NORM_L2, ARG int K=0, ARG Mat mask=Mat(), ARG int update=0, ARG bool crosscheck=false]>

--- Incoming ---
[   u'cv.normalize',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []],
        [u'int', u'norm_type', u'NORM_L2', []],
        [u'int', u'dtype', u'-1', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..normalize [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0, ARG int norm_type=NORM_L2, ARG int dtype=-1, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.minMaxLoc',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'double*', u'minVal', u'', ['/O']],
        [u'double*', u'maxVal', u'0', ['/O']],
        [u'Point*', u'minLoc', u'0', ['/O']],
        [u'Point*', u'maxLoc', u'0', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
manual: FUNC <void cv..minMaxLoc [ARG Mat src=, ARG double * minVal=, ARG double * maxVal=0, ARG Point * minLoc=0, ARG Point * maxLoc=0, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.reduce',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dim', u'', []],
        [u'int', u'rtype', u'', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..reduce [ARG Mat src=, ARG Mat dst=, ARG int dim=, ARG int rtype=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.merge',
    u'void',
    [],
    [['vector_Mat', u'mv', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..merge [ARG vector_Mat mv=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.split',
    u'void',
    [],
    [['Mat', u'm', '', []], ['vector_Mat', u'mv', '', ['/O']]],
    u'void']
ok: FUNC <void cv..split [ARG Mat m=, ARG vector_Mat mv=]>

--- Incoming ---
[   u'cv.mixChannels',
    u'void',
    [],
    [   ['vector_Mat', u'src', '', []],
        ['vector_Mat', u'dst', '', ['/IO']],
        [u'vector_int', u'fromTo', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..mixChannels [ARG vector_Mat src=, ARG vector_Mat dst=, ARG vector_int fromTo=]>

--- Incoming ---
[   u'cv.extractChannel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'coi', u'', []]],
    u'void']
ok: FUNC <void cv..extractChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>

--- Incoming ---
[   u'cv.insertChannel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'int', u'coi', u'', []]],
    u'void']
ok: FUNC <void cv..insertChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>

--- Incoming ---
[   u'cv.flip',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flipCode', u'', []]],
    u'void']
ok: FUNC <void cv..flip [ARG Mat src=, ARG Mat dst=, ARG int flipCode=]>

--- Incoming ---
[   u'enum cv.RotateFlags',
    '',
    [],
    [   [u'const cv.ROTATE_90_CLOCKWISE', u'0', [], [], None, ''],
        [u'const cv.ROTATE_180', u'1', [], [], None, ''],
        [u'const cv.ROTATE_90_COUNTERCLOCKWISE', u'2', [], [], None, '']],
    None]
ok: CONST ROTATE_90_CLOCKWISE=0
ok: CONST ROTATE_180=1
ok: CONST ROTATE_90_COUNTERCLOCKWISE=2

--- Incoming ---
[   u'cv.rotate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'rotateCode', u'', []]],
    u'void']
ok: FUNC <void cv..rotate [ARG Mat src=, ARG Mat dst=, ARG int rotateCode=]>

--- Incoming ---
[   u'cv.repeat',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'int', u'ny', u'', []],
        [u'int', u'nx', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..repeat [ARG Mat src=, ARG int ny=, ARG int nx=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.hconcat',
    u'void',
    [],
    [['vector_Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..hconcat [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.vconcat',
    u'void',
    [],
    [['vector_Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..vconcat [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.bitwise_and',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..bitwise_and [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_or',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..bitwise_or [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_xor',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..bitwise_xor [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_not',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..bitwise_not [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.absdiff',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..absdiff [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.copyTo',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', '', []]],
    u'void']
ok: FUNC <void cv..copyTo [ARG Mat src=, ARG Mat dst=, ARG Mat mask=]>

--- Incoming ---
[   u'cv.inRange',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'lowerb', '', []],
        ['Mat', u'upperb', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..inRange [ARG Mat src=, ARG Scalar lowerb=, ARG Scalar upperb=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.compare',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'cmpop', u'', []]],
    u'void']
ok: FUNC <void cv..compare [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int cmpop=]>

--- Incoming ---
[   u'cv.min',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..min [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.max',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..max [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.sqrt',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..sqrt [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.pow',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'double', u'power', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..pow [ARG Mat src=, ARG double power=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.exp',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..exp [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.log',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..log [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.polarToCart',
    u'void',
    [],
    [   ['Mat', u'magnitude', '', []],
        ['Mat', u'angle', '', []],
        ['Mat', u'x', '', ['/O']],
        ['Mat', u'y', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void']
ok: FUNC <void cv..polarToCart [ARG Mat magnitude=, ARG Mat angle=, ARG Mat x=, ARG Mat y=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.cartToPolar',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'magnitude', '', ['/O']],
        ['Mat', u'angle', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void']
ok: FUNC <void cv..cartToPolar [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=, ARG Mat angle=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.phase',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'angle', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void']
ok: FUNC <void cv..phase [ARG Mat x=, ARG Mat y=, ARG Mat angle=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.magnitude',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'magnitude', '', ['/O']]],
    u'void']
ok: FUNC <void cv..magnitude [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=]>

--- Incoming ---
[   u'cv.checkRange',
    u'bool',
    [],
    [   ['Mat', u'a', '', []],
        [u'bool', u'quiet', u'true', []],
        [u'Point*', u'pos', u'0', ['/O']],
        [u'double', u'minVal', u'-DBL_MAX', []],
        [u'double', u'maxVal', u'DBL_MAX', []]],
    u'bool']
ok: FUNC <bool cv..checkRange [ARG Mat a=, ARG bool quiet=true, ARG  * pos=0, ARG double minVal=-DBL_MAX, ARG double maxVal=DBL_MAX]>

--- Incoming ---
[   u'cv.patchNaNs',
    u'void',
    [],
    [['Mat', u'a', '', ['/IO']], [u'double', u'val', u'0', []]],
    u'void']
ok: FUNC <void cv..patchNaNs [ARG Mat a=, ARG double val=0]>

--- Incoming ---
[   u'cv.gemm',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src3', '', []],
        [u'double', u'beta', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void']
ok: FUNC <void cv..gemm [ARG Mat src1=, ARG Mat src2=, ARG double alpha=, ARG Mat src3=, ARG double beta=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.mulTransposed',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'bool', u'aTa', u'', []],
        ['Mat', u'delta', u'Mat()', []],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..mulTransposed [ARG Mat src=, ARG Mat dst=, ARG bool aTa=, ARG Mat delta=Mat(), ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.transpose',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..transpose [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.transform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'm', '', []]],
    u'void']
ok: FUNC <void cv..transform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>

--- Incoming ---
[   u'cv.perspectiveTransform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'm', '', []]],
    u'void']
ok: FUNC <void cv..perspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>

--- Incoming ---
[   u'cv.completeSymm',
    u'void',
    [],
    [['Mat', u'm', '', ['/IO']], [u'bool', u'lowerToUpper', u'false', []]],
    u'void']
ok: FUNC <void cv..completeSymm [ARG Mat m=, ARG bool lowerToUpper=false]>

--- Incoming ---
[   u'cv.setIdentity',
    u'void',
    [],
    [   ['Mat', u'mtx', '', ['/IO']],
        [u'Scalar', u's', u'Scalar(1)', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..setIdentity [ARG Mat mtx=, ARG Scalar s=Scalar(1)]>

--- Incoming ---
[u'cv.determinant', u'double', [], [['Mat', u'mtx', '', []]], u'double']
ok: FUNC <double cv..determinant [ARG Mat mtx=]>

--- Incoming ---
[u'cv.trace', u'Scalar', [], [['Mat', u'mtx', '', []]], u'Scalar']
ok: FUNC <Scalar cv..trace [ARG Mat mtx=]>

--- Incoming ---
[   u'cv.invert',
    u'double',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'DECOMP_LU', []]],
    u'double']
ok: FUNC <double cv..invert [ARG Mat src=, ARG Mat dst=, ARG int flags=DECOMP_LU]>

--- Incoming ---
[   u'cv.solve',
    u'bool',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'DECOMP_LU', []]],
    u'bool']
ok: FUNC <bool cv..solve [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int flags=DECOMP_LU]>

--- Incoming ---
[   u'cv.sort',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..sort [ARG Mat src=, ARG Mat dst=, ARG int flags=]>

--- Incoming ---
[   u'cv.sortIdx',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..sortIdx [ARG Mat src=, ARG Mat dst=, ARG int flags=]>

--- Incoming ---
[   u'cv.solveCubic',
    u'int',
    [],
    [['Mat', u'coeffs', '', []], ['Mat', u'roots', '', ['/O']]],
    u'int']
ok: FUNC <int cv..solveCubic [ARG Mat coeffs=, ARG Mat roots=]>

--- Incoming ---
[   u'cv.solvePoly',
    u'double',
    [],
    [   ['Mat', u'coeffs', '', []],
        ['Mat', u'roots', '', ['/O']],
        [u'int', u'maxIters', u'300', []]],
    u'double']
ok: FUNC <double cv..solvePoly [ARG Mat coeffs=, ARG Mat roots=, ARG int maxIters=300]>

--- Incoming ---
[   u'cv.eigen',
    u'bool',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'eigenvalues', '', ['/O']],
        ['Mat', u'eigenvectors', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv..eigen [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=Mat()]>

--- Incoming ---
[   u'cv.eigenNonSymmetric',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'eigenvalues', '', ['/O']],
        ['Mat', u'eigenvectors', '', ['/O']]],
    u'void']
ok: FUNC <void cv..eigenNonSymmetric [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=]>

--- Incoming ---
[   u'cv.calcCovarMatrix',
    u'void',
    [],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'covar', '', ['/O']],
        ['Mat', u'mean', '', ['/IO']],
        [u'int', u'flags', u'', []],
        [u'int', u'ctype', u'CV_64F', []]],
    u'void']
ok: FUNC <void cv..calcCovarMatrix [ARG Mat samples=, ARG Mat covar=, ARG Mat mean=, ARG int flags=, ARG int ctype=CV_64F]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        [u'int', u'maxComponents', u'0', []]],
    u'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG int maxComponents=0]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [u'=PCACompute2'],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        ['Mat', u'eigenvalues', '', ['/O']],
        [u'int', u'maxComponents', u'0', []]],
    u'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG int maxComponents=0]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        [u'double', u'retainedVariance', u'', []]],
    u'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG double retainedVariance=]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [u'=PCACompute2'],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        ['Mat', u'eigenvalues', '', ['/O']],
        [u'double', u'retainedVariance', u'', []]],
    u'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG double retainedVariance=]>

--- Incoming ---
[   u'cv.PCAProject',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', []],
        ['Mat', u'eigenvectors', '', []],
        ['Mat', u'result', '', ['/O']]],
    u'void']
ok: FUNC <void cv..PCAProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>

--- Incoming ---
[   u'cv.PCABackProject',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', []],
        ['Mat', u'eigenvectors', '', []],
        ['Mat', u'result', '', ['/O']]],
    u'void']
ok: FUNC <void cv..PCABackProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>

--- Incoming ---
[   u'cv.SVDecomp',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'w', '', ['/O']],
        ['Mat', u'u', '', ['/O']],
        ['Mat', u'vt', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void']
ok: FUNC <void cv..SVDecomp [ARG Mat src=, ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG int flags=0]>

--- Incoming ---
[   u'cv.SVBackSubst',
    u'void',
    [],
    [   ['Mat', u'w', '', []],
        ['Mat', u'u', '', []],
        ['Mat', u'vt', '', []],
        ['Mat', u'rhs', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..SVBackSubst [ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG Mat rhs=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.Mahalanobis',
    u'double',
    [],
    [   ['Mat', u'v1', '', []],
        ['Mat', u'v2', '', []],
        ['Mat', u'icovar', '', []]],
    u'double']
ok: FUNC <double cv..Mahalanobis [ARG Mat v1=, ARG Mat v2=, ARG Mat icovar=]>

--- Incoming ---
[   u'cv.dft',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [u'int', u'nonzeroRows', u'0', []]],
    u'void']
ok: FUNC <void cv..dft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>

--- Incoming ---
[   u'cv.idft',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [u'int', u'nonzeroRows', u'0', []]],
    u'void']
ok: FUNC <void cv..idft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>

--- Incoming ---
[   u'cv.dct',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void']
ok: FUNC <void cv..dct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.idct',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void']
ok: FUNC <void cv..idct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.mulSpectrums',
    u'void',
    [],
    [   ['Mat', u'a', '', []],
        ['Mat', u'b', '', []],
        ['Mat', u'c', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'bool', u'conjB', u'false', []]],
    u'void']
ok: FUNC <void cv..mulSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>

--- Incoming ---
[u'cv.getOptimalDFTSize', u'int', [], [[u'int', u'vecsize', u'', []]], u'int']
ok: FUNC <int cv..getOptimalDFTSize [ARG int vecsize=]>

--- Incoming ---
[u'cv.setRNGSeed', u'void', [], [[u'int', u'seed', u'', []]], u'void']
ok: FUNC <void cv..setRNGSeed [ARG int seed=]>

--- Incoming ---
[   u'cv.randu',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'low', '', []],
        ['Mat', u'high', '', []]],
    u'void']
ok: FUNC <void cv..randu [ARG Mat dst=, ARG double low=, ARG double high=]>

--- Incoming ---
[   u'cv.randn',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mean', '', []],
        ['Mat', u'stddev', '', []]],
    u'void']
ok: FUNC <void cv..randn [ARG Mat dst=, ARG double mean=, ARG double stddev=]>

--- Incoming ---
[   u'cv.randShuffle',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        [u'double', u'iterFactor', u'1.', []],
        [u'RNG*', u'rng', u'0', []]],
    u'void']
ok: FUNC <void cv..randShuffle [ARG Mat dst=, ARG double iterFactor=1., ARG RNG * rng=0]>

--- Incoming ---
[   u'enum cv.PCA.Flags',
    '',
    [],
    [   [u'const cv.PCA.DATA_AS_ROW', u'0', [], [], None, ''],
        [u'const cv.PCA.DATA_AS_COL', u'1', [], [], None, ''],
        [u'const cv.PCA.USE_AVG', u'2', [], [], None, '']],
    None]
class not found: CONST DATA_AS_ROW=0
ok: CONST PCA_DATA_AS_ROW=0
class not found: CONST DATA_AS_COL=1
ok: CONST PCA_DATA_AS_COL=1
class not found: CONST USE_AVG=2
ok: CONST PCA_USE_AVG=2

--- Incoming ---
[   u'enum cv.SVD.Flags',
    '',
    [],
    [   [u'const cv.SVD.MODIFY_A', u'1', [], [], None, ''],
        [u'const cv.SVD.NO_UV', u'2', [], [], None, ''],
        [u'const cv.SVD.FULL_UV', u'4', [], [], None, '']],
    None]
class not found: CONST MODIFY_A=1
manual: CONST SVD_MODIFY_A=1
class not found: CONST NO_UV=2
manual: CONST SVD_NO_UV=2
class not found: CONST FULL_UV=4
manual: CONST SVD_FULL_UV=4

--- Incoming ---
[   u'enum cv.RNG.<unnamed>',
    '',
    [],
    [   [u'const cv.RNG.UNIFORM', u'0', [], [], None, ''],
        [u'const cv.RNG.NORMAL', u'1', [], [], None, '']],
    None]
class not found: CONST UNIFORM=0
ok: CONST RNG_UNIFORM=0
class not found: CONST NORMAL=1
ok: CONST RNG_NORMAL=1

--- Incoming ---
[   u'cv.kmeans',
    u'double',
    [],
    [   ['Mat', u'data', '', []],
        [u'int', u'K', u'', []],
        ['Mat', u'bestLabels', '', ['/IO']],
        [u'TermCriteria', u'criteria', u'', []],
        [u'int', u'attempts', u'', []],
        [u'int', u'flags', u'', []],
        ['Mat', u'centers', u'Mat()', ['/O']]],
    u'double']
ok: FUNC <double cv..kmeans [ARG Mat data=, ARG int K=, ARG Mat bestLabels=, ARG TermCriteria criteria=, ARG int attempts=, ARG int flags=, ARG Mat centers=Mat()]>

--- Incoming ---
[   u'enum cv.Formatter.FormatType',
    '',
    [],
    [   [u'const cv.Formatter.FMT_DEFAULT', u'0', [], [], None, ''],
        [u'const cv.Formatter.FMT_MATLAB', u'1', [], [], None, ''],
        [u'const cv.Formatter.FMT_CSV', u'2', [], [], None, ''],
        [u'const cv.Formatter.FMT_PYTHON', u'3', [], [], None, ''],
        [u'const cv.Formatter.FMT_NUMPY', u'4', [], [], None, ''],
        [u'const cv.Formatter.FMT_C', u'5', [], [], None, '']],
    None]
class not found: CONST FMT_DEFAULT=0
ok: CONST Formatter_FMT_DEFAULT=0
class not found: CONST FMT_MATLAB=1
ok: CONST Formatter_FMT_MATLAB=1
class not found: CONST FMT_CSV=2
ok: CONST Formatter_FMT_CSV=2
class not found: CONST FMT_PYTHON=3
ok: CONST Formatter_FMT_PYTHON=3
class not found: CONST FMT_NUMPY=4
ok: CONST Formatter_FMT_NUMPY=4
class not found: CONST FMT_C=5
ok: CONST Formatter_FMT_C=5

--- Incoming ---
[u'class cv.Algorithm', '', [], [], None]
duplicated: CLASS cv::.Algorithm : 

--- Incoming ---
[u'cv.Algorithm.clear', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.Algorithm.clear []>

--- Incoming ---
[   u'cv.Algorithm.write',
    u'void',
    ['/C'],
    [   [u'Ptr_FileStorage', u'fs', u'', ['/C', '/Ref']],
        [u'String', u'name', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Algorithm.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[   u'cv.Algorithm.read',
    u'void',
    ['/V'],
    [[u'FileNode', u'fn', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Algorithm.read [ARG FileNode fn=]>

--- Incoming ---
[u'cv.Algorithm.empty', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.Algorithm.empty []>

--- Incoming ---
[   u'cv.Algorithm.save',
    u'void',
    ['/C', '/V'],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Algorithm.save [ARG String filename=]>

--- Incoming ---
[u'cv.Algorithm.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.Algorithm.getDefaultName []>

--- Incoming ---
[   u'enum struct cv.Param',
    '',
    [],
    [   [u'const cv.Param.INT', u'0', [], [], None, ''],
        [u'const cv.Param.BOOLEAN', u'1', [], [], None, ''],
        [u'const cv.Param.REAL', u'2', [], [], None, ''],
        [u'const cv.Param.STRING', u'3', [], [], None, ''],
        [u'const cv.Param.MAT', u'4', [], [], None, ''],
        [u'const cv.Param.MAT_VECTOR', u'5', [], [], None, ''],
        [u'const cv.Param.ALGORITHM', u'6', [], [], None, ''],
        [u'const cv.Param.FLOAT', u'7', [], [], None, ''],
        [u'const cv.Param.UNSIGNED_INT', u'8', [], [], None, ''],
        [u'const cv.Param.UINT64', u'9', [], [], None, ''],
        [u'const cv.Param.UCHAR', u'11', [], [], None, ''],
        [u'const cv.Param.SCALAR', u'12', [], [], None, '']],
    None]
class not found: CONST INT=0
ok: CONST Param_INT=0
class not found: CONST BOOLEAN=1
ok: CONST Param_BOOLEAN=1
class not found: CONST REAL=2
ok: CONST Param_REAL=2
class not found: CONST STRING=3
ok: CONST Param_STRING=3
class not found: CONST MAT=4
ok: CONST Param_MAT=4
class not found: CONST MAT_VECTOR=5
ok: CONST Param_MAT_VECTOR=5
class not found: CONST ALGORITHM=6
ok: CONST Param_ALGORITHM=6
class not found: CONST FLOAT=7
ok: CONST Param_FLOAT=7
class not found: CONST UNSIGNED_INT=8
ok: CONST Param_UNSIGNED_INT=8
class not found: CONST UINT64=9
ok: CONST Param_UINT64=9
class not found: CONST UCHAR=11
ok: CONST Param_UCHAR=11
class not found: CONST SCALAR=12
ok: CONST Param_SCALAR=12


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/core/include/opencv2/core/utility.hpp =====
Namespaces: set([u'cv.ogl', u'cv.instr', u'cv.utils', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv.samples', u'cv'])

--- Incoming ---
[u'cv.setNumThreads', u'void', [], [[u'int', u'nthreads', u'', []]], u'void']
ok: FUNC <void cv..setNumThreads [ARG int nthreads=]>

--- Incoming ---
[u'cv.getNumThreads', u'int', [], [], u'int']
ok: FUNC <int cv..getNumThreads []>

--- Incoming ---
[u'cv.getThreadNum', u'int', [], [], u'int']
ok: FUNC <int cv..getThreadNum []>

--- Incoming ---
[u'cv.getBuildInformation', u'String', [], [], u'String']
ok: FUNC <String cv..getBuildInformation []>

--- Incoming ---
[u'cv.getVersionString', u'String', [], [], u'String']
ok: FUNC <String cv..getVersionString []>

--- Incoming ---
[u'cv.getVersionMajor', u'int', [], [], u'int']
ok: FUNC <int cv..getVersionMajor []>

--- Incoming ---
[u'cv.getVersionMinor', u'int', [], [], u'int']
ok: FUNC <int cv..getVersionMinor []>

--- Incoming ---
[u'cv.getVersionRevision', u'int', [], [], u'int']
ok: FUNC <int cv..getVersionRevision []>

--- Incoming ---
[u'cv.getTickCount', u'int64', [], [], u'int64']
ok: FUNC <int64 cv..getTickCount []>

--- Incoming ---
[u'cv.getTickFrequency', u'double', [], [], u'double']
ok: FUNC <double cv..getTickFrequency []>

--- Incoming ---
[u'class cv.TickMeter', '', [], [], None]
ok: class CLASS cv::.TickMeter : , name: TickMeter, base: 

--- Incoming ---
[u'cv.TickMeter.TickMeter', '', [], [], None]
ok: FUNC < cv.TickMeter.TickMeter []>

--- Incoming ---
[u'cv.TickMeter.start', u'void', [], [], u'void']
ok: FUNC <void cv.TickMeter.start []>

--- Incoming ---
[u'cv.TickMeter.stop', u'void', [], [], u'void']
ok: FUNC <void cv.TickMeter.stop []>

--- Incoming ---
[u'cv.TickMeter.getTimeTicks', u'int64', ['/C'], [], u'int64']
ok: FUNC <int64 cv.TickMeter.getTimeTicks []>

--- Incoming ---
[u'cv.TickMeter.getTimeMicro', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.TickMeter.getTimeMicro []>

--- Incoming ---
[u'cv.TickMeter.getTimeMilli', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.TickMeter.getTimeMilli []>

--- Incoming ---
[u'cv.TickMeter.getTimeSec', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.TickMeter.getTimeSec []>

--- Incoming ---
[u'cv.TickMeter.getCounter', u'int64', ['/C'], [], u'int64']
ok: FUNC <int64 cv.TickMeter.getCounter []>

--- Incoming ---
[u'cv.TickMeter.reset', u'void', [], [], u'void']
ok: FUNC <void cv.TickMeter.reset []>

--- Incoming ---
[u'cv.getCPUTickCount', u'int64', [], [], u'int64']
ok: FUNC <int64 cv..getCPUTickCount []>

--- Incoming ---
[   u'cv.checkHardwareSupport',
    u'bool',
    [],
    [[u'int', u'feature', u'', []]],
    u'bool']
manual: FUNC <bool cv..checkHardwareSupport [ARG int feature=]>

--- Incoming ---
[   u'cv.getHardwareFeatureName',
    u'String',
    [],
    [[u'int', u'feature', u'', []]],
    u'String']
ok: FUNC <String cv..getHardwareFeatureName [ARG int feature=]>

--- Incoming ---
[u'cv.getNumberOfCPUs', u'int', [], [], u'int']
ok: FUNC <int cv..getNumberOfCPUs []>

--- Incoming ---
[u'cv.setUseOptimized', u'void', [], [[u'bool', u'onoff', u'', []]], u'void']
manual: FUNC <void cv..setUseOptimized [ARG bool onoff=]>

--- Incoming ---
[u'cv.useOptimized', u'bool', [], [], u'bool']
manual: FUNC <bool cv..useOptimized []>

--- Incoming ---
[   u'enum cv.instr.TYPE',
    '',
    [],
    [   [u'const cv.instr.TYPE_GENERAL', u'0', [], [], None, ''],
        [u'const cv.instr.TYPE_MARKER', u'0+1', [], [], None, ''],
        [u'const cv.instr.TYPE_WRAPPER', u'0+2', [], [], None, ''],
        [u'const cv.instr.TYPE_FUN', u'0+3', [], [], None, '']],
    None]
ok: CONST TYPE_GENERAL=0
ok: CONST TYPE_MARKER=0+1
ok: CONST TYPE_WRAPPER=0+2
ok: CONST TYPE_FUN=0+3

--- Incoming ---
[   u'enum cv.instr.IMPL',
    '',
    [],
    [   [u'const cv.instr.IMPL_PLAIN', u'0', [], [], None, ''],
        [u'const cv.instr.IMPL_IPP', u'0+1', [], [], None, ''],
        [u'const cv.instr.IMPL_OPENCL', u'0+2', [], [], None, '']],
    None]
ok: CONST IMPL_PLAIN=0
ok: CONST IMPL_IPP=0+1
ok: CONST IMPL_OPENCL=0+2

--- Incoming ---
[   u'enum cv.instr.FLAGS',
    '',
    [],
    [   [u'const cv.instr.FLAGS_NONE', u'0', [], [], None, ''],
        [u'const cv.instr.FLAGS_MAPPING', u'0x01', [], [], None, ''],
        [   u'const cv.instr.FLAGS_EXPAND_SAME_NAMES',
            u'0x02',
            [],
            [],
            None,
            '']],
    None]
ok: CONST FLAGS_NONE=0
ok: CONST FLAGS_MAPPING=0x01
ok: CONST FLAGS_EXPAND_SAME_NAMES=0x02

--- Incoming ---
[   u'cv.samples.findFile',
    u'String',
    [],
    [   [u'String', u'relative_path', u'', ['/C', '/Ref']],
        [u'bool', u'required', u'true', []],
        [u'bool', u'silentMode', u'false', []]],
    u'cv::String']
ok: FUNC <String cv.samples..findFile [ARG String relative_path=, ARG bool required=true, ARG bool silentMode=false]>

--- Incoming ---
[   u'cv.samples.findFileOrKeep',
    u'String',
    [],
    [   [u'String', u'relative_path', u'', ['/C', '/Ref']],
        [u'bool', u'silentMode', u'false', []]],
    u'cv::String']
ok: FUNC <String cv.samples..findFileOrKeep [ARG String relative_path=, ARG bool silentMode=false]>

--- Incoming ---
[   u'cv.samples.addSamplesDataSearchPath',
    u'void',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.samples..addSamplesDataSearchPath [ARG String path=]>

--- Incoming ---
[   u'cv.samples.addSamplesDataSearchSubDirectory',
    u'void',
    [],
    [[u'String', u'subdir', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.samples..addSamplesDataSearchSubDirectory [ARG String subdir=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/core/misc/java/src/cpp/core_manual.hpp =====
Namespaces: set([u'cv.ogl', u'cv.instr', u'cv.utils', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv.samples', u'cv'])

--- Incoming ---
[   u'cv.setErrorVerbosity',
    u'void',
    [],
    [[u'bool', u'verbose', u'', []]],
    u'void']
ok: FUNC <void cv..setErrorVerbosity [ARG bool verbose=]>

--- Incoming ---
[   u'cv.add',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..add [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.subtract',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..subtract [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.multiply',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..multiply [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..divide [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.absdiff',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..absdiff [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.compare',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'cmpop', u'', []]],
    u'void']
ok: FUNC <void cv..compare [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG int cmpop=]>

--- Incoming ---
[   u'cv.min',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..min [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.max',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..max [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>


===== Generating... =====
CLASS ::.Core : 
[CONST CV_8U=0(manual), CONST CV_8S=1(manual), CONST CV_16U=2(manual), CONST CV_16S=3(manual), CONST CV_32S=4(manual), CONST CV_32F=5(manual), CONST CV_64F=6(manual), CONST CV_USRTYPE1=7(manual)]
[CONST DECOMP_LU=0, CONST DECOMP_SVD=1, CONST DECOMP_EIG=2, CONST DECOMP_CHOLESKY=3, CONST DECOMP_QR=4, CONST DECOMP_NORMAL=16]
[CONST SVD_MODIFY_A=1(manual), CONST SVD_NO_UV=2(manual), CONST SVD_FULL_UV=4(manual), CONST FILLED=-1(manual), CONST REDUCE_SUM=0(manual), CONST REDUCE_AVG=1(manual), CONST REDUCE_MAX=2(manual), CONST REDUCE_MIN=3(manual), CONST RNG_UNIFORM=0, CONST RNG_NORMAL=1]
[CONST BORDER_CONSTANT=0, CONST BORDER_REPLICATE=1, CONST BORDER_REFLECT=2, CONST BORDER_WRAP=3, CONST BORDER_REFLECT_101=4, CONST BORDER_TRANSPARENT=5, CONST BORDER_REFLECT101=BORDER_REFLECT_101, CONST BORDER_DEFAULT=BORDER_REFLECT_101, CONST BORDER_ISOLATED=16]
[CONST GEMM_1_T=1, CONST GEMM_2_T=2, CONST GEMM_3_T=4]
[CONST KMEANS_RANDOM_CENTERS=0, CONST KMEANS_PP_CENTERS=2, CONST KMEANS_USE_INITIAL_LABELS=1]
[CONST CMP_EQ=0, CONST CMP_GT=1, CONST CMP_GE=2, CONST CMP_LT=3, CONST CMP_LE=4, CONST CMP_NE=5]
[CONST PCA_DATA_AS_ROW=0, CONST PCA_DATA_AS_COL=1, CONST PCA_USE_AVG=2]
[CONST DFT_INVERSE=1, CONST DFT_SCALE=2, CONST DFT_ROWS=4, CONST DFT_COMPLEX_OUTPUT=16, CONST DFT_REAL_OUTPUT=32, CONST DFT_COMPLEX_INPUT=64, CONST DCT_INVERSE=DFT_INVERSE, CONST DCT_ROWS=DFT_ROWS]
[CONST IMPL_PLAIN=0, CONST IMPL_IPP=0+1, CONST IMPL_OPENCL=0+2]
[CONST FLAGS_NONE=0, CONST FLAGS_MAPPING=0x01, CONST FLAGS_EXPAND_SAME_NAMES=0x02]
[CONST TYPE_GENERAL=0, CONST TYPE_MARKER=0+1, CONST TYPE_WRAPPER=0+2, CONST TYPE_FUN=0+3]
[CONST Formatter_FMT_DEFAULT=0, CONST Formatter_FMT_MATLAB=1, CONST Formatter_FMT_CSV=2, CONST Formatter_FMT_PYTHON=3, CONST Formatter_FMT_NUMPY=4, CONST Formatter_FMT_C=5]
[CONST SORT_EVERY_ROW=0, CONST SORT_EVERY_COLUMN=1, CONST SORT_ASCENDING=0, CONST SORT_DESCENDING=16]
[CONST COVAR_SCRAMBLED=0, CONST COVAR_NORMAL=1, CONST COVAR_USE_AVG=2, CONST COVAR_SCALE=4, CONST COVAR_ROWS=8, CONST COVAR_COLS=16]
[CONST Param_INT=0, CONST Param_BOOLEAN=1, CONST Param_REAL=2, CONST Param_STRING=3, CONST Param_MAT=4, CONST Param_MAT_VECTOR=5, CONST Param_ALGORITHM=6, CONST Param_FLOAT=7, CONST Param_UNSIGNED_INT=8, CONST Param_UINT64=9, CONST Param_UCHAR=11, CONST Param_SCALAR=12]
[CONST NORM_INF=1, CONST NORM_L1=2, CONST NORM_L2=4, CONST NORM_L2SQR=5, CONST NORM_HAMMING=6, CONST NORM_HAMMING2=7, CONST NORM_TYPE_MASK=7, CONST NORM_RELATIVE=8, CONST NORM_MINMAX=32]
[CONST ROTATE_90_CLOCKWISE=0, CONST ROTATE_180=1, CONST ROTATE_90_COUNTERCLOCKWISE=2]
[CONST StsOk=0, CONST StsBackTrace=-1, CONST StsError=-2, CONST StsInternal=-3, CONST StsNoMem=-4, CONST StsBadArg=-5, CONST StsBadFunc=-6, CONST StsNoConv=-7, CONST StsAutoTrace=-8, CONST HeaderIsNull=-9, CONST BadImageSize=-10, CONST BadOffset=-11, CONST BadDataPtr=-12, CONST BadStep=-13, CONST BadModelOrChSeq=-14, CONST BadNumChannels=-15, CONST BadNumChannel1U=-16, CONST BadDepth=-17, CONST BadAlphaChannel=-18, CONST BadOrder=-19, CONST BadOrigin=-20, CONST BadAlign=-21, CONST BadCallBack=-22, CONST BadTileSize=-23, CONST BadCOI=-24, CONST BadROISize=-25, CONST MaskIsTiled=-26, CONST StsNullPtr=-27, CONST StsVecLengthErr=-28, CONST StsFilterStructContentErr=-29, CONST StsKernelStructContentErr=-30, CONST StsFilterOffsetErr=-31, CONST StsBadSize=-201, CONST StsDivByZero=-202, CONST StsInplaceNotSupported=-203, CONST StsObjectNotFound=-204, CONST StsUnmatchedFormats=-205, CONST StsBadFlag=-206, CONST StsBadPoint=-207, CONST StsBadMask=-208, CONST StsUnmatchedSizes=-209, CONST StsUnsupportedFormat=-210, CONST StsOutOfRange=-211, CONST StsParseError=-212, CONST StsNotImplemented=-213, CONST StsBadMemBlock=-214, CONST StsAssert=-215, CONST GpuNotSupported=-216, CONST GpuApiCallError=-217, CONST OpenGlNotSupported=-218, CONST OpenGlApiCallError=-219, CONST OpenCLApiCallError=-220, CONST OpenCLDoubleNotSupported=-221, CONST OpenCLInitError=-222, CONST OpenCLNoAMDBlasFft=-223]
FUNC <Scalar cv..mean [ARG Mat src=, ARG Mat mask=Mat()]>
java: Scalar mean(Mat src, Mat mask)
java: Scalar mean(Mat src)
FUNC <Scalar cv..sum [ARG Mat src=]>
java: Scalar sumElems(Mat src)
FUNC <Scalar cv..trace [ARG Mat mtx=]>
java: Scalar trace(Mat mtx)
FUNC <String cv..getBuildInformation []>
java: String getBuildInformation()
FUNC <String cv..getHardwareFeatureName [ARG int feature=]>
java: String getHardwareFeatureName(int feature)
FUNC <String cv..getVersionString []>
java: String getVersionString()
FUNC <String cv.ipp..getIppVersion []>
java: String getIppVersion()
FUNC <String cv.samples..findFile [ARG String relative_path=, ARG bool required=true, ARG bool silentMode=false]>
java: String findFile(String relative_path, boolean required, boolean silentMode)
java: String findFile(String relative_path, boolean required)
java: String findFile(String relative_path)
FUNC <String cv.samples..findFileOrKeep [ARG String relative_path=, ARG bool silentMode=false]>
java: String findFileOrKeep(String relative_path, boolean silentMode)
java: String findFileOrKeep(String relative_path)
FUNC <bool cv..checkRange [ARG Mat a=, ARG bool quiet=true, ARG  * pos=0, ARG double minVal=-DBL_MAX, ARG double maxVal=DBL_MAX]>
java: boolean checkRange(Mat a, boolean quiet, double minVal, double maxVal)
java: boolean checkRange(Mat a, boolean quiet, double minVal)
java: boolean checkRange(Mat a, boolean quiet)
java: boolean checkRange(Mat a, boolean quiet)
java: boolean checkRange(Mat a)
FUNC <bool cv..eigen [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=Mat()]>
java: boolean eigen(Mat src, Mat eigenvalues, Mat eigenvectors)
java: boolean eigen(Mat src, Mat eigenvalues)
FUNC <bool cv..solve [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int flags=DECOMP_LU]>
java: boolean solve(Mat src1, Mat src2, Mat dst, int flags)
java: boolean solve(Mat src1, Mat src2, Mat dst)
FUNC <bool cv.ipp..useIPP []>
java: boolean useIPP()
FUNC <bool cv.ipp..useIPP_NotExact []>
java: boolean useIPP_NotExact()
FUNC <double cv..Mahalanobis [ARG Mat v1=, ARG Mat v2=, ARG Mat icovar=]>
java: double Mahalanobis(Mat v1, Mat v2, Mat icovar)
FUNC <double cv..PSNR [ARG Mat src1=, ARG Mat src2=, ARG double R=255.]>
java: double PSNR(Mat src1, Mat src2, double R)
java: double PSNR(Mat src1, Mat src2)
FUNC <double cv..determinant [ARG Mat mtx=]>
java: double determinant(Mat mtx)
FUNC <double cv..getTickFrequency []>
java: double getTickFrequency()
FUNC <double cv..invert [ARG Mat src=, ARG Mat dst=, ARG int flags=DECOMP_LU]>
java: double invert(Mat src, Mat dst, int flags)
java: double invert(Mat src, Mat dst)
FUNC <double cv..kmeans [ARG Mat data=, ARG int K=, ARG Mat bestLabels=, ARG TermCriteria criteria=, ARG int attempts=, ARG int flags=, ARG Mat centers=Mat()]>
java: double kmeans(Mat data, int K, Mat bestLabels, TermCriteria criteria, int attempts, int flags, Mat centers)
java: double kmeans(Mat data, int K, Mat bestLabels, TermCriteria criteria, int attempts, int flags)
FUNC <double cv..norm [ARG Mat src1=, ARG Mat src2=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>
java: double norm(Mat src1, Mat src2, int normType, Mat mask)
java: double norm(Mat src1, Mat src2, int normType)
java: double norm(Mat src1, Mat src2)
FUNC <double cv..norm [ARG Mat src1=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>
java: double norm(Mat src1, int normType, Mat mask)
java: double norm(Mat src1, int normType)
java: double norm(Mat src1)
FUNC <double cv..solvePoly [ARG Mat coeffs=, ARG Mat roots=, ARG int maxIters=300]>
java: double solvePoly(Mat coeffs, Mat roots, int maxIters)
java: double solvePoly(Mat coeffs, Mat roots)
FUNC <float cv..cubeRoot [ARG float val=]>
java: float cubeRoot(float val)
FUNC <float cv..fastAtan2 [ARG float y=, ARG float x=]>
java: float fastAtan2(float y, float x)
FUNC <int cv..borderInterpolate [ARG int p=, ARG int len=, ARG int borderType=]>
java: int borderInterpolate(int p, int len, int borderType)
FUNC <int cv..countNonZero [ARG Mat src=]>
java: int countNonZero(Mat src)
FUNC <int cv..getNumThreads []>
java: int getNumThreads()
FUNC <int cv..getNumberOfCPUs []>
java: int getNumberOfCPUs()
FUNC <int cv..getOptimalDFTSize [ARG int vecsize=]>
java: int getOptimalDFTSize(int vecsize)
FUNC <int cv..getThreadNum []>
java: int getThreadNum()
FUNC <int cv..getVersionMajor []>
java: int getVersionMajor()
FUNC <int cv..getVersionMinor []>
java: int getVersionMinor()
FUNC <int cv..getVersionRevision []>
java: int getVersionRevision()
FUNC <int cv..solveCubic [ARG Mat coeffs=, ARG Mat roots=]>
java: int solveCubic(Mat coeffs, Mat roots)
FUNC <int64 cv..getCPUTickCount []>
java: long getCPUTickCount()
FUNC <int64 cv..getTickCount []>
java: long getTickCount()
FUNC <void cv..LUT [ARG Mat src=, ARG Mat lut=, ARG Mat dst=]>
java: void LUT(Mat src, Mat lut, Mat dst)
FUNC <void cv..PCABackProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>
java: void PCABackProject(Mat data, Mat mean, Mat eigenvectors, Mat result)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG double retainedVariance=]>
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues, double retainedVariance)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG int maxComponents=0]>
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues, int maxComponents)
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG double retainedVariance=]>
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors, double retainedVariance)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG int maxComponents=0]>
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors, int maxComponents)
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors)
FUNC <void cv..PCAProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>
java: void PCAProject(Mat data, Mat mean, Mat eigenvectors, Mat result)
FUNC <void cv..SVBackSubst [ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG Mat rhs=, ARG Mat dst=]>
java: void SVBackSubst(Mat w, Mat u, Mat vt, Mat rhs, Mat dst)
FUNC <void cv..SVDecomp [ARG Mat src=, ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG int flags=0]>
java: void SVDecomp(Mat src, Mat w, Mat u, Mat vt, int flags)
java: void SVDecomp(Mat src, Mat w, Mat u, Mat vt)
FUNC <void cv..absdiff [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void absdiff(Mat src1, Mat src2, Mat dst)
FUNC <void cv..absdiff [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void absdiff(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..add [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void add(Mat src1, Mat src2, Mat dst, Mat mask, int dtype)
java: void add(Mat src1, Mat src2, Mat dst, Mat mask)
java: void add(Mat src1, Mat src2, Mat dst)
FUNC <void cv..add [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void add(Mat src1, Scalar src2, Mat dst, Mat mask, int dtype)
java: void add(Mat src1, Scalar src2, Mat dst, Mat mask)
java: void add(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..addWeighted [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG double beta=, ARG double gamma=, ARG Mat dst=, ARG int dtype=-1]>
java: void addWeighted(Mat src1, double alpha, Mat src2, double beta, double gamma, Mat dst, int dtype)
java: void addWeighted(Mat src1, double alpha, Mat src2, double beta, double gamma, Mat dst)
FUNC <void cv..batchDistance [ARG Mat src1=, ARG Mat src2=, ARG Mat dist=, ARG int dtype=, ARG Mat nidx=, ARG int normType=NORM_L2, ARG int K=0, ARG Mat mask=Mat(), ARG int update=0, ARG bool crosscheck=false]>
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask, int update, boolean crosscheck)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask, int update)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx)
FUNC <void cv..bitwise_and [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_and(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_and(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_not [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_not(Mat src, Mat dst, Mat mask)
java: void bitwise_not(Mat src, Mat dst)
FUNC <void cv..bitwise_or [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_or(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_or(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_xor [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_xor(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_xor(Mat src1, Mat src2, Mat dst)
FUNC <void cv..calcCovarMatrix [ARG Mat samples=, ARG Mat covar=, ARG Mat mean=, ARG int flags=, ARG int ctype=CV_64F]>
java: void calcCovarMatrix(Mat samples, Mat covar, Mat mean, int flags, int ctype)
java: void calcCovarMatrix(Mat samples, Mat covar, Mat mean, int flags)
FUNC <void cv..cartToPolar [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=, ARG Mat angle=, ARG bool angleInDegrees=false]>
java: void cartToPolar(Mat x, Mat y, Mat magnitude, Mat angle, boolean angleInDegrees)
java: void cartToPolar(Mat x, Mat y, Mat magnitude, Mat angle)
FUNC <void cv..compare [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int cmpop=]>
java: void compare(Mat src1, Mat src2, Mat dst, int cmpop)
FUNC <void cv..compare [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG int cmpop=]>
java: void compare(Mat src1, Scalar src2, Mat dst, int cmpop)
FUNC <void cv..completeSymm [ARG Mat m=, ARG bool lowerToUpper=false]>
java: void completeSymm(Mat m, boolean lowerToUpper)
java: void completeSymm(Mat m)
FUNC <void cv..convertFp16 [ARG Mat src=, ARG Mat dst=]>
java: void convertFp16(Mat src, Mat dst)
FUNC <void cv..convertScaleAbs [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0]>
java: void convertScaleAbs(Mat src, Mat dst, double alpha, double beta)
java: void convertScaleAbs(Mat src, Mat dst, double alpha)
java: void convertScaleAbs(Mat src, Mat dst)
FUNC <void cv..copyMakeBorder [ARG Mat src=, ARG Mat dst=, ARG int top=, ARG int bottom=, ARG int left=, ARG int right=, ARG int borderType=, ARG Scalar value=Scalar()]>
java: void copyMakeBorder(Mat src, Mat dst, int top, int bottom, int left, int right, int borderType, Scalar value)
java: void copyMakeBorder(Mat src, Mat dst, int top, int bottom, int left, int right, int borderType)
FUNC <void cv..copyTo [ARG Mat src=, ARG Mat dst=, ARG Mat mask=]>
java: void copyTo(Mat src, Mat dst, Mat mask)
FUNC <void cv..dct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>
java: void dct(Mat src, Mat dst, int flags)
java: void dct(Mat src, Mat dst)
FUNC <void cv..dft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>
java: void dft(Mat src, Mat dst, int flags, int nonzeroRows)
java: void dft(Mat src, Mat dst, int flags)
java: void dft(Mat src, Mat dst)
FUNC <void cv..divide [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void divide(Mat src1, Mat src2, Mat dst, double scale, int dtype)
java: void divide(Mat src1, Mat src2, Mat dst, double scale)
java: void divide(Mat src1, Mat src2, Mat dst)
FUNC <void cv..divide [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void divide(Mat src1, Scalar src2, Mat dst, double scale, int dtype)
java: void divide(Mat src1, Scalar src2, Mat dst, double scale)
java: void divide(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..divide [ARG double scale=, ARG Mat src2=, ARG Mat dst=, ARG int dtype=-1]>
java: void divide(double scale, Mat src2, Mat dst, int dtype)
java: void divide(double scale, Mat src2, Mat dst)
FUNC <void cv..eigenNonSymmetric [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=]>
java: void eigenNonSymmetric(Mat src, Mat eigenvalues, Mat eigenvectors)
FUNC <void cv..exp [ARG Mat src=, ARG Mat dst=]>
java: void exp(Mat src, Mat dst)
FUNC <void cv..extractChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>
java: void extractChannel(Mat src, Mat dst, int coi)
FUNC <void cv..findNonZero [ARG Mat src=, ARG Mat idx=]>
java: void findNonZero(Mat src, Mat idx)
FUNC <void cv..flip [ARG Mat src=, ARG Mat dst=, ARG int flipCode=]>
java: void flip(Mat src, Mat dst, int flipCode)
FUNC <void cv..gemm [ARG Mat src1=, ARG Mat src2=, ARG double alpha=, ARG Mat src3=, ARG double beta=, ARG Mat dst=, ARG int flags=0]>
java: void gemm(Mat src1, Mat src2, double alpha, Mat src3, double beta, Mat dst, int flags)
java: void gemm(Mat src1, Mat src2, double alpha, Mat src3, double beta, Mat dst)
FUNC <void cv..hconcat [ARG vector_Mat src=, ARG Mat dst=]>
java: void hconcat(List<Mat> src, Mat dst)
FUNC <void cv..idct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>
java: void idct(Mat src, Mat dst, int flags)
java: void idct(Mat src, Mat dst)
FUNC <void cv..idft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>
java: void idft(Mat src, Mat dst, int flags, int nonzeroRows)
java: void idft(Mat src, Mat dst, int flags)
java: void idft(Mat src, Mat dst)
FUNC <void cv..inRange [ARG Mat src=, ARG Scalar lowerb=, ARG Scalar upperb=, ARG Mat dst=]>
java: void inRange(Mat src, Scalar lowerb, Scalar upperb, Mat dst)
FUNC <void cv..insertChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>
java: void insertChannel(Mat src, Mat dst, int coi)
FUNC <void cv..log [ARG Mat src=, ARG Mat dst=]>
java: void log(Mat src, Mat dst)
FUNC <void cv..magnitude [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=]>
java: void magnitude(Mat x, Mat y, Mat magnitude)
FUNC <void cv..max [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void max(Mat src1, Mat src2, Mat dst)
FUNC <void cv..max [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void max(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..meanStdDev [ARG Mat src=, ARG vector_double mean=, ARG vector_double stddev=, ARG Mat mask=Mat()]>
java: void meanStdDev(Mat src, MatOfDouble mean, MatOfDouble stddev, Mat mask)
java: void meanStdDev(Mat src, MatOfDouble mean, MatOfDouble stddev)
FUNC <void cv..merge [ARG vector_Mat mv=, ARG Mat dst=]>
java: void merge(List<Mat> mv, Mat dst)
FUNC <void cv..min [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void min(Mat src1, Mat src2, Mat dst)
FUNC <void cv..min [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void min(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..mixChannels [ARG vector_Mat src=, ARG vector_Mat dst=, ARG vector_int fromTo=]>
java: void mixChannels(List<Mat> src, List<Mat> dst, MatOfInt fromTo)
FUNC <void cv..mulSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>
java: void mulSpectrums(Mat a, Mat b, Mat c, int flags, boolean conjB)
java: void mulSpectrums(Mat a, Mat b, Mat c, int flags)
FUNC <void cv..mulTransposed [ARG Mat src=, ARG Mat dst=, ARG bool aTa=, ARG Mat delta=Mat(), ARG double scale=1, ARG int dtype=-1]>
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta, double scale, int dtype)
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta, double scale)
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta)
java: void mulTransposed(Mat src, Mat dst, boolean aTa)
FUNC <void cv..multiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void multiply(Mat src1, Mat src2, Mat dst, double scale, int dtype)
java: void multiply(Mat src1, Mat src2, Mat dst, double scale)
java: void multiply(Mat src1, Mat src2, Mat dst)
FUNC <void cv..multiply [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void multiply(Mat src1, Scalar src2, Mat dst, double scale, int dtype)
java: void multiply(Mat src1, Scalar src2, Mat dst, double scale)
java: void multiply(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..normalize [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0, ARG int norm_type=NORM_L2, ARG int dtype=-1, ARG Mat mask=Mat()]>
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type, int dtype, Mat mask)
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type, int dtype)
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type)
java: void normalize(Mat src, Mat dst, double alpha, double beta)
java: void normalize(Mat src, Mat dst, double alpha)
java: void normalize(Mat src, Mat dst)
FUNC <void cv..patchNaNs [ARG Mat a=, ARG double val=0]>
java: void patchNaNs(Mat a, double val)
java: void patchNaNs(Mat a)
FUNC <void cv..perspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>
java: void perspectiveTransform(Mat src, Mat dst, Mat m)
FUNC <void cv..phase [ARG Mat x=, ARG Mat y=, ARG Mat angle=, ARG bool angleInDegrees=false]>
java: void phase(Mat x, Mat y, Mat angle, boolean angleInDegrees)
java: void phase(Mat x, Mat y, Mat angle)
FUNC <void cv..polarToCart [ARG Mat magnitude=, ARG Mat angle=, ARG Mat x=, ARG Mat y=, ARG bool angleInDegrees=false]>
java: void polarToCart(Mat magnitude, Mat angle, Mat x, Mat y, boolean angleInDegrees)
java: void polarToCart(Mat magnitude, Mat angle, Mat x, Mat y)
FUNC <void cv..pow [ARG Mat src=, ARG double power=, ARG Mat dst=]>
java: void pow(Mat src, double power, Mat dst)
FUNC <void cv..randShuffle [ARG Mat dst=, ARG double iterFactor=1., ARG RNG * rng=0]>
java: void randShuffle(Mat dst, double iterFactor)
java: void randShuffle(Mat dst, double iterFactor)
java: void randShuffle(Mat dst)
FUNC <void cv..randn [ARG Mat dst=, ARG double mean=, ARG double stddev=]>
java: void randn(Mat dst, double mean, double stddev)
FUNC <void cv..randu [ARG Mat dst=, ARG double low=, ARG double high=]>
java: void randu(Mat dst, double low, double high)
FUNC <void cv..reduce [ARG Mat src=, ARG Mat dst=, ARG int dim=, ARG int rtype=, ARG int dtype=-1]>
java: void reduce(Mat src, Mat dst, int dim, int rtype, int dtype)
java: void reduce(Mat src, Mat dst, int dim, int rtype)
FUNC <void cv..repeat [ARG Mat src=, ARG int ny=, ARG int nx=, ARG Mat dst=]>
java: void repeat(Mat src, int ny, int nx, Mat dst)
FUNC <void cv..rotate [ARG Mat src=, ARG Mat dst=, ARG int rotateCode=]>
java: void rotate(Mat src, Mat dst, int rotateCode)
FUNC <void cv..scaleAdd [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG Mat dst=]>
java: void scaleAdd(Mat src1, double alpha, Mat src2, Mat dst)
FUNC <void cv..setErrorVerbosity [ARG bool verbose=]>
java: void setErrorVerbosity(boolean verbose)
FUNC <void cv..setIdentity [ARG Mat mtx=, ARG Scalar s=Scalar(1)]>
java: void setIdentity(Mat mtx, Scalar s)
java: void setIdentity(Mat mtx)
FUNC <void cv..setNumThreads [ARG int nthreads=]>
java: void setNumThreads(int nthreads)
FUNC <void cv..setRNGSeed [ARG int seed=]>
java: void setRNGSeed(int seed)
FUNC <void cv..sort [ARG Mat src=, ARG Mat dst=, ARG int flags=]>
java: void sort(Mat src, Mat dst, int flags)
FUNC <void cv..sortIdx [ARG Mat src=, ARG Mat dst=, ARG int flags=]>
java: void sortIdx(Mat src, Mat dst, int flags)
FUNC <void cv..split [ARG Mat m=, ARG vector_Mat mv=]>
java: void split(Mat m, List<Mat> mv)
FUNC <void cv..sqrt [ARG Mat src=, ARG Mat dst=]>
java: void sqrt(Mat src, Mat dst)
FUNC <void cv..subtract [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void subtract(Mat src1, Mat src2, Mat dst, Mat mask, int dtype)
java: void subtract(Mat src1, Mat src2, Mat dst, Mat mask)
java: void subtract(Mat src1, Mat src2, Mat dst)
FUNC <void cv..subtract [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void subtract(Mat src1, Scalar src2, Mat dst, Mat mask, int dtype)
java: void subtract(Mat src1, Scalar src2, Mat dst, Mat mask)
java: void subtract(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..transform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>
java: void transform(Mat src, Mat dst, Mat m)
FUNC <void cv..transpose [ARG Mat src=, ARG Mat dst=]>
java: void transpose(Mat src, Mat dst)
FUNC <void cv..vconcat [ARG vector_Mat src=, ARG Mat dst=]>
java: void vconcat(List<Mat> src, Mat dst)
FUNC <void cv.ipp..setUseIPP [ARG bool flag=]>
java: void setUseIPP(boolean flag)
FUNC <void cv.ipp..setUseIPP_NotExact [ARG bool flag=]>
java: void setUseIPP_NotExact(boolean flag)
FUNC <void cv.samples..addSamplesDataSearchPath [ARG String path=]>
java: void addSamplesDataSearchPath(String path)
FUNC <void cv.samples..addSamplesDataSearchSubDirectory [ARG String subdir=]>
java: void addSamplesDataSearchSubDirectory(String subdir)
CLASS cv::.Algorithm : 
FUNC <String cv.Algorithm.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.Algorithm.empty []>
java: boolean empty()
FUNC <void cv.Algorithm.clear []>
java: void clear()
FUNC <void cv.Algorithm.read [ARG FileNode fn=]>
SKIP:void cv::Algorithm::read(FileNode fn)	 due to ARG type FileNode/I
FUNC <void cv.Algorithm.save [ARG String filename=]>
java: void save(String filename)
FUNC <void cv.Algorithm.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>
SKIP:void cv::Algorithm::write(Ptr_FileStorage fs, String name = String())	 due to ARG type Ptr_FileStorage/I
CLASS cv::.TickMeter : 
FUNC < cv.TickMeter.TickMeter []>
java:  TickMeter()
FUNC <double cv.TickMeter.getTimeMicro []>
java: double getTimeMicro()
FUNC <double cv.TickMeter.getTimeMilli []>
java: double getTimeMilli()
FUNC <double cv.TickMeter.getTimeSec []>
java: double getTimeSec()
FUNC <int64 cv.TickMeter.getCounter []>
java: long getCounter()
FUNC <int64 cv.TickMeter.getTimeTicks []>
java: long getTimeTicks()
FUNC <void cv.TickMeter.reset []>
java: void reset()
FUNC <void cv.TickMeter.start []>
java: void start()
FUNC <void cv.TickMeter.stop []>
java: void stop()

=== MODULE: imgproc (/home/borg/404/scripts_robotica/OpenCV/modules/imgproc) ===


Files (7):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/imgproc_c.h',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/types_c.h',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/hal/interface.h',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/imgproc.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp']

Common headers (0):
[]
ok: class CLASS ::.Imgproc : , name: Imgproc, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/imgproc_c.h =====
Namespaces: set([''])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/imgproc_c.h


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/types_c.h =====
Namespaces: set([''])

--- Incoming ---
[   u'enum SmoothMethod_c',
    '',
    [],
    [   [u'const CV_BLUR_NO_SCALE', u'0', [], [], None, ''],
        [u'const CV_BLUR', u'1', [], [], None, ''],
        [u'const CV_GAUSSIAN', u'2', [], [], None, ''],
        [u'const CV_MEDIAN', u'3', [], [], None, ''],
        [u'const CV_BILATERAL', u'4', [], [], None, '']],
    None]
ok: CONST CV_BLUR_NO_SCALE=0
ok: CONST CV_BLUR=1
ok: CONST CV_GAUSSIAN=2
ok: CONST CV_MEDIAN=3
ok: CONST CV_BILATERAL=4

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [[u'const CV_GAUSSIAN_5x5', u'7', [], [], None, '']],
    None]
ok: CONST CV_GAUSSIAN_5x5=7

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_SCHARR', u'-1', [], [], None, ''],
        [u'const CV_MAX_SOBEL_KSIZE', u'7', [], [], None, '']],
    None]
ok: CONST CV_SCHARR=-1
ok: CONST CV_MAX_SOBEL_KSIZE=7

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_BGR2BGRA', u'0', [], [], None, ''],
        [u'const CV_RGB2RGBA', u'CV_BGR2BGRA', [], [], None, ''],
        [u'const CV_BGRA2BGR', u'1', [], [], None, ''],
        [u'const CV_RGBA2RGB', u'CV_BGRA2BGR', [], [], None, ''],
        [u'const CV_BGR2RGBA', u'2', [], [], None, ''],
        [u'const CV_RGB2BGRA', u'CV_BGR2RGBA', [], [], None, ''],
        [u'const CV_RGBA2BGR', u'3', [], [], None, ''],
        [u'const CV_BGRA2RGB', u'CV_RGBA2BGR', [], [], None, ''],
        [u'const CV_BGR2RGB', u'4', [], [], None, ''],
        [u'const CV_RGB2BGR', u'CV_BGR2RGB', [], [], None, ''],
        [u'const CV_BGRA2RGBA', u'5', [], [], None, ''],
        [u'const CV_RGBA2BGRA', u'CV_BGRA2RGBA', [], [], None, ''],
        [u'const CV_BGR2GRAY', u'6', [], [], None, ''],
        [u'const CV_RGB2GRAY', u'7', [], [], None, ''],
        [u'const CV_GRAY2BGR', u'8', [], [], None, ''],
        [u'const CV_GRAY2RGB', u'CV_GRAY2BGR', [], [], None, ''],
        [u'const CV_GRAY2BGRA', u'9', [], [], None, ''],
        [u'const CV_GRAY2RGBA', u'CV_GRAY2BGRA', [], [], None, ''],
        [u'const CV_BGRA2GRAY', u'10', [], [], None, ''],
        [u'const CV_RGBA2GRAY', u'11', [], [], None, ''],
        [u'const CV_BGR2BGR565', u'12', [], [], None, ''],
        [u'const CV_RGB2BGR565', u'13', [], [], None, ''],
        [u'const CV_BGR5652BGR', u'14', [], [], None, ''],
        [u'const CV_BGR5652RGB', u'15', [], [], None, ''],
        [u'const CV_BGRA2BGR565', u'16', [], [], None, ''],
        [u'const CV_RGBA2BGR565', u'17', [], [], None, ''],
        [u'const CV_BGR5652BGRA', u'18', [], [], None, ''],
        [u'const CV_BGR5652RGBA', u'19', [], [], None, ''],
        [u'const CV_GRAY2BGR565', u'20', [], [], None, ''],
        [u'const CV_BGR5652GRAY', u'21', [], [], None, ''],
        [u'const CV_BGR2BGR555', u'22', [], [], None, ''],
        [u'const CV_RGB2BGR555', u'23', [], [], None, ''],
        [u'const CV_BGR5552BGR', u'24', [], [], None, ''],
        [u'const CV_BGR5552RGB', u'25', [], [], None, ''],
        [u'const CV_BGRA2BGR555', u'26', [], [], None, ''],
        [u'const CV_RGBA2BGR555', u'27', [], [], None, ''],
        [u'const CV_BGR5552BGRA', u'28', [], [], None, ''],
        [u'const CV_BGR5552RGBA', u'29', [], [], None, ''],
        [u'const CV_GRAY2BGR555', u'30', [], [], None, ''],
        [u'const CV_BGR5552GRAY', u'31', [], [], None, ''],
        [u'const CV_BGR2XYZ', u'32', [], [], None, ''],
        [u'const CV_RGB2XYZ', u'33', [], [], None, ''],
        [u'const CV_XYZ2BGR', u'34', [], [], None, ''],
        [u'const CV_XYZ2RGB', u'35', [], [], None, ''],
        [u'const CV_BGR2YCrCb', u'36', [], [], None, ''],
        [u'const CV_RGB2YCrCb', u'37', [], [], None, ''],
        [u'const CV_YCrCb2BGR', u'38', [], [], None, ''],
        [u'const CV_YCrCb2RGB', u'39', [], [], None, ''],
        [u'const CV_BGR2HSV', u'40', [], [], None, ''],
        [u'const CV_RGB2HSV', u'41', [], [], None, ''],
        [u'const CV_BGR2Lab', u'44', [], [], None, ''],
        [u'const CV_RGB2Lab', u'45', [], [], None, ''],
        [u'const CV_BayerBG2BGR', u'46', [], [], None, ''],
        [u'const CV_BayerGB2BGR', u'47', [], [], None, ''],
        [u'const CV_BayerRG2BGR', u'48', [], [], None, ''],
        [u'const CV_BayerGR2BGR', u'49', [], [], None, ''],
        [u'const CV_BayerBG2RGB', u'CV_BayerRG2BGR', [], [], None, ''],
        [u'const CV_BayerGB2RGB', u'CV_BayerGR2BGR', [], [], None, ''],
        [u'const CV_BayerRG2RGB', u'CV_BayerBG2BGR', [], [], None, ''],
        [u'const CV_BayerGR2RGB', u'CV_BayerGB2BGR', [], [], None, ''],
        [u'const CV_BGR2Luv', u'50', [], [], None, ''],
        [u'const CV_RGB2Luv', u'51', [], [], None, ''],
        [u'const CV_BGR2HLS', u'52', [], [], None, ''],
        [u'const CV_RGB2HLS', u'53', [], [], None, ''],
        [u'const CV_HSV2BGR', u'54', [], [], None, ''],
        [u'const CV_HSV2RGB', u'55', [], [], None, ''],
        [u'const CV_Lab2BGR', u'56', [], [], None, ''],
        [u'const CV_Lab2RGB', u'57', [], [], None, ''],
        [u'const CV_Luv2BGR', u'58', [], [], None, ''],
        [u'const CV_Luv2RGB', u'59', [], [], None, ''],
        [u'const CV_HLS2BGR', u'60', [], [], None, ''],
        [u'const CV_HLS2RGB', u'61', [], [], None, ''],
        [u'const CV_BayerBG2BGR_VNG', u'62', [], [], None, ''],
        [u'const CV_BayerGB2BGR_VNG', u'63', [], [], None, ''],
        [u'const CV_BayerRG2BGR_VNG', u'64', [], [], None, ''],
        [u'const CV_BayerGR2BGR_VNG', u'65', [], [], None, ''],
        [   u'const CV_BayerBG2RGB_VNG',
            u'CV_BayerRG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const CV_BayerGB2RGB_VNG',
            u'CV_BayerGR2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const CV_BayerRG2RGB_VNG',
            u'CV_BayerBG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const CV_BayerGR2RGB_VNG',
            u'CV_BayerGB2BGR_VNG',
            [],
            [],
            None,
            ''],
        [u'const CV_BGR2HSV_FULL', u'66', [], [], None, ''],
        [u'const CV_RGB2HSV_FULL', u'67', [], [], None, ''],
        [u'const CV_BGR2HLS_FULL', u'68', [], [], None, ''],
        [u'const CV_RGB2HLS_FULL', u'69', [], [], None, ''],
        [u'const CV_HSV2BGR_FULL', u'70', [], [], None, ''],
        [u'const CV_HSV2RGB_FULL', u'71', [], [], None, ''],
        [u'const CV_HLS2BGR_FULL', u'72', [], [], None, ''],
        [u'const CV_HLS2RGB_FULL', u'73', [], [], None, ''],
        [u'const CV_LBGR2Lab', u'74', [], [], None, ''],
        [u'const CV_LRGB2Lab', u'75', [], [], None, ''],
        [u'const CV_LBGR2Luv', u'76', [], [], None, ''],
        [u'const CV_LRGB2Luv', u'77', [], [], None, ''],
        [u'const CV_Lab2LBGR', u'78', [], [], None, ''],
        [u'const CV_Lab2LRGB', u'79', [], [], None, ''],
        [u'const CV_Luv2LBGR', u'80', [], [], None, ''],
        [u'const CV_Luv2LRGB', u'81', [], [], None, ''],
        [u'const CV_BGR2YUV', u'82', [], [], None, ''],
        [u'const CV_RGB2YUV', u'83', [], [], None, ''],
        [u'const CV_YUV2BGR', u'84', [], [], None, ''],
        [u'const CV_YUV2RGB', u'85', [], [], None, ''],
        [u'const CV_BayerBG2GRAY', u'86', [], [], None, ''],
        [u'const CV_BayerGB2GRAY', u'87', [], [], None, ''],
        [u'const CV_BayerRG2GRAY', u'88', [], [], None, ''],
        [u'const CV_BayerGR2GRAY', u'89', [], [], None, ''],
        [u'const CV_YUV2RGB_NV12', u'90', [], [], None, ''],
        [u'const CV_YUV2BGR_NV12', u'91', [], [], None, ''],
        [u'const CV_YUV2RGB_NV21', u'92', [], [], None, ''],
        [u'const CV_YUV2BGR_NV21', u'93', [], [], None, ''],
        [u'const CV_YUV420sp2RGB', u'CV_YUV2RGB_NV21', [], [], None, ''],
        [u'const CV_YUV420sp2BGR', u'CV_YUV2BGR_NV21', [], [], None, ''],
        [u'const CV_YUV2RGBA_NV12', u'94', [], [], None, ''],
        [u'const CV_YUV2BGRA_NV12', u'95', [], [], None, ''],
        [u'const CV_YUV2RGBA_NV21', u'96', [], [], None, ''],
        [u'const CV_YUV2BGRA_NV21', u'97', [], [], None, ''],
        [u'const CV_YUV420sp2RGBA', u'CV_YUV2RGBA_NV21', [], [], None, ''],
        [u'const CV_YUV420sp2BGRA', u'CV_YUV2BGRA_NV21', [], [], None, ''],
        [u'const CV_YUV2RGB_YV12', u'98', [], [], None, ''],
        [u'const CV_YUV2BGR_YV12', u'99', [], [], None, ''],
        [u'const CV_YUV2RGB_IYUV', u'100', [], [], None, ''],
        [u'const CV_YUV2BGR_IYUV', u'101', [], [], None, ''],
        [u'const CV_YUV2RGB_I420', u'CV_YUV2RGB_IYUV', [], [], None, ''],
        [u'const CV_YUV2BGR_I420', u'CV_YUV2BGR_IYUV', [], [], None, ''],
        [u'const CV_YUV420p2RGB', u'CV_YUV2RGB_YV12', [], [], None, ''],
        [u'const CV_YUV420p2BGR', u'CV_YUV2BGR_YV12', [], [], None, ''],
        [u'const CV_YUV2RGBA_YV12', u'102', [], [], None, ''],
        [u'const CV_YUV2BGRA_YV12', u'103', [], [], None, ''],
        [u'const CV_YUV2RGBA_IYUV', u'104', [], [], None, ''],
        [u'const CV_YUV2BGRA_IYUV', u'105', [], [], None, ''],
        [u'const CV_YUV2RGBA_I420', u'CV_YUV2RGBA_IYUV', [], [], None, ''],
        [u'const CV_YUV2BGRA_I420', u'CV_YUV2BGRA_IYUV', [], [], None, ''],
        [u'const CV_YUV420p2RGBA', u'CV_YUV2RGBA_YV12', [], [], None, ''],
        [u'const CV_YUV420p2BGRA', u'CV_YUV2BGRA_YV12', [], [], None, ''],
        [u'const CV_YUV2GRAY_420', u'106', [], [], None, ''],
        [u'const CV_YUV2GRAY_NV21', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2GRAY_NV12', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2GRAY_YV12', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2GRAY_IYUV', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2GRAY_I420', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV420sp2GRAY', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV420p2GRAY', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2RGB_UYVY', u'107', [], [], None, ''],
        [u'const CV_YUV2BGR_UYVY', u'108', [], [], None, ''],
        [u'const CV_YUV2RGB_Y422', u'CV_YUV2RGB_UYVY', [], [], None, ''],
        [u'const CV_YUV2BGR_Y422', u'CV_YUV2BGR_UYVY', [], [], None, ''],
        [u'const CV_YUV2RGB_UYNV', u'CV_YUV2RGB_UYVY', [], [], None, ''],
        [u'const CV_YUV2BGR_UYNV', u'CV_YUV2BGR_UYVY', [], [], None, ''],
        [u'const CV_YUV2RGBA_UYVY', u'111', [], [], None, ''],
        [u'const CV_YUV2BGRA_UYVY', u'112', [], [], None, ''],
        [u'const CV_YUV2RGBA_Y422', u'CV_YUV2RGBA_UYVY', [], [], None, ''],
        [u'const CV_YUV2BGRA_Y422', u'CV_YUV2BGRA_UYVY', [], [], None, ''],
        [u'const CV_YUV2RGBA_UYNV', u'CV_YUV2RGBA_UYVY', [], [], None, ''],
        [u'const CV_YUV2BGRA_UYNV', u'CV_YUV2BGRA_UYVY', [], [], None, ''],
        [u'const CV_YUV2RGB_YUY2', u'115', [], [], None, ''],
        [u'const CV_YUV2BGR_YUY2', u'116', [], [], None, ''],
        [u'const CV_YUV2RGB_YVYU', u'117', [], [], None, ''],
        [u'const CV_YUV2BGR_YVYU', u'118', [], [], None, ''],
        [u'const CV_YUV2RGB_YUYV', u'CV_YUV2RGB_YUY2', [], [], None, ''],
        [u'const CV_YUV2BGR_YUYV', u'CV_YUV2BGR_YUY2', [], [], None, ''],
        [u'const CV_YUV2RGB_YUNV', u'CV_YUV2RGB_YUY2', [], [], None, ''],
        [u'const CV_YUV2BGR_YUNV', u'CV_YUV2BGR_YUY2', [], [], None, ''],
        [u'const CV_YUV2RGBA_YUY2', u'119', [], [], None, ''],
        [u'const CV_YUV2BGRA_YUY2', u'120', [], [], None, ''],
        [u'const CV_YUV2RGBA_YVYU', u'121', [], [], None, ''],
        [u'const CV_YUV2BGRA_YVYU', u'122', [], [], None, ''],
        [u'const CV_YUV2RGBA_YUYV', u'CV_YUV2RGBA_YUY2', [], [], None, ''],
        [u'const CV_YUV2BGRA_YUYV', u'CV_YUV2BGRA_YUY2', [], [], None, ''],
        [u'const CV_YUV2RGBA_YUNV', u'CV_YUV2RGBA_YUY2', [], [], None, ''],
        [u'const CV_YUV2BGRA_YUNV', u'CV_YUV2BGRA_YUY2', [], [], None, ''],
        [u'const CV_YUV2GRAY_UYVY', u'123', [], [], None, ''],
        [u'const CV_YUV2GRAY_YUY2', u'124', [], [], None, ''],
        [u'const CV_YUV2GRAY_Y422', u'CV_YUV2GRAY_UYVY', [], [], None, ''],
        [u'const CV_YUV2GRAY_UYNV', u'CV_YUV2GRAY_UYVY', [], [], None, ''],
        [u'const CV_YUV2GRAY_YVYU', u'CV_YUV2GRAY_YUY2', [], [], None, ''],
        [u'const CV_YUV2GRAY_YUYV', u'CV_YUV2GRAY_YUY2', [], [], None, ''],
        [u'const CV_YUV2GRAY_YUNV', u'CV_YUV2GRAY_YUY2', [], [], None, ''],
        [u'const CV_RGBA2mRGBA', u'125', [], [], None, ''],
        [u'const CV_mRGBA2RGBA', u'126', [], [], None, ''],
        [u'const CV_RGB2YUV_I420', u'127', [], [], None, ''],
        [u'const CV_BGR2YUV_I420', u'128', [], [], None, ''],
        [u'const CV_RGB2YUV_IYUV', u'CV_RGB2YUV_I420', [], [], None, ''],
        [u'const CV_BGR2YUV_IYUV', u'CV_BGR2YUV_I420', [], [], None, ''],
        [u'const CV_RGBA2YUV_I420', u'129', [], [], None, ''],
        [u'const CV_BGRA2YUV_I420', u'130', [], [], None, ''],
        [u'const CV_RGBA2YUV_IYUV', u'CV_RGBA2YUV_I420', [], [], None, ''],
        [u'const CV_BGRA2YUV_IYUV', u'CV_BGRA2YUV_I420', [], [], None, ''],
        [u'const CV_RGB2YUV_YV12', u'131', [], [], None, ''],
        [u'const CV_BGR2YUV_YV12', u'132', [], [], None, ''],
        [u'const CV_RGBA2YUV_YV12', u'133', [], [], None, ''],
        [u'const CV_BGRA2YUV_YV12', u'134', [], [], None, ''],
        [u'const CV_BayerBG2BGR_EA', u'135', [], [], None, ''],
        [u'const CV_BayerGB2BGR_EA', u'136', [], [], None, ''],
        [u'const CV_BayerRG2BGR_EA', u'137', [], [], None, ''],
        [u'const CV_BayerGR2BGR_EA', u'138', [], [], None, ''],
        [u'const CV_BayerBG2RGB_EA', u'CV_BayerRG2BGR_EA', [], [], None, ''],
        [u'const CV_BayerGB2RGB_EA', u'CV_BayerGR2BGR_EA', [], [], None, ''],
        [u'const CV_BayerRG2RGB_EA', u'CV_BayerBG2BGR_EA', [], [], None, ''],
        [u'const CV_BayerGR2RGB_EA', u'CV_BayerGB2BGR_EA', [], [], None, ''],
        [u'const CV_BayerBG2BGRA', u'139', [], [], None, ''],
        [u'const CV_BayerGB2BGRA', u'140', [], [], None, ''],
        [u'const CV_BayerRG2BGRA', u'141', [], [], None, ''],
        [u'const CV_BayerGR2BGRA', u'142', [], [], None, ''],
        [u'const CV_BayerBG2RGBA', u'CV_BayerRG2BGRA', [], [], None, ''],
        [u'const CV_BayerGB2RGBA', u'CV_BayerGR2BGRA', [], [], None, ''],
        [u'const CV_BayerRG2RGBA', u'CV_BayerBG2BGRA', [], [], None, ''],
        [u'const CV_BayerGR2RGBA', u'CV_BayerGB2BGRA', [], [], None, ''],
        [u'const CV_COLORCVT_MAX', u'143', [], [], None, '']],
    None]
ignored: CONST CV_BGR2BGRA=0
ignored: CONST CV_RGB2RGBA=CV_BGR2BGRA
ignored: CONST CV_BGRA2BGR=1
ignored: CONST CV_RGBA2RGB=CV_BGRA2BGR
ignored: CONST CV_BGR2RGBA=2
ignored: CONST CV_RGB2BGRA=CV_BGR2RGBA
ignored: CONST CV_RGBA2BGR=3
ignored: CONST CV_BGRA2RGB=CV_RGBA2BGR
ignored: CONST CV_BGR2RGB=4
ignored: CONST CV_RGB2BGR=CV_BGR2RGB
ignored: CONST CV_BGRA2RGBA=5
ignored: CONST CV_RGBA2BGRA=CV_BGRA2RGBA
ignored: CONST CV_BGR2GRAY=6
ignored: CONST CV_RGB2GRAY=7
ignored: CONST CV_GRAY2BGR=8
ignored: CONST CV_GRAY2RGB=CV_GRAY2BGR
ignored: CONST CV_GRAY2BGRA=9
ignored: CONST CV_GRAY2RGBA=CV_GRAY2BGRA
ignored: CONST CV_BGRA2GRAY=10
ignored: CONST CV_RGBA2GRAY=11
ignored: CONST CV_BGR2BGR565=12
ignored: CONST CV_RGB2BGR565=13
ignored: CONST CV_BGR5652BGR=14
ignored: CONST CV_BGR5652RGB=15
ignored: CONST CV_BGRA2BGR565=16
ignored: CONST CV_RGBA2BGR565=17
ignored: CONST CV_BGR5652BGRA=18
ignored: CONST CV_BGR5652RGBA=19
ignored: CONST CV_GRAY2BGR565=20
ignored: CONST CV_BGR5652GRAY=21
ignored: CONST CV_BGR2BGR555=22
ignored: CONST CV_RGB2BGR555=23
ignored: CONST CV_BGR5552BGR=24
ignored: CONST CV_BGR5552RGB=25
ignored: CONST CV_BGRA2BGR555=26
ignored: CONST CV_RGBA2BGR555=27
ignored: CONST CV_BGR5552BGRA=28
ignored: CONST CV_BGR5552RGBA=29
ignored: CONST CV_GRAY2BGR555=30
ignored: CONST CV_BGR5552GRAY=31
ignored: CONST CV_BGR2XYZ=32
ignored: CONST CV_RGB2XYZ=33
ignored: CONST CV_XYZ2BGR=34
ignored: CONST CV_XYZ2RGB=35
ignored: CONST CV_BGR2YCrCb=36
ignored: CONST CV_RGB2YCrCb=37
ignored: CONST CV_YCrCb2BGR=38
ignored: CONST CV_YCrCb2RGB=39
ignored: CONST CV_BGR2HSV=40
ignored: CONST CV_RGB2HSV=41
ignored: CONST CV_BGR2Lab=44
ignored: CONST CV_RGB2Lab=45
ignored: CONST CV_BayerBG2BGR=46
ignored: CONST CV_BayerGB2BGR=47
ignored: CONST CV_BayerRG2BGR=48
ignored: CONST CV_BayerGR2BGR=49
ignored: CONST CV_BayerBG2RGB=CV_BayerRG2BGR
ignored: CONST CV_BayerGB2RGB=CV_BayerGR2BGR
ignored: CONST CV_BayerRG2RGB=CV_BayerBG2BGR
ignored: CONST CV_BayerGR2RGB=CV_BayerGB2BGR
ignored: CONST CV_BGR2Luv=50
ignored: CONST CV_RGB2Luv=51
ignored: CONST CV_BGR2HLS=52
ignored: CONST CV_RGB2HLS=53
ignored: CONST CV_HSV2BGR=54
ignored: CONST CV_HSV2RGB=55
ignored: CONST CV_Lab2BGR=56
ignored: CONST CV_Lab2RGB=57
ignored: CONST CV_Luv2BGR=58
ignored: CONST CV_Luv2RGB=59
ignored: CONST CV_HLS2BGR=60
ignored: CONST CV_HLS2RGB=61
ignored: CONST CV_BayerBG2BGR_VNG=62
ignored: CONST CV_BayerGB2BGR_VNG=63
ignored: CONST CV_BayerRG2BGR_VNG=64
ignored: CONST CV_BayerGR2BGR_VNG=65
ignored: CONST CV_BayerBG2RGB_VNG=CV_BayerRG2BGR_VNG
ignored: CONST CV_BayerGB2RGB_VNG=CV_BayerGR2BGR_VNG
ignored: CONST CV_BayerRG2RGB_VNG=CV_BayerBG2BGR_VNG
ignored: CONST CV_BayerGR2RGB_VNG=CV_BayerGB2BGR_VNG
ignored: CONST CV_BGR2HSV_FULL=66
ignored: CONST CV_RGB2HSV_FULL=67
ignored: CONST CV_BGR2HLS_FULL=68
ignored: CONST CV_RGB2HLS_FULL=69
ignored: CONST CV_HSV2BGR_FULL=70
ignored: CONST CV_HSV2RGB_FULL=71
ignored: CONST CV_HLS2BGR_FULL=72
ignored: CONST CV_HLS2RGB_FULL=73
ignored: CONST CV_LBGR2Lab=74
ignored: CONST CV_LRGB2Lab=75
ignored: CONST CV_LBGR2Luv=76
ignored: CONST CV_LRGB2Luv=77
ignored: CONST CV_Lab2LBGR=78
ignored: CONST CV_Lab2LRGB=79
ignored: CONST CV_Luv2LBGR=80
ignored: CONST CV_Luv2LRGB=81
ignored: CONST CV_BGR2YUV=82
ignored: CONST CV_RGB2YUV=83
ignored: CONST CV_YUV2BGR=84
ignored: CONST CV_YUV2RGB=85
ignored: CONST CV_BayerBG2GRAY=86
ignored: CONST CV_BayerGB2GRAY=87
ignored: CONST CV_BayerRG2GRAY=88
ignored: CONST CV_BayerGR2GRAY=89
ignored: CONST CV_YUV2RGB_NV12=90
ignored: CONST CV_YUV2BGR_NV12=91
ignored: CONST CV_YUV2RGB_NV21=92
ignored: CONST CV_YUV2BGR_NV21=93
ignored: CONST CV_YUV420sp2RGB=CV_YUV2RGB_NV21
ignored: CONST CV_YUV420sp2BGR=CV_YUV2BGR_NV21
ignored: CONST CV_YUV2RGBA_NV12=94
ignored: CONST CV_YUV2BGRA_NV12=95
ignored: CONST CV_YUV2RGBA_NV21=96
ignored: CONST CV_YUV2BGRA_NV21=97
ignored: CONST CV_YUV420sp2RGBA=CV_YUV2RGBA_NV21
ignored: CONST CV_YUV420sp2BGRA=CV_YUV2BGRA_NV21
ignored: CONST CV_YUV2RGB_YV12=98
ignored: CONST CV_YUV2BGR_YV12=99
ignored: CONST CV_YUV2RGB_IYUV=100
ignored: CONST CV_YUV2BGR_IYUV=101
ignored: CONST CV_YUV2RGB_I420=CV_YUV2RGB_IYUV
ignored: CONST CV_YUV2BGR_I420=CV_YUV2BGR_IYUV
ignored: CONST CV_YUV420p2RGB=CV_YUV2RGB_YV12
ignored: CONST CV_YUV420p2BGR=CV_YUV2BGR_YV12
ignored: CONST CV_YUV2RGBA_YV12=102
ignored: CONST CV_YUV2BGRA_YV12=103
ignored: CONST CV_YUV2RGBA_IYUV=104
ignored: CONST CV_YUV2BGRA_IYUV=105
ignored: CONST CV_YUV2RGBA_I420=CV_YUV2RGBA_IYUV
ignored: CONST CV_YUV2BGRA_I420=CV_YUV2BGRA_IYUV
ignored: CONST CV_YUV420p2RGBA=CV_YUV2RGBA_YV12
ignored: CONST CV_YUV420p2BGRA=CV_YUV2BGRA_YV12
ignored: CONST CV_YUV2GRAY_420=106
ignored: CONST CV_YUV2GRAY_NV21=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_NV12=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_YV12=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_IYUV=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_I420=CV_YUV2GRAY_420
ignored: CONST CV_YUV420sp2GRAY=CV_YUV2GRAY_420
ignored: CONST CV_YUV420p2GRAY=CV_YUV2GRAY_420
ignored: CONST CV_YUV2RGB_UYVY=107
ignored: CONST CV_YUV2BGR_UYVY=108
ignored: CONST CV_YUV2RGB_Y422=CV_YUV2RGB_UYVY
ignored: CONST CV_YUV2BGR_Y422=CV_YUV2BGR_UYVY
ignored: CONST CV_YUV2RGB_UYNV=CV_YUV2RGB_UYVY
ignored: CONST CV_YUV2BGR_UYNV=CV_YUV2BGR_UYVY
ignored: CONST CV_YUV2RGBA_UYVY=111
ignored: CONST CV_YUV2BGRA_UYVY=112
ignored: CONST CV_YUV2RGBA_Y422=CV_YUV2RGBA_UYVY
ignored: CONST CV_YUV2BGRA_Y422=CV_YUV2BGRA_UYVY
ignored: CONST CV_YUV2RGBA_UYNV=CV_YUV2RGBA_UYVY
ignored: CONST CV_YUV2BGRA_UYNV=CV_YUV2BGRA_UYVY
ignored: CONST CV_YUV2RGB_YUY2=115
ignored: CONST CV_YUV2BGR_YUY2=116
ignored: CONST CV_YUV2RGB_YVYU=117
ignored: CONST CV_YUV2BGR_YVYU=118
ignored: CONST CV_YUV2RGB_YUYV=CV_YUV2RGB_YUY2
ignored: CONST CV_YUV2BGR_YUYV=CV_YUV2BGR_YUY2
ignored: CONST CV_YUV2RGB_YUNV=CV_YUV2RGB_YUY2
ignored: CONST CV_YUV2BGR_YUNV=CV_YUV2BGR_YUY2
ignored: CONST CV_YUV2RGBA_YUY2=119
ignored: CONST CV_YUV2BGRA_YUY2=120
ignored: CONST CV_YUV2RGBA_YVYU=121
ignored: CONST CV_YUV2BGRA_YVYU=122
ignored: CONST CV_YUV2RGBA_YUYV=CV_YUV2RGBA_YUY2
ignored: CONST CV_YUV2BGRA_YUYV=CV_YUV2BGRA_YUY2
ignored: CONST CV_YUV2RGBA_YUNV=CV_YUV2RGBA_YUY2
ignored: CONST CV_YUV2BGRA_YUNV=CV_YUV2BGRA_YUY2
ignored: CONST CV_YUV2GRAY_UYVY=123
ignored: CONST CV_YUV2GRAY_YUY2=124
ignored: CONST CV_YUV2GRAY_Y422=CV_YUV2GRAY_UYVY
ignored: CONST CV_YUV2GRAY_UYNV=CV_YUV2GRAY_UYVY
ignored: CONST CV_YUV2GRAY_YVYU=CV_YUV2GRAY_YUY2
ignored: CONST CV_YUV2GRAY_YUYV=CV_YUV2GRAY_YUY2
ignored: CONST CV_YUV2GRAY_YUNV=CV_YUV2GRAY_YUY2
ok: CONST CV_RGBA2mRGBA=125
ok: CONST CV_mRGBA2RGBA=126
ignored: CONST CV_RGB2YUV_I420=127
ignored: CONST CV_BGR2YUV_I420=128
ignored: CONST CV_RGB2YUV_IYUV=CV_RGB2YUV_I420
ignored: CONST CV_BGR2YUV_IYUV=CV_BGR2YUV_I420
ignored: CONST CV_RGBA2YUV_I420=129
ignored: CONST CV_BGRA2YUV_I420=130
ignored: CONST CV_RGBA2YUV_IYUV=CV_RGBA2YUV_I420
ignored: CONST CV_BGRA2YUV_IYUV=CV_BGRA2YUV_I420
ignored: CONST CV_RGB2YUV_YV12=131
ignored: CONST CV_BGR2YUV_YV12=132
ignored: CONST CV_RGBA2YUV_YV12=133
ignored: CONST CV_BGRA2YUV_YV12=134
ignored: CONST CV_BayerBG2BGR_EA=135
ignored: CONST CV_BayerGB2BGR_EA=136
ignored: CONST CV_BayerRG2BGR_EA=137
ignored: CONST CV_BayerGR2BGR_EA=138
ignored: CONST CV_BayerBG2RGB_EA=CV_BayerRG2BGR_EA
ignored: CONST CV_BayerGB2RGB_EA=CV_BayerGR2BGR_EA
ignored: CONST CV_BayerRG2RGB_EA=CV_BayerBG2BGR_EA
ignored: CONST CV_BayerGR2RGB_EA=CV_BayerGB2BGR_EA
ignored: CONST CV_BayerBG2BGRA=139
ignored: CONST CV_BayerGB2BGRA=140
ignored: CONST CV_BayerRG2BGRA=141
ignored: CONST CV_BayerGR2BGRA=142
ignored: CONST CV_BayerBG2RGBA=CV_BayerRG2BGRA
ignored: CONST CV_BayerGB2RGBA=CV_BayerGR2BGRA
ignored: CONST CV_BayerRG2RGBA=CV_BayerBG2BGRA
ignored: CONST CV_BayerGR2RGBA=CV_BayerGB2BGRA
ignored: CONST CV_COLORCVT_MAX=143

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_INTER_NN', u'0', [], [], None, ''],
        [u'const CV_INTER_LINEAR', u'1', [], [], None, ''],
        [u'const CV_INTER_CUBIC', u'2', [], [], None, ''],
        [u'const CV_INTER_AREA', u'3', [], [], None, ''],
        [u'const CV_INTER_LANCZOS4', u'4', [], [], None, '']],
    None]
ok: CONST CV_INTER_NN=0
ok: CONST CV_INTER_LINEAR=1
ok: CONST CV_INTER_CUBIC=2
ok: CONST CV_INTER_AREA=3
ok: CONST CV_INTER_LANCZOS4=4

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_WARP_FILL_OUTLIERS', u'8', [], [], None, ''],
        [u'const CV_WARP_INVERSE_MAP', u'16', [], [], None, '']],
    None]
ok: CONST CV_WARP_FILL_OUTLIERS=8
ok: CONST CV_WARP_INVERSE_MAP=16

--- Incoming ---
[   u'enum MorphShapes_c',
    '',
    [],
    [   [u'const CV_SHAPE_RECT', u'0', [], [], None, ''],
        [u'const CV_SHAPE_CROSS', u'1', [], [], None, ''],
        [u'const CV_SHAPE_ELLIPSE', u'2', [], [], None, ''],
        [u'const CV_SHAPE_CUSTOM', u'100', [], [], None, '']],
    None]
ok: CONST CV_SHAPE_RECT=0
ok: CONST CV_SHAPE_CROSS=1
ok: CONST CV_SHAPE_ELLIPSE=2
ok: CONST CV_SHAPE_CUSTOM=100

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_MOP_ERODE', u'0', [], [], None, ''],
        [u'const CV_MOP_DILATE', u'1', [], [], None, ''],
        [u'const CV_MOP_OPEN', u'2', [], [], None, ''],
        [u'const CV_MOP_CLOSE', u'3', [], [], None, ''],
        [u'const CV_MOP_GRADIENT', u'4', [], [], None, ''],
        [u'const CV_MOP_TOPHAT', u'5', [], [], None, ''],
        [u'const CV_MOP_BLACKHAT', u'6', [], [], None, '']],
    None]
ok: CONST CV_MOP_ERODE=0
ok: CONST CV_MOP_DILATE=1
ok: CONST CV_MOP_OPEN=2
ok: CONST CV_MOP_CLOSE=3
ok: CONST CV_MOP_GRADIENT=4
ok: CONST CV_MOP_TOPHAT=5
ok: CONST CV_MOP_BLACKHAT=6

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_TM_SQDIFF', u'0', [], [], None, ''],
        [u'const CV_TM_SQDIFF_NORMED', u'1', [], [], None, ''],
        [u'const CV_TM_CCORR', u'2', [], [], None, ''],
        [u'const CV_TM_CCORR_NORMED', u'3', [], [], None, ''],
        [u'const CV_TM_CCOEFF', u'4', [], [], None, ''],
        [u'const CV_TM_CCOEFF_NORMED', u'5', [], [], None, '']],
    None]
ignored: CONST CV_TM_SQDIFF=0
ignored: CONST CV_TM_SQDIFF_NORMED=1
ignored: CONST CV_TM_CCORR=2
ignored: CONST CV_TM_CCORR_NORMED=3
ignored: CONST CV_TM_CCOEFF=4
ignored: CONST CV_TM_CCOEFF_NORMED=5

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_RETR_EXTERNAL', u'0', [], [], None, ''],
        [u'const CV_RETR_LIST', u'1', [], [], None, ''],
        [u'const CV_RETR_CCOMP', u'2', [], [], None, ''],
        [u'const CV_RETR_TREE', u'3', [], [], None, ''],
        [u'const CV_RETR_FLOODFILL', u'4', [], [], None, '']],
    None]
ok: CONST CV_RETR_EXTERNAL=0
ok: CONST CV_RETR_LIST=1
ok: CONST CV_RETR_CCOMP=2
ok: CONST CV_RETR_TREE=3
ok: CONST CV_RETR_FLOODFILL=4

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_CHAIN_CODE', u'0', [], [], None, ''],
        [u'const CV_CHAIN_APPROX_NONE', u'1', [], [], None, ''],
        [u'const CV_CHAIN_APPROX_SIMPLE', u'2', [], [], None, ''],
        [u'const CV_CHAIN_APPROX_TC89_L1', u'3', [], [], None, ''],
        [u'const CV_CHAIN_APPROX_TC89_KCOS', u'4', [], [], None, ''],
        [u'const CV_LINK_RUNS', u'5', [], [], None, '']],
    None]
ok: CONST CV_CHAIN_CODE=0
ok: CONST CV_CHAIN_APPROX_NONE=1
ok: CONST CV_CHAIN_APPROX_SIMPLE=2
ok: CONST CV_CHAIN_APPROX_TC89_L1=3
ok: CONST CV_CHAIN_APPROX_TC89_KCOS=4
ok: CONST CV_LINK_RUNS=5

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [[u'const CV_POLY_APPROX_DP', u'0', [], [], None, '']],
    None]
ok: CONST CV_POLY_APPROX_DP=0

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_CONTOURS_MATCH_I1', u'1', [], [], None, ''],
        [u'const CV_CONTOURS_MATCH_I2', u'2', [], [], None, ''],
        [u'const CV_CONTOURS_MATCH_I3', u'3', [], [], None, '']],
    None]
ok: CONST CV_CONTOURS_MATCH_I1=1
ok: CONST CV_CONTOURS_MATCH_I2=2
ok: CONST CV_CONTOURS_MATCH_I3=3

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_CLOCKWISE', u'1', [], [], None, ''],
        [u'const CV_COUNTER_CLOCKWISE', u'2', [], [], None, '']],
    None]
ok: CONST CV_CLOCKWISE=1
ok: CONST CV_COUNTER_CLOCKWISE=2

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_COMP_CORREL', u'0', [], [], None, ''],
        [u'const CV_COMP_CHISQR', u'1', [], [], None, ''],
        [u'const CV_COMP_INTERSECT', u'2', [], [], None, ''],
        [u'const CV_COMP_BHATTACHARYYA', u'3', [], [], None, ''],
        [   u'const CV_COMP_HELLINGER',
            u'CV_COMP_BHATTACHARYYA',
            [],
            [],
            None,
            ''],
        [u'const CV_COMP_CHISQR_ALT', u'4', [], [], None, ''],
        [u'const CV_COMP_KL_DIV', u'5', [], [], None, '']],
    None]
ok: CONST CV_COMP_CORREL=0
ok: CONST CV_COMP_CHISQR=1
ok: CONST CV_COMP_INTERSECT=2
ok: CONST CV_COMP_BHATTACHARYYA=3
ok: CONST CV_COMP_HELLINGER=CV_COMP_BHATTACHARYYA
ok: CONST CV_COMP_CHISQR_ALT=4
ok: CONST CV_COMP_KL_DIV=5

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_DIST_MASK_3', u'3', [], [], None, ''],
        [u'const CV_DIST_MASK_5', u'5', [], [], None, ''],
        [u'const CV_DIST_MASK_PRECISE', u'0', [], [], None, '']],
    None]
ok: CONST CV_DIST_MASK_3=3
ok: CONST CV_DIST_MASK_5=5
ok: CONST CV_DIST_MASK_PRECISE=0

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_DIST_LABEL_CCOMP', u'0', [], [], None, ''],
        [u'const CV_DIST_LABEL_PIXEL', u'1', [], [], None, '']],
    None]
ok: CONST CV_DIST_LABEL_CCOMP=0
ok: CONST CV_DIST_LABEL_PIXEL=1

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_DIST_USER', u'-1', [], [], None, ''],
        [u'const CV_DIST_L1', u'1', [], [], None, ''],
        [u'const CV_DIST_L2', u'2', [], [], None, ''],
        [u'const CV_DIST_C', u'3', [], [], None, ''],
        [u'const CV_DIST_L12', u'4', [], [], None, ''],
        [u'const CV_DIST_FAIR', u'5', [], [], None, ''],
        [u'const CV_DIST_WELSCH', u'6', [], [], None, ''],
        [u'const CV_DIST_HUBER', u'7', [], [], None, '']],
    None]
ok: CONST CV_DIST_USER=-1
ok: CONST CV_DIST_L1=1
ok: CONST CV_DIST_L2=2
ok: CONST CV_DIST_C=3
ok: CONST CV_DIST_L12=4
ok: CONST CV_DIST_FAIR=5
ok: CONST CV_DIST_WELSCH=6
ok: CONST CV_DIST_HUBER=7

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_THRESH_BINARY', u'0', [], [], None, ''],
        [u'const CV_THRESH_BINARY_INV', u'1', [], [], None, ''],
        [u'const CV_THRESH_TRUNC', u'2', [], [], None, ''],
        [u'const CV_THRESH_TOZERO', u'3', [], [], None, ''],
        [u'const CV_THRESH_TOZERO_INV', u'4', [], [], None, ''],
        [u'const CV_THRESH_MASK', u'7', [], [], None, ''],
        [u'const CV_THRESH_OTSU', u'8', [], [], None, ''],
        [u'const CV_THRESH_TRIANGLE', u'16', [], [], None, '']],
    None]
ok: CONST CV_THRESH_BINARY=0
ok: CONST CV_THRESH_BINARY_INV=1
ok: CONST CV_THRESH_TRUNC=2
ok: CONST CV_THRESH_TOZERO=3
ok: CONST CV_THRESH_TOZERO_INV=4
ok: CONST CV_THRESH_MASK=7
ok: CONST CV_THRESH_OTSU=8
ok: CONST CV_THRESH_TRIANGLE=16

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_ADAPTIVE_THRESH_MEAN_C', u'0', [], [], None, ''],
        [u'const CV_ADAPTIVE_THRESH_GAUSSIAN_C', u'1', [], [], None, '']],
    None]
ignored: CONST CV_ADAPTIVE_THRESH_MEAN_C=0
ignored: CONST CV_ADAPTIVE_THRESH_GAUSSIAN_C=1

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_FLOODFILL_FIXED_RANGE', u'(1 << 16)', [], [], None, ''],
        [u'const CV_FLOODFILL_MASK_ONLY', u'(1 << 17)', [], [], None, '']],
    None]
ignored: CONST CV_FLOODFILL_FIXED_RANGE=(1 << 16)
ignored: CONST CV_FLOODFILL_MASK_ONLY=(1 << 17)

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [[u'const CV_CANNY_L2_GRADIENT', u'(1 << 31)', [], [], None, '']],
    None]
ok: CONST CV_CANNY_L2_GRADIENT=(1 << 31)

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_HOUGH_STANDARD', u'0', [], [], None, ''],
        [u'const CV_HOUGH_PROBABILISTIC', u'1', [], [], None, ''],
        [u'const CV_HOUGH_MULTI_SCALE', u'2', [], [], None, ''],
        [u'const CV_HOUGH_GRADIENT', u'3', [], [], None, '']],
    None]
ok: CONST CV_HOUGH_STANDARD=0
ok: CONST CV_HOUGH_PROBABILISTIC=1
ok: CONST CV_HOUGH_MULTI_SCALE=2
ok: CONST CV_HOUGH_GRADIENT=3


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/hal/interface.h =====
Namespaces: set([''])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/hal/interface.h


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[   u'enum cv.SpecialFilter',
    '',
    [],
    [[u'const cv.FILTER_SCHARR', u'-1', [], [], None, '']],
    None]
ok: CONST FILTER_SCHARR=-1

--- Incoming ---
[   u'enum cv.MorphTypes',
    '',
    [],
    [   [u'const cv.MORPH_ERODE', u'0', [], [], None, ''],
        [u'const cv.MORPH_DILATE', u'1', [], [], None, ''],
        [u'const cv.MORPH_OPEN', u'2', [], [], None, ''],
        [u'const cv.MORPH_CLOSE', u'3', [], [], None, ''],
        [u'const cv.MORPH_GRADIENT', u'4', [], [], None, ''],
        [u'const cv.MORPH_TOPHAT', u'5', [], [], None, ''],
        [u'const cv.MORPH_BLACKHAT', u'6', [], [], None, ''],
        [u'const cv.MORPH_HITMISS', u'7', [], [], None, '']],
    None]
ok: CONST MORPH_ERODE=0
ok: CONST MORPH_DILATE=1
ok: CONST MORPH_OPEN=2
ok: CONST MORPH_CLOSE=3
ok: CONST MORPH_GRADIENT=4
ok: CONST MORPH_TOPHAT=5
ok: CONST MORPH_BLACKHAT=6
ok: CONST MORPH_HITMISS=7

--- Incoming ---
[   u'enum cv.MorphShapes',
    '',
    [],
    [   [u'const cv.MORPH_RECT', u'0', [], [], None, ''],
        [u'const cv.MORPH_CROSS', u'1', [], [], None, ''],
        [u'const cv.MORPH_ELLIPSE', u'2', [], [], None, '']],
    None]
ok: CONST MORPH_RECT=0
ok: CONST MORPH_CROSS=1
ok: CONST MORPH_ELLIPSE=2

--- Incoming ---
[   u'enum cv.InterpolationFlags',
    '',
    [],
    [   [u'const cv.INTER_NEAREST', u'0', [], [], None, ''],
        [u'const cv.INTER_LINEAR', u'1', [], [], None, ''],
        [u'const cv.INTER_CUBIC', u'2', [], [], None, ''],
        [u'const cv.INTER_AREA', u'3', [], [], None, ''],
        [u'const cv.INTER_LANCZOS4', u'4', [], [], None, ''],
        [u'const cv.INTER_LINEAR_EXACT', u'5', [], [], None, ''],
        [u'const cv.INTER_MAX', u'7', [], [], None, ''],
        [u'const cv.WARP_FILL_OUTLIERS', u'8', [], [], None, ''],
        [u'const cv.WARP_INVERSE_MAP', u'16', [], [], None, '']],
    None]
ok: CONST INTER_NEAREST=0
ok: CONST INTER_LINEAR=1
ok: CONST INTER_CUBIC=2
ok: CONST INTER_AREA=3
ok: CONST INTER_LANCZOS4=4
ok: CONST INTER_LINEAR_EXACT=5
ok: CONST INTER_MAX=7
ok: CONST WARP_FILL_OUTLIERS=8
ok: CONST WARP_INVERSE_MAP=16

--- Incoming ---
[   u'enum cv.WarpPolarMode',
    '',
    [],
    [   [u'const cv.WARP_POLAR_LINEAR', u'0', [], [], None, ''],
        [u'const cv.WARP_POLAR_LOG', u'256', [], [], None, '']],
    None]
ok: CONST WARP_POLAR_LINEAR=0
ok: CONST WARP_POLAR_LOG=256

--- Incoming ---
[   u'enum cv.InterpolationMasks',
    '',
    [],
    [   [u'const cv.INTER_BITS', u'5', [], [], None, ''],
        [u'const cv.INTER_BITS2', u'INTER_BITS * 2', [], [], None, ''],
        [u'const cv.INTER_TAB_SIZE', u'1 << INTER_BITS', [], [], None, ''],
        [   u'const cv.INTER_TAB_SIZE2',
            u'INTER_TAB_SIZE * INTER_TAB_SIZE',
            [],
            [],
            None,
            '']],
    None]
ok: CONST INTER_BITS=5
ok: CONST INTER_BITS2=INTER_BITS * 2
ok: CONST INTER_TAB_SIZE=1 << INTER_BITS
ok: CONST INTER_TAB_SIZE2=INTER_TAB_SIZE * INTER_TAB_SIZE

--- Incoming ---
[   u'enum cv.DistanceTypes',
    '',
    [],
    [   [u'const cv.DIST_USER', u'-1', [], [], None, ''],
        [u'const cv.DIST_L1', u'1', [], [], None, ''],
        [u'const cv.DIST_L2', u'2', [], [], None, ''],
        [u'const cv.DIST_C', u'3', [], [], None, ''],
        [u'const cv.DIST_L12', u'4', [], [], None, ''],
        [u'const cv.DIST_FAIR', u'5', [], [], None, ''],
        [u'const cv.DIST_WELSCH', u'6', [], [], None, ''],
        [u'const cv.DIST_HUBER', u'7', [], [], None, '']],
    None]
ok: CONST DIST_USER=-1
ok: CONST DIST_L1=1
ok: CONST DIST_L2=2
ok: CONST DIST_C=3
ok: CONST DIST_L12=4
ok: CONST DIST_FAIR=5
ok: CONST DIST_WELSCH=6
ok: CONST DIST_HUBER=7

--- Incoming ---
[   u'enum cv.DistanceTransformMasks',
    '',
    [],
    [   [u'const cv.DIST_MASK_3', u'3', [], [], None, ''],
        [u'const cv.DIST_MASK_5', u'5', [], [], None, ''],
        [u'const cv.DIST_MASK_PRECISE', u'0', [], [], None, '']],
    None]
ok: CONST DIST_MASK_3=3
ok: CONST DIST_MASK_5=5
ok: CONST DIST_MASK_PRECISE=0

--- Incoming ---
[   u'enum cv.ThresholdTypes',
    '',
    [],
    [   [u'const cv.THRESH_BINARY', u'0', [], [], None, ''],
        [u'const cv.THRESH_BINARY_INV', u'1', [], [], None, ''],
        [u'const cv.THRESH_TRUNC', u'2', [], [], None, ''],
        [u'const cv.THRESH_TOZERO', u'3', [], [], None, ''],
        [u'const cv.THRESH_TOZERO_INV', u'4', [], [], None, ''],
        [u'const cv.THRESH_MASK', u'7', [], [], None, ''],
        [u'const cv.THRESH_OTSU', u'8', [], [], None, ''],
        [u'const cv.THRESH_TRIANGLE', u'16', [], [], None, '']],
    None]
ok: CONST THRESH_BINARY=0
ok: CONST THRESH_BINARY_INV=1
ok: CONST THRESH_TRUNC=2
ok: CONST THRESH_TOZERO=3
ok: CONST THRESH_TOZERO_INV=4
ok: CONST THRESH_MASK=7
ok: CONST THRESH_OTSU=8
ok: CONST THRESH_TRIANGLE=16

--- Incoming ---
[   u'enum cv.AdaptiveThresholdTypes',
    '',
    [],
    [   [u'const cv.ADAPTIVE_THRESH_MEAN_C', u'0', [], [], None, ''],
        [u'const cv.ADAPTIVE_THRESH_GAUSSIAN_C', u'1', [], [], None, '']],
    None]
ok: CONST ADAPTIVE_THRESH_MEAN_C=0
ok: CONST ADAPTIVE_THRESH_GAUSSIAN_C=1

--- Incoming ---
[   u'enum cv.GrabCutClasses',
    '',
    [],
    [   [u'const cv.GC_BGD', u'0', [], [], None, ''],
        [u'const cv.GC_FGD', u'1', [], [], None, ''],
        [u'const cv.GC_PR_BGD', u'2', [], [], None, ''],
        [u'const cv.GC_PR_FGD', u'3', [], [], None, '']],
    None]
ok: CONST GC_BGD=0
ok: CONST GC_FGD=1
ok: CONST GC_PR_BGD=2
ok: CONST GC_PR_FGD=3

--- Incoming ---
[   u'enum cv.GrabCutModes',
    '',
    [],
    [   [u'const cv.GC_INIT_WITH_RECT', u'0', [], [], None, ''],
        [u'const cv.GC_INIT_WITH_MASK', u'1', [], [], None, ''],
        [u'const cv.GC_EVAL', u'2', [], [], None, ''],
        [u'const cv.GC_EVAL_FREEZE_MODEL', u'3', [], [], None, '']],
    None]
ok: CONST GC_INIT_WITH_RECT=0
ok: CONST GC_INIT_WITH_MASK=1
ok: CONST GC_EVAL=2
ok: CONST GC_EVAL_FREEZE_MODEL=3

--- Incoming ---
[   u'enum cv.DistanceTransformLabelTypes',
    '',
    [],
    [   [u'const cv.DIST_LABEL_CCOMP', u'0', [], [], None, ''],
        [u'const cv.DIST_LABEL_PIXEL', u'1', [], [], None, '']],
    None]
ok: CONST DIST_LABEL_CCOMP=0
ok: CONST DIST_LABEL_PIXEL=1

--- Incoming ---
[   u'enum cv.FloodFillFlags',
    '',
    [],
    [   [u'const cv.FLOODFILL_FIXED_RANGE', u'1 << 16', [], [], None, ''],
        [u'const cv.FLOODFILL_MASK_ONLY', u'1 << 17', [], [], None, '']],
    None]
ok: CONST FLOODFILL_FIXED_RANGE=1 << 16
ok: CONST FLOODFILL_MASK_ONLY=1 << 17

--- Incoming ---
[   u'enum cv.ConnectedComponentsTypes',
    '',
    [],
    [   [u'const cv.CC_STAT_LEFT', u'0', [], [], None, ''],
        [u'const cv.CC_STAT_TOP', u'1', [], [], None, ''],
        [u'const cv.CC_STAT_WIDTH', u'2', [], [], None, ''],
        [u'const cv.CC_STAT_HEIGHT', u'3', [], [], None, ''],
        [u'const cv.CC_STAT_AREA', u'4', [], [], None, ''],
        [u'const cv.CC_STAT_MAX', u'5', [], [], None, '']],
    None]
ok: CONST CC_STAT_LEFT=0
ok: CONST CC_STAT_TOP=1
ok: CONST CC_STAT_WIDTH=2
ok: CONST CC_STAT_HEIGHT=3
ok: CONST CC_STAT_AREA=4
ok: CONST CC_STAT_MAX=5

--- Incoming ---
[   u'enum cv.ConnectedComponentsAlgorithmsTypes',
    '',
    [],
    [   [u'const cv.CCL_WU', u'0', [], [], None, ''],
        [u'const cv.CCL_DEFAULT', u'-1', [], [], None, ''],
        [u'const cv.CCL_GRANA', u'1', [], [], None, '']],
    None]
ok: CONST CCL_WU=0
ok: CONST CCL_DEFAULT=-1
ok: CONST CCL_GRANA=1

--- Incoming ---
[   u'enum cv.RetrievalModes',
    '',
    [],
    [   [u'const cv.RETR_EXTERNAL', u'0', [], [], None, ''],
        [u'const cv.RETR_LIST', u'1', [], [], None, ''],
        [u'const cv.RETR_CCOMP', u'2', [], [], None, ''],
        [u'const cv.RETR_TREE', u'3', [], [], None, ''],
        [u'const cv.RETR_FLOODFILL', u'4', [], [], None, '']],
    None]
ok: CONST RETR_EXTERNAL=0
ok: CONST RETR_LIST=1
ok: CONST RETR_CCOMP=2
ok: CONST RETR_TREE=3
ok: CONST RETR_FLOODFILL=4

--- Incoming ---
[   u'enum cv.ContourApproximationModes',
    '',
    [],
    [   [u'const cv.CHAIN_APPROX_NONE', u'1', [], [], None, ''],
        [u'const cv.CHAIN_APPROX_SIMPLE', u'2', [], [], None, ''],
        [u'const cv.CHAIN_APPROX_TC89_L1', u'3', [], [], None, ''],
        [u'const cv.CHAIN_APPROX_TC89_KCOS', u'4', [], [], None, '']],
    None]
ok: CONST CHAIN_APPROX_NONE=1
ok: CONST CHAIN_APPROX_SIMPLE=2
ok: CONST CHAIN_APPROX_TC89_L1=3
ok: CONST CHAIN_APPROX_TC89_KCOS=4

--- Incoming ---
[   u'enum cv.ShapeMatchModes',
    '',
    [],
    [   [u'const cv.CONTOURS_MATCH_I1', u'1', [], [], None, ''],
        [u'const cv.CONTOURS_MATCH_I2', u'2', [], [], None, ''],
        [u'const cv.CONTOURS_MATCH_I3', u'3', [], [], None, '']],
    None]
ok: CONST CONTOURS_MATCH_I1=1
ok: CONST CONTOURS_MATCH_I2=2
ok: CONST CONTOURS_MATCH_I3=3

--- Incoming ---
[   u'enum cv.HoughModes',
    '',
    [],
    [   [u'const cv.HOUGH_STANDARD', u'0', [], [], None, ''],
        [u'const cv.HOUGH_PROBABILISTIC', u'1', [], [], None, ''],
        [u'const cv.HOUGH_MULTI_SCALE', u'2', [], [], None, ''],
        [u'const cv.HOUGH_GRADIENT', u'3', [], [], None, '']],
    None]
ok: CONST HOUGH_STANDARD=0
ok: CONST HOUGH_PROBABILISTIC=1
ok: CONST HOUGH_MULTI_SCALE=2
ok: CONST HOUGH_GRADIENT=3

--- Incoming ---
[   u'enum cv.LineSegmentDetectorModes',
    '',
    [],
    [   [u'const cv.LSD_REFINE_NONE', u'0', [], [], None, ''],
        [u'const cv.LSD_REFINE_STD', u'1', [], [], None, ''],
        [u'const cv.LSD_REFINE_ADV', u'2', [], [], None, '']],
    None]
ok: CONST LSD_REFINE_NONE=0
ok: CONST LSD_REFINE_STD=1
ok: CONST LSD_REFINE_ADV=2

--- Incoming ---
[   u'enum cv.HistCompMethods',
    '',
    [],
    [   [u'const cv.HISTCMP_CORREL', u'0', [], [], None, ''],
        [u'const cv.HISTCMP_CHISQR', u'1', [], [], None, ''],
        [u'const cv.HISTCMP_INTERSECT', u'2', [], [], None, ''],
        [u'const cv.HISTCMP_BHATTACHARYYA', u'3', [], [], None, ''],
        [   u'const cv.HISTCMP_HELLINGER',
            u'HISTCMP_BHATTACHARYYA',
            [],
            [],
            None,
            ''],
        [u'const cv.HISTCMP_CHISQR_ALT', u'4', [], [], None, ''],
        [u'const cv.HISTCMP_KL_DIV', u'5', [], [], None, '']],
    None]
ok: CONST HISTCMP_CORREL=0
ok: CONST HISTCMP_CHISQR=1
ok: CONST HISTCMP_INTERSECT=2
ok: CONST HISTCMP_BHATTACHARYYA=3
ok: CONST HISTCMP_HELLINGER=HISTCMP_BHATTACHARYYA
ok: CONST HISTCMP_CHISQR_ALT=4
ok: CONST HISTCMP_KL_DIV=5

--- Incoming ---
[   u'enum cv.ColorConversionCodes',
    '',
    [],
    [   [u'const cv.COLOR_BGR2BGRA', u'0', [], [], None, ''],
        [u'const cv.COLOR_RGB2RGBA', u'COLOR_BGR2BGRA', [], [], None, ''],
        [u'const cv.COLOR_BGRA2BGR', u'1', [], [], None, ''],
        [u'const cv.COLOR_RGBA2RGB', u'COLOR_BGRA2BGR', [], [], None, ''],
        [u'const cv.COLOR_BGR2RGBA', u'2', [], [], None, ''],
        [u'const cv.COLOR_RGB2BGRA', u'COLOR_BGR2RGBA', [], [], None, ''],
        [u'const cv.COLOR_RGBA2BGR', u'3', [], [], None, ''],
        [u'const cv.COLOR_BGRA2RGB', u'COLOR_RGBA2BGR', [], [], None, ''],
        [u'const cv.COLOR_BGR2RGB', u'4', [], [], None, ''],
        [u'const cv.COLOR_RGB2BGR', u'COLOR_BGR2RGB', [], [], None, ''],
        [u'const cv.COLOR_BGRA2RGBA', u'5', [], [], None, ''],
        [u'const cv.COLOR_RGBA2BGRA', u'COLOR_BGRA2RGBA', [], [], None, ''],
        [u'const cv.COLOR_BGR2GRAY', u'6', [], [], None, ''],
        [u'const cv.COLOR_RGB2GRAY', u'7', [], [], None, ''],
        [u'const cv.COLOR_GRAY2BGR', u'8', [], [], None, ''],
        [u'const cv.COLOR_GRAY2RGB', u'COLOR_GRAY2BGR', [], [], None, ''],
        [u'const cv.COLOR_GRAY2BGRA', u'9', [], [], None, ''],
        [u'const cv.COLOR_GRAY2RGBA', u'COLOR_GRAY2BGRA', [], [], None, ''],
        [u'const cv.COLOR_BGRA2GRAY', u'10', [], [], None, ''],
        [u'const cv.COLOR_RGBA2GRAY', u'11', [], [], None, ''],
        [u'const cv.COLOR_BGR2BGR565', u'12', [], [], None, ''],
        [u'const cv.COLOR_RGB2BGR565', u'13', [], [], None, ''],
        [u'const cv.COLOR_BGR5652BGR', u'14', [], [], None, ''],
        [u'const cv.COLOR_BGR5652RGB', u'15', [], [], None, ''],
        [u'const cv.COLOR_BGRA2BGR565', u'16', [], [], None, ''],
        [u'const cv.COLOR_RGBA2BGR565', u'17', [], [], None, ''],
        [u'const cv.COLOR_BGR5652BGRA', u'18', [], [], None, ''],
        [u'const cv.COLOR_BGR5652RGBA', u'19', [], [], None, ''],
        [u'const cv.COLOR_GRAY2BGR565', u'20', [], [], None, ''],
        [u'const cv.COLOR_BGR5652GRAY', u'21', [], [], None, ''],
        [u'const cv.COLOR_BGR2BGR555', u'22', [], [], None, ''],
        [u'const cv.COLOR_RGB2BGR555', u'23', [], [], None, ''],
        [u'const cv.COLOR_BGR5552BGR', u'24', [], [], None, ''],
        [u'const cv.COLOR_BGR5552RGB', u'25', [], [], None, ''],
        [u'const cv.COLOR_BGRA2BGR555', u'26', [], [], None, ''],
        [u'const cv.COLOR_RGBA2BGR555', u'27', [], [], None, ''],
        [u'const cv.COLOR_BGR5552BGRA', u'28', [], [], None, ''],
        [u'const cv.COLOR_BGR5552RGBA', u'29', [], [], None, ''],
        [u'const cv.COLOR_GRAY2BGR555', u'30', [], [], None, ''],
        [u'const cv.COLOR_BGR5552GRAY', u'31', [], [], None, ''],
        [u'const cv.COLOR_BGR2XYZ', u'32', [], [], None, ''],
        [u'const cv.COLOR_RGB2XYZ', u'33', [], [], None, ''],
        [u'const cv.COLOR_XYZ2BGR', u'34', [], [], None, ''],
        [u'const cv.COLOR_XYZ2RGB', u'35', [], [], None, ''],
        [u'const cv.COLOR_BGR2YCrCb', u'36', [], [], None, ''],
        [u'const cv.COLOR_RGB2YCrCb', u'37', [], [], None, ''],
        [u'const cv.COLOR_YCrCb2BGR', u'38', [], [], None, ''],
        [u'const cv.COLOR_YCrCb2RGB', u'39', [], [], None, ''],
        [u'const cv.COLOR_BGR2HSV', u'40', [], [], None, ''],
        [u'const cv.COLOR_RGB2HSV', u'41', [], [], None, ''],
        [u'const cv.COLOR_BGR2Lab', u'44', [], [], None, ''],
        [u'const cv.COLOR_RGB2Lab', u'45', [], [], None, ''],
        [u'const cv.COLOR_BGR2Luv', u'50', [], [], None, ''],
        [u'const cv.COLOR_RGB2Luv', u'51', [], [], None, ''],
        [u'const cv.COLOR_BGR2HLS', u'52', [], [], None, ''],
        [u'const cv.COLOR_RGB2HLS', u'53', [], [], None, ''],
        [u'const cv.COLOR_HSV2BGR', u'54', [], [], None, ''],
        [u'const cv.COLOR_HSV2RGB', u'55', [], [], None, ''],
        [u'const cv.COLOR_Lab2BGR', u'56', [], [], None, ''],
        [u'const cv.COLOR_Lab2RGB', u'57', [], [], None, ''],
        [u'const cv.COLOR_Luv2BGR', u'58', [], [], None, ''],
        [u'const cv.COLOR_Luv2RGB', u'59', [], [], None, ''],
        [u'const cv.COLOR_HLS2BGR', u'60', [], [], None, ''],
        [u'const cv.COLOR_HLS2RGB', u'61', [], [], None, ''],
        [u'const cv.COLOR_BGR2HSV_FULL', u'66', [], [], None, ''],
        [u'const cv.COLOR_RGB2HSV_FULL', u'67', [], [], None, ''],
        [u'const cv.COLOR_BGR2HLS_FULL', u'68', [], [], None, ''],
        [u'const cv.COLOR_RGB2HLS_FULL', u'69', [], [], None, ''],
        [u'const cv.COLOR_HSV2BGR_FULL', u'70', [], [], None, ''],
        [u'const cv.COLOR_HSV2RGB_FULL', u'71', [], [], None, ''],
        [u'const cv.COLOR_HLS2BGR_FULL', u'72', [], [], None, ''],
        [u'const cv.COLOR_HLS2RGB_FULL', u'73', [], [], None, ''],
        [u'const cv.COLOR_LBGR2Lab', u'74', [], [], None, ''],
        [u'const cv.COLOR_LRGB2Lab', u'75', [], [], None, ''],
        [u'const cv.COLOR_LBGR2Luv', u'76', [], [], None, ''],
        [u'const cv.COLOR_LRGB2Luv', u'77', [], [], None, ''],
        [u'const cv.COLOR_Lab2LBGR', u'78', [], [], None, ''],
        [u'const cv.COLOR_Lab2LRGB', u'79', [], [], None, ''],
        [u'const cv.COLOR_Luv2LBGR', u'80', [], [], None, ''],
        [u'const cv.COLOR_Luv2LRGB', u'81', [], [], None, ''],
        [u'const cv.COLOR_BGR2YUV', u'82', [], [], None, ''],
        [u'const cv.COLOR_RGB2YUV', u'83', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR', u'84', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB', u'85', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB_NV12', u'90', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_NV12', u'91', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB_NV21', u'92', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_NV21', u'93', [], [], None, ''],
        [   u'const cv.COLOR_YUV420sp2RGB',
            u'COLOR_YUV2RGB_NV21',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420sp2BGR',
            u'COLOR_YUV2BGR_NV21',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGBA_NV12', u'94', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_NV12', u'95', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGBA_NV21', u'96', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_NV21', u'97', [], [], None, ''],
        [   u'const cv.COLOR_YUV420sp2RGBA',
            u'COLOR_YUV2RGBA_NV21',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420sp2BGRA',
            u'COLOR_YUV2BGRA_NV21',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGB_YV12', u'98', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_YV12', u'99', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB_IYUV', u'100', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_IYUV', u'101', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGB_I420',
            u'COLOR_YUV2RGB_IYUV',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_I420',
            u'COLOR_YUV2BGR_IYUV',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2RGB',
            u'COLOR_YUV2RGB_YV12',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2BGR',
            u'COLOR_YUV2BGR_YV12',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGBA_YV12', u'102', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_YV12', u'103', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGBA_IYUV', u'104', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_IYUV', u'105', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGBA_I420',
            u'COLOR_YUV2RGBA_IYUV',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_I420',
            u'COLOR_YUV2BGRA_IYUV',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2RGBA',
            u'COLOR_YUV2RGBA_YV12',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2BGRA',
            u'COLOR_YUV2BGRA_YV12',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2GRAY_420', u'106', [], [], None, ''],
        [   u'const cv.COLOR_YUV2GRAY_NV21',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_NV12',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_YV12',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_IYUV',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_I420',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420sp2GRAY',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2GRAY',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGB_UYVY', u'107', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_UYVY', u'108', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGB_Y422',
            u'COLOR_YUV2RGB_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_Y422',
            u'COLOR_YUV2BGR_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2RGB_UYNV',
            u'COLOR_YUV2RGB_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_UYNV',
            u'COLOR_YUV2BGR_UYVY',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGBA_UYVY', u'111', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_UYVY', u'112', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGBA_Y422',
            u'COLOR_YUV2RGBA_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_Y422',
            u'COLOR_YUV2BGRA_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2RGBA_UYNV',
            u'COLOR_YUV2RGBA_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_UYNV',
            u'COLOR_YUV2BGRA_UYVY',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGB_YUY2', u'115', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_YUY2', u'116', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB_YVYU', u'117', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_YVYU', u'118', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGB_YUYV',
            u'COLOR_YUV2RGB_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_YUYV',
            u'COLOR_YUV2BGR_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2RGB_YUNV',
            u'COLOR_YUV2RGB_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_YUNV',
            u'COLOR_YUV2BGR_YUY2',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGBA_YUY2', u'119', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_YUY2', u'120', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGBA_YVYU', u'121', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_YVYU', u'122', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGBA_YUYV',
            u'COLOR_YUV2RGBA_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_YUYV',
            u'COLOR_YUV2BGRA_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2RGBA_YUNV',
            u'COLOR_YUV2RGBA_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_YUNV',
            u'COLOR_YUV2BGRA_YUY2',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2GRAY_UYVY', u'123', [], [], None, ''],
        [u'const cv.COLOR_YUV2GRAY_YUY2', u'124', [], [], None, ''],
        [   u'const cv.COLOR_YUV2GRAY_Y422',
            u'COLOR_YUV2GRAY_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_UYNV',
            u'COLOR_YUV2GRAY_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_YVYU',
            u'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_YUYV',
            u'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_YUNV',
            u'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_RGBA2mRGBA', u'125', [], [], None, ''],
        [u'const cv.COLOR_mRGBA2RGBA', u'126', [], [], None, ''],
        [u'const cv.COLOR_RGB2YUV_I420', u'127', [], [], None, ''],
        [u'const cv.COLOR_BGR2YUV_I420', u'128', [], [], None, ''],
        [   u'const cv.COLOR_RGB2YUV_IYUV',
            u'COLOR_RGB2YUV_I420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BGR2YUV_IYUV',
            u'COLOR_BGR2YUV_I420',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_RGBA2YUV_I420', u'129', [], [], None, ''],
        [u'const cv.COLOR_BGRA2YUV_I420', u'130', [], [], None, ''],
        [   u'const cv.COLOR_RGBA2YUV_IYUV',
            u'COLOR_RGBA2YUV_I420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BGRA2YUV_IYUV',
            u'COLOR_BGRA2YUV_I420',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_RGB2YUV_YV12', u'131', [], [], None, ''],
        [u'const cv.COLOR_BGR2YUV_YV12', u'132', [], [], None, ''],
        [u'const cv.COLOR_RGBA2YUV_YV12', u'133', [], [], None, ''],
        [u'const cv.COLOR_BGRA2YUV_YV12', u'134', [], [], None, ''],
        [u'const cv.COLOR_BayerBG2BGR', u'46', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2BGR', u'47', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2BGR', u'48', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2BGR', u'49', [], [], None, ''],
        [   u'const cv.COLOR_BayerBG2RGB',
            u'COLOR_BayerRG2BGR',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGB2RGB',
            u'COLOR_BayerGR2BGR',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerRG2RGB',
            u'COLOR_BayerBG2BGR',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGR2RGB',
            u'COLOR_BayerGB2BGR',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_BayerBG2GRAY', u'86', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2GRAY', u'87', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2GRAY', u'88', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2GRAY', u'89', [], [], None, ''],
        [u'const cv.COLOR_BayerBG2BGR_VNG', u'62', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2BGR_VNG', u'63', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2BGR_VNG', u'64', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2BGR_VNG', u'65', [], [], None, ''],
        [   u'const cv.COLOR_BayerBG2RGB_VNG',
            u'COLOR_BayerRG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGB2RGB_VNG',
            u'COLOR_BayerGR2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerRG2RGB_VNG',
            u'COLOR_BayerBG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGR2RGB_VNG',
            u'COLOR_BayerGB2BGR_VNG',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_BayerBG2BGR_EA', u'135', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2BGR_EA', u'136', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2BGR_EA', u'137', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2BGR_EA', u'138', [], [], None, ''],
        [   u'const cv.COLOR_BayerBG2RGB_EA',
            u'COLOR_BayerRG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGB2RGB_EA',
            u'COLOR_BayerGR2BGR_EA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerRG2RGB_EA',
            u'COLOR_BayerBG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGR2RGB_EA',
            u'COLOR_BayerGB2BGR_EA',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_BayerBG2BGRA', u'139', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2BGRA', u'140', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2BGRA', u'141', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2BGRA', u'142', [], [], None, ''],
        [   u'const cv.COLOR_BayerBG2RGBA',
            u'COLOR_BayerRG2BGRA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGB2RGBA',
            u'COLOR_BayerGR2BGRA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerRG2RGBA',
            u'COLOR_BayerBG2BGRA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGR2RGBA',
            u'COLOR_BayerGB2BGRA',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_COLORCVT_MAX', u'143', [], [], None, '']],
    None]
ok: CONST COLOR_BGR2BGRA=0
ok: CONST COLOR_RGB2RGBA=COLOR_BGR2BGRA
ok: CONST COLOR_BGRA2BGR=1
ok: CONST COLOR_RGBA2RGB=COLOR_BGRA2BGR
ok: CONST COLOR_BGR2RGBA=2
ok: CONST COLOR_RGB2BGRA=COLOR_BGR2RGBA
ok: CONST COLOR_RGBA2BGR=3
ok: CONST COLOR_BGRA2RGB=COLOR_RGBA2BGR
ok: CONST COLOR_BGR2RGB=4
ok: CONST COLOR_RGB2BGR=COLOR_BGR2RGB
ok: CONST COLOR_BGRA2RGBA=5
ok: CONST COLOR_RGBA2BGRA=COLOR_BGRA2RGBA
ok: CONST COLOR_BGR2GRAY=6
ok: CONST COLOR_RGB2GRAY=7
ok: CONST COLOR_GRAY2BGR=8
ok: CONST COLOR_GRAY2RGB=COLOR_GRAY2BGR
ok: CONST COLOR_GRAY2BGRA=9
ok: CONST COLOR_GRAY2RGBA=COLOR_GRAY2BGRA
ok: CONST COLOR_BGRA2GRAY=10
ok: CONST COLOR_RGBA2GRAY=11
ok: CONST COLOR_BGR2BGR565=12
ok: CONST COLOR_RGB2BGR565=13
ok: CONST COLOR_BGR5652BGR=14
ok: CONST COLOR_BGR5652RGB=15
ok: CONST COLOR_BGRA2BGR565=16
ok: CONST COLOR_RGBA2BGR565=17
ok: CONST COLOR_BGR5652BGRA=18
ok: CONST COLOR_BGR5652RGBA=19
ok: CONST COLOR_GRAY2BGR565=20
ok: CONST COLOR_BGR5652GRAY=21
ok: CONST COLOR_BGR2BGR555=22
ok: CONST COLOR_RGB2BGR555=23
ok: CONST COLOR_BGR5552BGR=24
ok: CONST COLOR_BGR5552RGB=25
ok: CONST COLOR_BGRA2BGR555=26
ok: CONST COLOR_RGBA2BGR555=27
ok: CONST COLOR_BGR5552BGRA=28
ok: CONST COLOR_BGR5552RGBA=29
ok: CONST COLOR_GRAY2BGR555=30
ok: CONST COLOR_BGR5552GRAY=31
ok: CONST COLOR_BGR2XYZ=32
ok: CONST COLOR_RGB2XYZ=33
ok: CONST COLOR_XYZ2BGR=34
ok: CONST COLOR_XYZ2RGB=35
ok: CONST COLOR_BGR2YCrCb=36
ok: CONST COLOR_RGB2YCrCb=37
ok: CONST COLOR_YCrCb2BGR=38
ok: CONST COLOR_YCrCb2RGB=39
ok: CONST COLOR_BGR2HSV=40
ok: CONST COLOR_RGB2HSV=41
ok: CONST COLOR_BGR2Lab=44
ok: CONST COLOR_RGB2Lab=45
ok: CONST COLOR_BGR2Luv=50
ok: CONST COLOR_RGB2Luv=51
ok: CONST COLOR_BGR2HLS=52
ok: CONST COLOR_RGB2HLS=53
ok: CONST COLOR_HSV2BGR=54
ok: CONST COLOR_HSV2RGB=55
ok: CONST COLOR_Lab2BGR=56
ok: CONST COLOR_Lab2RGB=57
ok: CONST COLOR_Luv2BGR=58
ok: CONST COLOR_Luv2RGB=59
ok: CONST COLOR_HLS2BGR=60
ok: CONST COLOR_HLS2RGB=61
ok: CONST COLOR_BGR2HSV_FULL=66
ok: CONST COLOR_RGB2HSV_FULL=67
ok: CONST COLOR_BGR2HLS_FULL=68
ok: CONST COLOR_RGB2HLS_FULL=69
ok: CONST COLOR_HSV2BGR_FULL=70
ok: CONST COLOR_HSV2RGB_FULL=71
ok: CONST COLOR_HLS2BGR_FULL=72
ok: CONST COLOR_HLS2RGB_FULL=73
ok: CONST COLOR_LBGR2Lab=74
ok: CONST COLOR_LRGB2Lab=75
ok: CONST COLOR_LBGR2Luv=76
ok: CONST COLOR_LRGB2Luv=77
ok: CONST COLOR_Lab2LBGR=78
ok: CONST COLOR_Lab2LRGB=79
ok: CONST COLOR_Luv2LBGR=80
ok: CONST COLOR_Luv2LRGB=81
ok: CONST COLOR_BGR2YUV=82
ok: CONST COLOR_RGB2YUV=83
ok: CONST COLOR_YUV2BGR=84
ok: CONST COLOR_YUV2RGB=85
ok: CONST COLOR_YUV2RGB_NV12=90
ok: CONST COLOR_YUV2BGR_NV12=91
ok: CONST COLOR_YUV2RGB_NV21=92
ok: CONST COLOR_YUV2BGR_NV21=93
ok: CONST COLOR_YUV420sp2RGB=COLOR_YUV2RGB_NV21
ok: CONST COLOR_YUV420sp2BGR=COLOR_YUV2BGR_NV21
ok: CONST COLOR_YUV2RGBA_NV12=94
ok: CONST COLOR_YUV2BGRA_NV12=95
ok: CONST COLOR_YUV2RGBA_NV21=96
ok: CONST COLOR_YUV2BGRA_NV21=97
ok: CONST COLOR_YUV420sp2RGBA=COLOR_YUV2RGBA_NV21
ok: CONST COLOR_YUV420sp2BGRA=COLOR_YUV2BGRA_NV21
ok: CONST COLOR_YUV2RGB_YV12=98
ok: CONST COLOR_YUV2BGR_YV12=99
ok: CONST COLOR_YUV2RGB_IYUV=100
ok: CONST COLOR_YUV2BGR_IYUV=101
ok: CONST COLOR_YUV2RGB_I420=COLOR_YUV2RGB_IYUV
ok: CONST COLOR_YUV2BGR_I420=COLOR_YUV2BGR_IYUV
ok: CONST COLOR_YUV420p2RGB=COLOR_YUV2RGB_YV12
ok: CONST COLOR_YUV420p2BGR=COLOR_YUV2BGR_YV12
ok: CONST COLOR_YUV2RGBA_YV12=102
ok: CONST COLOR_YUV2BGRA_YV12=103
ok: CONST COLOR_YUV2RGBA_IYUV=104
ok: CONST COLOR_YUV2BGRA_IYUV=105
ok: CONST COLOR_YUV2RGBA_I420=COLOR_YUV2RGBA_IYUV
ok: CONST COLOR_YUV2BGRA_I420=COLOR_YUV2BGRA_IYUV
ok: CONST COLOR_YUV420p2RGBA=COLOR_YUV2RGBA_YV12
ok: CONST COLOR_YUV420p2BGRA=COLOR_YUV2BGRA_YV12
ok: CONST COLOR_YUV2GRAY_420=106
ok: CONST COLOR_YUV2GRAY_NV21=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_NV12=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_YV12=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_IYUV=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_I420=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV420sp2GRAY=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV420p2GRAY=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2RGB_UYVY=107
ok: CONST COLOR_YUV2BGR_UYVY=108
ok: CONST COLOR_YUV2RGB_Y422=COLOR_YUV2RGB_UYVY
ok: CONST COLOR_YUV2BGR_Y422=COLOR_YUV2BGR_UYVY
ok: CONST COLOR_YUV2RGB_UYNV=COLOR_YUV2RGB_UYVY
ok: CONST COLOR_YUV2BGR_UYNV=COLOR_YUV2BGR_UYVY
ok: CONST COLOR_YUV2RGBA_UYVY=111
ok: CONST COLOR_YUV2BGRA_UYVY=112
ok: CONST COLOR_YUV2RGBA_Y422=COLOR_YUV2RGBA_UYVY
ok: CONST COLOR_YUV2BGRA_Y422=COLOR_YUV2BGRA_UYVY
ok: CONST COLOR_YUV2RGBA_UYNV=COLOR_YUV2RGBA_UYVY
ok: CONST COLOR_YUV2BGRA_UYNV=COLOR_YUV2BGRA_UYVY
ok: CONST COLOR_YUV2RGB_YUY2=115
ok: CONST COLOR_YUV2BGR_YUY2=116
ok: CONST COLOR_YUV2RGB_YVYU=117
ok: CONST COLOR_YUV2BGR_YVYU=118
ok: CONST COLOR_YUV2RGB_YUYV=COLOR_YUV2RGB_YUY2
ok: CONST COLOR_YUV2BGR_YUYV=COLOR_YUV2BGR_YUY2
ok: CONST COLOR_YUV2RGB_YUNV=COLOR_YUV2RGB_YUY2
ok: CONST COLOR_YUV2BGR_YUNV=COLOR_YUV2BGR_YUY2
ok: CONST COLOR_YUV2RGBA_YUY2=119
ok: CONST COLOR_YUV2BGRA_YUY2=120
ok: CONST COLOR_YUV2RGBA_YVYU=121
ok: CONST COLOR_YUV2BGRA_YVYU=122
ok: CONST COLOR_YUV2RGBA_YUYV=COLOR_YUV2RGBA_YUY2
ok: CONST COLOR_YUV2BGRA_YUYV=COLOR_YUV2BGRA_YUY2
ok: CONST COLOR_YUV2RGBA_YUNV=COLOR_YUV2RGBA_YUY2
ok: CONST COLOR_YUV2BGRA_YUNV=COLOR_YUV2BGRA_YUY2
ok: CONST COLOR_YUV2GRAY_UYVY=123
ok: CONST COLOR_YUV2GRAY_YUY2=124
ok: CONST COLOR_YUV2GRAY_Y422=COLOR_YUV2GRAY_UYVY
ok: CONST COLOR_YUV2GRAY_UYNV=COLOR_YUV2GRAY_UYVY
ok: CONST COLOR_YUV2GRAY_YVYU=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_YUV2GRAY_YUYV=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_YUV2GRAY_YUNV=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_RGBA2mRGBA=125
ok: CONST COLOR_mRGBA2RGBA=126
ok: CONST COLOR_RGB2YUV_I420=127
ok: CONST COLOR_BGR2YUV_I420=128
ok: CONST COLOR_RGB2YUV_IYUV=COLOR_RGB2YUV_I420
ok: CONST COLOR_BGR2YUV_IYUV=COLOR_BGR2YUV_I420
ok: CONST COLOR_RGBA2YUV_I420=129
ok: CONST COLOR_BGRA2YUV_I420=130
ok: CONST COLOR_RGBA2YUV_IYUV=COLOR_RGBA2YUV_I420
ok: CONST COLOR_BGRA2YUV_IYUV=COLOR_BGRA2YUV_I420
ok: CONST COLOR_RGB2YUV_YV12=131
ok: CONST COLOR_BGR2YUV_YV12=132
ok: CONST COLOR_RGBA2YUV_YV12=133
ok: CONST COLOR_BGRA2YUV_YV12=134
ok: CONST COLOR_BayerBG2BGR=46
ok: CONST COLOR_BayerGB2BGR=47
ok: CONST COLOR_BayerRG2BGR=48
ok: CONST COLOR_BayerGR2BGR=49
ok: CONST COLOR_BayerBG2RGB=COLOR_BayerRG2BGR
ok: CONST COLOR_BayerGB2RGB=COLOR_BayerGR2BGR
ok: CONST COLOR_BayerRG2RGB=COLOR_BayerBG2BGR
ok: CONST COLOR_BayerGR2RGB=COLOR_BayerGB2BGR
ok: CONST COLOR_BayerBG2GRAY=86
ok: CONST COLOR_BayerGB2GRAY=87
ok: CONST COLOR_BayerRG2GRAY=88
ok: CONST COLOR_BayerGR2GRAY=89
ok: CONST COLOR_BayerBG2BGR_VNG=62
ok: CONST COLOR_BayerGB2BGR_VNG=63
ok: CONST COLOR_BayerRG2BGR_VNG=64
ok: CONST COLOR_BayerGR2BGR_VNG=65
ok: CONST COLOR_BayerBG2RGB_VNG=COLOR_BayerRG2BGR_VNG
ok: CONST COLOR_BayerGB2RGB_VNG=COLOR_BayerGR2BGR_VNG
ok: CONST COLOR_BayerRG2RGB_VNG=COLOR_BayerBG2BGR_VNG
ok: CONST COLOR_BayerGR2RGB_VNG=COLOR_BayerGB2BGR_VNG
ok: CONST COLOR_BayerBG2BGR_EA=135
ok: CONST COLOR_BayerGB2BGR_EA=136
ok: CONST COLOR_BayerRG2BGR_EA=137
ok: CONST COLOR_BayerGR2BGR_EA=138
ok: CONST COLOR_BayerBG2RGB_EA=COLOR_BayerRG2BGR_EA
ok: CONST COLOR_BayerGB2RGB_EA=COLOR_BayerGR2BGR_EA
ok: CONST COLOR_BayerRG2RGB_EA=COLOR_BayerBG2BGR_EA
ok: CONST COLOR_BayerGR2RGB_EA=COLOR_BayerGB2BGR_EA
ok: CONST COLOR_BayerBG2BGRA=139
ok: CONST COLOR_BayerGB2BGRA=140
ok: CONST COLOR_BayerRG2BGRA=141
ok: CONST COLOR_BayerGR2BGRA=142
ok: CONST COLOR_BayerBG2RGBA=COLOR_BayerRG2BGRA
ok: CONST COLOR_BayerGB2RGBA=COLOR_BayerGR2BGRA
ok: CONST COLOR_BayerRG2RGBA=COLOR_BayerBG2BGRA
ok: CONST COLOR_BayerGR2RGBA=COLOR_BayerGB2BGRA
ok: CONST COLOR_COLORCVT_MAX=143

--- Incoming ---
[   u'enum cv.RectanglesIntersectTypes',
    '',
    [],
    [   [u'const cv.INTERSECT_NONE', u'0', [], [], None, ''],
        [u'const cv.INTERSECT_PARTIAL', u'1', [], [], None, ''],
        [u'const cv.INTERSECT_FULL', u'2', [], [], None, '']],
    None]
ok: CONST INTERSECT_NONE=0
ok: CONST INTERSECT_PARTIAL=1
ok: CONST INTERSECT_FULL=2

--- Incoming ---
[   u'enum cv.LineTypes',
    '',
    [],
    [   [u'const cv.FILLED', u'-1', [], [], None, ''],
        [u'const cv.LINE_4', u'4', [], [], None, ''],
        [u'const cv.LINE_8', u'8', [], [], None, ''],
        [u'const cv.LINE_AA', u'16', [], [], None, '']],
    None]
ok: CONST FILLED=-1
ok: CONST LINE_4=4
ok: CONST LINE_8=8
ok: CONST LINE_AA=16

--- Incoming ---
[   u'enum cv.HersheyFonts',
    '',
    [],
    [   [u'const cv.FONT_HERSHEY_SIMPLEX', u'0', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_PLAIN', u'1', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_DUPLEX', u'2', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_COMPLEX', u'3', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_TRIPLEX', u'4', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_COMPLEX_SMALL', u'5', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_SCRIPT_SIMPLEX', u'6', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_SCRIPT_COMPLEX', u'7', [], [], None, ''],
        [u'const cv.FONT_ITALIC', u'16', [], [], None, '']],
    None]
ok: CONST FONT_HERSHEY_SIMPLEX=0
ok: CONST FONT_HERSHEY_PLAIN=1
ok: CONST FONT_HERSHEY_DUPLEX=2
ok: CONST FONT_HERSHEY_COMPLEX=3
ok: CONST FONT_HERSHEY_TRIPLEX=4
ok: CONST FONT_HERSHEY_COMPLEX_SMALL=5
ok: CONST FONT_HERSHEY_SCRIPT_SIMPLEX=6
ok: CONST FONT_HERSHEY_SCRIPT_COMPLEX=7
ok: CONST FONT_ITALIC=16

--- Incoming ---
[   u'enum cv.MarkerTypes',
    '',
    [],
    [   [u'const cv.MARKER_CROSS', u'0', [], [], None, ''],
        [u'const cv.MARKER_TILTED_CROSS', u'1', [], [], None, ''],
        [u'const cv.MARKER_STAR', u'2', [], [], None, ''],
        [u'const cv.MARKER_DIAMOND', u'3', [], [], None, ''],
        [u'const cv.MARKER_SQUARE', u'4', [], [], None, ''],
        [u'const cv.MARKER_TRIANGLE_UP', u'5', [], [], None, ''],
        [u'const cv.MARKER_TRIANGLE_DOWN', u'6', [], [], None, '']],
    None]
ok: CONST MARKER_CROSS=0
ok: CONST MARKER_TILTED_CROSS=1
ok: CONST MARKER_STAR=2
ok: CONST MARKER_DIAMOND=3
ok: CONST MARKER_SQUARE=4
ok: CONST MARKER_TRIANGLE_UP=5
ok: CONST MARKER_TRIANGLE_DOWN=6

--- Incoming ---
[u'class cv.GeneralizedHough', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.GeneralizedHough : Algorithm, name: GeneralizedHough, base: Algorithm

--- Incoming ---
[   u'cv.GeneralizedHough.setTemplate',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'templ', '', []],
        [u'Point', u'templCenter', u'Point(-1, -1)', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat templ=, ARG Point templCenter=Point(-1, -1)]>

--- Incoming ---
[   u'cv.GeneralizedHough.setTemplate',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'edges', '', []],
        ['Mat', u'dx', '', []],
        ['Mat', u'dy', '', []],
        [u'Point', u'templCenter', u'Point(-1, -1)', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Point templCenter=Point(-1, -1)]>

--- Incoming ---
[   u'cv.GeneralizedHough.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'positions', '', ['/O']],
        ['Mat', u'votes', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.detect [ARG Mat image=, ARG Mat positions=, ARG Mat votes=Mat()]>

--- Incoming ---
[   u'cv.GeneralizedHough.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'edges', '', []],
        ['Mat', u'dx', '', []],
        ['Mat', u'dy', '', []],
        ['Mat', u'positions', '', ['/O']],
        ['Mat', u'votes', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.detect [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Mat positions=, ARG Mat votes=Mat()]>

--- Incoming ---
[   u'cv.GeneralizedHough.setCannyLowThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'cannyLowThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setCannyLowThresh [ARG int cannyLowThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHough.getCannyLowThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHough.getCannyLowThresh []>

--- Incoming ---
[   u'cv.GeneralizedHough.setCannyHighThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'cannyHighThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setCannyHighThresh [ARG int cannyHighThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHough.getCannyHighThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHough.getCannyHighThresh []>

--- Incoming ---
[   u'cv.GeneralizedHough.setMinDist',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minDist', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setMinDist [ARG double minDist=]>

--- Incoming ---
[   u'cv.GeneralizedHough.getMinDist',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHough.getMinDist []>

--- Incoming ---
[   u'cv.GeneralizedHough.setDp',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'dp', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setDp [ARG double dp=]>

--- Incoming ---
[u'cv.GeneralizedHough.getDp', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.GeneralizedHough.getDp []>

--- Incoming ---
[   u'cv.GeneralizedHough.setMaxBufferSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxBufferSize', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setMaxBufferSize [ARG int maxBufferSize=]>

--- Incoming ---
[   u'cv.GeneralizedHough.getMaxBufferSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHough.getMaxBufferSize []>

--- Incoming ---
[u'class cv.GeneralizedHoughBallard', u': cv::GeneralizedHough', [], [], None]
ok: class CLASS cv::.GeneralizedHoughBallard : GeneralizedHough, name: GeneralizedHoughBallard, base: GeneralizedHough

--- Incoming ---
[   u'cv.GeneralizedHoughBallard.setLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'levels', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughBallard.setLevels [ARG int levels=]>

--- Incoming ---
[   u'cv.GeneralizedHoughBallard.getLevels',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughBallard.getLevels []>

--- Incoming ---
[   u'cv.GeneralizedHoughBallard.setVotesThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'votesThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughBallard.setVotesThreshold [ARG int votesThreshold=]>

--- Incoming ---
[   u'cv.GeneralizedHoughBallard.getVotesThreshold',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughBallard.getVotesThreshold []>

--- Incoming ---
[u'class cv.GeneralizedHoughGuil', u': cv::GeneralizedHough', [], [], None]
ok: class CLASS cv::.GeneralizedHoughGuil : GeneralizedHough, name: GeneralizedHoughGuil, base: GeneralizedHough

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setXi',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'xi', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setXi [ARG double xi=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getXi',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getXi []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'levels', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setLevels [ARG int levels=]>

--- Incoming ---
[u'cv.GeneralizedHoughGuil.getLevels', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getLevels []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setAngleEpsilon',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'angleEpsilon', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleEpsilon [ARG double angleEpsilon=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getAngleEpsilon',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getAngleEpsilon []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setMinAngle',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minAngle', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMinAngle [ARG double minAngle=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getMinAngle',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMinAngle []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setMaxAngle',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'maxAngle', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMaxAngle [ARG double maxAngle=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getMaxAngle',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMaxAngle []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setAngleStep',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'angleStep', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleStep [ARG double angleStep=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getAngleStep',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getAngleStep []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setAngleThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'angleThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleThresh [ARG int angleThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getAngleThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getAngleThresh []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setMinScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minScale', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMinScale [ARG double minScale=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getMinScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMinScale []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setMaxScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'maxScale', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMaxScale [ARG double maxScale=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getMaxScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMaxScale []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setScaleStep',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'scaleStep', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setScaleStep [ARG double scaleStep=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getScaleStep',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getScaleStep []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setScaleThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'scaleThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setScaleThresh [ARG int scaleThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getScaleThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getScaleThresh []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setPosThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'posThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setPosThresh [ARG int posThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getPosThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getPosThresh []>

--- Incoming ---
[u'class cv.CLAHE', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.CLAHE : Algorithm, name: CLAHE, base: Algorithm

--- Incoming ---
[   u'cv.CLAHE.apply',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.CLAHE.apply [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.CLAHE.setClipLimit',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'clipLimit', u'', []]],
    u'void']
ok: FUNC <void cv.CLAHE.setClipLimit [ARG double clipLimit=]>

--- Incoming ---
[u'cv.CLAHE.getClipLimit', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.CLAHE.getClipLimit []>

--- Incoming ---
[   u'cv.CLAHE.setTilesGridSize',
    u'void',
    ['/V', '/PV'],
    [[u'Size', u'tileGridSize', u'', []]],
    u'void']
ok: FUNC <void cv.CLAHE.setTilesGridSize [ARG Size tileGridSize=]>

--- Incoming ---
[u'cv.CLAHE.getTilesGridSize', u'Size', ['/C', '/V', '/PV'], [], u'Size']
ok: FUNC <Size cv.CLAHE.getTilesGridSize []>

--- Incoming ---
[u'cv.CLAHE.collectGarbage', u'void', ['/V', '/PV'], [], u'void']
ok: FUNC <void cv.CLAHE.collectGarbage []>

--- Incoming ---
[u'class cv.Subdiv2D', '', [], [], None]
ok: class CLASS cv::.Subdiv2D : , name: Subdiv2D, base: 

--- Incoming ---
[   u'enum cv.Subdiv2D.<unnamed>',
    '',
    [],
    [   [u'const cv.Subdiv2D.PTLOC_ERROR', u'-2', [], [], None, ''],
        [u'const cv.Subdiv2D.PTLOC_OUTSIDE_RECT', u'-1', [], [], None, ''],
        [u'const cv.Subdiv2D.PTLOC_INSIDE', u'0', [], [], None, ''],
        [u'const cv.Subdiv2D.PTLOC_VERTEX', u'1', [], [], None, ''],
        [u'const cv.Subdiv2D.PTLOC_ON_EDGE', u'2', [], [], None, '']],
    None]
ok: CONST PTLOC_ERROR=-2
ok: CONST PTLOC_OUTSIDE_RECT=-1
ok: CONST PTLOC_INSIDE=0
ok: CONST PTLOC_VERTEX=1
ok: CONST PTLOC_ON_EDGE=2

--- Incoming ---
[   u'enum cv.Subdiv2D.<unnamed>',
    '',
    [],
    [   [u'const cv.Subdiv2D.NEXT_AROUND_ORG', u'0x00', [], [], None, ''],
        [u'const cv.Subdiv2D.NEXT_AROUND_DST', u'0x22', [], [], None, ''],
        [u'const cv.Subdiv2D.PREV_AROUND_ORG', u'0x11', [], [], None, ''],
        [u'const cv.Subdiv2D.PREV_AROUND_DST', u'0x33', [], [], None, ''],
        [u'const cv.Subdiv2D.NEXT_AROUND_LEFT', u'0x13', [], [], None, ''],
        [u'const cv.Subdiv2D.NEXT_AROUND_RIGHT', u'0x31', [], [], None, ''],
        [u'const cv.Subdiv2D.PREV_AROUND_LEFT', u'0x20', [], [], None, ''],
        [u'const cv.Subdiv2D.PREV_AROUND_RIGHT', u'0x02', [], [], None, '']],
    None]
ok: CONST NEXT_AROUND_ORG=0x00
ok: CONST NEXT_AROUND_DST=0x22
ok: CONST PREV_AROUND_ORG=0x11
ok: CONST PREV_AROUND_DST=0x33
ok: CONST NEXT_AROUND_LEFT=0x13
ok: CONST NEXT_AROUND_RIGHT=0x31
ok: CONST PREV_AROUND_LEFT=0x20
ok: CONST PREV_AROUND_RIGHT=0x02

--- Incoming ---
[u'cv.Subdiv2D.Subdiv2D', '', [], [], None]
ok: FUNC < cv.Subdiv2D.Subdiv2D []>

--- Incoming ---
[u'cv.Subdiv2D.Subdiv2D', '', [], [[u'Rect', u'rect', u'', []]], None]
ok: FUNC < cv.Subdiv2D.Subdiv2D [ARG Rect rect=]>

--- Incoming ---
[   u'cv.Subdiv2D.initDelaunay',
    u'void',
    [],
    [[u'Rect', u'rect', u'', []]],
    u'void']
ok: FUNC <void cv.Subdiv2D.initDelaunay [ARG Rect rect=]>

--- Incoming ---
[u'cv.Subdiv2D.insert', u'int', [], [[u'Point2f', u'pt', u'', []]], u'int']
ok: FUNC <int cv.Subdiv2D.insert [ARG Point2f pt=]>

--- Incoming ---
[   u'cv.Subdiv2D.insert',
    u'void',
    [],
    [[u'vector_Point2f', u'ptvec', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.insert [ARG vector_Point2f ptvec=]>

--- Incoming ---
[   u'cv.Subdiv2D.locate',
    u'int',
    [],
    [   [u'Point2f', u'pt', u'', []],
        [u'int', u'edge', u'', ['/O', '/Ref']],
        [u'int', u'vertex', u'', ['/O', '/Ref']]],
    u'int']
ok: FUNC <int cv.Subdiv2D.locate [ARG Point2f pt=, ARG int edge=, ARG int vertex=]>

--- Incoming ---
[   u'cv.Subdiv2D.findNearest',
    u'int',
    [],
    [[u'Point2f', u'pt', u'', []], [u'Point2f*', u'nearestPt', u'0', ['/O']]],
    u'int']
ok: FUNC <int cv.Subdiv2D.findNearest [ARG Point2f pt=, ARG Point2f * nearestPt=0]>

--- Incoming ---
[   u'cv.Subdiv2D.getEdgeList',
    u'void',
    ['/C'],
    [[u'vector_Vec4f', u'edgeList', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.getEdgeList [ARG vector_Vec4f edgeList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getLeadingEdgeList',
    u'void',
    ['/C'],
    [[u'vector_int', u'leadingEdgeList', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.getLeadingEdgeList [ARG vector_int leadingEdgeList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getTriangleList',
    u'void',
    ['/C'],
    [[u'vector_Vec6f', u'triangleList', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.getTriangleList [ARG vector_Vec6f triangleList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getVoronoiFacetList',
    u'void',
    [],
    [   [u'vector_int', u'idx', u'', ['/C', '/Ref']],
        [u'vector_vector_Point2f', u'facetList', u'', ['/O', '/Ref']],
        [u'vector_Point2f', u'facetCenters', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.getVoronoiFacetList [ARG vector_int idx=, ARG vector_vector_Point2f facetList=, ARG vector_Point2f facetCenters=]>

--- Incoming ---
[   u'cv.Subdiv2D.getVertex',
    u'Point2f',
    ['/C'],
    [[u'int', u'vertex', u'', []], [u'int*', u'firstEdge', u'0', ['/O']]],
    u'Point2f']
ok: FUNC <Point2f cv.Subdiv2D.getVertex [ARG int vertex=, ARG int * firstEdge=0]>

--- Incoming ---
[   u'cv.Subdiv2D.getEdge',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'int', u'nextEdgeType', u'', []]],
    u'int']
ok: FUNC <int cv.Subdiv2D.getEdge [ARG int edge=, ARG int nextEdgeType=]>

--- Incoming ---
[u'cv.Subdiv2D.nextEdge', u'int', ['/C'], [[u'int', u'edge', u'', []]], u'int']
ok: FUNC <int cv.Subdiv2D.nextEdge [ARG int edge=]>

--- Incoming ---
[   u'cv.Subdiv2D.rotateEdge',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'int', u'rotate', u'', []]],
    u'int']
ok: FUNC <int cv.Subdiv2D.rotateEdge [ARG int edge=, ARG int rotate=]>

--- Incoming ---
[u'cv.Subdiv2D.symEdge', u'int', ['/C'], [[u'int', u'edge', u'', []]], u'int']
ok: FUNC <int cv.Subdiv2D.symEdge [ARG int edge=]>

--- Incoming ---
[   u'cv.Subdiv2D.edgeOrg',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'Point2f*', u'orgpt', u'0', ['/O']]],
    u'int']
ok: FUNC <int cv.Subdiv2D.edgeOrg [ARG int edge=, ARG Point2f * orgpt=0]>

--- Incoming ---
[   u'cv.Subdiv2D.edgeDst',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'Point2f*', u'dstpt', u'0', ['/O']]],
    u'int']
ok: FUNC <int cv.Subdiv2D.edgeDst [ARG int edge=, ARG Point2f * dstpt=0]>

--- Incoming ---
[u'class cv.LineSegmentDetector', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.LineSegmentDetector : Algorithm, name: LineSegmentDetector, base: Algorithm

--- Incoming ---
[   u'cv.LineSegmentDetector.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'_image', '', []],
        ['Mat', u'_lines', '', ['/O']],
        ['Mat', u'width', u'Mat()', ['/O']],
        ['Mat', u'prec', u'Mat()', ['/O']],
        ['Mat', u'nfa', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.LineSegmentDetector.detect [ARG Mat _image=, ARG Mat _lines=, ARG Mat width=Mat(), ARG Mat prec=Mat(), ARG Mat nfa=Mat()]>

--- Incoming ---
[   u'cv.LineSegmentDetector.drawSegments',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'_image', '', ['/IO']], ['Mat', u'lines', '', []]],
    u'void']
ok: FUNC <void cv.LineSegmentDetector.drawSegments [ARG Mat _image=, ARG Mat lines=]>

--- Incoming ---
[   u'cv.LineSegmentDetector.compareSegments',
    u'int',
    ['/V', '/PV'],
    [   [u'Size', u'size', u'', ['/C', '/Ref']],
        ['Mat', u'lines1', '', []],
        ['Mat', u'lines2', '', []],
        ['Mat', u'_image', u'Mat()', ['/IO']]],
    u'int']
ok: FUNC <int cv.LineSegmentDetector.compareSegments [ARG Size size=, ARG Mat lines1=, ARG Mat lines2=, ARG Mat _image=Mat()]>

--- Incoming ---
[   u'cv.createLineSegmentDetector',
    u'Ptr_LineSegmentDetector',
    [],
    [   [u'int', u'_refine', u'LSD_REFINE_STD', []],
        [u'double', u'_scale', u'0.8', []],
        [u'double', u'_sigma_scale', u'0.6', []],
        [u'double', u'_quant', u'2.0', []],
        [u'double', u'_ang_th', u'22.5', []],
        [u'double', u'_log_eps', u'0', []],
        [u'double', u'_density_th', u'0.7', []],
        [u'int', u'_n_bins', u'1024', []]],
    u'Ptr<LineSegmentDetector>']
ok: FUNC <Ptr_LineSegmentDetector cv..createLineSegmentDetector [ARG int _refine=LSD_REFINE_STD, ARG double _scale=0.8, ARG double _sigma_scale=0.6, ARG double _quant=2.0, ARG double _ang_th=22.5, ARG double _log_eps=0, ARG double _density_th=0.7, ARG int _n_bins=1024]>

--- Incoming ---
[   u'cv.getGaussianKernel',
    u'Mat',
    [],
    [   [u'int', u'ksize', u'', []],
        [u'double', u'sigma', u'', []],
        [u'int', u'ktype', u'CV_64F', []]],
    u'Mat']
ok: FUNC <Mat cv..getGaussianKernel [ARG int ksize=, ARG double sigma=, ARG int ktype=CV_64F]>

--- Incoming ---
[   u'cv.getDerivKernels',
    u'void',
    [],
    [   ['Mat', u'kx', '', ['/O']],
        ['Mat', u'ky', '', ['/O']],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'int', u'ksize', u'', []],
        [u'bool', u'normalize', u'false', []],
        [u'int', u'ktype', u'CV_32F', []]],
    u'void']
ok: FUNC <void cv..getDerivKernels [ARG Mat kx=, ARG Mat ky=, ARG int dx=, ARG int dy=, ARG int ksize=, ARG bool normalize=false, ARG int ktype=CV_32F]>

--- Incoming ---
[   u'cv.getGaborKernel',
    u'Mat',
    [],
    [   [u'Size', u'ksize', u'', []],
        [u'double', u'sigma', u'', []],
        [u'double', u'theta', u'', []],
        [u'double', u'lambd', u'', []],
        [u'double', u'gamma', u'', []],
        [u'double', u'psi', u'CV_PI*0.5', []],
        [u'int', u'ktype', u'CV_64F', []]],
    u'Mat']
ok: FUNC <Mat cv..getGaborKernel [ARG Size ksize=, ARG double sigma=, ARG double theta=, ARG double lambd=, ARG double gamma=, ARG double psi=CV_PI*0.5, ARG int ktype=CV_64F]>

--- Incoming ---
[   u'cv.getStructuringElement',
    u'Mat',
    [],
    [   [u'int', u'shape', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []]],
    u'Mat']
ok: FUNC <Mat cv..getStructuringElement [ARG int shape=, ARG Size ksize=, ARG Point anchor=Point(-1,-1)]>

--- Incoming ---
[   u'cv.medianBlur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ksize', u'', []]],
    u'void']
ok: FUNC <void cv..medianBlur [ARG Mat src=, ARG Mat dst=, ARG int ksize=]>

--- Incoming ---
[   u'cv.GaussianBlur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'ksize', u'', []],
        [u'double', u'sigmaX', u'', []],
        [u'double', u'sigmaY', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..GaussianBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG double sigmaX=, ARG double sigmaY=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.bilateralFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'd', u'', []],
        [u'double', u'sigmaColor', u'', []],
        [u'double', u'sigmaSpace', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..bilateralFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.boxFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'bool', u'normalize', u'true', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..boxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.sqrBoxFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1, -1)', []],
        [u'bool', u'normalize', u'true', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..sqrBoxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1, -1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.blur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..blur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.filter2D',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..filter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.sepFilter2D',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        ['Mat', u'kernelX', '', []],
        ['Mat', u'kernelY', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..sepFilter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernelX=, ARG Mat kernelY=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Sobel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'int', u'ksize', u'3', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..Sobel [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG int ksize=3, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.spatialGradient',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dx', '', ['/O']],
        ['Mat', u'dy', '', ['/O']],
        [u'int', u'ksize', u'3', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..spatialGradient [ARG Mat src=, ARG Mat dx=, ARG Mat dy=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Scharr',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..Scharr [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Laplacian',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'ksize', u'1', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..Laplacian [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int ksize=1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Canny',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'edges', '', ['/O']],
        [u'double', u'threshold1', u'', []],
        [u'double', u'threshold2', u'', []],
        [u'int', u'apertureSize', u'3', []],
        [u'bool', u'L2gradient', u'false', []]],
    u'void']
ok: FUNC <void cv..Canny [ARG Mat image=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>

--- Incoming ---
[   u'cv.Canny',
    u'void',
    [],
    [   ['Mat', u'dx', '', []],
        ['Mat', u'dy', '', []],
        ['Mat', u'edges', '', ['/O']],
        [u'double', u'threshold1', u'', []],
        [u'double', u'threshold2', u'', []],
        [u'bool', u'L2gradient', u'false', []]],
    u'void']
ok: FUNC <void cv..Canny [ARG Mat dx=, ARG Mat dy=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG bool L2gradient=false]>

--- Incoming ---
[   u'cv.cornerMinEigenVal',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'3', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..cornerMinEigenVal [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerHarris',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'', []],
        [u'double', u'k', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..cornerHarris [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG double k=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerEigenValsAndVecs',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..cornerEigenValsAndVecs [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.preCornerDetect',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ksize', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..preCornerDetect [ARG Mat src=, ARG Mat dst=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerSubPix',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/IO']],
        [u'Size', u'winSize', u'', []],
        [u'Size', u'zeroZone', u'', []],
        [u'TermCriteria', u'criteria', u'', []]],
    u'void']
ok: FUNC <void cv..cornerSubPix [ARG Mat image=, ARG Mat corners=, ARG Size winSize=, ARG Size zeroZone=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.goodFeaturesToTrack',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'maxCorners', u'', []],
        [u'double', u'qualityLevel', u'', []],
        [u'double', u'minDistance', u'', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'blockSize', u'3', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'void']
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=Mat(), ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.goodFeaturesToTrack',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'maxCorners', u'', []],
        [u'double', u'qualityLevel', u'', []],
        [u'double', u'minDistance', u'', []],
        ['Mat', u'mask', '', []],
        [u'int', u'blockSize', u'', []],
        [u'int', u'gradientSize', u'', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'void']
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG int blockSize=, ARG int gradientSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.HoughLines',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'lines', '', ['/O']],
        [u'double', u'rho', u'', []],
        [u'double', u'theta', u'', []],
        [u'int', u'threshold', u'', []],
        [u'double', u'srn', u'0', []],
        [u'double', u'stn', u'0', []],
        [u'double', u'min_theta', u'0', []],
        [u'double', u'max_theta', u'CV_PI', []]],
    u'void']
ok: FUNC <void cv..HoughLines [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>

--- Incoming ---
[   u'cv.HoughLinesP',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'lines', '', ['/O']],
        [u'double', u'rho', u'', []],
        [u'double', u'theta', u'', []],
        [u'int', u'threshold', u'', []],
        [u'double', u'minLineLength', u'0', []],
        [u'double', u'maxLineGap', u'0', []]],
    u'void']
ok: FUNC <void cv..HoughLinesP [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double minLineLength=0, ARG double maxLineGap=0]>

--- Incoming ---
[   u'cv.HoughLinesPointSet',
    u'void',
    [],
    [   ['Mat', u'_point', '', []],
        ['Mat', u'_lines', '', ['/O']],
        [u'int', u'lines_max', u'', []],
        [u'int', u'threshold', u'', []],
        [u'double', u'min_rho', u'', []],
        [u'double', u'max_rho', u'', []],
        [u'double', u'rho_step', u'', []],
        [u'double', u'min_theta', u'', []],
        [u'double', u'max_theta', u'', []],
        [u'double', u'theta_step', u'', []]],
    u'void']
ok: FUNC <void cv..HoughLinesPointSet [ARG Mat _point=, ARG Mat _lines=, ARG int lines_max=, ARG int threshold=, ARG double min_rho=, ARG double max_rho=, ARG double rho_step=, ARG double min_theta=, ARG double max_theta=, ARG double theta_step=]>

--- Incoming ---
[   u'cv.HoughCircles',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'circles', '', ['/O']],
        [u'int', u'method', u'', []],
        [u'double', u'dp', u'', []],
        [u'double', u'minDist', u'', []],
        [u'double', u'param1', u'100', []],
        [u'double', u'param2', u'100', []],
        [u'int', u'minRadius', u'0', []],
        [u'int', u'maxRadius', u'0', []]],
    u'void']
ok: FUNC <void cv..HoughCircles [ARG Mat image=, ARG Mat circles=, ARG int method=, ARG double dp=, ARG double minDist=, ARG double param1=100, ARG double param2=100, ARG int minRadius=0, ARG int maxRadius=0]>

--- Incoming ---
[   u'cv.erode',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..erode [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.dilate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..dilate [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.morphologyEx',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'op', u'', []],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..morphologyEx [ARG Mat src=, ARG Mat dst=, ARG int op=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.resize',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dsize', u'', []],
        [u'double', u'fx', u'0', []],
        [u'double', u'fy', u'0', []],
        [u'int', u'interpolation', u'INTER_LINEAR', []]],
    u'void']
ok: FUNC <void cv..resize [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG double fx=0, ARG double fy=0, ARG int interpolation=INTER_LINEAR]>

--- Incoming ---
[   u'cv.warpAffine',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'M', '', []],
        [u'Size', u'dsize', u'', []],
        [u'int', u'flags', u'INTER_LINEAR', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..warpAffine [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.warpPerspective',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'M', '', []],
        [u'Size', u'dsize', u'', []],
        [u'int', u'flags', u'INTER_LINEAR', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..warpPerspective [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.remap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'map1', '', []],
        ['Mat', u'map2', '', []],
        [u'int', u'interpolation', u'', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..remap [ARG Mat src=, ARG Mat dst=, ARG Mat map1=, ARG Mat map2=, ARG int interpolation=, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.convertMaps',
    u'void',
    [],
    [   ['Mat', u'map1', '', []],
        ['Mat', u'map2', '', []],
        ['Mat', u'dstmap1', '', ['/O']],
        ['Mat', u'dstmap2', '', ['/O']],
        [u'int', u'dstmap1type', u'', []],
        [u'bool', u'nninterpolation', u'false', []]],
    u'void']
ok: FUNC <void cv..convertMaps [ARG Mat map1=, ARG Mat map2=, ARG Mat dstmap1=, ARG Mat dstmap2=, ARG int dstmap1type=, ARG bool nninterpolation=false]>

--- Incoming ---
[   u'cv.getRotationMatrix2D',
    u'Mat',
    [],
    [   [u'Point2f', u'center', u'', []],
        [u'double', u'angle', u'', []],
        [u'double', u'scale', u'', []]],
    u'Mat']
ok: FUNC <Mat cv..getRotationMatrix2D [ARG Point2f center=, ARG double angle=, ARG double scale=]>

--- Incoming ---
[   u'cv.invertAffineTransform',
    u'void',
    [],
    [['Mat', u'M', '', []], ['Mat', u'iM', '', ['/O']]],
    u'void']
ok: FUNC <void cv..invertAffineTransform [ARG Mat M=, ARG Mat iM=]>

--- Incoming ---
[   u'cv.getPerspectiveTransform',
    u'Mat',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        [u'int', u'solveMethod', u'DECOMP_LU', []]],
    u'Mat']
ok: FUNC <Mat cv..getPerspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG int solveMethod=DECOMP_LU]>

--- Incoming ---
[   u'cv.getAffineTransform',
    u'Mat',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', []]],
    u'Mat']
ok: FUNC <Mat cv..getAffineTransform [ARG vector_Point2f src=, ARG vector_Point2f dst=]>

--- Incoming ---
[   u'cv.getRectSubPix',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patchSize', u'', []],
        [u'Point2f', u'center', u'', []],
        ['Mat', u'patch', '', ['/O']],
        [u'int', u'patchType', u'-1', []]],
    u'void']
ok: FUNC <void cv..getRectSubPix [ARG Mat image=, ARG Size patchSize=, ARG Point2f center=, ARG Mat patch=, ARG int patchType=-1]>

--- Incoming ---
[   u'cv.logPolar',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Point2f', u'center', u'', []],
        [u'double', u'M', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..logPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double M=, ARG int flags=]>

--- Incoming ---
[   u'cv.linearPolar',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Point2f', u'center', u'', []],
        [u'double', u'maxRadius', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..linearPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>

--- Incoming ---
[   u'cv.warpPolar',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dsize', u'', []],
        [u'Point2f', u'center', u'', []],
        [u'double', u'maxRadius', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..warpPolar [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        [u'int', u'sdepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG int sdepth=-1]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [u'=integral2'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        ['Mat', u'sqsum', '', ['/O']],
        [u'int', u'sdepth', u'-1', []],
        [u'int', u'sqdepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG int sdepth=-1, ARG int sqdepth=-1]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [u'=integral3'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        ['Mat', u'sqsum', '', ['/O']],
        ['Mat', u'tilted', '', ['/O']],
        [u'int', u'sdepth', u'-1', []],
        [u'int', u'sqdepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG Mat tilted=, ARG int sdepth=-1, ARG int sqdepth=-1]>

--- Incoming ---
[   u'cv.accumulate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..accumulate [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateSquare',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..accumulateSquare [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateProduct',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..accumulateProduct [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateWeighted',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'double', u'alpha', u'', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..accumulateWeighted [ARG Mat src=, ARG Mat dst=, ARG double alpha=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.phaseCorrelate',
    u'Point2d',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'window', u'Mat()', []],
        [u'double*', u'response', u'0', ['/O']]],
    u'Point2d']
ok: FUNC <Point2d cv..phaseCorrelate [ARG Mat src1=, ARG Mat src2=, ARG Mat window=Mat(), ARG double * response=0]>

--- Incoming ---
[   u'cv.createHanningWindow',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/O']],
        [u'Size', u'winSize', u'', []],
        [u'int', u'type', u'', []]],
    u'void']
ok: FUNC <void cv..createHanningWindow [ARG Mat dst=, ARG Size winSize=, ARG int type=]>

--- Incoming ---
[   u'cv.threshold',
    u'double',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'thresh', u'', []],
        [u'double', u'maxval', u'', []],
        [u'int', u'type', u'', []]],
    u'double']
ok: FUNC <double cv..threshold [ARG Mat src=, ARG Mat dst=, ARG double thresh=, ARG double maxval=, ARG int type=]>

--- Incoming ---
[   u'cv.adaptiveThreshold',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'maxValue', u'', []],
        [u'int', u'adaptiveMethod', u'', []],
        [u'int', u'thresholdType', u'', []],
        [u'int', u'blockSize', u'', []],
        [u'double', u'C', u'', []]],
    u'void']
ok: FUNC <void cv..adaptiveThreshold [ARG Mat src=, ARG Mat dst=, ARG double maxValue=, ARG int adaptiveMethod=, ARG int thresholdType=, ARG int blockSize=, ARG double C=]>

--- Incoming ---
[   u'cv.pyrDown',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dstsize', u'Size()', ['/C', '/Ref']],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..pyrDown [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.pyrUp',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dstsize', u'Size()', ['/C', '/Ref']],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..pyrUp [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.calcHist',
    u'void',
    [],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_int', u'channels', u'', ['/C', '/Ref']],
        ['Mat', u'mask', '', []],
        ['Mat', u'hist', '', ['/O']],
        [u'vector_int', u'histSize', u'', ['/C', '/Ref']],
        [u'vector_float', u'ranges', u'', ['/C', '/Ref']],
        [u'bool', u'accumulate', u'false', []]],
    u'void']
ok: FUNC <void cv..calcHist [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat mask=, ARG Mat hist=, ARG vector_int histSize=, ARG vector_float ranges=, ARG bool accumulate=false]>

--- Incoming ---
[   u'cv.calcBackProject',
    u'void',
    [],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_int', u'channels', u'', ['/C', '/Ref']],
        ['Mat', u'hist', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'vector_float', u'ranges', u'', ['/C', '/Ref']],
        [u'double', u'scale', u'', []]],
    u'void']
ok: FUNC <void cv..calcBackProject [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat hist=, ARG Mat dst=, ARG vector_float ranges=, ARG double scale=]>

--- Incoming ---
[   u'cv.compareHist',
    u'double',
    [],
    [   ['Mat', u'H1', '', []],
        ['Mat', u'H2', '', []],
        [u'int', u'method', u'', []]],
    u'double']
ok: FUNC <double cv..compareHist [ARG Mat H1=, ARG Mat H2=, ARG int method=]>

--- Incoming ---
[   u'cv.equalizeHist',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..equalizeHist [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.createCLAHE',
    u'Ptr_CLAHE',
    [],
    [   [u'double', u'clipLimit', u'40.0', []],
        [u'Size', u'tileGridSize', u'Size(8, 8)', []]],
    u'Ptr<CLAHE>']
ok: FUNC <Ptr_CLAHE cv..createCLAHE [ARG double clipLimit=40.0, ARG Size tileGridSize=Size(8, 8)]>

--- Incoming ---
[   u'cv.wrapperEMD',
    u'float',
    [u'=EMD'],
    [   ['Mat', u'signature1', '', []],
        ['Mat', u'signature2', '', []],
        [u'int', u'distType', u'', []],
        ['Mat', u'cost', u'Mat()', []],
        [u'Ptr_float', u'lowerBound', u'Ptr<float>()', ['/IO']],
        ['Mat', u'flow', u'Mat()', ['/O']]],
    u'float']
ok: FUNC <float cv..wrapperEMD [ARG Mat signature1=, ARG Mat signature2=, ARG int distType=, ARG Mat cost=Mat(), ARG Ptr_float lowerBound=Ptr<float>(), ARG Mat flow=Mat()]>

--- Incoming ---
[   u'cv.watershed',
    u'void',
    [],
    [['Mat', u'image', '', []], ['Mat', u'markers', '', ['/IO']]],
    u'void']
ok: FUNC <void cv..watershed [ARG Mat image=, ARG Mat markers=]>

--- Incoming ---
[   u'cv.pyrMeanShiftFiltering',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'sp', u'', []],
        [u'double', u'sr', u'', []],
        [u'int', u'maxLevel', u'1', []],
        [   u'TermCriteria',
            u'termcrit',
            u'TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)',
            []]],
    u'void']
ok: FUNC <void cv..pyrMeanShiftFiltering [ARG Mat src=, ARG Mat dst=, ARG double sp=, ARG double sr=, ARG int maxLevel=1, ARG TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)]>

--- Incoming ---
[   u'cv.grabCut',
    u'void',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'mask', '', ['/IO']],
        [u'Rect', u'rect', u'', []],
        ['Mat', u'bgdModel', '', ['/IO']],
        ['Mat', u'fgdModel', '', ['/IO']],
        [u'int', u'iterCount', u'', []],
        [u'int', u'mode', u'GC_EVAL', []]],
    u'void']
ok: FUNC <void cv..grabCut [ARG Mat img=, ARG Mat mask=, ARG Rect rect=, ARG Mat bgdModel=, ARG Mat fgdModel=, ARG int iterCount=, ARG int mode=GC_EVAL]>

--- Incoming ---
[   u'cv.distanceTransform',
    u'void',
    [u'=distanceTransformWithLabels'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'distanceType', u'', []],
        [u'int', u'maskSize', u'', []],
        [u'int', u'labelType', u'DIST_LABEL_CCOMP', []]],
    u'void']
ok: FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG Mat labels=, ARG int distanceType=, ARG int maskSize=, ARG int labelType=DIST_LABEL_CCOMP]>

--- Incoming ---
[   u'cv.distanceTransform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'distanceType', u'', []],
        [u'int', u'maskSize', u'', []],
        [u'int', u'dstType', u'CV_32F', []]],
    u'void']
ok: FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG int distanceType=, ARG int maskSize=, ARG int dstType=CV_32F]>

--- Incoming ---
[   u'cv.floodFill',
    u'int',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'mask', '', ['/IO']],
        [u'Point', u'seedPoint', u'', []],
        [u'Scalar', u'newVal', u'', []],
        [u'Rect*', u'rect', u'0', ['/O']],
        [u'Scalar', u'loDiff', u'Scalar()', []],
        [u'Scalar', u'upDiff', u'Scalar()', []],
        [u'int', u'flags', u'4', []]],
    u'int']
ok: FUNC <int cv..floodFill [ARG Mat image=, ARG Mat mask=, ARG Point seedPoint=, ARG Scalar newVal=, ARG Rect * rect=0, ARG Scalar loDiff=Scalar(), ARG Scalar upDiff=Scalar(), ARG int flags=4]>

--- Incoming ---
[   u'cv.cvtColor',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'code', u'', []],
        [u'int', u'dstCn', u'0', []]],
    u'void']
ok: FUNC <void cv..cvtColor [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>

--- Incoming ---
[   u'cv.cvtColorTwoPlane',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'code', u'', []]],
    u'void']
ok: FUNC <void cv..cvtColorTwoPlane [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int code=]>

--- Incoming ---
[   u'cv.demosaicing',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'code', u'', []],
        [u'int', u'dstCn', u'0', []]],
    u'void']
ok: FUNC <void cv..demosaicing [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>

--- Incoming ---
[   u'cv.moments',
    u'Moments',
    [],
    [['Mat', u'array', '', []], [u'bool', u'binaryImage', u'false', []]],
    u'Moments']
ok: FUNC <Moments cv..moments [ARG Mat array=, ARG bool binaryImage=false]>

--- Incoming ---
[   u'cv.HuMoments',
    u'void',
    [],
    [[u'Moments', u'm', u'', ['/C', '/Ref']], ['Mat', u'hu', '', ['/O']]],
    u'void']
ok: FUNC <void cv..HuMoments [ARG Moments m=, ARG Mat hu=]>

--- Incoming ---
[   u'enum cv.TemplateMatchModes',
    '',
    [],
    [   [u'const cv.TM_SQDIFF', u'0', [], [], None, ''],
        [u'const cv.TM_SQDIFF_NORMED', u'1', [], [], None, ''],
        [u'const cv.TM_CCORR', u'2', [], [], None, ''],
        [u'const cv.TM_CCORR_NORMED', u'3', [], [], None, ''],
        [u'const cv.TM_CCOEFF', u'4', [], [], None, ''],
        [u'const cv.TM_CCOEFF_NORMED', u'5', [], [], None, '']],
    None]
ok: CONST TM_SQDIFF=0
ok: CONST TM_SQDIFF_NORMED=1
ok: CONST TM_CCORR=2
ok: CONST TM_CCORR_NORMED=3
ok: CONST TM_CCOEFF=4
ok: CONST TM_CCOEFF_NORMED=5

--- Incoming ---
[   u'cv.matchTemplate',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'templ', '', []],
        ['Mat', u'result', '', ['/O']],
        [u'int', u'method', u'', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..matchTemplate [ARG Mat image=, ARG Mat templ=, ARG Mat result=, ARG int method=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.connectedComponents',
    u'int',
    [u'=connectedComponentsWithAlgorithm'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'connectivity', u'', []],
        [u'int', u'ltype', u'', []],
        [u'int', u'ccltype', u'', []]],
    u'int']
ok: FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>

--- Incoming ---
[   u'cv.connectedComponents',
    u'int',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'connectivity', u'8', []],
        [u'int', u'ltype', u'CV_32S', []]],
    u'int']
ok: FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=8, ARG int ltype=CV_32S]>

--- Incoming ---
[   u'cv.connectedComponentsWithStats',
    u'int',
    [u'=connectedComponentsWithStatsWithAlgorithm'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        ['Mat', u'stats', '', ['/O']],
        ['Mat', u'centroids', '', ['/O']],
        [u'int', u'connectivity', u'', []],
        [u'int', u'ltype', u'', []],
        [u'int', u'ccltype', u'', []]],
    u'int']
ok: FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>

--- Incoming ---
[   u'cv.connectedComponentsWithStats',
    u'int',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        ['Mat', u'stats', '', ['/O']],
        ['Mat', u'centroids', '', ['/O']],
        [u'int', u'connectivity', u'8', []],
        [u'int', u'ltype', u'CV_32S', []]],
    u'int']
ok: FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=8, ARG int ltype=CV_32S]>

--- Incoming ---
[   u'cv.findContours',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['vector_Mat', u'contours', '', ['/O']],
        ['Mat', u'hierarchy', '', ['/O']],
        [u'int', u'mode', u'', []],
        [u'int', u'method', u'', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void']
ok: FUNC <void cv..findContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG Mat hierarchy=, ARG int mode=, ARG int method=, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.approxPolyDP',
    u'void',
    [],
    [   ['Mat', u'curve', '', []],
        ['Mat', u'approxCurve', '', ['/O']],
        [u'double', u'epsilon', u'', []],
        [u'bool', u'closed', u'', []]],
    u'void']
ok: FUNC <void cv..approxPolyDP [ARG vector_Point2f curve=, ARG vector_Point2f approxCurve=, ARG double epsilon=, ARG bool closed=]>

--- Incoming ---
[   u'cv.arcLength',
    u'double',
    [],
    [['Mat', u'curve', '', []], [u'bool', u'closed', u'', []]],
    u'double']
ok: FUNC <double cv..arcLength [ARG vector_Point2f curve=, ARG bool closed=]>

--- Incoming ---
[u'cv.boundingRect', u'Rect', [], [['Mat', u'array', '', []]], u'Rect']
ok: FUNC <Rect cv..boundingRect [ARG Mat array=]>

--- Incoming ---
[   u'cv.contourArea',
    u'double',
    [],
    [['Mat', u'contour', '', []], [u'bool', u'oriented', u'false', []]],
    u'double']
ok: FUNC <double cv..contourArea [ARG Mat contour=, ARG bool oriented=false]>

--- Incoming ---
[   u'cv.minAreaRect',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..minAreaRect [ARG vector_Point2f points=]>

--- Incoming ---
[   u'cv.boxPoints',
    u'void',
    [],
    [[u'RotatedRect', u'box', u'', []], ['Mat', u'points', '', ['/O']]],
    u'void']
ok: FUNC <void cv..boxPoints [ARG RotatedRect box=, ARG Mat points=]>

--- Incoming ---
[   u'cv.minEnclosingCircle',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        [u'Point2f', u'center', u'', ['/O', '/Ref']],
        [u'float', u'radius', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv..minEnclosingCircle [ARG vector_Point2f points=, ARG Point2f center=, ARG float radius=]>

--- Incoming ---
[   u'cv.minEnclosingTriangle',
    u'double',
    [],
    [['Mat', u'points', '', []], ['Mat', u'triangle', '', ['/O', '/O']]],
    u'double']
ok: FUNC <double cv..minEnclosingTriangle [ARG Mat points=, ARG Mat triangle=]>

--- Incoming ---
[   u'cv.matchShapes',
    u'double',
    [],
    [   ['Mat', u'contour1', '', []],
        ['Mat', u'contour2', '', []],
        [u'int', u'method', u'', []],
        [u'double', u'parameter', u'', []]],
    u'double']
ok: FUNC <double cv..matchShapes [ARG Mat contour1=, ARG Mat contour2=, ARG int method=, ARG double parameter=]>

--- Incoming ---
[   u'cv.convexHull',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        ['Mat', u'hull', '', ['/O']],
        [u'bool', u'clockwise', u'false', []],
        [u'bool', u'returnPoints', u'true', []]],
    u'void']
ok: FUNC <void cv..convexHull [ARG vector_Point points=, ARG vector_int hull=, ARG bool clockwise=false, ARG  returnPoints=true]>

--- Incoming ---
[   u'cv.convexityDefects',
    u'void',
    [],
    [   ['Mat', u'contour', '', []],
        ['Mat', u'convexhull', '', []],
        ['Mat', u'convexityDefects', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convexityDefects [ARG vector_Point contour=, ARG vector_int convexhull=, ARG vector_Vec4i convexityDefects=]>

--- Incoming ---
[u'cv.isContourConvex', u'bool', [], [['Mat', u'contour', '', []]], u'bool']
ok: FUNC <bool cv..isContourConvex [ARG vector_Point contour=]>

--- Incoming ---
[   u'cv.intersectConvexConvex',
    u'float',
    [],
    [   ['Mat', u'_p1', '', []],
        ['Mat', u'_p2', '', []],
        ['Mat', u'_p12', '', ['/O']],
        [u'bool', u'handleNested', u'true', []]],
    u'float']
ok: FUNC <float cv..intersectConvexConvex [ARG Mat _p1=, ARG Mat _p2=, ARG Mat _p12=, ARG bool handleNested=true]>

--- Incoming ---
[   u'cv.fitEllipse',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipse [ARG vector_Point2f points=]>

--- Incoming ---
[   u'cv.fitEllipseAMS',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipseAMS [ARG Mat points=]>

--- Incoming ---
[   u'cv.fitEllipseDirect',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipseDirect [ARG Mat points=]>

--- Incoming ---
[   u'cv.fitLine',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        ['Mat', u'line', '', ['/O']],
        [u'int', u'distType', u'', []],
        [u'double', u'param', u'', []],
        [u'double', u'reps', u'', []],
        [u'double', u'aeps', u'', []]],
    u'void']
ok: FUNC <void cv..fitLine [ARG Mat points=, ARG Mat line=, ARG int distType=, ARG double param=, ARG double reps=, ARG double aeps=]>

--- Incoming ---
[   u'cv.pointPolygonTest',
    u'double',
    [],
    [   ['Mat', u'contour', '', []],
        [u'Point2f', u'pt', u'', []],
        [u'bool', u'measureDist', u'', []]],
    u'double']
ok: FUNC <double cv..pointPolygonTest [ARG vector_Point2f contour=, ARG Point2f pt=, ARG bool measureDist=]>

--- Incoming ---
[   u'cv.rotatedRectangleIntersection',
    u'int',
    [],
    [   [u'RotatedRect', u'rect1', u'', ['/C', '/Ref']],
        [u'RotatedRect', u'rect2', u'', ['/C', '/Ref']],
        ['Mat', u'intersectingRegion', '', ['/O']]],
    u'int']
ok: FUNC <int cv..rotatedRectangleIntersection [ARG RotatedRect rect1=, ARG RotatedRect rect2=, ARG Mat intersectingRegion=]>

--- Incoming ---
[   u'cv.createGeneralizedHoughBallard',
    u'Ptr_GeneralizedHoughBallard',
    [],
    [],
    u'Ptr<GeneralizedHoughBallard>']
ok: FUNC <Ptr_GeneralizedHoughBallard cv..createGeneralizedHoughBallard []>

--- Incoming ---
[   u'cv.createGeneralizedHoughGuil',
    u'Ptr_GeneralizedHoughGuil',
    [],
    [],
    u'Ptr<GeneralizedHoughGuil>']
ok: FUNC <Ptr_GeneralizedHoughGuil cv..createGeneralizedHoughGuil []>

--- Incoming ---
[   u'enum cv.ColormapTypes',
    '',
    [],
    [   [u'const cv.COLORMAP_AUTUMN', u'0', [], [], None, ''],
        [u'const cv.COLORMAP_BONE', u'1', [], [], None, ''],
        [u'const cv.COLORMAP_JET', u'2', [], [], None, ''],
        [u'const cv.COLORMAP_WINTER', u'3', [], [], None, ''],
        [u'const cv.COLORMAP_RAINBOW', u'4', [], [], None, ''],
        [u'const cv.COLORMAP_OCEAN', u'5', [], [], None, ''],
        [u'const cv.COLORMAP_SUMMER', u'6', [], [], None, ''],
        [u'const cv.COLORMAP_SPRING', u'7', [], [], None, ''],
        [u'const cv.COLORMAP_COOL', u'8', [], [], None, ''],
        [u'const cv.COLORMAP_HSV', u'9', [], [], None, ''],
        [u'const cv.COLORMAP_PINK', u'10', [], [], None, ''],
        [u'const cv.COLORMAP_HOT', u'11', [], [], None, ''],
        [u'const cv.COLORMAP_PARULA', u'12', [], [], None, ''],
        [u'const cv.COLORMAP_MAGMA', u'13', [], [], None, ''],
        [u'const cv.COLORMAP_INFERNO', u'14', [], [], None, ''],
        [u'const cv.COLORMAP_PLASMA', u'15', [], [], None, ''],
        [u'const cv.COLORMAP_VIRIDIS', u'16', [], [], None, ''],
        [u'const cv.COLORMAP_CIVIDIS', u'17', [], [], None, ''],
        [u'const cv.COLORMAP_TWILIGHT', u'18', [], [], None, ''],
        [u'const cv.COLORMAP_TWILIGHT_SHIFTED', u'19', [], [], None, '']],
    None]
ok: CONST COLORMAP_AUTUMN=0
ok: CONST COLORMAP_BONE=1
ok: CONST COLORMAP_JET=2
ok: CONST COLORMAP_WINTER=3
ok: CONST COLORMAP_RAINBOW=4
ok: CONST COLORMAP_OCEAN=5
ok: CONST COLORMAP_SUMMER=6
ok: CONST COLORMAP_SPRING=7
ok: CONST COLORMAP_COOL=8
ok: CONST COLORMAP_HSV=9
ok: CONST COLORMAP_PINK=10
ok: CONST COLORMAP_HOT=11
ok: CONST COLORMAP_PARULA=12
ok: CONST COLORMAP_MAGMA=13
ok: CONST COLORMAP_INFERNO=14
ok: CONST COLORMAP_PLASMA=15
ok: CONST COLORMAP_VIRIDIS=16
ok: CONST COLORMAP_CIVIDIS=17
ok: CONST COLORMAP_TWILIGHT=18
ok: CONST COLORMAP_TWILIGHT_SHIFTED=19

--- Incoming ---
[   u'cv.applyColorMap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'colormap', u'', []]],
    u'void']
ok: FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG int colormap=]>

--- Incoming ---
[   u'cv.applyColorMap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'userColor', '', []]],
    u'void']
ok: FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG Mat userColor=]>

--- Incoming ---
[   u'cv.line',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..line [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.arrowedLine',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'line_type', u'8', []],
        [u'int', u'shift', u'0', []],
        [u'double', u'tipLength', u'0.1', []]],
    u'void']
ok: FUNC <void cv..arrowedLine [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int line_type=8, ARG int shift=0, ARG double tipLength=0.1]>

--- Incoming ---
[   u'cv.rectangle',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..rectangle [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.rectangle',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Rect', u'rec', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..rectangle [ARG Mat img=, ARG Rect rec=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.circle',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'center', u'', []],
        [u'int', u'radius', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..circle [ARG Mat img=, ARG Point center=, ARG int radius=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.ellipse',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'center', u'', []],
        [u'Size', u'axes', u'', []],
        [u'double', u'angle', u'', []],
        [u'double', u'startAngle', u'', []],
        [u'double', u'endAngle', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..ellipse [ARG Mat img=, ARG Point center=, ARG Size axes=, ARG double angle=, ARG double startAngle=, ARG double endAngle=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.ellipse',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'RotatedRect', u'box', u'', ['/C', '/Ref']],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []]],
    u'void']
ok: FUNC <void cv..ellipse [ARG Mat img=, ARG RotatedRect box=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8]>

--- Incoming ---
[   u'cv.drawMarker',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'position', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'markerType', u'MARKER_CROSS', []],
        [u'int', u'markerSize', u'20', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'line_type', u'8', []]],
    u'void']
ok: FUNC <void cv..drawMarker [ARG Mat img=, ARG Point position=, ARG Scalar color=, ARG int markerType=MARKER_CROSS, ARG int markerSize=20, ARG int thickness=1, ARG int line_type=8]>

--- Incoming ---
[   u'cv.fillConvexPoly',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['Mat', u'points', '', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..fillConvexPoly [ARG Mat img=, ARG vector_Point points=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.fillPoly',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['vector_Mat', u'pts', '', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void']
ok: FUNC <void cv..fillPoly [ARG Mat img=, ARG vector_vector_Point pts=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.polylines',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['vector_Mat', u'pts', '', []],
        [u'bool', u'isClosed', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..polylines [ARG Mat img=, ARG vector_vector_Point pts=, ARG bool isClosed=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.drawContours',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['vector_Mat', u'contours', '', []],
        [u'int', u'contourIdx', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        ['Mat', u'hierarchy', u'Mat()', []],
        [u'int', u'maxLevel', u'INT_MAX', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void']
ok: FUNC <void cv..drawContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG int contourIdx=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG Mat hierarchy=Mat(), ARG int maxLevel=INT_MAX, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.clipLine',
    u'bool',
    [],
    [   [u'Rect', u'imgRect', u'', []],
        [u'Point', u'pt1', u'', ['/O', '/IO', '/Ref']],
        [u'Point', u'pt2', u'', ['/O', '/IO', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..clipLine [ARG Rect imgRect=, ARG Point pt1=, ARG Point pt2=]>

--- Incoming ---
[   u'cv.ellipse2Poly',
    u'void',
    [],
    [   [u'Point', u'center', u'', []],
        [u'Size', u'axes', u'', []],
        [u'int', u'angle', u'', []],
        [u'int', u'arcStart', u'', []],
        [u'int', u'arcEnd', u'', []],
        [u'int', u'delta', u'', []],
        [u'vector_Point', u'pts', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv..ellipse2Poly [ARG Point center=, ARG Size axes=, ARG int angle=, ARG int arcStart=, ARG int arcEnd=, ARG int delta=, ARG vector_Point pts=]>

--- Incoming ---
[   u'cv.putText',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'String', u'text', u'', ['/C', '/Ref']],
        [u'Point', u'org', u'', []],
        [u'int', u'fontFace', u'', []],
        [u'double', u'fontScale', u'', []],
        [u'Scalar', u'color', u'', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'bool', u'bottomLeftOrigin', u'false', []]],
    u'void']
ok: FUNC <void cv..putText [ARG Mat img=, ARG String text=, ARG Point org=, ARG int fontFace=, ARG double fontScale=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG bool bottomLeftOrigin=false]>

--- Incoming ---
[   u'cv.getTextSize',
    u'Size',
    [],
    [   [u'String', u'text', u'', ['/C', '/Ref']],
        [u'int', u'fontFace', u'', []],
        [u'double', u'fontScale', u'', []],
        [u'int', u'thickness', u'', []],
        [u'int*', u'baseLine', u'', ['/O']]],
    u'Size']
manual: FUNC <Size cv..getTextSize [ARG String text=, ARG int fontFace=, ARG double fontScale=, ARG int thickness=, ARG int * baseLine=]>

--- Incoming ---
[   u'cv.getFontScaleFromHeight',
    u'double',
    [],
    [   [u'int', u'fontFace', u'', ['/C']],
        [u'int', u'pixelHeight', u'', ['/C']],
        [u'int', u'thickness', u'1', ['/C']]],
    u'double']
ok: FUNC <double cv..getFontScaleFromHeight [ARG int fontFace=, ARG int pixelHeight=, ARG int thickness=1]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/imgproc.hpp =====
Namespaces: set(['', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/imgproc.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp =====
Namespaces: set(['', u'cv.hal', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp =====
Namespaces: set(['', u'cv.detail', u'cv.hal', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp


===== Generating... =====
CLASS ::.Imgproc : 
[CONST IPL_BORDER_CONSTANT=0(manual), CONST IPL_BORDER_REPLICATE=1(manual), CONST IPL_BORDER_REFLECT=2(manual), CONST IPL_BORDER_WRAP=3(manual), CONST IPL_BORDER_REFLECT_101=4(manual), CONST IPL_BORDER_TRANSPARENT=5(manual), CONST CV_INTER_NN=0, CONST CV_INTER_LINEAR=1, CONST CV_INTER_CUBIC=2, CONST CV_INTER_AREA=3, CONST CV_INTER_LANCZOS4=4, CONST CV_MOP_ERODE=0, CONST CV_MOP_DILATE=1, CONST CV_MOP_OPEN=2, CONST CV_MOP_CLOSE=3, CONST CV_MOP_GRADIENT=4, CONST CV_MOP_TOPHAT=5, CONST CV_MOP_BLACKHAT=6, CONST CV_RETR_EXTERNAL=0, CONST CV_RETR_LIST=1, CONST CV_RETR_CCOMP=2, CONST CV_RETR_TREE=3, CONST CV_RETR_FLOODFILL=4, CONST CV_CHAIN_APPROX_NONE=1, CONST CV_CHAIN_APPROX_SIMPLE=2, CONST CV_CHAIN_APPROX_TC89_L1=3, CONST CV_CHAIN_APPROX_TC89_KCOS=4, CONST CV_THRESH_BINARY=0, CONST CV_THRESH_BINARY_INV=1, CONST CV_THRESH_TRUNC=2, CONST CV_THRESH_TOZERO=3, CONST CV_THRESH_TOZERO_INV=4, CONST CV_THRESH_MASK=7, CONST CV_THRESH_OTSU=8, CONST CV_THRESH_TRIANGLE=16]
[CONST FONT_HERSHEY_SIMPLEX=0, CONST FONT_HERSHEY_PLAIN=1, CONST FONT_HERSHEY_DUPLEX=2, CONST FONT_HERSHEY_COMPLEX=3, CONST FONT_HERSHEY_TRIPLEX=4, CONST FONT_HERSHEY_COMPLEX_SMALL=5, CONST FONT_HERSHEY_SCRIPT_SIMPLEX=6, CONST FONT_HERSHEY_SCRIPT_COMPLEX=7, CONST FONT_ITALIC=16]
[CONST INTER_BITS=5, CONST INTER_BITS2=INTER_BITS * 2, CONST INTER_TAB_SIZE=1 << INTER_BITS, CONST INTER_TAB_SIZE2=INTER_TAB_SIZE * INTER_TAB_SIZE]
[CONST MORPH_ERODE=0, CONST MORPH_DILATE=1, CONST MORPH_OPEN=2, CONST MORPH_CLOSE=3, CONST MORPH_GRADIENT=4, CONST MORPH_TOPHAT=5, CONST MORPH_BLACKHAT=6, CONST MORPH_HITMISS=7]
[CONST FLOODFILL_FIXED_RANGE=1 << 16, CONST FLOODFILL_MASK_ONLY=1 << 17]
[CONST HOUGH_STANDARD=0, CONST HOUGH_PROBABILISTIC=1, CONST HOUGH_MULTI_SCALE=2, CONST HOUGH_GRADIENT=3]
[CONST CCL_WU=0, CONST CCL_DEFAULT=-1, CONST CCL_GRANA=1]
[CONST RETR_EXTERNAL=0, CONST RETR_LIST=1, CONST RETR_CCOMP=2, CONST RETR_TREE=3, CONST RETR_FLOODFILL=4]
[CONST GC_BGD=0, CONST GC_FGD=1, CONST GC_PR_BGD=2, CONST GC_PR_FGD=3]
[CONST COLORMAP_AUTUMN=0, CONST COLORMAP_BONE=1, CONST COLORMAP_JET=2, CONST COLORMAP_WINTER=3, CONST COLORMAP_RAINBOW=4, CONST COLORMAP_OCEAN=5, CONST COLORMAP_SUMMER=6, CONST COLORMAP_SPRING=7, CONST COLORMAP_COOL=8, CONST COLORMAP_HSV=9, CONST COLORMAP_PINK=10, CONST COLORMAP_HOT=11, CONST COLORMAP_PARULA=12, CONST COLORMAP_MAGMA=13, CONST COLORMAP_INFERNO=14, CONST COLORMAP_PLASMA=15, CONST COLORMAP_VIRIDIS=16, CONST COLORMAP_CIVIDIS=17, CONST COLORMAP_TWILIGHT=18, CONST COLORMAP_TWILIGHT_SHIFTED=19]
[CONST HISTCMP_CORREL=0, CONST HISTCMP_CHISQR=1, CONST HISTCMP_INTERSECT=2, CONST HISTCMP_BHATTACHARYYA=3, CONST HISTCMP_HELLINGER=HISTCMP_BHATTACHARYYA, CONST HISTCMP_CHISQR_ALT=4, CONST HISTCMP_KL_DIV=5]
[CONST FILLED=-1, CONST LINE_4=4, CONST LINE_8=8, CONST LINE_AA=16]
[CONST INTER_NEAREST=0, CONST INTER_LINEAR=1, CONST INTER_CUBIC=2, CONST INTER_AREA=3, CONST INTER_LANCZOS4=4, CONST INTER_LINEAR_EXACT=5, CONST INTER_MAX=7, CONST WARP_FILL_OUTLIERS=8, CONST WARP_INVERSE_MAP=16]
[CONST FILTER_SCHARR=-1]
[CONST CHAIN_APPROX_NONE=1, CONST CHAIN_APPROX_SIMPLE=2, CONST CHAIN_APPROX_TC89_L1=3, CONST CHAIN_APPROX_TC89_KCOS=4]
[CONST INTERSECT_NONE=0, CONST INTERSECT_PARTIAL=1, CONST INTERSECT_FULL=2]
[CONST CONTOURS_MATCH_I1=1, CONST CONTOURS_MATCH_I2=2, CONST CONTOURS_MATCH_I3=3]
[CONST WARP_POLAR_LINEAR=0, CONST WARP_POLAR_LOG=256]
[CONST COLOR_BGR2BGRA=0, CONST COLOR_RGB2RGBA=COLOR_BGR2BGRA, CONST COLOR_BGRA2BGR=1, CONST COLOR_RGBA2RGB=COLOR_BGRA2BGR, CONST COLOR_BGR2RGBA=2, CONST COLOR_RGB2BGRA=COLOR_BGR2RGBA, CONST COLOR_RGBA2BGR=3, CONST COLOR_BGRA2RGB=COLOR_RGBA2BGR, CONST COLOR_BGR2RGB=4, CONST COLOR_RGB2BGR=COLOR_BGR2RGB, CONST COLOR_BGRA2RGBA=5, CONST COLOR_RGBA2BGRA=COLOR_BGRA2RGBA, CONST COLOR_BGR2GRAY=6, CONST COLOR_RGB2GRAY=7, CONST COLOR_GRAY2BGR=8, CONST COLOR_GRAY2RGB=COLOR_GRAY2BGR, CONST COLOR_GRAY2BGRA=9, CONST COLOR_GRAY2RGBA=COLOR_GRAY2BGRA, CONST COLOR_BGRA2GRAY=10, CONST COLOR_RGBA2GRAY=11, CONST COLOR_BGR2BGR565=12, CONST COLOR_RGB2BGR565=13, CONST COLOR_BGR5652BGR=14, CONST COLOR_BGR5652RGB=15, CONST COLOR_BGRA2BGR565=16, CONST COLOR_RGBA2BGR565=17, CONST COLOR_BGR5652BGRA=18, CONST COLOR_BGR5652RGBA=19, CONST COLOR_GRAY2BGR565=20, CONST COLOR_BGR5652GRAY=21, CONST COLOR_BGR2BGR555=22, CONST COLOR_RGB2BGR555=23, CONST COLOR_BGR5552BGR=24, CONST COLOR_BGR5552RGB=25, CONST COLOR_BGRA2BGR555=26, CONST COLOR_RGBA2BGR555=27, CONST COLOR_BGR5552BGRA=28, CONST COLOR_BGR5552RGBA=29, CONST COLOR_GRAY2BGR555=30, CONST COLOR_BGR5552GRAY=31, CONST COLOR_BGR2XYZ=32, CONST COLOR_RGB2XYZ=33, CONST COLOR_XYZ2BGR=34, CONST COLOR_XYZ2RGB=35, CONST COLOR_BGR2YCrCb=36, CONST COLOR_RGB2YCrCb=37, CONST COLOR_YCrCb2BGR=38, CONST COLOR_YCrCb2RGB=39, CONST COLOR_BGR2HSV=40, CONST COLOR_RGB2HSV=41, CONST COLOR_BGR2Lab=44, CONST COLOR_RGB2Lab=45, CONST COLOR_BGR2Luv=50, CONST COLOR_RGB2Luv=51, CONST COLOR_BGR2HLS=52, CONST COLOR_RGB2HLS=53, CONST COLOR_HSV2BGR=54, CONST COLOR_HSV2RGB=55, CONST COLOR_Lab2BGR=56, CONST COLOR_Lab2RGB=57, CONST COLOR_Luv2BGR=58, CONST COLOR_Luv2RGB=59, CONST COLOR_HLS2BGR=60, CONST COLOR_HLS2RGB=61, CONST COLOR_BGR2HSV_FULL=66, CONST COLOR_RGB2HSV_FULL=67, CONST COLOR_BGR2HLS_FULL=68, CONST COLOR_RGB2HLS_FULL=69, CONST COLOR_HSV2BGR_FULL=70, CONST COLOR_HSV2RGB_FULL=71, CONST COLOR_HLS2BGR_FULL=72, CONST COLOR_HLS2RGB_FULL=73, CONST COLOR_LBGR2Lab=74, CONST COLOR_LRGB2Lab=75, CONST COLOR_LBGR2Luv=76, CONST COLOR_LRGB2Luv=77, CONST COLOR_Lab2LBGR=78, CONST COLOR_Lab2LRGB=79, CONST COLOR_Luv2LBGR=80, CONST COLOR_Luv2LRGB=81, CONST COLOR_BGR2YUV=82, CONST COLOR_RGB2YUV=83, CONST COLOR_YUV2BGR=84, CONST COLOR_YUV2RGB=85, CONST COLOR_YUV2RGB_NV12=90, CONST COLOR_YUV2BGR_NV12=91, CONST COLOR_YUV2RGB_NV21=92, CONST COLOR_YUV2BGR_NV21=93, CONST COLOR_YUV420sp2RGB=COLOR_YUV2RGB_NV21, CONST COLOR_YUV420sp2BGR=COLOR_YUV2BGR_NV21, CONST COLOR_YUV2RGBA_NV12=94, CONST COLOR_YUV2BGRA_NV12=95, CONST COLOR_YUV2RGBA_NV21=96, CONST COLOR_YUV2BGRA_NV21=97, CONST COLOR_YUV420sp2RGBA=COLOR_YUV2RGBA_NV21, CONST COLOR_YUV420sp2BGRA=COLOR_YUV2BGRA_NV21, CONST COLOR_YUV2RGB_YV12=98, CONST COLOR_YUV2BGR_YV12=99, CONST COLOR_YUV2RGB_IYUV=100, CONST COLOR_YUV2BGR_IYUV=101, CONST COLOR_YUV2RGB_I420=COLOR_YUV2RGB_IYUV, CONST COLOR_YUV2BGR_I420=COLOR_YUV2BGR_IYUV, CONST COLOR_YUV420p2RGB=COLOR_YUV2RGB_YV12, CONST COLOR_YUV420p2BGR=COLOR_YUV2BGR_YV12, CONST COLOR_YUV2RGBA_YV12=102, CONST COLOR_YUV2BGRA_YV12=103, CONST COLOR_YUV2RGBA_IYUV=104, CONST COLOR_YUV2BGRA_IYUV=105, CONST COLOR_YUV2RGBA_I420=COLOR_YUV2RGBA_IYUV, CONST COLOR_YUV2BGRA_I420=COLOR_YUV2BGRA_IYUV, CONST COLOR_YUV420p2RGBA=COLOR_YUV2RGBA_YV12, CONST COLOR_YUV420p2BGRA=COLOR_YUV2BGRA_YV12, CONST COLOR_YUV2GRAY_420=106, CONST COLOR_YUV2GRAY_NV21=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_NV12=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_YV12=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_IYUV=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_I420=COLOR_YUV2GRAY_420, CONST COLOR_YUV420sp2GRAY=COLOR_YUV2GRAY_420, CONST COLOR_YUV420p2GRAY=COLOR_YUV2GRAY_420, CONST COLOR_YUV2RGB_UYVY=107, CONST COLOR_YUV2BGR_UYVY=108, CONST COLOR_YUV2RGB_Y422=COLOR_YUV2RGB_UYVY, CONST COLOR_YUV2BGR_Y422=COLOR_YUV2BGR_UYVY, CONST COLOR_YUV2RGB_UYNV=COLOR_YUV2RGB_UYVY, CONST COLOR_YUV2BGR_UYNV=COLOR_YUV2BGR_UYVY, CONST COLOR_YUV2RGBA_UYVY=111, CONST COLOR_YUV2BGRA_UYVY=112, CONST COLOR_YUV2RGBA_Y422=COLOR_YUV2RGBA_UYVY, CONST COLOR_YUV2BGRA_Y422=COLOR_YUV2BGRA_UYVY, CONST COLOR_YUV2RGBA_UYNV=COLOR_YUV2RGBA_UYVY, CONST COLOR_YUV2BGRA_UYNV=COLOR_YUV2BGRA_UYVY, CONST COLOR_YUV2RGB_YUY2=115, CONST COLOR_YUV2BGR_YUY2=116, CONST COLOR_YUV2RGB_YVYU=117, CONST COLOR_YUV2BGR_YVYU=118, CONST COLOR_YUV2RGB_YUYV=COLOR_YUV2RGB_YUY2, CONST COLOR_YUV2BGR_YUYV=COLOR_YUV2BGR_YUY2, CONST COLOR_YUV2RGB_YUNV=COLOR_YUV2RGB_YUY2, CONST COLOR_YUV2BGR_YUNV=COLOR_YUV2BGR_YUY2, CONST COLOR_YUV2RGBA_YUY2=119, CONST COLOR_YUV2BGRA_YUY2=120, CONST COLOR_YUV2RGBA_YVYU=121, CONST COLOR_YUV2BGRA_YVYU=122, CONST COLOR_YUV2RGBA_YUYV=COLOR_YUV2RGBA_YUY2, CONST COLOR_YUV2BGRA_YUYV=COLOR_YUV2BGRA_YUY2, CONST COLOR_YUV2RGBA_YUNV=COLOR_YUV2RGBA_YUY2, CONST COLOR_YUV2BGRA_YUNV=COLOR_YUV2BGRA_YUY2, CONST COLOR_YUV2GRAY_UYVY=123, CONST COLOR_YUV2GRAY_YUY2=124, CONST COLOR_YUV2GRAY_Y422=COLOR_YUV2GRAY_UYVY, CONST COLOR_YUV2GRAY_UYNV=COLOR_YUV2GRAY_UYVY, CONST COLOR_YUV2GRAY_YVYU=COLOR_YUV2GRAY_YUY2, CONST COLOR_YUV2GRAY_YUYV=COLOR_YUV2GRAY_YUY2, CONST COLOR_YUV2GRAY_YUNV=COLOR_YUV2GRAY_YUY2, CONST COLOR_RGBA2mRGBA=125, CONST COLOR_mRGBA2RGBA=126, CONST COLOR_RGB2YUV_I420=127, CONST COLOR_BGR2YUV_I420=128, CONST COLOR_RGB2YUV_IYUV=COLOR_RGB2YUV_I420, CONST COLOR_BGR2YUV_IYUV=COLOR_BGR2YUV_I420, CONST COLOR_RGBA2YUV_I420=129, CONST COLOR_BGRA2YUV_I420=130, CONST COLOR_RGBA2YUV_IYUV=COLOR_RGBA2YUV_I420, CONST COLOR_BGRA2YUV_IYUV=COLOR_BGRA2YUV_I420, CONST COLOR_RGB2YUV_YV12=131, CONST COLOR_BGR2YUV_YV12=132, CONST COLOR_RGBA2YUV_YV12=133, CONST COLOR_BGRA2YUV_YV12=134, CONST COLOR_BayerBG2BGR=46, CONST COLOR_BayerGB2BGR=47, CONST COLOR_BayerRG2BGR=48, CONST COLOR_BayerGR2BGR=49, CONST COLOR_BayerBG2RGB=COLOR_BayerRG2BGR, CONST COLOR_BayerGB2RGB=COLOR_BayerGR2BGR, CONST COLOR_BayerRG2RGB=COLOR_BayerBG2BGR, CONST COLOR_BayerGR2RGB=COLOR_BayerGB2BGR, CONST COLOR_BayerBG2GRAY=86, CONST COLOR_BayerGB2GRAY=87, CONST COLOR_BayerRG2GRAY=88, CONST COLOR_BayerGR2GRAY=89, CONST COLOR_BayerBG2BGR_VNG=62, CONST COLOR_BayerGB2BGR_VNG=63, CONST COLOR_BayerRG2BGR_VNG=64, CONST COLOR_BayerGR2BGR_VNG=65, CONST COLOR_BayerBG2RGB_VNG=COLOR_BayerRG2BGR_VNG, CONST COLOR_BayerGB2RGB_VNG=COLOR_BayerGR2BGR_VNG, CONST COLOR_BayerRG2RGB_VNG=COLOR_BayerBG2BGR_VNG, CONST COLOR_BayerGR2RGB_VNG=COLOR_BayerGB2BGR_VNG, CONST COLOR_BayerBG2BGR_EA=135, CONST COLOR_BayerGB2BGR_EA=136, CONST COLOR_BayerRG2BGR_EA=137, CONST COLOR_BayerGR2BGR_EA=138, CONST COLOR_BayerBG2RGB_EA=COLOR_BayerRG2BGR_EA, CONST COLOR_BayerGB2RGB_EA=COLOR_BayerGR2BGR_EA, CONST COLOR_BayerRG2RGB_EA=COLOR_BayerBG2BGR_EA, CONST COLOR_BayerGR2RGB_EA=COLOR_BayerGB2BGR_EA, CONST COLOR_BayerBG2BGRA=139, CONST COLOR_BayerGB2BGRA=140, CONST COLOR_BayerRG2BGRA=141, CONST COLOR_BayerGR2BGRA=142, CONST COLOR_BayerBG2RGBA=COLOR_BayerRG2BGRA, CONST COLOR_BayerGB2RGBA=COLOR_BayerGR2BGRA, CONST COLOR_BayerRG2RGBA=COLOR_BayerBG2BGRA, CONST COLOR_BayerGR2RGBA=COLOR_BayerGB2BGRA, CONST COLOR_COLORCVT_MAX=143]
[CONST LSD_REFINE_NONE=0, CONST LSD_REFINE_STD=1, CONST LSD_REFINE_ADV=2]
[CONST THRESH_BINARY=0, CONST THRESH_BINARY_INV=1, CONST THRESH_TRUNC=2, CONST THRESH_TOZERO=3, CONST THRESH_TOZERO_INV=4, CONST THRESH_MASK=7, CONST THRESH_OTSU=8, CONST THRESH_TRIANGLE=16]
[CONST ADAPTIVE_THRESH_MEAN_C=0, CONST ADAPTIVE_THRESH_GAUSSIAN_C=1]
[CONST CV_SHAPE_RECT=0, CONST CV_SHAPE_CROSS=1, CONST CV_SHAPE_ELLIPSE=2, CONST CV_SHAPE_CUSTOM=100]
[CONST CV_GAUSSIAN_5x5=7, CONST CV_SCHARR=-1, CONST CV_MAX_SOBEL_KSIZE=7, CONST CV_RGBA2mRGBA=125, CONST CV_mRGBA2RGBA=126, CONST CV_WARP_FILL_OUTLIERS=8, CONST CV_WARP_INVERSE_MAP=16, CONST CV_CHAIN_CODE=0, CONST CV_LINK_RUNS=5, CONST CV_POLY_APPROX_DP=0, CONST CV_CONTOURS_MATCH_I1=1, CONST CV_CONTOURS_MATCH_I2=2, CONST CV_CONTOURS_MATCH_I3=3, CONST CV_CLOCKWISE=1, CONST CV_COUNTER_CLOCKWISE=2, CONST CV_COMP_CORREL=0, CONST CV_COMP_CHISQR=1, CONST CV_COMP_INTERSECT=2, CONST CV_COMP_BHATTACHARYYA=3, CONST CV_COMP_HELLINGER=CV_COMP_BHATTACHARYYA, CONST CV_COMP_CHISQR_ALT=4, CONST CV_COMP_KL_DIV=5, CONST CV_DIST_MASK_3=3, CONST CV_DIST_MASK_5=5, CONST CV_DIST_MASK_PRECISE=0, CONST CV_DIST_LABEL_CCOMP=0, CONST CV_DIST_LABEL_PIXEL=1, CONST CV_DIST_USER=-1, CONST CV_DIST_L1=1, CONST CV_DIST_L2=2, CONST CV_DIST_C=3, CONST CV_DIST_L12=4, CONST CV_DIST_FAIR=5, CONST CV_DIST_WELSCH=6, CONST CV_DIST_HUBER=7, CONST CV_CANNY_L2_GRADIENT=(1 << 31), CONST CV_HOUGH_STANDARD=0, CONST CV_HOUGH_PROBABILISTIC=1, CONST CV_HOUGH_MULTI_SCALE=2, CONST CV_HOUGH_GRADIENT=3]
[CONST GC_INIT_WITH_RECT=0, CONST GC_INIT_WITH_MASK=1, CONST GC_EVAL=2, CONST GC_EVAL_FREEZE_MODEL=3]
[CONST MORPH_RECT=0, CONST MORPH_CROSS=1, CONST MORPH_ELLIPSE=2]
[CONST DIST_LABEL_CCOMP=0, CONST DIST_LABEL_PIXEL=1]
[CONST DIST_USER=-1, CONST DIST_L1=1, CONST DIST_L2=2, CONST DIST_C=3, CONST DIST_L12=4, CONST DIST_FAIR=5, CONST DIST_WELSCH=6, CONST DIST_HUBER=7]
[CONST TM_SQDIFF=0, CONST TM_SQDIFF_NORMED=1, CONST TM_CCORR=2, CONST TM_CCORR_NORMED=3, CONST TM_CCOEFF=4, CONST TM_CCOEFF_NORMED=5]
[CONST DIST_MASK_3=3, CONST DIST_MASK_5=5, CONST DIST_MASK_PRECISE=0]
[CONST CC_STAT_LEFT=0, CONST CC_STAT_TOP=1, CONST CC_STAT_WIDTH=2, CONST CC_STAT_HEIGHT=3, CONST CC_STAT_AREA=4, CONST CC_STAT_MAX=5]
[CONST CV_BLUR_NO_SCALE=0, CONST CV_BLUR=1, CONST CV_GAUSSIAN=2, CONST CV_MEDIAN=3, CONST CV_BILATERAL=4]
[CONST MARKER_CROSS=0, CONST MARKER_TILTED_CROSS=1, CONST MARKER_STAR=2, CONST MARKER_DIAMOND=3, CONST MARKER_SQUARE=4, CONST MARKER_TRIANGLE_UP=5, CONST MARKER_TRIANGLE_DOWN=6]
FUNC <Mat cv..getAffineTransform [ARG vector_Point2f src=, ARG vector_Point2f dst=]>
java: Mat getAffineTransform(MatOfPoint2f src, MatOfPoint2f dst)
FUNC <Mat cv..getGaborKernel [ARG Size ksize=, ARG double sigma=, ARG double theta=, ARG double lambd=, ARG double gamma=, ARG double psi=CV_PI*0.5, ARG int ktype=CV_64F]>
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi, int ktype)
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi)
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma)
FUNC <Mat cv..getGaussianKernel [ARG int ksize=, ARG double sigma=, ARG int ktype=CV_64F]>
java: Mat getGaussianKernel(int ksize, double sigma, int ktype)
java: Mat getGaussianKernel(int ksize, double sigma)
FUNC <Mat cv..getPerspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG int solveMethod=DECOMP_LU]>
java: Mat getPerspectiveTransform(Mat src, Mat dst, int solveMethod)
java: Mat getPerspectiveTransform(Mat src, Mat dst)
FUNC <Mat cv..getRotationMatrix2D [ARG Point2f center=, ARG double angle=, ARG double scale=]>
java: Mat getRotationMatrix2D(Point center, double angle, double scale)
FUNC <Mat cv..getStructuringElement [ARG int shape=, ARG Size ksize=, ARG Point anchor=Point(-1,-1)]>
java: Mat getStructuringElement(int shape, Size ksize, Point anchor)
java: Mat getStructuringElement(int shape, Size ksize)
FUNC <Moments cv..moments [ARG Mat array=, ARG bool binaryImage=false]>
java: Moments moments(Mat array, boolean binaryImage)
java: Moments moments(Mat array)
FUNC <Point2d cv..phaseCorrelate [ARG Mat src1=, ARG Mat src2=, ARG Mat window=Mat(), ARG double * response=0]>
java: Point phaseCorrelate(Mat src1, Mat src2, Mat window, double[] response)
java: Point phaseCorrelate(Mat src1, Mat src2, Mat window)
java: Point phaseCorrelate(Mat src1, Mat src2)
FUNC <Ptr_CLAHE cv..createCLAHE [ARG double clipLimit=40.0, ARG Size tileGridSize=Size(8, 8)]>
java: CLAHE createCLAHE(double clipLimit, Size tileGridSize)
java: CLAHE createCLAHE(double clipLimit)
java: CLAHE createCLAHE()
FUNC <Ptr_GeneralizedHoughBallard cv..createGeneralizedHoughBallard []>
java: GeneralizedHoughBallard createGeneralizedHoughBallard()
FUNC <Ptr_GeneralizedHoughGuil cv..createGeneralizedHoughGuil []>
java: GeneralizedHoughGuil createGeneralizedHoughGuil()
FUNC <Ptr_LineSegmentDetector cv..createLineSegmentDetector [ARG int _refine=LSD_REFINE_STD, ARG double _scale=0.8, ARG double _sigma_scale=0.6, ARG double _quant=2.0, ARG double _ang_th=22.5, ARG double _log_eps=0, ARG double _density_th=0.7, ARG int _n_bins=1024]>
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps, double _density_th, int _n_bins)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps, double _density_th)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale)
java: LineSegmentDetector createLineSegmentDetector(int _refine)
java: LineSegmentDetector createLineSegmentDetector()
FUNC <Rect cv..boundingRect [ARG Mat array=]>
java: Rect boundingRect(Mat array)
FUNC <RotatedRect cv..fitEllipse [ARG vector_Point2f points=]>
java: RotatedRect fitEllipse(MatOfPoint2f points)
FUNC <RotatedRect cv..fitEllipseAMS [ARG Mat points=]>
java: RotatedRect fitEllipseAMS(Mat points)
FUNC <RotatedRect cv..fitEllipseDirect [ARG Mat points=]>
java: RotatedRect fitEllipseDirect(Mat points)
FUNC <RotatedRect cv..minAreaRect [ARG vector_Point2f points=]>
java: RotatedRect minAreaRect(MatOfPoint2f points)
FUNC <bool cv..clipLine [ARG Rect imgRect=, ARG Point pt1=, ARG Point pt2=]>
java: boolean clipLine(Rect imgRect, Point pt1, Point pt2)
FUNC <bool cv..isContourConvex [ARG vector_Point contour=]>
java: boolean isContourConvex(MatOfPoint contour)
FUNC <double cv..arcLength [ARG vector_Point2f curve=, ARG bool closed=]>
java: double arcLength(MatOfPoint2f curve, boolean closed)
FUNC <double cv..compareHist [ARG Mat H1=, ARG Mat H2=, ARG int method=]>
java: double compareHist(Mat H1, Mat H2, int method)
FUNC <double cv..contourArea [ARG Mat contour=, ARG bool oriented=false]>
java: double contourArea(Mat contour, boolean oriented)
java: double contourArea(Mat contour)
FUNC <double cv..getFontScaleFromHeight [ARG int fontFace=, ARG int pixelHeight=, ARG int thickness=1]>
java: double getFontScaleFromHeight(int fontFace, int pixelHeight, int thickness)
java: double getFontScaleFromHeight(int fontFace, int pixelHeight)
FUNC <double cv..matchShapes [ARG Mat contour1=, ARG Mat contour2=, ARG int method=, ARG double parameter=]>
java: double matchShapes(Mat contour1, Mat contour2, int method, double parameter)
FUNC <double cv..minEnclosingTriangle [ARG Mat points=, ARG Mat triangle=]>
java: double minEnclosingTriangle(Mat points, Mat triangle)
FUNC <double cv..pointPolygonTest [ARG vector_Point2f contour=, ARG Point2f pt=, ARG bool measureDist=]>
java: double pointPolygonTest(MatOfPoint2f contour, Point pt, boolean measureDist)
FUNC <double cv..threshold [ARG Mat src=, ARG Mat dst=, ARG double thresh=, ARG double maxval=, ARG int type=]>
java: double threshold(Mat src, Mat dst, double thresh, double maxval, int type)
FUNC <float cv..intersectConvexConvex [ARG Mat _p1=, ARG Mat _p2=, ARG Mat _p12=, ARG bool handleNested=true]>
java: float intersectConvexConvex(Mat _p1, Mat _p2, Mat _p12, boolean handleNested)
java: float intersectConvexConvex(Mat _p1, Mat _p2, Mat _p12)
FUNC <float cv..wrapperEMD [ARG Mat signature1=, ARG Mat signature2=, ARG int distType=, ARG Mat cost=Mat(), ARG Ptr_float lowerBound=Ptr<float>(), ARG Mat flow=Mat()]>
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost, Mat flow)
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost)
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost)
java: float EMD(Mat signature1, Mat signature2, int distType)
FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>
java: int connectedComponentsWithAlgorithm(Mat image, Mat labels, int connectivity, int ltype, int ccltype)
FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=8, ARG int ltype=CV_32S]>
java: int connectedComponents(Mat image, Mat labels, int connectivity, int ltype)
java: int connectedComponents(Mat image, Mat labels, int connectivity)
java: int connectedComponents(Mat image, Mat labels)
FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>
java: int connectedComponentsWithStatsWithAlgorithm(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity, int ltype, int ccltype)
FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=8, ARG int ltype=CV_32S]>
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity, int ltype)
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity)
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids)
FUNC <int cv..floodFill [ARG Mat image=, ARG Mat mask=, ARG Point seedPoint=, ARG Scalar newVal=, ARG Rect * rect=0, ARG Scalar loDiff=Scalar(), ARG Scalar upDiff=Scalar(), ARG int flags=4]>
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff, Scalar upDiff, int flags)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff, Scalar upDiff)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal)
FUNC <int cv..rotatedRectangleIntersection [ARG RotatedRect rect1=, ARG RotatedRect rect2=, ARG Mat intersectingRegion=]>
java: int rotatedRectangleIntersection(RotatedRect rect1, RotatedRect rect2, Mat intersectingRegion)
FUNC <void cv..Canny [ARG Mat dx=, ARG Mat dy=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG bool L2gradient=false]>
java: void Canny(Mat dx, Mat dy, Mat edges, double threshold1, double threshold2, boolean L2gradient)
java: void Canny(Mat dx, Mat dy, Mat edges, double threshold1, double threshold2)
FUNC <void cv..Canny [ARG Mat image=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2, int apertureSize, boolean L2gradient)
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2, int apertureSize)
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2)
FUNC <void cv..GaussianBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG double sigmaX=, ARG double sigmaY=0, ARG int borderType=BORDER_DEFAULT]>
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX, double sigmaY, int borderType)
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX, double sigmaY)
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX)
FUNC <void cv..HoughCircles [ARG Mat image=, ARG Mat circles=, ARG int method=, ARG double dp=, ARG double minDist=, ARG double param1=100, ARG double param2=100, ARG int minRadius=0, ARG int maxRadius=0]>
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2, int minRadius, int maxRadius)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2, int minRadius)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist)
FUNC <void cv..HoughLines [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta, double max_theta)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold)
FUNC <void cv..HoughLinesP [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double minLineLength=0, ARG double maxLineGap=0]>
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold, double minLineLength, double maxLineGap)
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold, double minLineLength)
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold)
FUNC <void cv..HoughLinesPointSet [ARG Mat _point=, ARG Mat _lines=, ARG int lines_max=, ARG int threshold=, ARG double min_rho=, ARG double max_rho=, ARG double rho_step=, ARG double min_theta=, ARG double max_theta=, ARG double theta_step=]>
java: void HoughLinesPointSet(Mat _point, Mat _lines, int lines_max, int threshold, double min_rho, double max_rho, double rho_step, double min_theta, double max_theta, double theta_step)
FUNC <void cv..HuMoments [ARG Moments m=, ARG Mat hu=]>
java: void HuMoments(Moments m, Mat hu)
FUNC <void cv..Laplacian [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int ksize=1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale, double delta, int borderType)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale, double delta)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize)
java: void Laplacian(Mat src, Mat dst, int ddepth)
FUNC <void cv..Scharr [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale, double delta)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy)
FUNC <void cv..Sobel [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG int ksize=3, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy)
FUNC <void cv..accumulate [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulate(Mat src, Mat dst, Mat mask)
java: void accumulate(Mat src, Mat dst)
FUNC <void cv..accumulateProduct [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulateProduct(Mat src1, Mat src2, Mat dst, Mat mask)
java: void accumulateProduct(Mat src1, Mat src2, Mat dst)
FUNC <void cv..accumulateSquare [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulateSquare(Mat src, Mat dst, Mat mask)
java: void accumulateSquare(Mat src, Mat dst)
FUNC <void cv..accumulateWeighted [ARG Mat src=, ARG Mat dst=, ARG double alpha=, ARG Mat mask=Mat()]>
java: void accumulateWeighted(Mat src, Mat dst, double alpha, Mat mask)
java: void accumulateWeighted(Mat src, Mat dst, double alpha)
FUNC <void cv..adaptiveThreshold [ARG Mat src=, ARG Mat dst=, ARG double maxValue=, ARG int adaptiveMethod=, ARG int thresholdType=, ARG int blockSize=, ARG double C=]>
java: void adaptiveThreshold(Mat src, Mat dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)
FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG Mat userColor=]>
java: void applyColorMap(Mat src, Mat dst, Mat userColor)
FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG int colormap=]>
java: void applyColorMap(Mat src, Mat dst, int colormap)
FUNC <void cv..approxPolyDP [ARG vector_Point2f curve=, ARG vector_Point2f approxCurve=, ARG double epsilon=, ARG bool closed=]>
java: void approxPolyDP(MatOfPoint2f curve, MatOfPoint2f approxCurve, double epsilon, boolean closed)
FUNC <void cv..arrowedLine [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int line_type=8, ARG int shift=0, ARG double tipLength=0.1]>
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type, int shift, double tipLength)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type, int shift)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..bilateralFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>
java: void bilateralFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int borderType)
java: void bilateralFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace)
FUNC <void cv..blur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG int borderType=BORDER_DEFAULT]>
java: void blur(Mat src, Mat dst, Size ksize, Point anchor, int borderType)
java: void blur(Mat src, Mat dst, Size ksize, Point anchor)
java: void blur(Mat src, Mat dst, Size ksize)
FUNC <void cv..boxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize, int borderType)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize)
FUNC <void cv..boxPoints [ARG RotatedRect box=, ARG Mat points=]>
java: void boxPoints(RotatedRect box, Mat points)
FUNC <void cv..calcBackProject [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat hist=, ARG Mat dst=, ARG vector_float ranges=, ARG double scale=]>
java: void calcBackProject(List<Mat> images, MatOfInt channels, Mat hist, Mat dst, MatOfFloat ranges, double scale)
FUNC <void cv..calcHist [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat mask=, ARG Mat hist=, ARG vector_int histSize=, ARG vector_float ranges=, ARG bool accumulate=false]>
java: void calcHist(List<Mat> images, MatOfInt channels, Mat mask, Mat hist, MatOfInt histSize, MatOfFloat ranges, boolean accumulate)
java: void calcHist(List<Mat> images, MatOfInt channels, Mat mask, Mat hist, MatOfInt histSize, MatOfFloat ranges)
FUNC <void cv..circle [ARG Mat img=, ARG Point center=, ARG int radius=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness, int lineType, int shift)
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness, int lineType)
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness)
java: void circle(Mat img, Point center, int radius, Scalar color)
FUNC <void cv..convertMaps [ARG Mat map1=, ARG Mat map2=, ARG Mat dstmap1=, ARG Mat dstmap2=, ARG int dstmap1type=, ARG bool nninterpolation=false]>
java: void convertMaps(Mat map1, Mat map2, Mat dstmap1, Mat dstmap2, int dstmap1type, boolean nninterpolation)
java: void convertMaps(Mat map1, Mat map2, Mat dstmap1, Mat dstmap2, int dstmap1type)
FUNC <void cv..convexHull [ARG vector_Point points=, ARG vector_int hull=, ARG bool clockwise=false, ARG  returnPoints=true]>
java: void convexHull(MatOfPoint points, MatOfInt hull, boolean clockwise)
java: void convexHull(MatOfPoint points, MatOfInt hull, boolean clockwise)
java: void convexHull(MatOfPoint points, MatOfInt hull)
FUNC <void cv..convexityDefects [ARG vector_Point contour=, ARG vector_int convexhull=, ARG vector_Vec4i convexityDefects=]>
java: void convexityDefects(MatOfPoint contour, MatOfInt convexhull, MatOfInt4 convexityDefects)
FUNC <void cv..cornerEigenValsAndVecs [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>
java: void cornerEigenValsAndVecs(Mat src, Mat dst, int blockSize, int ksize, int borderType)
java: void cornerEigenValsAndVecs(Mat src, Mat dst, int blockSize, int ksize)
FUNC <void cv..cornerHarris [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG double k=, ARG int borderType=BORDER_DEFAULT]>
java: void cornerHarris(Mat src, Mat dst, int blockSize, int ksize, double k, int borderType)
java: void cornerHarris(Mat src, Mat dst, int blockSize, int ksize, double k)
FUNC <void cv..cornerMinEigenVal [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize, int ksize, int borderType)
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize, int ksize)
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize)
FUNC <void cv..cornerSubPix [ARG Mat image=, ARG Mat corners=, ARG Size winSize=, ARG Size zeroZone=, ARG TermCriteria criteria=]>
java: void cornerSubPix(Mat image, Mat corners, Size winSize, Size zeroZone, TermCriteria criteria)
FUNC <void cv..createHanningWindow [ARG Mat dst=, ARG Size winSize=, ARG int type=]>
java: void createHanningWindow(Mat dst, Size winSize, int type)
FUNC <void cv..cvtColor [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>
java: void cvtColor(Mat src, Mat dst, int code, int dstCn)
java: void cvtColor(Mat src, Mat dst, int code)
FUNC <void cv..cvtColorTwoPlane [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int code=]>
java: void cvtColorTwoPlane(Mat src1, Mat src2, Mat dst, int code)
FUNC <void cv..demosaicing [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>
java: void demosaicing(Mat src, Mat dst, int code, int dstCn)
java: void demosaicing(Mat src, Mat dst, int code)
FUNC <void cv..dilate [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor)
java: void dilate(Mat src, Mat dst, Mat kernel)
FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG Mat labels=, ARG int distanceType=, ARG int maskSize=, ARG int labelType=DIST_LABEL_CCOMP]>
java: void distanceTransformWithLabels(Mat src, Mat dst, Mat labels, int distanceType, int maskSize, int labelType)
java: void distanceTransformWithLabels(Mat src, Mat dst, Mat labels, int distanceType, int maskSize)
FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG int distanceType=, ARG int maskSize=, ARG int dstType=CV_32F]>
java: void distanceTransform(Mat src, Mat dst, int distanceType, int maskSize, int dstType)
java: void distanceTransform(Mat src, Mat dst, int distanceType, int maskSize)
FUNC <void cv..drawContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG int contourIdx=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG Mat hierarchy=Mat(), ARG int maxLevel=INT_MAX, ARG Point offset=Point()]>
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy, int maxLevel, Point offset)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy, int maxLevel)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color)
FUNC <void cv..drawMarker [ARG Mat img=, ARG Point position=, ARG Scalar color=, ARG int markerType=MARKER_CROSS, ARG int markerSize=20, ARG int thickness=1, ARG int line_type=8]>
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize, int thickness, int line_type)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize, int thickness)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType)
java: void drawMarker(Mat img, Point position, Scalar color)
FUNC <void cv..ellipse [ARG Mat img=, ARG Point center=, ARG Size axes=, ARG double angle=, ARG double startAngle=, ARG double endAngle=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness, int lineType, int shift)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness, int lineType)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color)
FUNC <void cv..ellipse [ARG Mat img=, ARG RotatedRect box=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8]>
java: void ellipse(Mat img, RotatedRect box, Scalar color, int thickness, int lineType)
java: void ellipse(Mat img, RotatedRect box, Scalar color, int thickness)
java: void ellipse(Mat img, RotatedRect box, Scalar color)
FUNC <void cv..ellipse2Poly [ARG Point center=, ARG Size axes=, ARG int angle=, ARG int arcStart=, ARG int arcEnd=, ARG int delta=, ARG vector_Point pts=]>
java: void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, MatOfPoint pts)
FUNC <void cv..equalizeHist [ARG Mat src=, ARG Mat dst=]>
java: void equalizeHist(Mat src, Mat dst)
FUNC <void cv..erode [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor)
java: void erode(Mat src, Mat dst, Mat kernel)
FUNC <void cv..fillConvexPoly [ARG Mat img=, ARG vector_Point points=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0]>
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color, int lineType, int shift)
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color, int lineType)
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color)
FUNC <void cv..fillPoly [ARG Mat img=, ARG vector_vector_Point pts=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0, ARG Point offset=Point()]>
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType, int shift, Point offset)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType, int shift)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color)
FUNC <void cv..filter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor, double delta, int borderType)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor, double delta)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel)
FUNC <void cv..findContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG Mat hierarchy=, ARG int mode=, ARG int method=, ARG Point offset=Point()]>
java: void findContours(Mat image, List<MatOfPoint> contours, Mat hierarchy, int mode, int method, Point offset)
java: void findContours(Mat image, List<MatOfPoint> contours, Mat hierarchy, int mode, int method)
FUNC <void cv..fitLine [ARG Mat points=, ARG Mat line=, ARG int distType=, ARG double param=, ARG double reps=, ARG double aeps=]>
java: void fitLine(Mat points, Mat line, int distType, double param, double reps, double aeps)
FUNC <void cv..getDerivKernels [ARG Mat kx=, ARG Mat ky=, ARG int dx=, ARG int dy=, ARG int ksize=, ARG bool normalize=false, ARG int ktype=CV_32F]>
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize, boolean normalize, int ktype)
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize, boolean normalize)
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize)
FUNC <void cv..getRectSubPix [ARG Mat image=, ARG Size patchSize=, ARG Point2f center=, ARG Mat patch=, ARG int patchType=-1]>
java: void getRectSubPix(Mat image, Size patchSize, Point center, Mat patch, int patchType)
java: void getRectSubPix(Mat image, Size patchSize, Point center, Mat patch)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG int blockSize=, ARG int gradientSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize, boolean useHarrisDetector)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=Mat(), ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, boolean useHarrisDetector)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance)
FUNC <void cv..grabCut [ARG Mat img=, ARG Mat mask=, ARG Rect rect=, ARG Mat bgdModel=, ARG Mat fgdModel=, ARG int iterCount=, ARG int mode=GC_EVAL]>
java: void grabCut(Mat img, Mat mask, Rect rect, Mat bgdModel, Mat fgdModel, int iterCount, int mode)
java: void grabCut(Mat img, Mat mask, Rect rect, Mat bgdModel, Mat fgdModel, int iterCount)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG Mat tilted=, ARG int sdepth=-1, ARG int sqdepth=-1]>
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted, int sdepth, int sqdepth)
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted, int sdepth)
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG int sdepth=-1, ARG int sqdepth=-1]>
java: void integral2(Mat src, Mat sum, Mat sqsum, int sdepth, int sqdepth)
java: void integral2(Mat src, Mat sum, Mat sqsum, int sdepth)
java: void integral2(Mat src, Mat sum, Mat sqsum)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG int sdepth=-1]>
java: void integral(Mat src, Mat sum, int sdepth)
java: void integral(Mat src, Mat sum)
FUNC <void cv..invertAffineTransform [ARG Mat M=, ARG Mat iM=]>
java: void invertAffineTransform(Mat M, Mat iM)
FUNC <void cv..line [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType, int shift)
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType)
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void line(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..linearPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>
java: void linearPolar(Mat src, Mat dst, Point center, double maxRadius, int flags)
FUNC <void cv..logPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double M=, ARG int flags=]>
java: void logPolar(Mat src, Mat dst, Point center, double M, int flags)
FUNC <void cv..matchTemplate [ARG Mat image=, ARG Mat templ=, ARG Mat result=, ARG int method=, ARG Mat mask=Mat()]>
java: void matchTemplate(Mat image, Mat templ, Mat result, int method, Mat mask)
java: void matchTemplate(Mat image, Mat templ, Mat result, int method)
FUNC <void cv..medianBlur [ARG Mat src=, ARG Mat dst=, ARG int ksize=]>
java: void medianBlur(Mat src, Mat dst, int ksize)
FUNC <void cv..minEnclosingCircle [ARG vector_Point2f points=, ARG Point2f center=, ARG float radius=]>
java: void minEnclosingCircle(MatOfPoint2f points, Point center, float[] radius)
FUNC <void cv..morphologyEx [ARG Mat src=, ARG Mat dst=, ARG int op=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations, int borderType)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel)
FUNC <void cv..polylines [ARG Mat img=, ARG vector_vector_Point pts=, ARG bool isClosed=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness, int lineType, int shift)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness, int lineType)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color)
FUNC <void cv..preCornerDetect [ARG Mat src=, ARG Mat dst=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>
java: void preCornerDetect(Mat src, Mat dst, int ksize, int borderType)
java: void preCornerDetect(Mat src, Mat dst, int ksize)
FUNC <void cv..putText [ARG Mat img=, ARG String text=, ARG Point org=, ARG int fontFace=, ARG double fontScale=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG bool bottomLeftOrigin=false]>
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, boolean bottomLeftOrigin)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color)
FUNC <void cv..pyrDown [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>
java: void pyrDown(Mat src, Mat dst, Size dstsize, int borderType)
java: void pyrDown(Mat src, Mat dst, Size dstsize)
java: void pyrDown(Mat src, Mat dst)
FUNC <void cv..pyrMeanShiftFiltering [ARG Mat src=, ARG Mat dst=, ARG double sp=, ARG double sr=, ARG int maxLevel=1, ARG TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)]>
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr, int maxLevel, TermCriteria termcrit)
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr, int maxLevel)
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr)
FUNC <void cv..pyrUp [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>
java: void pyrUp(Mat src, Mat dst, Size dstsize, int borderType)
java: void pyrUp(Mat src, Mat dst, Size dstsize)
java: void pyrUp(Mat src, Mat dst)
FUNC <void cv..rectangle [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType, int shift)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..rectangle [ARG Mat img=, ARG Rect rec=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness, int lineType, int shift)
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness, int lineType)
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness)
java: void rectangle(Mat img, Rect rec, Scalar color)
FUNC <void cv..remap [ARG Mat src=, ARG Mat dst=, ARG Mat map1=, ARG Mat map2=, ARG int interpolation=, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation, int borderMode, Scalar borderValue)
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation, int borderMode)
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation)
FUNC <void cv..resize [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG double fx=0, ARG double fy=0, ARG int interpolation=INTER_LINEAR]>
java: void resize(Mat src, Mat dst, Size dsize, double fx, double fy, int interpolation)
java: void resize(Mat src, Mat dst, Size dsize, double fx, double fy)
java: void resize(Mat src, Mat dst, Size dsize, double fx)
java: void resize(Mat src, Mat dst, Size dsize)
FUNC <void cv..sepFilter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernelX=, ARG Mat kernelY=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor, double delta, int borderType)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor, double delta)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY)
FUNC <void cv..spatialGradient [ARG Mat src=, ARG Mat dx=, ARG Mat dy=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>
java: void spatialGradient(Mat src, Mat dx, Mat dy, int ksize, int borderType)
java: void spatialGradient(Mat src, Mat dx, Mat dy, int ksize)
java: void spatialGradient(Mat src, Mat dx, Mat dy)
FUNC <void cv..sqrBoxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1, -1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize, int borderType)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize)
FUNC <void cv..warpAffine [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode, Scalar borderValue)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize)
FUNC <void cv..warpPerspective [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode, Scalar borderValue)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize)
FUNC <void cv..warpPolar [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>
java: void warpPolar(Mat src, Mat dst, Size dsize, Point center, double maxRadius, int flags)
FUNC <void cv..watershed [ARG Mat image=, ARG Mat markers=]>
java: void watershed(Mat image, Mat markers)
CLASS cv::.CLAHE : Algorithm
FUNC <Size cv.CLAHE.getTilesGridSize []>
java: Size getTilesGridSize()
FUNC <double cv.CLAHE.getClipLimit []>
java: double getClipLimit()
FUNC <void cv.CLAHE.apply [ARG Mat src=, ARG Mat dst=]>
java: void apply(Mat src, Mat dst)
FUNC <void cv.CLAHE.collectGarbage []>
java: void collectGarbage()
FUNC <void cv.CLAHE.setClipLimit [ARG double clipLimit=]>
java: void setClipLimit(double clipLimit)
FUNC <void cv.CLAHE.setTilesGridSize [ARG Size tileGridSize=]>
java: void setTilesGridSize(Size tileGridSize)
CLASS cv::.Subdiv2D : 
[CONST PTLOC_ERROR=-2, CONST PTLOC_OUTSIDE_RECT=-1, CONST PTLOC_INSIDE=0, CONST PTLOC_VERTEX=1, CONST PTLOC_ON_EDGE=2, CONST NEXT_AROUND_ORG=0x00, CONST NEXT_AROUND_DST=0x22, CONST PREV_AROUND_ORG=0x11, CONST PREV_AROUND_DST=0x33, CONST NEXT_AROUND_LEFT=0x13, CONST NEXT_AROUND_RIGHT=0x31, CONST PREV_AROUND_LEFT=0x20, CONST PREV_AROUND_RIGHT=0x02]
FUNC < cv.Subdiv2D.Subdiv2D [ARG Rect rect=]>
java:  Subdiv2D(Rect rect)
FUNC < cv.Subdiv2D.Subdiv2D []>
java:  Subdiv2D()
FUNC <Point2f cv.Subdiv2D.getVertex [ARG int vertex=, ARG int * firstEdge=0]>
java: Point getVertex(int vertex, int[] firstEdge)
java: Point getVertex(int vertex)
FUNC <int cv.Subdiv2D.edgeDst [ARG int edge=, ARG Point2f * dstpt=0]>
java: int edgeDst(int edge, Point dstpt)
java: int edgeDst(int edge)
FUNC <int cv.Subdiv2D.edgeOrg [ARG int edge=, ARG Point2f * orgpt=0]>
java: int edgeOrg(int edge, Point orgpt)
java: int edgeOrg(int edge)
FUNC <int cv.Subdiv2D.findNearest [ARG Point2f pt=, ARG Point2f * nearestPt=0]>
java: int findNearest(Point pt, Point nearestPt)
java: int findNearest(Point pt)
FUNC <int cv.Subdiv2D.getEdge [ARG int edge=, ARG int nextEdgeType=]>
java: int getEdge(int edge, int nextEdgeType)
FUNC <int cv.Subdiv2D.insert [ARG Point2f pt=]>
java: int insert(Point pt)
FUNC <int cv.Subdiv2D.locate [ARG Point2f pt=, ARG int edge=, ARG int vertex=]>
java: int locate(Point pt, int[] edge, int[] vertex)
FUNC <int cv.Subdiv2D.nextEdge [ARG int edge=]>
java: int nextEdge(int edge)
FUNC <int cv.Subdiv2D.rotateEdge [ARG int edge=, ARG int rotate=]>
java: int rotateEdge(int edge, int rotate)
FUNC <int cv.Subdiv2D.symEdge [ARG int edge=]>
java: int symEdge(int edge)
FUNC <void cv.Subdiv2D.getEdgeList [ARG vector_Vec4f edgeList=]>
java: void getEdgeList(MatOfFloat4 edgeList)
FUNC <void cv.Subdiv2D.getLeadingEdgeList [ARG vector_int leadingEdgeList=]>
java: void getLeadingEdgeList(MatOfInt leadingEdgeList)
FUNC <void cv.Subdiv2D.getTriangleList [ARG vector_Vec6f triangleList=]>
java: void getTriangleList(MatOfFloat6 triangleList)
FUNC <void cv.Subdiv2D.getVoronoiFacetList [ARG vector_int idx=, ARG vector_vector_Point2f facetList=, ARG vector_Point2f facetCenters=]>
java: void getVoronoiFacetList(MatOfInt idx, List<MatOfPoint2f> facetList, MatOfPoint2f facetCenters)
FUNC <void cv.Subdiv2D.initDelaunay [ARG Rect rect=]>
java: void initDelaunay(Rect rect)
FUNC <void cv.Subdiv2D.insert [ARG vector_Point2f ptvec=]>
java: void insert(MatOfPoint2f ptvec)
CLASS cv::.GeneralizedHoughBallard : GeneralizedHough
FUNC <int cv.GeneralizedHoughBallard.getLevels []>
java: int getLevels()
FUNC <int cv.GeneralizedHoughBallard.getVotesThreshold []>
java: int getVotesThreshold()
FUNC <void cv.GeneralizedHoughBallard.setLevels [ARG int levels=]>
java: void setLevels(int levels)
FUNC <void cv.GeneralizedHoughBallard.setVotesThreshold [ARG int votesThreshold=]>
java: void setVotesThreshold(int votesThreshold)
CLASS cv::.GeneralizedHough : Algorithm
FUNC <double cv.GeneralizedHough.getDp []>
java: double getDp()
FUNC <double cv.GeneralizedHough.getMinDist []>
java: double getMinDist()
FUNC <int cv.GeneralizedHough.getCannyHighThresh []>
java: int getCannyHighThresh()
FUNC <int cv.GeneralizedHough.getCannyLowThresh []>
java: int getCannyLowThresh()
FUNC <int cv.GeneralizedHough.getMaxBufferSize []>
java: int getMaxBufferSize()
FUNC <void cv.GeneralizedHough.detect [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Mat positions=, ARG Mat votes=Mat()]>
java: void detect(Mat edges, Mat dx, Mat dy, Mat positions, Mat votes)
java: void detect(Mat edges, Mat dx, Mat dy, Mat positions)
FUNC <void cv.GeneralizedHough.detect [ARG Mat image=, ARG Mat positions=, ARG Mat votes=Mat()]>
java: void detect(Mat image, Mat positions, Mat votes)
java: void detect(Mat image, Mat positions)
FUNC <void cv.GeneralizedHough.setCannyHighThresh [ARG int cannyHighThresh=]>
java: void setCannyHighThresh(int cannyHighThresh)
FUNC <void cv.GeneralizedHough.setCannyLowThresh [ARG int cannyLowThresh=]>
java: void setCannyLowThresh(int cannyLowThresh)
FUNC <void cv.GeneralizedHough.setDp [ARG double dp=]>
java: void setDp(double dp)
FUNC <void cv.GeneralizedHough.setMaxBufferSize [ARG int maxBufferSize=]>
java: void setMaxBufferSize(int maxBufferSize)
FUNC <void cv.GeneralizedHough.setMinDist [ARG double minDist=]>
java: void setMinDist(double minDist)
FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Point templCenter=Point(-1, -1)]>
java: void setTemplate(Mat edges, Mat dx, Mat dy, Point templCenter)
java: void setTemplate(Mat edges, Mat dx, Mat dy)
FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat templ=, ARG Point templCenter=Point(-1, -1)]>
java: void setTemplate(Mat templ, Point templCenter)
java: void setTemplate(Mat templ)
CLASS cv::.GeneralizedHoughGuil : GeneralizedHough
FUNC <double cv.GeneralizedHoughGuil.getAngleEpsilon []>
java: double getAngleEpsilon()
FUNC <double cv.GeneralizedHoughGuil.getAngleStep []>
java: double getAngleStep()
FUNC <double cv.GeneralizedHoughGuil.getMaxAngle []>
java: double getMaxAngle()
FUNC <double cv.GeneralizedHoughGuil.getMaxScale []>
java: double getMaxScale()
FUNC <double cv.GeneralizedHoughGuil.getMinAngle []>
java: double getMinAngle()
FUNC <double cv.GeneralizedHoughGuil.getMinScale []>
java: double getMinScale()
FUNC <double cv.GeneralizedHoughGuil.getScaleStep []>
java: double getScaleStep()
FUNC <double cv.GeneralizedHoughGuil.getXi []>
java: double getXi()
FUNC <int cv.GeneralizedHoughGuil.getAngleThresh []>
java: int getAngleThresh()
FUNC <int cv.GeneralizedHoughGuil.getLevels []>
java: int getLevels()
FUNC <int cv.GeneralizedHoughGuil.getPosThresh []>
java: int getPosThresh()
FUNC <int cv.GeneralizedHoughGuil.getScaleThresh []>
java: int getScaleThresh()
FUNC <void cv.GeneralizedHoughGuil.setAngleEpsilon [ARG double angleEpsilon=]>
java: void setAngleEpsilon(double angleEpsilon)
FUNC <void cv.GeneralizedHoughGuil.setAngleStep [ARG double angleStep=]>
java: void setAngleStep(double angleStep)
FUNC <void cv.GeneralizedHoughGuil.setAngleThresh [ARG int angleThresh=]>
java: void setAngleThresh(int angleThresh)
FUNC <void cv.GeneralizedHoughGuil.setLevels [ARG int levels=]>
java: void setLevels(int levels)
FUNC <void cv.GeneralizedHoughGuil.setMaxAngle [ARG double maxAngle=]>
java: void setMaxAngle(double maxAngle)
FUNC <void cv.GeneralizedHoughGuil.setMaxScale [ARG double maxScale=]>
java: void setMaxScale(double maxScale)
FUNC <void cv.GeneralizedHoughGuil.setMinAngle [ARG double minAngle=]>
java: void setMinAngle(double minAngle)
FUNC <void cv.GeneralizedHoughGuil.setMinScale [ARG double minScale=]>
java: void setMinScale(double minScale)
FUNC <void cv.GeneralizedHoughGuil.setPosThresh [ARG int posThresh=]>
java: void setPosThresh(int posThresh)
FUNC <void cv.GeneralizedHoughGuil.setScaleStep [ARG double scaleStep=]>
java: void setScaleStep(double scaleStep)
FUNC <void cv.GeneralizedHoughGuil.setScaleThresh [ARG int scaleThresh=]>
java: void setScaleThresh(int scaleThresh)
FUNC <void cv.GeneralizedHoughGuil.setXi [ARG double xi=]>
java: void setXi(double xi)
CLASS cv::.LineSegmentDetector : Algorithm
FUNC <int cv.LineSegmentDetector.compareSegments [ARG Size size=, ARG Mat lines1=, ARG Mat lines2=, ARG Mat _image=Mat()]>
java: int compareSegments(Size size, Mat lines1, Mat lines2, Mat _image)
java: int compareSegments(Size size, Mat lines1, Mat lines2)
FUNC <void cv.LineSegmentDetector.detect [ARG Mat _image=, ARG Mat _lines=, ARG Mat width=Mat(), ARG Mat prec=Mat(), ARG Mat nfa=Mat()]>
java: void detect(Mat _image, Mat _lines, Mat width, Mat prec, Mat nfa)
java: void detect(Mat _image, Mat _lines, Mat width, Mat prec)
java: void detect(Mat _image, Mat _lines, Mat width)
java: void detect(Mat _image, Mat _lines)
FUNC <void cv.LineSegmentDetector.drawSegments [ARG Mat _image=, ARG Mat lines=]>
java: void drawSegments(Mat _image, Mat lines)

=== MODULE: ml (/home/borg/404/scripts_robotica/OpenCV/modules/ml) ===


Files (2):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/ml/include/opencv2/ml.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/ml/include/opencv2/ml/ml.hpp']

Common headers (0):
[]
ok: class CLASS ::.Ml : , name: Ml, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/ml/include/opencv2/ml.hpp =====
Namespaces: set([u'cv', u'cv.ml'])

--- Incoming ---
[   u'enum cv.ml.VariableTypes',
    '',
    [],
    [   [u'const cv.ml.VAR_NUMERICAL', u'0', [], [], None, ''],
        [u'const cv.ml.VAR_ORDERED', u'0', [], [], None, ''],
        [u'const cv.ml.VAR_CATEGORICAL', u'1', [], [], None, '']],
    None]
ok: CONST VAR_NUMERICAL=0
ok: CONST VAR_ORDERED=0
ok: CONST VAR_CATEGORICAL=1

--- Incoming ---
[   u'enum cv.ml.ErrorTypes',
    '',
    [],
    [   [u'const cv.ml.TEST_ERROR', u'0', [], [], None, ''],
        [u'const cv.ml.TRAIN_ERROR', u'1', [], [], None, '']],
    None]
ok: CONST TEST_ERROR=0
ok: CONST TRAIN_ERROR=1

--- Incoming ---
[   u'enum cv.ml.SampleTypes',
    '',
    [],
    [   [u'const cv.ml.ROW_SAMPLE', u'0', [], [], None, ''],
        [u'const cv.ml.COL_SAMPLE', u'1', [], [], None, '']],
    None]
ok: CONST ROW_SAMPLE=0
ok: CONST COL_SAMPLE=1

--- Incoming ---
[   u'class cv.ml.ParamGrid',
    '',
    [],
    [   [u'double', u'minVal', '', ['/RW']],
        [u'double', u'maxVal', '', ['/RW']],
        [u'double', u'logStep', '', ['/RW']]],
    None]
ok: class CLASS cv.ml::.ParamGrid : , name: ParamGrid, base: 

--- Incoming ---
[   u'cv.ml.ParamGrid.create',
    u'Ptr_ParamGrid',
    ['/S'],
    [   [u'double', u'minVal', u'0.', []],
        [u'double', u'maxVal', u'0.', []],
        [u'double', u'logstep', u'1.', []]],
    u'Ptr<ParamGrid>']
ok: FUNC <Ptr_ParamGrid cv.ml.ParamGrid.create [ARG double minVal=0., ARG double maxVal=0., ARG double logstep=1.]>

--- Incoming ---
[u'class cv.ml.TrainData', '', [], [], None]
ok: class CLASS cv.ml::.TrainData : , name: TrainData, base: 

--- Incoming ---
[u'cv.ml.TrainData.getLayout', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getLayout []>

--- Incoming ---
[u'cv.ml.TrainData.getNTrainSamples', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNTrainSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNTestSamples', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNTestSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNSamples', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNVars', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNVars []>

--- Incoming ---
[u'cv.ml.TrainData.getNAllVars', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNAllVars []>

--- Incoming ---
[   u'cv.ml.TrainData.getSample',
    u'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'varIdx', '', []],
        [u'int', u'sidx', u'', []],
        [u'float*', u'buf', u'', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getSample [ARG Mat varIdx=, ARG int sidx=, ARG float * buf=]>

--- Incoming ---
[u'cv.ml.TrainData.getSamples', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getMissing', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getMissing []>

--- Incoming ---
[   u'cv.ml.TrainData.getTrainSamples',
    u'Mat',
    ['/C', '/V', '/PV'],
    [   [u'int', u'layout', u'ROW_SAMPLE', []],
        [u'bool', u'compressSamples', u'true', []],
        [u'bool', u'compressVars', u'true', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSamples [ARG int layout=ROW_SAMPLE, ARG bool compressSamples=true, ARG bool compressVars=true]>

--- Incoming ---
[u'cv.ml.TrainData.getTrainResponses', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainResponses []>

--- Incoming ---
[   u'cv.ml.TrainData.getTrainNormCatResponses',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getTestResponses', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestResponses []>

--- Incoming ---
[   u'cv.ml.TrainData.getTestNormCatResponses',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getResponses', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getResponses []>

--- Incoming ---
[   u'cv.ml.TrainData.getNormCatResponses',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getSampleWeights', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSampleWeights []>

--- Incoming ---
[   u'cv.ml.TrainData.getTrainSampleWeights',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSampleWeights []>

--- Incoming ---
[   u'cv.ml.TrainData.getTestSampleWeights',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSampleWeights []>

--- Incoming ---
[u'cv.ml.TrainData.getVarIdx', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarIdx []>

--- Incoming ---
[u'cv.ml.TrainData.getVarType', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarType []>

--- Incoming ---
[u'cv.ml.TrainData.getVarSymbolFlags', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarSymbolFlags []>

--- Incoming ---
[u'cv.ml.TrainData.getResponseType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getResponseType []>

--- Incoming ---
[u'cv.ml.TrainData.getTrainSampleIdx', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSampleIdx []>

--- Incoming ---
[u'cv.ml.TrainData.getTestSampleIdx', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSampleIdx []>

--- Incoming ---
[   u'cv.ml.TrainData.getValues',
    u'void',
    ['/C', '/V', '/PV'],
    [   [u'int', u'vi', u'', []],
        ['Mat', u'sidx', '', []],
        [u'float*', u'values', u'', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getValues [ARG int vi=, ARG Mat sidx=, ARG float * values=]>

--- Incoming ---
[   u'cv.ml.TrainData.getDefaultSubstValues',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getDefaultSubstValues []>

--- Incoming ---
[   u'cv.ml.TrainData.getCatCount',
    u'int',
    ['/C', '/V', '/PV'],
    [[u'int', u'vi', u'', []]],
    u'int']
ok: FUNC <int cv.ml.TrainData.getCatCount [ARG int vi=]>

--- Incoming ---
[u'cv.ml.TrainData.getClassLabels', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getClassLabels []>

--- Incoming ---
[u'cv.ml.TrainData.getCatOfs', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getCatOfs []>

--- Incoming ---
[u'cv.ml.TrainData.getCatMap', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getCatMap []>

--- Incoming ---
[   u'cv.ml.TrainData.setTrainTestSplit',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'count', u'', []], [u'bool', u'shuffle', u'true', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.setTrainTestSplit [ARG int count=, ARG bool shuffle=true]>

--- Incoming ---
[   u'cv.ml.TrainData.setTrainTestSplitRatio',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'ratio', u'', []], [u'bool', u'shuffle', u'true', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.setTrainTestSplitRatio [ARG double ratio=, ARG bool shuffle=true]>

--- Incoming ---
[u'cv.ml.TrainData.shuffleTrainTest', u'void', ['/V', '/PV'], [], u'void']
ok: FUNC <void cv.ml.TrainData.shuffleTrainTest []>

--- Incoming ---
[u'cv.ml.TrainData.getTestSamples', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSamples []>

--- Incoming ---
[   u'cv.ml.TrainData.getNames',
    u'void',
    ['/C', '/V', '/PV'],
    [[u'vector_String', u'names', u'', ['/Ref']]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getNames [ARG vector_String names=]>

--- Incoming ---
[   u'cv.ml.TrainData.getSubVector',
    u'Mat',
    ['/S'],
    [   [u'Mat', u'vec', u'', ['/C', '/Ref']],
        [u'Mat', u'idx', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSubVector [ARG Mat vec=, ARG Mat idx=]>

--- Incoming ---
[   u'cv.ml.TrainData.getSubMatrix',
    u'Mat',
    ['/S'],
    [   [u'Mat', u'matrix', u'', ['/C', '/Ref']],
        [u'Mat', u'idx', u'', ['/C', '/Ref']],
        [u'int', u'layout', u'', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSubMatrix [ARG Mat matrix=, ARG Mat idx=, ARG int layout=]>

--- Incoming ---
[   u'cv.ml.TrainData.create',
    u'Ptr_TrainData',
    ['/S'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'layout', u'', []],
        ['Mat', u'responses', '', []],
        ['Mat', u'varIdx', u'Mat()', []],
        ['Mat', u'sampleIdx', u'Mat()', []],
        ['Mat', u'sampleWeights', u'Mat()', []],
        ['Mat', u'varType', u'Mat()', []]],
    u'Ptr<TrainData>']
ok: FUNC <Ptr_TrainData cv.ml.TrainData.create [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG Mat varIdx=Mat(), ARG Mat sampleIdx=Mat(), ARG Mat sampleWeights=Mat(), ARG Mat varType=Mat()]>

--- Incoming ---
[u'class cv.ml.StatModel', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ml::.StatModel : Algorithm, name: StatModel, base: Algorithm

--- Incoming ---
[   u'enum cv.ml.StatModel.Flags',
    '',
    [],
    [   [u'const cv.ml.StatModel.UPDATE_MODEL', u'1', [], [], None, ''],
        [u'const cv.ml.StatModel.RAW_OUTPUT', u'1', [], [], None, ''],
        [u'const cv.ml.StatModel.COMPRESSED_INPUT', u'2', [], [], None, ''],
        [u'const cv.ml.StatModel.PREPROCESSED_INPUT', u'4', [], [], None, '']],
    None]
ok: CONST UPDATE_MODEL=1
ok: CONST RAW_OUTPUT=1
ok: CONST COMPRESSED_INPUT=2
ok: CONST PREPROCESSED_INPUT=4

--- Incoming ---
[u'cv.ml.StatModel.getVarCount', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.StatModel.getVarCount []>

--- Incoming ---
[u'cv.ml.StatModel.empty', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.empty []>

--- Incoming ---
[u'cv.ml.StatModel.isTrained', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.isTrained []>

--- Incoming ---
[u'cv.ml.StatModel.isClassifier', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.isClassifier []>

--- Incoming ---
[   u'cv.ml.StatModel.train',
    u'bool',
    ['/V'],
    [   [u'Ptr_TrainData', u'trainData', u'', ['/C', '/Ref']],
        [u'int', u'flags', u'0', []]],
    u'bool']
ok: FUNC <bool cv.ml.StatModel.train [ARG Ptr_TrainData trainData=, ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.StatModel.train',
    u'bool',
    ['/V'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'layout', u'', []],
        ['Mat', u'responses', '', []]],
    u'bool']
ok: FUNC <bool cv.ml.StatModel.train [ARG Mat samples=, ARG int layout=, ARG Mat responses=]>

--- Incoming ---
[   u'cv.ml.StatModel.calcError',
    u'float',
    ['/C', '/V'],
    [   [u'Ptr_TrainData', u'data', u'', ['/C', '/Ref']],
        [u'bool', u'test', u'', []],
        ['Mat', u'resp', '', ['/O']]],
    u'float']
ok: FUNC <float cv.ml.StatModel.calcError [ARG Ptr_TrainData data=, ARG bool test=, ARG Mat resp=]>

--- Incoming ---
[   u'cv.ml.StatModel.predict',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', u'Mat()', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.StatModel.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[u'class cv.ml.NormalBayesClassifier', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.NormalBayesClassifier : StatModel, name: NormalBayesClassifier, base: StatModel

--- Incoming ---
[   u'cv.ml.NormalBayesClassifier.predictProb',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'inputs', '', []],
        ['Mat', u'outputs', '', ['/O']],
        ['Mat', u'outputProbs', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.NormalBayesClassifier.predictProb [ARG Mat inputs=, ARG Mat outputs=, ARG Mat outputProbs=, ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.NormalBayesClassifier.create',
    u'Ptr_NormalBayesClassifier',
    ['/S'],
    [],
    u'Ptr<NormalBayesClassifier>']
ok: FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.create []>

--- Incoming ---
[   u'cv.ml.NormalBayesClassifier.load',
    u'Ptr_NormalBayesClassifier',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<NormalBayesClassifier>']
ok: FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.KNearest', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.KNearest : StatModel, name: KNearest, base: StatModel

--- Incoming ---
[u'cv.ml.KNearest.getDefaultK', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.KNearest.getDefaultK []>

--- Incoming ---
[   u'cv.ml.KNearest.setDefaultK',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setDefaultK [ARG int val=]>

--- Incoming ---
[u'cv.ml.KNearest.getIsClassifier', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.KNearest.getIsClassifier []>

--- Incoming ---
[   u'cv.ml.KNearest.setIsClassifier',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setIsClassifier [ARG bool val=]>

--- Incoming ---
[u'cv.ml.KNearest.getEmax', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.KNearest.getEmax []>

--- Incoming ---
[   u'cv.ml.KNearest.setEmax',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setEmax [ARG int val=]>

--- Incoming ---
[u'cv.ml.KNearest.getAlgorithmType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.KNearest.getAlgorithmType []>

--- Incoming ---
[   u'cv.ml.KNearest.setAlgorithmType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setAlgorithmType [ARG int val=]>

--- Incoming ---
[   u'cv.ml.KNearest.findNearest',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'k', u'', []],
        ['Mat', u'results', '', ['/O']],
        ['Mat', u'neighborResponses', u'Mat()', ['/O']],
        ['Mat', u'dist', u'Mat()', ['/O']]],
    u'float']
ok: FUNC <float cv.ml.KNearest.findNearest [ARG Mat samples=, ARG int k=, ARG Mat results=, ARG Mat neighborResponses=Mat(), ARG Mat dist=Mat()]>

--- Incoming ---
[   u'enum cv.ml.KNearest.Types',
    '',
    [],
    [   [u'const cv.ml.KNearest.BRUTE_FORCE', u'1', [], [], None, ''],
        [u'const cv.ml.KNearest.KDTREE', u'2', [], [], None, '']],
    None]
ok: CONST BRUTE_FORCE=1
ok: CONST KDTREE=2

--- Incoming ---
[u'cv.ml.KNearest.create', u'Ptr_KNearest', ['/S'], [], u'Ptr<KNearest>']
ok: FUNC <Ptr_KNearest cv.ml.KNearest.create []>

--- Incoming ---
[   u'cv.ml.KNearest.load',
    u'Ptr_KNearest',
    ['/S'],
    [[u'String', u'filepath', u'', ['/C', '/Ref']]],
    u'Ptr<KNearest>']
ok: FUNC <Ptr_KNearest cv.ml.KNearest.load [ARG String filepath=]>

--- Incoming ---
[u'class cv.ml.SVM', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.SVM : StatModel, name: SVM, base: StatModel

--- Incoming ---
[u'cv.ml.SVM.getType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.SVM.getType []>

--- Incoming ---
[   u'cv.ml.SVM.setType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setType [ARG int val=]>

--- Incoming ---
[u'cv.ml.SVM.getGamma', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getGamma []>

--- Incoming ---
[   u'cv.ml.SVM.setGamma',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setGamma [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getCoef0', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getCoef0 []>

--- Incoming ---
[   u'cv.ml.SVM.setCoef0',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setCoef0 [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getDegree', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getDegree []>

--- Incoming ---
[   u'cv.ml.SVM.setDegree',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setDegree [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getC', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getC []>

--- Incoming ---
[   u'cv.ml.SVM.setC',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setC [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getNu', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getNu []>

--- Incoming ---
[   u'cv.ml.SVM.setNu',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setNu [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getP', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getP []>

--- Incoming ---
[   u'cv.ml.SVM.setP',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setP [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getClassWeights', u'Mat', ['/C', '/V', '/PV'], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.SVM.getClassWeights []>

--- Incoming ---
[   u'cv.ml.SVM.setClassWeights',
    u'void',
    ['/V', '/PV'],
    [[u'Mat', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.SVM.setClassWeights [ARG Mat val=]>

--- Incoming ---
[   u'cv.ml.SVM.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'cv::TermCriteria']
ok: FUNC <TermCriteria cv.ml.SVM.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.SVM.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.SVM.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.SVM.getKernelType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.SVM.getKernelType []>

--- Incoming ---
[   u'cv.ml.SVM.setKernel',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'kernelType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setKernel [ARG int kernelType=]>

--- Incoming ---
[   u'enum cv.ml.SVM.Types',
    '',
    [],
    [   [u'const cv.ml.SVM.C_SVC', u'100', [], [], None, ''],
        [u'const cv.ml.SVM.NU_SVC', u'101', [], [], None, ''],
        [u'const cv.ml.SVM.ONE_CLASS', u'102', [], [], None, ''],
        [u'const cv.ml.SVM.EPS_SVR', u'103', [], [], None, ''],
        [u'const cv.ml.SVM.NU_SVR', u'104', [], [], None, '']],
    None]
ok: CONST C_SVC=100
ok: CONST NU_SVC=101
ok: CONST ONE_CLASS=102
ok: CONST EPS_SVR=103
ok: CONST NU_SVR=104

--- Incoming ---
[   u'enum cv.ml.SVM.KernelTypes',
    '',
    [],
    [   [u'const cv.ml.SVM.CUSTOM', u'-1', [], [], None, ''],
        [u'const cv.ml.SVM.LINEAR', u'0', [], [], None, ''],
        [u'const cv.ml.SVM.POLY', u'1', [], [], None, ''],
        [u'const cv.ml.SVM.RBF', u'2', [], [], None, ''],
        [u'const cv.ml.SVM.SIGMOID', u'3', [], [], None, ''],
        [u'const cv.ml.SVM.CHI2', u'4', [], [], None, ''],
        [u'const cv.ml.SVM.INTER', u'5', [], [], None, '']],
    None]
ok: CONST CUSTOM=-1
ok: CONST LINEAR=0
ok: CONST POLY=1
ok: CONST RBF=2
ok: CONST SIGMOID=3
ok: CONST CHI2=4
ok: CONST INTER=5

--- Incoming ---
[   u'enum cv.ml.SVM.ParamTypes',
    '',
    [],
    [   [u'const cv.ml.SVM.C', u'0', [], [], None, ''],
        [u'const cv.ml.SVM.GAMMA', u'1', [], [], None, ''],
        [u'const cv.ml.SVM.P', u'2', [], [], None, ''],
        [u'const cv.ml.SVM.NU', u'3', [], [], None, ''],
        [u'const cv.ml.SVM.COEF', u'4', [], [], None, ''],
        [u'const cv.ml.SVM.DEGREE', u'5', [], [], None, '']],
    None]
ok: CONST C=0
ok: CONST GAMMA=1
ok: CONST P=2
ok: CONST NU=3
ok: CONST COEF=4
ok: CONST DEGREE=5

--- Incoming ---
[   u'cv.ml.SVM.trainAuto',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'layout', u'', []],
        ['Mat', u'responses', '', []],
        [u'int', u'kFold', u'10', []],
        [u'Ptr_ParamGrid', u'Cgrid', u'SVM::getDefaultGridPtr(SVM::C)', []],
        [   u'Ptr_ParamGrid',
            u'gammaGrid',
            u'SVM::getDefaultGridPtr(SVM::GAMMA)',
            []],
        [u'Ptr_ParamGrid', u'pGrid', u'SVM::getDefaultGridPtr(SVM::P)', []],
        [u'Ptr_ParamGrid', u'nuGrid', u'SVM::getDefaultGridPtr(SVM::NU)', []],
        [   u'Ptr_ParamGrid',
            u'coeffGrid',
            u'SVM::getDefaultGridPtr(SVM::COEF)',
            []],
        [   u'Ptr_ParamGrid',
            u'degreeGrid',
            u'SVM::getDefaultGridPtr(SVM::DEGREE)',
            []],
        [u'bool', u'balanced', u'false', []]],
    u'bool']
ok: FUNC <bool cv.ml.SVM.trainAuto [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG int kFold=10, ARG Ptr_ParamGrid Cgrid=SVM::getDefaultGridPtr(SVM::C), ARG Ptr_ParamGrid gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA), ARG Ptr_ParamGrid pGrid=SVM::getDefaultGridPtr(SVM::P), ARG Ptr_ParamGrid nuGrid=SVM::getDefaultGridPtr(SVM::NU), ARG Ptr_ParamGrid coeffGrid=SVM::getDefaultGridPtr(SVM::COEF), ARG Ptr_ParamGrid degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE), ARG bool balanced=false]>

--- Incoming ---
[u'cv.ml.SVM.getSupportVectors', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.SVM.getSupportVectors []>

--- Incoming ---
[   u'cv.ml.SVM.getUncompressedSupportVectors',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.SVM.getUncompressedSupportVectors []>

--- Incoming ---
[   u'cv.ml.SVM.getDecisionFunction',
    u'double',
    ['/C', '/V', '/PV'],
    [   [u'int', u'i', u'', []],
        ['Mat', u'alpha', '', ['/O']],
        ['Mat', u'svidx', '', ['/O']]],
    u'double']
ok: FUNC <double cv.ml.SVM.getDecisionFunction [ARG int i=, ARG Mat alpha=, ARG Mat svidx=]>

--- Incoming ---
[   u'cv.ml.SVM.getDefaultGridPtr',
    u'Ptr_ParamGrid',
    ['/S'],
    [[u'int', u'param_id', u'', []]],
    u'Ptr<ParamGrid>']
ok: FUNC <Ptr_ParamGrid cv.ml.SVM.getDefaultGridPtr [ARG int param_id=]>

--- Incoming ---
[u'cv.ml.SVM.create', u'Ptr_SVM', ['/S'], [], u'Ptr<SVM>']
ok: FUNC <Ptr_SVM cv.ml.SVM.create []>

--- Incoming ---
[   u'cv.ml.SVM.load',
    u'Ptr_SVM',
    ['/S'],
    [[u'String', u'filepath', u'', ['/C', '/Ref']]],
    u'Ptr<SVM>']
ok: FUNC <Ptr_SVM cv.ml.SVM.load [ARG String filepath=]>

--- Incoming ---
[u'class cv.ml.EM', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.EM : StatModel, name: EM, base: StatModel

--- Incoming ---
[   u'enum cv.ml.EM.Types',
    '',
    [],
    [   [u'const cv.ml.EM.COV_MAT_SPHERICAL', u'0', [], [], None, ''],
        [u'const cv.ml.EM.COV_MAT_DIAGONAL', u'1', [], [], None, ''],
        [u'const cv.ml.EM.COV_MAT_GENERIC', u'2', [], [], None, ''],
        [   u'const cv.ml.EM.COV_MAT_DEFAULT',
            u'COV_MAT_DIAGONAL',
            [],
            [],
            None,
            '']],
    None]
ok: CONST COV_MAT_SPHERICAL=0
ok: CONST COV_MAT_DIAGONAL=1
ok: CONST COV_MAT_GENERIC=2
ok: CONST COV_MAT_DEFAULT=COV_MAT_DIAGONAL

--- Incoming ---
[   u'enum cv.ml.EM.<unnamed>',
    '',
    [],
    [   [u'const cv.ml.EM.DEFAULT_NCLUSTERS', u'5', [], [], None, ''],
        [u'const cv.ml.EM.DEFAULT_MAX_ITERS', u'100', [], [], None, '']],
    None]
ok: CONST DEFAULT_NCLUSTERS=5
ok: CONST DEFAULT_MAX_ITERS=100

--- Incoming ---
[   u'enum cv.ml.EM.<unnamed>',
    '',
    [],
    [   [u'const cv.ml.EM.START_E_STEP', u'1', [], [], None, ''],
        [u'const cv.ml.EM.START_M_STEP', u'2', [], [], None, ''],
        [u'const cv.ml.EM.START_AUTO_STEP', u'0', [], [], None, '']],
    None]
ok: CONST START_E_STEP=1
ok: CONST START_M_STEP=2
ok: CONST START_AUTO_STEP=0

--- Incoming ---
[u'cv.ml.EM.getClustersNumber', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.EM.getClustersNumber []>

--- Incoming ---
[   u'cv.ml.EM.setClustersNumber',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.EM.setClustersNumber [ARG int val=]>

--- Incoming ---
[u'cv.ml.EM.getCovarianceMatrixType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.EM.getCovarianceMatrixType []>

--- Incoming ---
[   u'cv.ml.EM.setCovarianceMatrixType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.EM.setCovarianceMatrixType [ARG int val=]>

--- Incoming ---
[   u'cv.ml.EM.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.EM.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.EM.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.EM.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.EM.getWeights', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.EM.getWeights []>

--- Incoming ---
[u'cv.ml.EM.getMeans', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.EM.getMeans []>

--- Incoming ---
[   u'cv.ml.EM.getCovs',
    u'void',
    ['/C', '/V', '/PV'],
    [[u'vector_Mat', u'covs', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.EM.getCovs [ARG vector_Mat covs=]>

--- Incoming ---
[   u'cv.ml.EM.predict',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', u'Mat()', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.EM.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.EM.predict2',
    u'Vec2d',
    ['/C', '/V', '/PV'],
    [['Mat', u'sample', '', []], ['Mat', u'probs', '', ['/O']]],
    u'Vec2d']
ok: FUNC <Vec2d cv.ml.EM.predict2 [ARG Mat sample=, ARG Mat probs=]>

--- Incoming ---
[   u'cv.ml.EM.trainEM',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainEM [ARG Mat samples=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[   u'cv.ml.EM.trainE',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'means0', '', []],
        ['Mat', u'covs0', u'Mat()', []],
        ['Mat', u'weights0', u'Mat()', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainE [ARG Mat samples=, ARG Mat means0=, ARG Mat covs0=Mat(), ARG Mat weights0=Mat(), ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[   u'cv.ml.EM.trainM',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'probs0', '', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainM [ARG Mat samples=, ARG Mat probs0=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[u'cv.ml.EM.create', u'Ptr_EM', ['/S'], [], u'Ptr<EM>']
ok: FUNC <Ptr_EM cv.ml.EM.create []>

--- Incoming ---
[   u'cv.ml.EM.load',
    u'Ptr_EM',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<EM>']
ok: FUNC <Ptr_EM cv.ml.EM.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.DTrees', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.DTrees : StatModel, name: DTrees, base: StatModel

--- Incoming ---
[   u'enum cv.ml.DTrees.Flags',
    '',
    [],
    [   [u'const cv.ml.DTrees.PREDICT_AUTO', u'0', [], [], None, ''],
        [u'const cv.ml.DTrees.PREDICT_SUM', u'(1<<8)', [], [], None, ''],
        [u'const cv.ml.DTrees.PREDICT_MAX_VOTE', u'(2<<8)', [], [], None, ''],
        [u'const cv.ml.DTrees.PREDICT_MASK', u'(3<<8)', [], [], None, '']],
    None]
ok: CONST PREDICT_AUTO=0
ok: CONST PREDICT_SUM=(1<<8)
ok: CONST PREDICT_MAX_VOTE=(2<<8)
ok: CONST PREDICT_MASK=(3<<8)

--- Incoming ---
[u'cv.ml.DTrees.getMaxCategories', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMaxCategories []>

--- Incoming ---
[   u'cv.ml.DTrees.setMaxCategories',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMaxCategories [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getMaxDepth', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMaxDepth []>

--- Incoming ---
[   u'cv.ml.DTrees.setMaxDepth',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMaxDepth [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getMinSampleCount', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMinSampleCount []>

--- Incoming ---
[   u'cv.ml.DTrees.setMinSampleCount',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMinSampleCount [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getCVFolds', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.DTrees.getCVFolds []>

--- Incoming ---
[   u'cv.ml.DTrees.setCVFolds',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setCVFolds [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getUseSurrogates', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.DTrees.getUseSurrogates []>

--- Incoming ---
[   u'cv.ml.DTrees.setUseSurrogates',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setUseSurrogates [ARG bool val=]>

--- Incoming ---
[u'cv.ml.DTrees.getUse1SERule', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.DTrees.getUse1SERule []>

--- Incoming ---
[   u'cv.ml.DTrees.setUse1SERule',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setUse1SERule [ARG bool val=]>

--- Incoming ---
[   u'cv.ml.DTrees.getTruncatePrunedTree',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.ml.DTrees.getTruncatePrunedTree []>

--- Incoming ---
[   u'cv.ml.DTrees.setTruncatePrunedTree',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setTruncatePrunedTree [ARG bool val=]>

--- Incoming ---
[   u'cv.ml.DTrees.getRegressionAccuracy',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ml.DTrees.getRegressionAccuracy []>

--- Incoming ---
[   u'cv.ml.DTrees.setRegressionAccuracy',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setRegressionAccuracy [ARG float val=]>

--- Incoming ---
[u'cv.ml.DTrees.getPriors', u'Mat', ['/C', '/V', '/PV'], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.DTrees.getPriors []>

--- Incoming ---
[   u'cv.ml.DTrees.setPriors',
    u'void',
    ['/V', '/PV'],
    [[u'Mat', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setPriors [ARG Mat val=]>

--- Incoming ---
[u'cv.ml.DTrees.create', u'Ptr_DTrees', ['/S'], [], u'Ptr<DTrees>']
ok: FUNC <Ptr_DTrees cv.ml.DTrees.create []>

--- Incoming ---
[   u'cv.ml.DTrees.load',
    u'Ptr_DTrees',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<DTrees>']
ok: FUNC <Ptr_DTrees cv.ml.DTrees.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.RTrees', u': cv::ml::DTrees', [], [], None]
ok: class CLASS cv.ml::.RTrees : DTrees, name: RTrees, base: DTrees

--- Incoming ---
[   u'cv.ml.RTrees.getCalculateVarImportance',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.ml.RTrees.getCalculateVarImportance []>

--- Incoming ---
[   u'cv.ml.RTrees.setCalculateVarImportance',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setCalculateVarImportance [ARG bool val=]>

--- Incoming ---
[u'cv.ml.RTrees.getActiveVarCount', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.RTrees.getActiveVarCount []>

--- Incoming ---
[   u'cv.ml.RTrees.setActiveVarCount',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setActiveVarCount [ARG int val=]>

--- Incoming ---
[   u'cv.ml.RTrees.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.RTrees.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.RTrees.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.RTrees.getVarImportance', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.RTrees.getVarImportance []>

--- Incoming ---
[   u'cv.ml.RTrees.getVotes',
    u'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.getVotes [ARG Mat samples=, ARG Mat results=, ARG int flags=]>

--- Incoming ---
[u'cv.ml.RTrees.create', u'Ptr_RTrees', ['/S'], [], u'Ptr<RTrees>']
ok: FUNC <Ptr_RTrees cv.ml.RTrees.create []>

--- Incoming ---
[   u'cv.ml.RTrees.load',
    u'Ptr_RTrees',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<RTrees>']
ok: FUNC <Ptr_RTrees cv.ml.RTrees.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.Boost', u': cv::ml::DTrees', [], [], None]
ok: class CLASS cv.ml::.Boost : DTrees, name: Boost, base: DTrees

--- Incoming ---
[u'cv.ml.Boost.getBoostType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.Boost.getBoostType []>

--- Incoming ---
[   u'cv.ml.Boost.setBoostType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setBoostType [ARG int val=]>

--- Incoming ---
[u'cv.ml.Boost.getWeakCount', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.Boost.getWeakCount []>

--- Incoming ---
[   u'cv.ml.Boost.setWeakCount',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setWeakCount [ARG int val=]>

--- Incoming ---
[   u'cv.ml.Boost.getWeightTrimRate',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.Boost.getWeightTrimRate []>

--- Incoming ---
[   u'cv.ml.Boost.setWeightTrimRate',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setWeightTrimRate [ARG double val=]>

--- Incoming ---
[   u'enum cv.ml.Boost.Types',
    '',
    [],
    [   [u'const cv.ml.Boost.DISCRETE', u'0', [], [], None, ''],
        [u'const cv.ml.Boost.REAL', u'1', [], [], None, ''],
        [u'const cv.ml.Boost.LOGIT', u'2', [], [], None, ''],
        [u'const cv.ml.Boost.GENTLE', u'3', [], [], None, '']],
    None]
ok: CONST DISCRETE=0
ok: CONST REAL=1
ok: CONST LOGIT=2
ok: CONST GENTLE=3

--- Incoming ---
[u'cv.ml.Boost.create', u'Ptr_Boost', ['/S'], [], u'Ptr<Boost>']
ok: FUNC <Ptr_Boost cv.ml.Boost.create []>

--- Incoming ---
[   u'cv.ml.Boost.load',
    u'Ptr_Boost',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<Boost>']
ok: FUNC <Ptr_Boost cv.ml.Boost.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.ANN_MLP', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.ANN_MLP : StatModel, name: ANN_MLP, base: StatModel

--- Incoming ---
[   u'enum cv.ml.ANN_MLP.TrainingMethods',
    '',
    [],
    [   [u'const cv.ml.ANN_MLP.BACKPROP', u'0', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.RPROP', u'1', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.ANNEAL', u'2', [], [], None, '']],
    None]
ok: CONST BACKPROP=0
ok: CONST RPROP=1
ok: CONST ANNEAL=2

--- Incoming ---
[   u'cv.ml.ANN_MLP.setTrainMethod',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'method', u'', []],
        [u'double', u'param1', u'0', []],
        [u'double', u'param2', u'0', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setTrainMethod [ARG int method=, ARG double param1=0, ARG double param2=0]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getTrainMethod', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.ANN_MLP.getTrainMethod []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setActivationFunction',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'type', u'', []],
        [u'double', u'param1', u'0', []],
        [u'double', u'param2', u'0', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setActivationFunction [ARG int type=, ARG double param1=0, ARG double param2=0]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setLayerSizes',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'_layer_sizes', '', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setLayerSizes [ARG Mat _layer_sizes=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getLayerSizes', u'Mat', ['/C', '/V', '/PV'], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.ANN_MLP.getLayerSizes []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.ANN_MLP.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getBackpropWeightScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getBackpropWeightScale []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setBackpropWeightScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setBackpropWeightScale [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getBackpropMomentumScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getBackpropMomentumScale []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setBackpropMomentumScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setBackpropMomentumScale [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDW0', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDW0 []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDW0',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDW0 [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getRpropDWPlus',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWPlus []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWPlus',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWPlus [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getRpropDWMinus',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMinus []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMinus',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMinus [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDWMin', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMin []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMin',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMin [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDWMax', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMax []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMax',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMax [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getAnnealInitialT',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealInitialT []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setAnnealInitialT',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealInitialT [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getAnnealFinalT',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealFinalT []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setAnnealFinalT',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealFinalT [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getAnnealCoolingRatio',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealCoolingRatio []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setAnnealCoolingRatio',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealCoolingRatio [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getAnnealItePerStep', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.ANN_MLP.getAnnealItePerStep []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setAnnealItePerStep',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealItePerStep [ARG int val=]>

--- Incoming ---
[   u'enum cv.ml.ANN_MLP.ActivationFunctions',
    '',
    [],
    [   [u'const cv.ml.ANN_MLP.IDENTITY', u'0', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.SIGMOID_SYM', u'1', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.GAUSSIAN', u'2', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.RELU', u'3', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.LEAKYRELU', u'4', [], [], None, '']],
    None]
ok: CONST IDENTITY=0
ok: CONST SIGMOID_SYM=1
ok: CONST GAUSSIAN=2
ok: CONST RELU=3
ok: CONST LEAKYRELU=4

--- Incoming ---
[   u'enum cv.ml.ANN_MLP.TrainFlags',
    '',
    [],
    [   [u'const cv.ml.ANN_MLP.UPDATE_WEIGHTS', u'1', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.NO_INPUT_SCALE', u'2', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.NO_OUTPUT_SCALE', u'4', [], [], None, '']],
    None]
ok: CONST UPDATE_WEIGHTS=1
ok: CONST NO_INPUT_SCALE=2
ok: CONST NO_OUTPUT_SCALE=4

--- Incoming ---
[   u'cv.ml.ANN_MLP.getWeights',
    u'Mat',
    ['/C', '/V', '/PV'],
    [[u'int', u'layerIdx', u'', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.ANN_MLP.getWeights [ARG int layerIdx=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.create', u'Ptr_ANN_MLP', ['/S'], [], u'Ptr<ANN_MLP>']
ok: FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.create []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.load',
    u'Ptr_ANN_MLP',
    ['/S'],
    [[u'String', u'filepath', u'', ['/C', '/Ref']]],
    u'Ptr<ANN_MLP>']
ok: FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.load [ARG String filepath=]>

--- Incoming ---
[u'class cv.ml.LogisticRegression', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.LogisticRegression : StatModel, name: LogisticRegression, base: StatModel

--- Incoming ---
[   u'cv.ml.LogisticRegression.getLearningRate',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.LogisticRegression.getLearningRate []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setLearningRate',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setLearningRate [ARG double val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ml.LogisticRegression.getIterations []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setIterations [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getRegularization',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ml.LogisticRegression.getRegularization []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setRegularization',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setRegularization [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getTrainMethod',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ml.LogisticRegression.getTrainMethod []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setTrainMethod',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setTrainMethod [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getMiniBatchSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ml.LogisticRegression.getMiniBatchSize []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setMiniBatchSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setMiniBatchSize [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.LogisticRegression.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[   u'enum cv.ml.LogisticRegression.RegKinds',
    '',
    [],
    [   [   u'const cv.ml.LogisticRegression.REG_DISABLE',
            u'-1',
            [],
            [],
            None,
            ''],
        [u'const cv.ml.LogisticRegression.REG_L1', u'0', [], [], None, ''],
        [u'const cv.ml.LogisticRegression.REG_L2', u'1', [], [], None, '']],
    None]
ok: CONST REG_DISABLE=-1
ok: CONST REG_L1=0
ok: CONST REG_L2=1

--- Incoming ---
[   u'enum cv.ml.LogisticRegression.Methods',
    '',
    [],
    [   [u'const cv.ml.LogisticRegression.BATCH', u'0', [], [], None, ''],
        [   u'const cv.ml.LogisticRegression.MINI_BATCH',
            u'1',
            [],
            [],
            None,
            '']],
    None]
ok: CONST BATCH=0
ok: CONST MINI_BATCH=1

--- Incoming ---
[   u'cv.ml.LogisticRegression.predict',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', u'Mat()', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.LogisticRegression.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.get_learnt_thetas',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.LogisticRegression.get_learnt_thetas []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.create',
    u'Ptr_LogisticRegression',
    ['/S'],
    [],
    u'Ptr<LogisticRegression>']
ok: FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.create []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.load',
    u'Ptr_LogisticRegression',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<LogisticRegression>']
ok: FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.SVMSGD', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.SVMSGD : StatModel, name: SVMSGD, base: StatModel

--- Incoming ---
[   u'enum cv.ml.SVMSGD.SvmsgdType',
    '',
    [],
    [   [u'const cv.ml.SVMSGD.SGD', '0', [], [], None, ''],
        [u'const cv.ml.SVMSGD.ASGD', '1', [], [], None, '']],
    None]
ok: CONST SGD=0
ok: CONST ASGD=1

--- Incoming ---
[   u'enum cv.ml.SVMSGD.MarginType',
    '',
    [],
    [   [u'const cv.ml.SVMSGD.SOFT_MARGIN', '0', [], [], None, ''],
        [u'const cv.ml.SVMSGD.HARD_MARGIN', '1', [], [], None, '']],
    None]
ok: CONST SOFT_MARGIN=0
ok: CONST HARD_MARGIN=1

--- Incoming ---
[u'cv.ml.SVMSGD.getWeights', u'Mat', ['/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.SVMSGD.getWeights []>

--- Incoming ---
[u'cv.ml.SVMSGD.getShift', u'float', ['/V', '/PV'], [], u'float']
ok: FUNC <float cv.ml.SVMSGD.getShift []>

--- Incoming ---
[u'cv.ml.SVMSGD.create', u'Ptr_SVMSGD', ['/S'], [], u'Ptr<SVMSGD>']
ok: FUNC <Ptr_SVMSGD cv.ml.SVMSGD.create []>

--- Incoming ---
[   u'cv.ml.SVMSGD.load',
    u'Ptr_SVMSGD',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<SVMSGD>']
ok: FUNC <Ptr_SVMSGD cv.ml.SVMSGD.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[   u'cv.ml.SVMSGD.setOptimalParameters',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'svmsgdType', u'SVMSGD::ASGD', []],
        [u'int', u'marginType', u'SVMSGD::SOFT_MARGIN', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setOptimalParameters [ARG int svmsgdType=SVMSGD::ASGD, ARG int marginType=SVMSGD::SOFT_MARGIN]>

--- Incoming ---
[u'cv.ml.SVMSGD.getSvmsgdType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.SVMSGD.getSvmsgdType []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setSvmsgdType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'svmsgdType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setSvmsgdType [ARG int svmsgdType=]>

--- Incoming ---
[u'cv.ml.SVMSGD.getMarginType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.SVMSGD.getMarginType []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setMarginType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'marginType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setMarginType [ARG int marginType=]>

--- Incoming ---
[   u'cv.ml.SVMSGD.getMarginRegularization',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ml.SVMSGD.getMarginRegularization []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setMarginRegularization',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'marginRegularization', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setMarginRegularization [ARG float marginRegularization=]>

--- Incoming ---
[   u'cv.ml.SVMSGD.getInitialStepSize',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ml.SVMSGD.getInitialStepSize []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setInitialStepSize',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'InitialStepSize', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setInitialStepSize [ARG float InitialStepSize=]>

--- Incoming ---
[   u'cv.ml.SVMSGD.getStepDecreasingPower',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ml.SVMSGD.getStepDecreasingPower []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setStepDecreasingPower',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'stepDecreasingPower', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setStepDecreasingPower [ARG float stepDecreasingPower=]>

--- Incoming ---
[   u'cv.ml.SVMSGD.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.SVMSGD.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setTermCriteria [ARG TermCriteria val=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/ml/include/opencv2/ml/ml.hpp =====
Namespaces: set([u'cv', u'cv.ml'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/ml/include/opencv2/ml/ml.hpp


===== Generating... =====
CLASS cv.ml::.EM : StatModel
[CONST DEFAULT_NCLUSTERS=5, CONST DEFAULT_MAX_ITERS=100, CONST START_E_STEP=1, CONST START_M_STEP=2, CONST START_AUTO_STEP=0]
[CONST COV_MAT_SPHERICAL=0, CONST COV_MAT_DIAGONAL=1, CONST COV_MAT_GENERIC=2, CONST COV_MAT_DEFAULT=COV_MAT_DIAGONAL]
FUNC <Mat cv.ml.EM.getMeans []>
java: Mat getMeans()
FUNC <Mat cv.ml.EM.getWeights []>
java: Mat getWeights()
FUNC <Ptr_EM cv.ml.EM.create []>
java: EM create()
FUNC <Ptr_EM cv.ml.EM.load [ARG String filepath=, ARG String nodeName=String()]>
java: EM load(String filepath, String nodeName)
java: EM load(String filepath)
FUNC <TermCriteria cv.ml.EM.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <Vec2d cv.ml.EM.predict2 [ARG Mat sample=, ARG Mat probs=]>
java: double[] predict2(Mat sample, Mat probs)
FUNC <bool cv.ml.EM.trainE [ARG Mat samples=, ARG Mat means0=, ARG Mat covs0=Mat(), ARG Mat weights0=Mat(), ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods, Mat labels)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0)
java: boolean trainE(Mat samples, Mat means0, Mat covs0)
java: boolean trainE(Mat samples, Mat means0)
FUNC <bool cv.ml.EM.trainEM [ARG Mat samples=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainEM(Mat samples, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainEM(Mat samples, Mat logLikelihoods, Mat labels)
java: boolean trainEM(Mat samples, Mat logLikelihoods)
java: boolean trainEM(Mat samples)
FUNC <bool cv.ml.EM.trainM [ARG Mat samples=, ARG Mat probs0=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods, Mat labels)
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods)
java: boolean trainM(Mat samples, Mat probs0)
FUNC <float cv.ml.EM.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
FUNC <int cv.ml.EM.getClustersNumber []>
java: int getClustersNumber()
FUNC <int cv.ml.EM.getCovarianceMatrixType []>
java: int getCovarianceMatrixType()
FUNC <void cv.ml.EM.getCovs [ARG vector_Mat covs=]>
java: void getCovs(List<Mat> covs)
FUNC <void cv.ml.EM.setClustersNumber [ARG int val=]>
java: void setClustersNumber(int val)
FUNC <void cv.ml.EM.setCovarianceMatrixType [ARG int val=]>
java: void setCovarianceMatrixType(int val)
FUNC <void cv.ml.EM.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
CLASS cv.ml::.SVM : StatModel
[CONST CUSTOM=-1, CONST LINEAR=0, CONST POLY=1, CONST RBF=2, CONST SIGMOID=3, CONST CHI2=4, CONST INTER=5]
[CONST C_SVC=100, CONST NU_SVC=101, CONST ONE_CLASS=102, CONST EPS_SVR=103, CONST NU_SVR=104]
[CONST C=0, CONST GAMMA=1, CONST P=2, CONST NU=3, CONST COEF=4, CONST DEGREE=5]
FUNC <Mat cv.ml.SVM.getClassWeights []>
java: Mat getClassWeights()
FUNC <Mat cv.ml.SVM.getSupportVectors []>
java: Mat getSupportVectors()
FUNC <Mat cv.ml.SVM.getUncompressedSupportVectors []>
java: Mat getUncompressedSupportVectors()
FUNC <Ptr_ParamGrid cv.ml.SVM.getDefaultGridPtr [ARG int param_id=]>
java: ParamGrid getDefaultGridPtr(int param_id)
FUNC <Ptr_SVM cv.ml.SVM.create []>
java: SVM create()
FUNC <Ptr_SVM cv.ml.SVM.load [ARG String filepath=]>
java: SVM load(String filepath)
FUNC <TermCriteria cv.ml.SVM.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <bool cv.ml.SVM.trainAuto [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG int kFold=10, ARG Ptr_ParamGrid Cgrid=SVM::getDefaultGridPtr(SVM::C), ARG Ptr_ParamGrid gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA), ARG Ptr_ParamGrid pGrid=SVM::getDefaultGridPtr(SVM::P), ARG Ptr_ParamGrid nuGrid=SVM::getDefaultGridPtr(SVM::NU), ARG Ptr_ParamGrid coeffGrid=SVM::getDefaultGridPtr(SVM::COEF), ARG Ptr_ParamGrid degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE), ARG bool balanced=false]>
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid, ParamGrid degreeGrid, boolean balanced)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid, ParamGrid degreeGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold)
java: boolean trainAuto(Mat samples, int layout, Mat responses)
FUNC <double cv.ml.SVM.getC []>
java: double getC()
FUNC <double cv.ml.SVM.getCoef0 []>
java: double getCoef0()
FUNC <double cv.ml.SVM.getDecisionFunction [ARG int i=, ARG Mat alpha=, ARG Mat svidx=]>
java: double getDecisionFunction(int i, Mat alpha, Mat svidx)
FUNC <double cv.ml.SVM.getDegree []>
java: double getDegree()
FUNC <double cv.ml.SVM.getGamma []>
java: double getGamma()
FUNC <double cv.ml.SVM.getNu []>
java: double getNu()
FUNC <double cv.ml.SVM.getP []>
java: double getP()
FUNC <int cv.ml.SVM.getKernelType []>
java: int getKernelType()
FUNC <int cv.ml.SVM.getType []>
java: int getType()
FUNC <void cv.ml.SVM.setC [ARG double val=]>
java: void setC(double val)
FUNC <void cv.ml.SVM.setClassWeights [ARG Mat val=]>
java: void setClassWeights(Mat val)
FUNC <void cv.ml.SVM.setCoef0 [ARG double val=]>
java: void setCoef0(double val)
FUNC <void cv.ml.SVM.setDegree [ARG double val=]>
java: void setDegree(double val)
FUNC <void cv.ml.SVM.setGamma [ARG double val=]>
java: void setGamma(double val)
FUNC <void cv.ml.SVM.setKernel [ARG int kernelType=]>
java: void setKernel(int kernelType)
FUNC <void cv.ml.SVM.setNu [ARG double val=]>
java: void setNu(double val)
FUNC <void cv.ml.SVM.setP [ARG double val=]>
java: void setP(double val)
FUNC <void cv.ml.SVM.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.SVM.setType [ARG int val=]>
java: void setType(int val)
CLASS ::.Ml : 
[CONST ROW_SAMPLE=0, CONST COL_SAMPLE=1]
[CONST VAR_NUMERICAL=0, CONST VAR_ORDERED=0, CONST VAR_CATEGORICAL=1]
[CONST TEST_ERROR=0, CONST TRAIN_ERROR=1]
CLASS cv.ml::.NormalBayesClassifier : StatModel
FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.create []>
java: NormalBayesClassifier create()
FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.load [ARG String filepath=, ARG String nodeName=String()]>
java: NormalBayesClassifier load(String filepath, String nodeName)
java: NormalBayesClassifier load(String filepath)
FUNC <float cv.ml.NormalBayesClassifier.predictProb [ARG Mat inputs=, ARG Mat outputs=, ARG Mat outputProbs=, ARG int flags=0]>
java: float predictProb(Mat inputs, Mat outputs, Mat outputProbs, int flags)
java: float predictProb(Mat inputs, Mat outputs, Mat outputProbs)
CLASS cv.ml::.TrainData : 
FUNC <Mat cv.ml.TrainData.getCatMap []>
java: Mat getCatMap()
FUNC <Mat cv.ml.TrainData.getCatOfs []>
java: Mat getCatOfs()
FUNC <Mat cv.ml.TrainData.getClassLabels []>
java: Mat getClassLabels()
FUNC <Mat cv.ml.TrainData.getDefaultSubstValues []>
java: Mat getDefaultSubstValues()
FUNC <Mat cv.ml.TrainData.getMissing []>
java: Mat getMissing()
FUNC <Mat cv.ml.TrainData.getNormCatResponses []>
java: Mat getNormCatResponses()
FUNC <Mat cv.ml.TrainData.getResponses []>
java: Mat getResponses()
FUNC <Mat cv.ml.TrainData.getSampleWeights []>
java: Mat getSampleWeights()
FUNC <Mat cv.ml.TrainData.getSamples []>
java: Mat getSamples()
FUNC <Mat cv.ml.TrainData.getSubMatrix [ARG Mat matrix=, ARG Mat idx=, ARG int layout=]>
java: Mat getSubMatrix(Mat matrix, Mat idx, int layout)
FUNC <Mat cv.ml.TrainData.getSubVector [ARG Mat vec=, ARG Mat idx=]>
java: Mat getSubVector(Mat vec, Mat idx)
FUNC <Mat cv.ml.TrainData.getTestNormCatResponses []>
java: Mat getTestNormCatResponses()
FUNC <Mat cv.ml.TrainData.getTestResponses []>
java: Mat getTestResponses()
FUNC <Mat cv.ml.TrainData.getTestSampleIdx []>
java: Mat getTestSampleIdx()
FUNC <Mat cv.ml.TrainData.getTestSampleWeights []>
java: Mat getTestSampleWeights()
FUNC <Mat cv.ml.TrainData.getTestSamples []>
java: Mat getTestSamples()
FUNC <Mat cv.ml.TrainData.getTrainNormCatResponses []>
java: Mat getTrainNormCatResponses()
FUNC <Mat cv.ml.TrainData.getTrainResponses []>
java: Mat getTrainResponses()
FUNC <Mat cv.ml.TrainData.getTrainSampleIdx []>
java: Mat getTrainSampleIdx()
FUNC <Mat cv.ml.TrainData.getTrainSampleWeights []>
java: Mat getTrainSampleWeights()
FUNC <Mat cv.ml.TrainData.getTrainSamples [ARG int layout=ROW_SAMPLE, ARG bool compressSamples=true, ARG bool compressVars=true]>
java: Mat getTrainSamples(int layout, boolean compressSamples, boolean compressVars)
java: Mat getTrainSamples(int layout, boolean compressSamples)
java: Mat getTrainSamples(int layout)
java: Mat getTrainSamples()
FUNC <Mat cv.ml.TrainData.getVarIdx []>
java: Mat getVarIdx()
FUNC <Mat cv.ml.TrainData.getVarSymbolFlags []>
java: Mat getVarSymbolFlags()
FUNC <Mat cv.ml.TrainData.getVarType []>
java: Mat getVarType()
FUNC <Ptr_TrainData cv.ml.TrainData.create [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG Mat varIdx=Mat(), ARG Mat sampleIdx=Mat(), ARG Mat sampleWeights=Mat(), ARG Mat varType=Mat()]>
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx, Mat sampleWeights, Mat varType)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx, Mat sampleWeights)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx)
java: TrainData create(Mat samples, int layout, Mat responses)
FUNC <int cv.ml.TrainData.getCatCount [ARG int vi=]>
java: int getCatCount(int vi)
FUNC <int cv.ml.TrainData.getLayout []>
java: int getLayout()
FUNC <int cv.ml.TrainData.getNAllVars []>
java: int getNAllVars()
FUNC <int cv.ml.TrainData.getNSamples []>
java: int getNSamples()
FUNC <int cv.ml.TrainData.getNTestSamples []>
java: int getNTestSamples()
FUNC <int cv.ml.TrainData.getNTrainSamples []>
java: int getNTrainSamples()
FUNC <int cv.ml.TrainData.getNVars []>
java: int getNVars()
FUNC <int cv.ml.TrainData.getResponseType []>
java: int getResponseType()
FUNC <void cv.ml.TrainData.getNames [ARG vector_String names=]>
java: void getNames(List<String> names)
FUNC <void cv.ml.TrainData.getSample [ARG Mat varIdx=, ARG int sidx=, ARG float * buf=]>
java: void getSample(Mat varIdx, int sidx, float buf)
FUNC <void cv.ml.TrainData.getValues [ARG int vi=, ARG Mat sidx=, ARG float * values=]>
java: void getValues(int vi, Mat sidx, float values)
FUNC <void cv.ml.TrainData.setTrainTestSplit [ARG int count=, ARG bool shuffle=true]>
java: void setTrainTestSplit(int count, boolean shuffle)
java: void setTrainTestSplit(int count)
FUNC <void cv.ml.TrainData.setTrainTestSplitRatio [ARG double ratio=, ARG bool shuffle=true]>
java: void setTrainTestSplitRatio(double ratio, boolean shuffle)
java: void setTrainTestSplitRatio(double ratio)
FUNC <void cv.ml.TrainData.shuffleTrainTest []>
java: void shuffleTrainTest()
CLASS cv.ml::.Boost : DTrees
[CONST DISCRETE=0, CONST REAL=1, CONST LOGIT=2, CONST GENTLE=3]
FUNC <Ptr_Boost cv.ml.Boost.create []>
java: Boost create()
FUNC <Ptr_Boost cv.ml.Boost.load [ARG String filepath=, ARG String nodeName=String()]>
java: Boost load(String filepath, String nodeName)
java: Boost load(String filepath)
FUNC <double cv.ml.Boost.getWeightTrimRate []>
java: double getWeightTrimRate()
FUNC <int cv.ml.Boost.getBoostType []>
java: int getBoostType()
FUNC <int cv.ml.Boost.getWeakCount []>
java: int getWeakCount()
FUNC <void cv.ml.Boost.setBoostType [ARG int val=]>
java: void setBoostType(int val)
FUNC <void cv.ml.Boost.setWeakCount [ARG int val=]>
java: void setWeakCount(int val)
FUNC <void cv.ml.Boost.setWeightTrimRate [ARG double val=]>
java: void setWeightTrimRate(double val)
CLASS cv.ml::.LogisticRegression : StatModel
[CONST REG_DISABLE=-1, CONST REG_L1=0, CONST REG_L2=1]
[CONST BATCH=0, CONST MINI_BATCH=1]
FUNC <Mat cv.ml.LogisticRegression.get_learnt_thetas []>
java: Mat get_learnt_thetas()
FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.create []>
java: LogisticRegression create()
FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.load [ARG String filepath=, ARG String nodeName=String()]>
java: LogisticRegression load(String filepath, String nodeName)
java: LogisticRegression load(String filepath)
FUNC <TermCriteria cv.ml.LogisticRegression.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.ml.LogisticRegression.getLearningRate []>
java: double getLearningRate()
FUNC <float cv.ml.LogisticRegression.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
FUNC <int cv.ml.LogisticRegression.getIterations []>
java: int getIterations()
FUNC <int cv.ml.LogisticRegression.getMiniBatchSize []>
java: int getMiniBatchSize()
FUNC <int cv.ml.LogisticRegression.getRegularization []>
java: int getRegularization()
FUNC <int cv.ml.LogisticRegression.getTrainMethod []>
java: int getTrainMethod()
FUNC <void cv.ml.LogisticRegression.setIterations [ARG int val=]>
java: void setIterations(int val)
FUNC <void cv.ml.LogisticRegression.setLearningRate [ARG double val=]>
java: void setLearningRate(double val)
FUNC <void cv.ml.LogisticRegression.setMiniBatchSize [ARG int val=]>
java: void setMiniBatchSize(int val)
FUNC <void cv.ml.LogisticRegression.setRegularization [ARG int val=]>
java: void setRegularization(int val)
FUNC <void cv.ml.LogisticRegression.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.LogisticRegression.setTrainMethod [ARG int val=]>
java: void setTrainMethod(int val)
CLASS cv.ml::.ParamGrid : 
FUNC <Ptr_ParamGrid cv.ml.ParamGrid.create [ARG double minVal=0., ARG double maxVal=0., ARG double logstep=1.]>
java: ParamGrid create(double minVal, double maxVal, double logstep)
java: ParamGrid create(double minVal, double maxVal)
java: ParamGrid create(double minVal)
java: ParamGrid create()
FUNC <double cv.ml.ParamGrid.get_minVal []>
java: double get_minVal()
FUNC <void cv.ml.ParamGrid.set_minVal [ARG double minVal=]>
java: void set_minVal(double minVal)
FUNC <double cv.ml.ParamGrid.get_maxVal []>
java: double get_maxVal()
FUNC <void cv.ml.ParamGrid.set_maxVal [ARG double maxVal=]>
java: void set_maxVal(double maxVal)
FUNC <double cv.ml.ParamGrid.get_logStep []>
java: double get_logStep()
FUNC <void cv.ml.ParamGrid.set_logStep [ARG double logStep=]>
java: void set_logStep(double logStep)
CLASS cv.ml::.KNearest : StatModel
[CONST BRUTE_FORCE=1, CONST KDTREE=2]
FUNC <Ptr_KNearest cv.ml.KNearest.create []>
java: KNearest create()
FUNC <Ptr_KNearest cv.ml.KNearest.load [ARG String filepath=]>
java: KNearest load(String filepath)
FUNC <bool cv.ml.KNearest.getIsClassifier []>
java: boolean getIsClassifier()
FUNC <float cv.ml.KNearest.findNearest [ARG Mat samples=, ARG int k=, ARG Mat results=, ARG Mat neighborResponses=Mat(), ARG Mat dist=Mat()]>
java: float findNearest(Mat samples, int k, Mat results, Mat neighborResponses, Mat dist)
java: float findNearest(Mat samples, int k, Mat results, Mat neighborResponses)
java: float findNearest(Mat samples, int k, Mat results)
FUNC <int cv.ml.KNearest.getAlgorithmType []>
java: int getAlgorithmType()
FUNC <int cv.ml.KNearest.getDefaultK []>
java: int getDefaultK()
FUNC <int cv.ml.KNearest.getEmax []>
java: int getEmax()
FUNC <void cv.ml.KNearest.setAlgorithmType [ARG int val=]>
java: void setAlgorithmType(int val)
FUNC <void cv.ml.KNearest.setDefaultK [ARG int val=]>
java: void setDefaultK(int val)
FUNC <void cv.ml.KNearest.setEmax [ARG int val=]>
java: void setEmax(int val)
FUNC <void cv.ml.KNearest.setIsClassifier [ARG bool val=]>
java: void setIsClassifier(boolean val)
CLASS cv.ml::.SVMSGD : StatModel
[CONST SGD=0, CONST ASGD=1]
[CONST SOFT_MARGIN=0, CONST HARD_MARGIN=1]
FUNC <Mat cv.ml.SVMSGD.getWeights []>
java: Mat getWeights()
FUNC <Ptr_SVMSGD cv.ml.SVMSGD.create []>
java: SVMSGD create()
FUNC <Ptr_SVMSGD cv.ml.SVMSGD.load [ARG String filepath=, ARG String nodeName=String()]>
java: SVMSGD load(String filepath, String nodeName)
java: SVMSGD load(String filepath)
FUNC <TermCriteria cv.ml.SVMSGD.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <float cv.ml.SVMSGD.getInitialStepSize []>
java: float getInitialStepSize()
FUNC <float cv.ml.SVMSGD.getMarginRegularization []>
java: float getMarginRegularization()
FUNC <float cv.ml.SVMSGD.getShift []>
java: float getShift()
FUNC <float cv.ml.SVMSGD.getStepDecreasingPower []>
java: float getStepDecreasingPower()
FUNC <int cv.ml.SVMSGD.getMarginType []>
java: int getMarginType()
FUNC <int cv.ml.SVMSGD.getSvmsgdType []>
java: int getSvmsgdType()
FUNC <void cv.ml.SVMSGD.setInitialStepSize [ARG float InitialStepSize=]>
java: void setInitialStepSize(float InitialStepSize)
FUNC <void cv.ml.SVMSGD.setMarginRegularization [ARG float marginRegularization=]>
java: void setMarginRegularization(float marginRegularization)
FUNC <void cv.ml.SVMSGD.setMarginType [ARG int marginType=]>
java: void setMarginType(int marginType)
FUNC <void cv.ml.SVMSGD.setOptimalParameters [ARG int svmsgdType=SVMSGD::ASGD, ARG int marginType=SVMSGD::SOFT_MARGIN]>
java: void setOptimalParameters(int svmsgdType, int marginType)
java: void setOptimalParameters(int svmsgdType)
java: void setOptimalParameters()
FUNC <void cv.ml.SVMSGD.setStepDecreasingPower [ARG float stepDecreasingPower=]>
java: void setStepDecreasingPower(float stepDecreasingPower)
FUNC <void cv.ml.SVMSGD.setSvmsgdType [ARG int svmsgdType=]>
java: void setSvmsgdType(int svmsgdType)
FUNC <void cv.ml.SVMSGD.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
CLASS cv.ml::.DTrees : StatModel
[CONST PREDICT_AUTO=0, CONST PREDICT_SUM=(1<<8), CONST PREDICT_MAX_VOTE=(2<<8), CONST PREDICT_MASK=(3<<8)]
FUNC <Mat cv.ml.DTrees.getPriors []>
java: Mat getPriors()
FUNC <Ptr_DTrees cv.ml.DTrees.create []>
java: DTrees create()
FUNC <Ptr_DTrees cv.ml.DTrees.load [ARG String filepath=, ARG String nodeName=String()]>
java: DTrees load(String filepath, String nodeName)
java: DTrees load(String filepath)
FUNC <bool cv.ml.DTrees.getTruncatePrunedTree []>
java: boolean getTruncatePrunedTree()
FUNC <bool cv.ml.DTrees.getUse1SERule []>
java: boolean getUse1SERule()
FUNC <bool cv.ml.DTrees.getUseSurrogates []>
java: boolean getUseSurrogates()
FUNC <float cv.ml.DTrees.getRegressionAccuracy []>
java: float getRegressionAccuracy()
FUNC <int cv.ml.DTrees.getCVFolds []>
java: int getCVFolds()
FUNC <int cv.ml.DTrees.getMaxCategories []>
java: int getMaxCategories()
FUNC <int cv.ml.DTrees.getMaxDepth []>
java: int getMaxDepth()
FUNC <int cv.ml.DTrees.getMinSampleCount []>
java: int getMinSampleCount()
FUNC <void cv.ml.DTrees.setCVFolds [ARG int val=]>
java: void setCVFolds(int val)
FUNC <void cv.ml.DTrees.setMaxCategories [ARG int val=]>
java: void setMaxCategories(int val)
FUNC <void cv.ml.DTrees.setMaxDepth [ARG int val=]>
java: void setMaxDepth(int val)
FUNC <void cv.ml.DTrees.setMinSampleCount [ARG int val=]>
java: void setMinSampleCount(int val)
FUNC <void cv.ml.DTrees.setPriors [ARG Mat val=]>
java: void setPriors(Mat val)
FUNC <void cv.ml.DTrees.setRegressionAccuracy [ARG float val=]>
java: void setRegressionAccuracy(float val)
FUNC <void cv.ml.DTrees.setTruncatePrunedTree [ARG bool val=]>
java: void setTruncatePrunedTree(boolean val)
FUNC <void cv.ml.DTrees.setUse1SERule [ARG bool val=]>
java: void setUse1SERule(boolean val)
FUNC <void cv.ml.DTrees.setUseSurrogates [ARG bool val=]>
java: void setUseSurrogates(boolean val)
CLASS cv.ml::.ANN_MLP : StatModel
[CONST BACKPROP=0, CONST RPROP=1, CONST ANNEAL=2]
[CONST UPDATE_WEIGHTS=1, CONST NO_INPUT_SCALE=2, CONST NO_OUTPUT_SCALE=4]
[CONST IDENTITY=0, CONST SIGMOID_SYM=1, CONST GAUSSIAN=2, CONST RELU=3, CONST LEAKYRELU=4]
FUNC <Mat cv.ml.ANN_MLP.getLayerSizes []>
java: Mat getLayerSizes()
FUNC <Mat cv.ml.ANN_MLP.getWeights [ARG int layerIdx=]>
java: Mat getWeights(int layerIdx)
FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.create []>
java: ANN_MLP create()
FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.load [ARG String filepath=]>
java: ANN_MLP load(String filepath)
FUNC <TermCriteria cv.ml.ANN_MLP.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.ml.ANN_MLP.getAnnealCoolingRatio []>
java: double getAnnealCoolingRatio()
FUNC <double cv.ml.ANN_MLP.getAnnealFinalT []>
java: double getAnnealFinalT()
FUNC <double cv.ml.ANN_MLP.getAnnealInitialT []>
java: double getAnnealInitialT()
FUNC <double cv.ml.ANN_MLP.getBackpropMomentumScale []>
java: double getBackpropMomentumScale()
FUNC <double cv.ml.ANN_MLP.getBackpropWeightScale []>
java: double getBackpropWeightScale()
FUNC <double cv.ml.ANN_MLP.getRpropDW0 []>
java: double getRpropDW0()
FUNC <double cv.ml.ANN_MLP.getRpropDWMax []>
java: double getRpropDWMax()
FUNC <double cv.ml.ANN_MLP.getRpropDWMin []>
java: double getRpropDWMin()
FUNC <double cv.ml.ANN_MLP.getRpropDWMinus []>
java: double getRpropDWMinus()
FUNC <double cv.ml.ANN_MLP.getRpropDWPlus []>
java: double getRpropDWPlus()
FUNC <int cv.ml.ANN_MLP.getAnnealItePerStep []>
java: int getAnnealItePerStep()
FUNC <int cv.ml.ANN_MLP.getTrainMethod []>
java: int getTrainMethod()
FUNC <void cv.ml.ANN_MLP.setActivationFunction [ARG int type=, ARG double param1=0, ARG double param2=0]>
java: void setActivationFunction(int type, double param1, double param2)
java: void setActivationFunction(int type, double param1)
java: void setActivationFunction(int type)
FUNC <void cv.ml.ANN_MLP.setAnnealCoolingRatio [ARG double val=]>
java: void setAnnealCoolingRatio(double val)
FUNC <void cv.ml.ANN_MLP.setAnnealFinalT [ARG double val=]>
java: void setAnnealFinalT(double val)
FUNC <void cv.ml.ANN_MLP.setAnnealInitialT [ARG double val=]>
java: void setAnnealInitialT(double val)
FUNC <void cv.ml.ANN_MLP.setAnnealItePerStep [ARG int val=]>
java: void setAnnealItePerStep(int val)
FUNC <void cv.ml.ANN_MLP.setBackpropMomentumScale [ARG double val=]>
java: void setBackpropMomentumScale(double val)
FUNC <void cv.ml.ANN_MLP.setBackpropWeightScale [ARG double val=]>
java: void setBackpropWeightScale(double val)
FUNC <void cv.ml.ANN_MLP.setLayerSizes [ARG Mat _layer_sizes=]>
java: void setLayerSizes(Mat _layer_sizes)
FUNC <void cv.ml.ANN_MLP.setRpropDW0 [ARG double val=]>
java: void setRpropDW0(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMax [ARG double val=]>
java: void setRpropDWMax(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMin [ARG double val=]>
java: void setRpropDWMin(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMinus [ARG double val=]>
java: void setRpropDWMinus(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWPlus [ARG double val=]>
java: void setRpropDWPlus(double val)
FUNC <void cv.ml.ANN_MLP.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.ANN_MLP.setTrainMethod [ARG int method=, ARG double param1=0, ARG double param2=0]>
java: void setTrainMethod(int method, double param1, double param2)
java: void setTrainMethod(int method, double param1)
java: void setTrainMethod(int method)
CLASS cv.ml::.StatModel : Algorithm
[CONST UPDATE_MODEL=1, CONST RAW_OUTPUT=1, CONST COMPRESSED_INPUT=2, CONST PREPROCESSED_INPUT=4]
FUNC <bool cv.ml.StatModel.empty []>
java: boolean empty()
FUNC <bool cv.ml.StatModel.isClassifier []>
java: boolean isClassifier()
FUNC <bool cv.ml.StatModel.isTrained []>
java: boolean isTrained()
FUNC <bool cv.ml.StatModel.train [ARG Mat samples=, ARG int layout=, ARG Mat responses=]>
java: boolean train(Mat samples, int layout, Mat responses)
FUNC <bool cv.ml.StatModel.train [ARG Ptr_TrainData trainData=, ARG int flags=0]>
java: boolean train(TrainData trainData, int flags)
java: boolean train(TrainData trainData)
FUNC <float cv.ml.StatModel.calcError [ARG Ptr_TrainData data=, ARG bool test=, ARG Mat resp=]>
java: float calcError(TrainData data, boolean test, Mat resp)
FUNC <float cv.ml.StatModel.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
FUNC <int cv.ml.StatModel.getVarCount []>
java: int getVarCount()
CLASS cv.ml::.RTrees : DTrees
FUNC <Mat cv.ml.RTrees.getVarImportance []>
java: Mat getVarImportance()
FUNC <Ptr_RTrees cv.ml.RTrees.create []>
java: RTrees create()
FUNC <Ptr_RTrees cv.ml.RTrees.load [ARG String filepath=, ARG String nodeName=String()]>
java: RTrees load(String filepath, String nodeName)
java: RTrees load(String filepath)
FUNC <TermCriteria cv.ml.RTrees.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <bool cv.ml.RTrees.getCalculateVarImportance []>
java: boolean getCalculateVarImportance()
FUNC <int cv.ml.RTrees.getActiveVarCount []>
java: int getActiveVarCount()
FUNC <void cv.ml.RTrees.getVotes [ARG Mat samples=, ARG Mat results=, ARG int flags=]>
java: void getVotes(Mat samples, Mat results, int flags)
FUNC <void cv.ml.RTrees.setActiveVarCount [ARG int val=]>
java: void setActiveVarCount(int val)
FUNC <void cv.ml.RTrees.setCalculateVarImportance [ARG bool val=]>
java: void setCalculateVarImportance(boolean val)
FUNC <void cv.ml.RTrees.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)

=== MODULE: phase_unwrapping (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/phase_unwrapping) ===


Files (3):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping/phase_unwrapping.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping/histogramphaseunwrapping.hpp']

Common headers (0):
[]
ok: class CLASS ::.Phase_unwrapping : , name: Phase_unwrapping, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping/phase_unwrapping.hpp =====
Namespaces: set([u'cv', u'cv.phase_unwrapping'])

--- Incoming ---
[u'class cv.phase_unwrapping.PhaseUnwrapping', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.phase_unwrapping::.PhaseUnwrapping : Algorithm, name: PhaseUnwrapping, base: Algorithm

--- Incoming ---
[   u'cv.phase_unwrapping.PhaseUnwrapping.unwrapPhaseMap',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'wrappedPhaseMap', '', []],
        ['Mat', u'unwrappedPhaseMap', '', ['/O']],
        ['Mat', u'shadowMask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.phase_unwrapping.PhaseUnwrapping.unwrapPhaseMap [ARG Mat wrappedPhaseMap=, ARG Mat unwrappedPhaseMap=, ARG Mat shadowMask=Mat()]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping/histogramphaseunwrapping.hpp =====
Namespaces: set([u'cv', u'cv.phase_unwrapping'])

--- Incoming ---
[   u'class cv.phase_unwrapping.HistogramPhaseUnwrapping',
    u': cv::phase_unwrapping::PhaseUnwrapping',
    [],
    [],
    None]
ok: class CLASS cv.phase_unwrapping::.HistogramPhaseUnwrapping : PhaseUnwrapping, name: HistogramPhaseUnwrapping, base: PhaseUnwrapping

--- Incoming ---
[   u'cv.phase_unwrapping.HistogramPhaseUnwrapping.getInverseReliabilityMap',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'reliabilityMap', '', ['/O']]],
    u'void']
ok: FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.getInverseReliabilityMap [ARG Mat reliabilityMap=]>


===== Generating... =====
CLASS cv.phase_unwrapping::.PhaseUnwrapping : Algorithm
FUNC <void cv.phase_unwrapping.PhaseUnwrapping.unwrapPhaseMap [ARG Mat wrappedPhaseMap=, ARG Mat unwrappedPhaseMap=, ARG Mat shadowMask=Mat()]>
java: void unwrapPhaseMap(Mat wrappedPhaseMap, Mat unwrappedPhaseMap, Mat shadowMask)
java: void unwrapPhaseMap(Mat wrappedPhaseMap, Mat unwrappedPhaseMap)
CLASS cv.phase_unwrapping::.HistogramPhaseUnwrapping : PhaseUnwrapping
FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.getInverseReliabilityMap [ARG Mat reliabilityMap=]>
java: void getInverseReliabilityMap(Mat reliabilityMap)
CLASS ::.Phase_unwrapping : 

=== MODULE: photo (/home/borg/404/scripts_robotica/OpenCV/modules/photo) ===


Files (3):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/photo/include/opencv2/photo.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/photo/include/opencv2/photo/cuda.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/photo/include/opencv2/photo/photo.hpp']

Common headers (0):
[]
ok: class CLASS ::.Photo : , name: Photo, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/photo/include/opencv2/photo.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.INPAINT_NS', u'0', [], [], None, ''],
        [u'const cv.INPAINT_TELEA', u'1', [], [], None, '']],
    None]
ok: CONST INPAINT_NS=0
ok: CONST INPAINT_TELEA=1

--- Incoming ---
[   u'cv.inpaint',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'inpaintMask', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'inpaintRadius', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..inpaint [ARG Mat src=, ARG Mat inpaintMask=, ARG Mat dst=, ARG double inpaintRadius=, ARG int flags=]>

--- Incoming ---
[   u'cv.fastNlMeansDenoising',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'h', u'3', []],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   u'cv.fastNlMeansDenoising',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'vector_float', u'h', u'', ['/C', '/Ref']],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []],
        [u'int', u'normType', u'NORM_L2', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>

--- Incoming ---
[   u'cv.fastNlMeansDenoisingColored',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'h', u'3', []],
        [u'float', u'hColor', u'3', []],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoisingColored [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   u'cv.fastNlMeansDenoisingMulti',
    u'void',
    [],
    [   ['vector_Mat', u'srcImgs', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'imgToDenoiseIndex', u'', []],
        [u'int', u'temporalWindowSize', u'', []],
        [u'float', u'h', u'3', []],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   u'cv.fastNlMeansDenoisingMulti',
    u'void',
    [],
    [   ['vector_Mat', u'srcImgs', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'imgToDenoiseIndex', u'', []],
        [u'int', u'temporalWindowSize', u'', []],
        [u'vector_float', u'h', u'', ['/C', '/Ref']],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []],
        [u'int', u'normType', u'NORM_L2', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>

--- Incoming ---
[   u'cv.fastNlMeansDenoisingColoredMulti',
    u'void',
    [],
    [   ['vector_Mat', u'srcImgs', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'imgToDenoiseIndex', u'', []],
        [u'int', u'temporalWindowSize', u'', []],
        [u'float', u'h', u'3', []],
        [u'float', u'hColor', u'3', []],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoisingColoredMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   u'cv.denoise_TVL1',
    u'void',
    [],
    [   [u'vector_Mat', u'observations', u'', ['/C', '/Ref']],
        [u'Mat', u'result', u'', ['/Ref']],
        [u'double', u'lambda', u'1.0', []],
        [u'int', u'niters', u'30', []]],
    u'void']
ok: FUNC <void cv..denoise_TVL1 [ARG vector_Mat observations=, ARG Mat result=, ARG double lambda=1.0, ARG int niters=30]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [[u'const cv.LDR_SIZE', u'256', [], [], None, '']],
    None]
ok: CONST LDR_SIZE=256

--- Incoming ---
[u'class cv.Tonemap', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.Tonemap : Algorithm, name: Tonemap, base: Algorithm

--- Incoming ---
[   u'cv.Tonemap.process',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.Tonemap.process [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[u'cv.Tonemap.getGamma', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.Tonemap.getGamma []>

--- Incoming ---
[   u'cv.Tonemap.setGamma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'gamma', u'', []]],
    u'void']
ok: FUNC <void cv.Tonemap.setGamma [ARG float gamma=]>

--- Incoming ---
[   u'cv.createTonemap',
    u'Ptr_Tonemap',
    [],
    [[u'float', u'gamma', u'1.0f', []]],
    u'Ptr<Tonemap>']
ok: FUNC <Ptr_Tonemap cv..createTonemap [ARG float gamma=1.0f]>

--- Incoming ---
[u'class cv.TonemapDrago', u': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapDrago : Tonemap, name: TonemapDrago, base: Tonemap

--- Incoming ---
[u'cv.TonemapDrago.getSaturation', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.TonemapDrago.getSaturation []>

--- Incoming ---
[   u'cv.TonemapDrago.setSaturation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'saturation', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapDrago.setSaturation [ARG float saturation=]>

--- Incoming ---
[u'cv.TonemapDrago.getBias', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.TonemapDrago.getBias []>

--- Incoming ---
[   u'cv.TonemapDrago.setBias',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'bias', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapDrago.setBias [ARG float bias=]>

--- Incoming ---
[   u'cv.createTonemapDrago',
    u'Ptr_TonemapDrago',
    [],
    [   [u'float', u'gamma', u'1.0f', []],
        [u'float', u'saturation', u'1.0f', []],
        [u'float', u'bias', u'0.85f', []]],
    u'Ptr<TonemapDrago>']
ok: FUNC <Ptr_TonemapDrago cv..createTonemapDrago [ARG float gamma=1.0f, ARG float saturation=1.0f, ARG float bias=0.85f]>

--- Incoming ---
[u'class cv.TonemapReinhard', u': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapReinhard : Tonemap, name: TonemapReinhard, base: Tonemap

--- Incoming ---
[   u'cv.TonemapReinhard.getIntensity',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.TonemapReinhard.getIntensity []>

--- Incoming ---
[   u'cv.TonemapReinhard.setIntensity',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'intensity', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapReinhard.setIntensity [ARG float intensity=]>

--- Incoming ---
[   u'cv.TonemapReinhard.getLightAdaptation',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.TonemapReinhard.getLightAdaptation []>

--- Incoming ---
[   u'cv.TonemapReinhard.setLightAdaptation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'light_adapt', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapReinhard.setLightAdaptation [ARG float light_adapt=]>

--- Incoming ---
[   u'cv.TonemapReinhard.getColorAdaptation',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.TonemapReinhard.getColorAdaptation []>

--- Incoming ---
[   u'cv.TonemapReinhard.setColorAdaptation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'color_adapt', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapReinhard.setColorAdaptation [ARG float color_adapt=]>

--- Incoming ---
[   u'cv.createTonemapReinhard',
    u'Ptr_TonemapReinhard',
    [],
    [   [u'float', u'gamma', u'1.0f', []],
        [u'float', u'intensity', u'0.0f', []],
        [u'float', u'light_adapt', u'1.0f', []],
        [u'float', u'color_adapt', u'0.0f', []]],
    u'Ptr<TonemapReinhard>']
ok: FUNC <Ptr_TonemapReinhard cv..createTonemapReinhard [ARG float gamma=1.0f, ARG float intensity=0.0f, ARG float light_adapt=1.0f, ARG float color_adapt=0.0f]>

--- Incoming ---
[u'class cv.TonemapMantiuk', u': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapMantiuk : Tonemap, name: TonemapMantiuk, base: Tonemap

--- Incoming ---
[u'cv.TonemapMantiuk.getScale', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.TonemapMantiuk.getScale []>

--- Incoming ---
[   u'cv.TonemapMantiuk.setScale',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'scale', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapMantiuk.setScale [ARG float scale=]>

--- Incoming ---
[   u'cv.TonemapMantiuk.getSaturation',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.TonemapMantiuk.getSaturation []>

--- Incoming ---
[   u'cv.TonemapMantiuk.setSaturation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'saturation', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapMantiuk.setSaturation [ARG float saturation=]>

--- Incoming ---
[   u'cv.createTonemapMantiuk',
    u'Ptr_TonemapMantiuk',
    [],
    [   [u'float', u'gamma', u'1.0f', []],
        [u'float', u'scale', u'0.7f', []],
        [u'float', u'saturation', u'1.0f', []]],
    u'Ptr<TonemapMantiuk>']
ok: FUNC <Ptr_TonemapMantiuk cv..createTonemapMantiuk [ARG float gamma=1.0f, ARG float scale=0.7f, ARG float saturation=1.0f]>

--- Incoming ---
[u'class cv.AlignExposures', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.AlignExposures : Algorithm, name: AlignExposures, base: Algorithm

--- Incoming ---
[   u'cv.AlignExposures.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        [u'vector_Mat', u'dst', u'', ['/Ref']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.AlignExposures.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[u'class cv.AlignMTB', u': cv::AlignExposures', [], [], None]
ok: class CLASS cv::.AlignMTB : AlignExposures, name: AlignMTB, base: AlignExposures

--- Incoming ---
[   u'cv.AlignMTB.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        [u'vector_Mat', u'dst', u'', ['/Ref']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   u'cv.AlignMTB.process',
    u'void',
    ['/V', '/PV'],
    [['vector_Mat', u'src', '', []], [u'vector_Mat', u'dst', u'', ['/Ref']]],
    u'void']
ok: FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=]>

--- Incoming ---
[   u'cv.AlignMTB.calculateShift',
    u'Point',
    ['/V', '/PV'],
    [['Mat', u'img0', '', []], ['Mat', u'img1', '', []]],
    u'Point']
ok: FUNC <Point cv.AlignMTB.calculateShift [ARG Mat img0=, ARG Mat img1=]>

--- Incoming ---
[   u'cv.AlignMTB.shiftMat',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Point', u'shift', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.AlignMTB.shiftMat [ARG Mat src=, ARG Mat dst=, ARG Point shift=]>

--- Incoming ---
[   u'cv.AlignMTB.computeBitmaps',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'img', '', []],
        ['Mat', u'tb', '', ['/O']],
        ['Mat', u'eb', '', ['/O']]],
    u'void']
ok: FUNC <void cv.AlignMTB.computeBitmaps [ARG Mat img=, ARG Mat tb=, ARG Mat eb=]>

--- Incoming ---
[u'cv.AlignMTB.getMaxBits', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AlignMTB.getMaxBits []>

--- Incoming ---
[   u'cv.AlignMTB.setMaxBits',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'max_bits', u'', []]],
    u'void']
ok: FUNC <void cv.AlignMTB.setMaxBits [ARG int max_bits=]>

--- Incoming ---
[u'cv.AlignMTB.getExcludeRange', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AlignMTB.getExcludeRange []>

--- Incoming ---
[   u'cv.AlignMTB.setExcludeRange',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'exclude_range', u'', []]],
    u'void']
ok: FUNC <void cv.AlignMTB.setExcludeRange [ARG int exclude_range=]>

--- Incoming ---
[u'cv.AlignMTB.getCut', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.AlignMTB.getCut []>

--- Incoming ---
[   u'cv.AlignMTB.setCut',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.AlignMTB.setCut [ARG bool value=]>

--- Incoming ---
[   u'cv.createAlignMTB',
    u'Ptr_AlignMTB',
    [],
    [   [u'int', u'max_bits', u'6', []],
        [u'int', u'exclude_range', u'4', []],
        [u'bool', u'cut', u'true', []]],
    u'Ptr<AlignMTB>']
ok: FUNC <Ptr_AlignMTB cv..createAlignMTB [ARG int max_bits=6, ARG int exclude_range=4, ARG bool cut=true]>

--- Incoming ---
[u'class cv.CalibrateCRF', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.CalibrateCRF : Algorithm, name: CalibrateCRF, base: Algorithm

--- Incoming ---
[   u'cv.CalibrateCRF.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []]],
    u'void']
ok: FUNC <void cv.CalibrateCRF.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
[u'class cv.CalibrateDebevec', u': cv::CalibrateCRF', [], [], None]
ok: class CLASS cv::.CalibrateDebevec : CalibrateCRF, name: CalibrateDebevec, base: CalibrateCRF

--- Incoming ---
[u'cv.CalibrateDebevec.getLambda', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.CalibrateDebevec.getLambda []>

--- Incoming ---
[   u'cv.CalibrateDebevec.setLambda',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'lambda', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateDebevec.setLambda [ARG float lambda=]>

--- Incoming ---
[u'cv.CalibrateDebevec.getSamples', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.CalibrateDebevec.getSamples []>

--- Incoming ---
[   u'cv.CalibrateDebevec.setSamples',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'samples', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateDebevec.setSamples [ARG int samples=]>

--- Incoming ---
[u'cv.CalibrateDebevec.getRandom', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.CalibrateDebevec.getRandom []>

--- Incoming ---
[   u'cv.CalibrateDebevec.setRandom',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'random', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateDebevec.setRandom [ARG bool random=]>

--- Incoming ---
[   u'cv.createCalibrateDebevec',
    u'Ptr_CalibrateDebevec',
    [],
    [   [u'int', u'samples', u'70', []],
        [u'float', u'lambda', u'10.0f', []],
        [u'bool', u'random', u'false', []]],
    u'Ptr<CalibrateDebevec>']
ok: FUNC <Ptr_CalibrateDebevec cv..createCalibrateDebevec [ARG int samples=70, ARG float lambda=10.0f, ARG bool random=false]>

--- Incoming ---
[u'class cv.CalibrateRobertson', u': cv::CalibrateCRF', [], [], None]
ok: class CLASS cv::.CalibrateRobertson : CalibrateCRF, name: CalibrateRobertson, base: CalibrateCRF

--- Incoming ---
[u'cv.CalibrateRobertson.getMaxIter', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.CalibrateRobertson.getMaxIter []>

--- Incoming ---
[   u'cv.CalibrateRobertson.setMaxIter',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'max_iter', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateRobertson.setMaxIter [ARG int max_iter=]>

--- Incoming ---
[   u'cv.CalibrateRobertson.getThreshold',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.CalibrateRobertson.getThreshold []>

--- Incoming ---
[   u'cv.CalibrateRobertson.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateRobertson.setThreshold [ARG float threshold=]>

--- Incoming ---
[u'cv.CalibrateRobertson.getRadiance', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.CalibrateRobertson.getRadiance []>

--- Incoming ---
[   u'cv.createCalibrateRobertson',
    u'Ptr_CalibrateRobertson',
    [],
    [[u'int', u'max_iter', u'30', []], [u'float', u'threshold', u'0.01f', []]],
    u'Ptr<CalibrateRobertson>']
ok: FUNC <Ptr_CalibrateRobertson cv..createCalibrateRobertson [ARG int max_iter=30, ARG float threshold=0.01f]>

--- Incoming ---
[u'class cv.MergeExposures', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.MergeExposures : Algorithm, name: MergeExposures, base: Algorithm

--- Incoming ---
[   u'cv.MergeExposures.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.MergeExposures.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[u'class cv.MergeDebevec', u': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeDebevec : MergeExposures, name: MergeDebevec, base: MergeExposures

--- Incoming ---
[   u'cv.MergeDebevec.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   u'cv.MergeDebevec.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []]],
    u'void']
ok: FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
[u'cv.createMergeDebevec', u'Ptr_MergeDebevec', [], [], u'Ptr<MergeDebevec>']
ok: FUNC <Ptr_MergeDebevec cv..createMergeDebevec []>

--- Incoming ---
[u'class cv.MergeMertens', u': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeMertens : MergeExposures, name: MergeMertens, base: MergeExposures

--- Incoming ---
[   u'cv.MergeMertens.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   u'cv.MergeMertens.process',
    u'void',
    ['/V', '/PV'],
    [['vector_Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.MergeMertens.getContrastWeight',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.MergeMertens.getContrastWeight []>

--- Incoming ---
[   u'cv.MergeMertens.setContrastWeight',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'contrast_weiht', u'', []]],
    u'void']
ok: FUNC <void cv.MergeMertens.setContrastWeight [ARG float contrast_weiht=]>

--- Incoming ---
[   u'cv.MergeMertens.getSaturationWeight',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.MergeMertens.getSaturationWeight []>

--- Incoming ---
[   u'cv.MergeMertens.setSaturationWeight',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'saturation_weight', u'', []]],
    u'void']
ok: FUNC <void cv.MergeMertens.setSaturationWeight [ARG float saturation_weight=]>

--- Incoming ---
[   u'cv.MergeMertens.getExposureWeight',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.MergeMertens.getExposureWeight []>

--- Incoming ---
[   u'cv.MergeMertens.setExposureWeight',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'exposure_weight', u'', []]],
    u'void']
ok: FUNC <void cv.MergeMertens.setExposureWeight [ARG float exposure_weight=]>

--- Incoming ---
[   u'cv.createMergeMertens',
    u'Ptr_MergeMertens',
    [],
    [   [u'float', u'contrast_weight', u'1.0f', []],
        [u'float', u'saturation_weight', u'1.0f', []],
        [u'float', u'exposure_weight', u'0.0f', []]],
    u'Ptr<MergeMertens>']
ok: FUNC <Ptr_MergeMertens cv..createMergeMertens [ARG float contrast_weight=1.0f, ARG float saturation_weight=1.0f, ARG float exposure_weight=0.0f]>

--- Incoming ---
[u'class cv.MergeRobertson', u': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeRobertson : MergeExposures, name: MergeRobertson, base: MergeExposures

--- Incoming ---
[   u'cv.MergeRobertson.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   u'cv.MergeRobertson.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []]],
    u'void']
ok: FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
[   u'cv.createMergeRobertson',
    u'Ptr_MergeRobertson',
    [],
    [],
    u'Ptr<MergeRobertson>']
ok: FUNC <Ptr_MergeRobertson cv..createMergeRobertson []>

--- Incoming ---
[   u'cv.decolor',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'grayscale', '', ['/O']],
        ['Mat', u'color_boost', '', ['/O']]],
    u'void']
ok: FUNC <void cv..decolor [ARG Mat src=, ARG Mat grayscale=, ARG Mat color_boost=]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.NORMAL_CLONE', u'1', [], [], None, ''],
        [u'const cv.MIXED_CLONE', u'2', [], [], None, ''],
        [u'const cv.MONOCHROME_TRANSFER', u'3', [], [], None, '']],
    None]
ok: CONST NORMAL_CLONE=1
ok: CONST MIXED_CLONE=2
ok: CONST MONOCHROME_TRANSFER=3

--- Incoming ---
[   u'cv.seamlessClone',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        ['Mat', u'mask', '', []],
        [u'Point', u'p', u'', []],
        ['Mat', u'blend', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..seamlessClone [ARG Mat src=, ARG Mat dst=, ARG Mat mask=, ARG Point p=, ARG Mat blend=, ARG int flags=]>

--- Incoming ---
[   u'cv.colorChange',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mask', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'red_mul', u'1.0f', []],
        [u'float', u'green_mul', u'1.0f', []],
        [u'float', u'blue_mul', u'1.0f', []]],
    u'void']
ok: FUNC <void cv..colorChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float red_mul=1.0f, ARG float green_mul=1.0f, ARG float blue_mul=1.0f]>

--- Incoming ---
[   u'cv.illuminationChange',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mask', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'alpha', u'0.2f', []],
        [u'float', u'beta', u'0.4f', []]],
    u'void']
ok: FUNC <void cv..illuminationChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float alpha=0.2f, ARG float beta=0.4f]>

--- Incoming ---
[   u'cv.textureFlattening',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mask', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'low_threshold', u'30', []],
        [u'float', u'high_threshold', u'45', []],
        [u'int', u'kernel_size', u'3', []]],
    u'void']
ok: FUNC <void cv..textureFlattening [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float low_threshold=30, ARG float high_threshold=45, ARG int kernel_size=3]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.RECURS_FILTER', u'1', [], [], None, ''],
        [u'const cv.NORMCONV_FILTER', u'2', [], [], None, '']],
    None]
ok: CONST RECURS_FILTER=1
ok: CONST NORMCONV_FILTER=2

--- Incoming ---
[   u'cv.edgePreservingFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'1', []],
        [u'float', u'sigma_s', u'60', []],
        [u'float', u'sigma_r', u'0.4f', []]],
    u'void']
ok: FUNC <void cv..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int flags=1, ARG float sigma_s=60, ARG float sigma_r=0.4f]>

--- Incoming ---
[   u'cv.detailEnhance',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'sigma_s', u'10', []],
        [u'float', u'sigma_r', u'0.15f', []]],
    u'void']
ok: FUNC <void cv..detailEnhance [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=10, ARG float sigma_r=0.15f]>

--- Incoming ---
[   u'cv.pencilSketch',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst1', '', ['/O']],
        ['Mat', u'dst2', '', ['/O']],
        [u'float', u'sigma_s', u'60', []],
        [u'float', u'sigma_r', u'0.07f', []],
        [u'float', u'shade_factor', u'0.02f', []]],
    u'void']
ok: FUNC <void cv..pencilSketch [ARG Mat src=, ARG Mat dst1=, ARG Mat dst2=, ARG float sigma_s=60, ARG float sigma_r=0.07f, ARG float shade_factor=0.02f]>

--- Incoming ---
[   u'cv.stylization',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'sigma_s', u'60', []],
        [u'float', u'sigma_r', u'0.45f', []]],
    u'void']
ok: FUNC <void cv..stylization [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=60, ARG float sigma_r=0.45f]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/photo/include/opencv2/photo/cuda.hpp =====
Namespaces: set([u'cv.cuda', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/photo/include/opencv2/photo/cuda.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/photo/include/opencv2/photo/photo.hpp =====
Namespaces: set([u'cv.cuda', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/photo/include/opencv2/photo/photo.hpp


===== Generating... =====
CLASS cv::.MergeMertens : MergeExposures
FUNC <float cv.MergeMertens.getContrastWeight []>
java: float getContrastWeight()
FUNC <float cv.MergeMertens.getExposureWeight []>
java: float getExposureWeight()
FUNC <float cv.MergeMertens.getSaturationWeight []>
java: float getSaturationWeight()
FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=]>
java: void process(List<Mat> src, Mat dst)
FUNC <void cv.MergeMertens.setContrastWeight [ARG float contrast_weiht=]>
java: void setContrastWeight(float contrast_weiht)
FUNC <void cv.MergeMertens.setExposureWeight [ARG float exposure_weight=]>
java: void setExposureWeight(float exposure_weight)
FUNC <void cv.MergeMertens.setSaturationWeight [ARG float saturation_weight=]>
java: void setSaturationWeight(float saturation_weight)
CLASS cv::.TonemapMantiuk : Tonemap
FUNC <float cv.TonemapMantiuk.getSaturation []>
java: float getSaturation()
FUNC <float cv.TonemapMantiuk.getScale []>
java: float getScale()
FUNC <void cv.TonemapMantiuk.setSaturation [ARG float saturation=]>
java: void setSaturation(float saturation)
FUNC <void cv.TonemapMantiuk.setScale [ARG float scale=]>
java: void setScale(float scale)
CLASS cv::.CalibrateRobertson : CalibrateCRF
FUNC <Mat cv.CalibrateRobertson.getRadiance []>
java: Mat getRadiance()
FUNC <float cv.CalibrateRobertson.getThreshold []>
java: float getThreshold()
FUNC <int cv.CalibrateRobertson.getMaxIter []>
java: int getMaxIter()
FUNC <void cv.CalibrateRobertson.setMaxIter [ARG int max_iter=]>
java: void setMaxIter(int max_iter)
FUNC <void cv.CalibrateRobertson.setThreshold [ARG float threshold=]>
java: void setThreshold(float threshold)
CLASS cv::.CalibrateDebevec : CalibrateCRF
FUNC <bool cv.CalibrateDebevec.getRandom []>
java: boolean getRandom()
FUNC <float cv.CalibrateDebevec.getLambda []>
java: float getLambda()
FUNC <int cv.CalibrateDebevec.getSamples []>
java: int getSamples()
FUNC <void cv.CalibrateDebevec.setLambda [ARG float lambda=]>
java: void setLambda(float lambda)
FUNC <void cv.CalibrateDebevec.setRandom [ARG bool random=]>
java: void setRandom(boolean random)
FUNC <void cv.CalibrateDebevec.setSamples [ARG int samples=]>
java: void setSamples(int samples)
CLASS cv::.TonemapReinhard : Tonemap
FUNC <float cv.TonemapReinhard.getColorAdaptation []>
java: float getColorAdaptation()
FUNC <float cv.TonemapReinhard.getIntensity []>
java: float getIntensity()
FUNC <float cv.TonemapReinhard.getLightAdaptation []>
java: float getLightAdaptation()
FUNC <void cv.TonemapReinhard.setColorAdaptation [ARG float color_adapt=]>
java: void setColorAdaptation(float color_adapt)
FUNC <void cv.TonemapReinhard.setIntensity [ARG float intensity=]>
java: void setIntensity(float intensity)
FUNC <void cv.TonemapReinhard.setLightAdaptation [ARG float light_adapt=]>
java: void setLightAdaptation(float light_adapt)
CLASS ::.Photo : 
[CONST INPAINT_NS=0, CONST INPAINT_TELEA=1, CONST LDR_SIZE=256, CONST NORMAL_CLONE=1, CONST MIXED_CLONE=2, CONST MONOCHROME_TRANSFER=3, CONST RECURS_FILTER=1, CONST NORMCONV_FILTER=2]
FUNC <Ptr_AlignMTB cv..createAlignMTB [ARG int max_bits=6, ARG int exclude_range=4, ARG bool cut=true]>
java: AlignMTB createAlignMTB(int max_bits, int exclude_range, boolean cut)
java: AlignMTB createAlignMTB(int max_bits, int exclude_range)
java: AlignMTB createAlignMTB(int max_bits)
java: AlignMTB createAlignMTB()
FUNC <Ptr_CalibrateDebevec cv..createCalibrateDebevec [ARG int samples=70, ARG float lambda=10.0f, ARG bool random=false]>
java: CalibrateDebevec createCalibrateDebevec(int samples, float lambda, boolean random)
java: CalibrateDebevec createCalibrateDebevec(int samples, float lambda)
java: CalibrateDebevec createCalibrateDebevec(int samples)
java: CalibrateDebevec createCalibrateDebevec()
FUNC <Ptr_CalibrateRobertson cv..createCalibrateRobertson [ARG int max_iter=30, ARG float threshold=0.01f]>
java: CalibrateRobertson createCalibrateRobertson(int max_iter, float threshold)
java: CalibrateRobertson createCalibrateRobertson(int max_iter)
java: CalibrateRobertson createCalibrateRobertson()
FUNC <Ptr_MergeDebevec cv..createMergeDebevec []>
java: MergeDebevec createMergeDebevec()
FUNC <Ptr_MergeMertens cv..createMergeMertens [ARG float contrast_weight=1.0f, ARG float saturation_weight=1.0f, ARG float exposure_weight=0.0f]>
java: MergeMertens createMergeMertens(float contrast_weight, float saturation_weight, float exposure_weight)
java: MergeMertens createMergeMertens(float contrast_weight, float saturation_weight)
java: MergeMertens createMergeMertens(float contrast_weight)
java: MergeMertens createMergeMertens()
FUNC <Ptr_MergeRobertson cv..createMergeRobertson []>
java: MergeRobertson createMergeRobertson()
FUNC <Ptr_Tonemap cv..createTonemap [ARG float gamma=1.0f]>
java: Tonemap createTonemap(float gamma)
java: Tonemap createTonemap()
FUNC <Ptr_TonemapDrago cv..createTonemapDrago [ARG float gamma=1.0f, ARG float saturation=1.0f, ARG float bias=0.85f]>
java: TonemapDrago createTonemapDrago(float gamma, float saturation, float bias)
java: TonemapDrago createTonemapDrago(float gamma, float saturation)
java: TonemapDrago createTonemapDrago(float gamma)
java: TonemapDrago createTonemapDrago()
FUNC <Ptr_TonemapMantiuk cv..createTonemapMantiuk [ARG float gamma=1.0f, ARG float scale=0.7f, ARG float saturation=1.0f]>
java: TonemapMantiuk createTonemapMantiuk(float gamma, float scale, float saturation)
java: TonemapMantiuk createTonemapMantiuk(float gamma, float scale)
java: TonemapMantiuk createTonemapMantiuk(float gamma)
java: TonemapMantiuk createTonemapMantiuk()
FUNC <Ptr_TonemapReinhard cv..createTonemapReinhard [ARG float gamma=1.0f, ARG float intensity=0.0f, ARG float light_adapt=1.0f, ARG float color_adapt=0.0f]>
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity, float light_adapt, float color_adapt)
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity, float light_adapt)
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity)
java: TonemapReinhard createTonemapReinhard(float gamma)
java: TonemapReinhard createTonemapReinhard()
FUNC <void cv..colorChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float red_mul=1.0f, ARG float green_mul=1.0f, ARG float blue_mul=1.0f]>
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul, float green_mul, float blue_mul)
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul, float green_mul)
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul)
java: void colorChange(Mat src, Mat mask, Mat dst)
FUNC <void cv..decolor [ARG Mat src=, ARG Mat grayscale=, ARG Mat color_boost=]>
java: void decolor(Mat src, Mat grayscale, Mat color_boost)
FUNC <void cv..denoise_TVL1 [ARG vector_Mat observations=, ARG Mat result=, ARG double lambda=1.0, ARG int niters=30]>
java: void denoise_TVL1(List<Mat> observations, Mat result, double lambda, int niters)
java: void denoise_TVL1(List<Mat> observations, Mat result, double lambda)
java: void denoise_TVL1(List<Mat> observations, Mat result)
FUNC <void cv..detailEnhance [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=10, ARG float sigma_r=0.15f]>
java: void detailEnhance(Mat src, Mat dst, float sigma_s, float sigma_r)
java: void detailEnhance(Mat src, Mat dst, float sigma_s)
java: void detailEnhance(Mat src, Mat dst)
FUNC <void cv..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int flags=1, ARG float sigma_s=60, ARG float sigma_r=0.4f]>
java: void edgePreservingFilter(Mat src, Mat dst, int flags, float sigma_s, float sigma_r)
java: void edgePreservingFilter(Mat src, Mat dst, int flags, float sigma_s)
java: void edgePreservingFilter(Mat src, Mat dst, int flags)
java: void edgePreservingFilter(Mat src, Mat dst)
FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, float h, int templateWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, float h)
java: void fastNlMeansDenoising(Mat src, Mat dst)
FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize, int searchWindowSize, int normType)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h)
FUNC <void cv..fastNlMeansDenoisingColored [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor, int templateWindowSize)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst)
FUNC <void cv..fastNlMeansDenoisingColoredMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor, int templateWindowSize)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize)
FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, int templateWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize)
FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize, int searchWindowSize, int normType)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h)
FUNC <void cv..illuminationChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float alpha=0.2f, ARG float beta=0.4f]>
java: void illuminationChange(Mat src, Mat mask, Mat dst, float alpha, float beta)
java: void illuminationChange(Mat src, Mat mask, Mat dst, float alpha)
java: void illuminationChange(Mat src, Mat mask, Mat dst)
FUNC <void cv..inpaint [ARG Mat src=, ARG Mat inpaintMask=, ARG Mat dst=, ARG double inpaintRadius=, ARG int flags=]>
java: void inpaint(Mat src, Mat inpaintMask, Mat dst, double inpaintRadius, int flags)
FUNC <void cv..pencilSketch [ARG Mat src=, ARG Mat dst1=, ARG Mat dst2=, ARG float sigma_s=60, ARG float sigma_r=0.07f, ARG float shade_factor=0.02f]>
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s, float sigma_r, float shade_factor)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s, float sigma_r)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2)
FUNC <void cv..seamlessClone [ARG Mat src=, ARG Mat dst=, ARG Mat mask=, ARG Point p=, ARG Mat blend=, ARG int flags=]>
java: void seamlessClone(Mat src, Mat dst, Mat mask, Point p, Mat blend, int flags)
FUNC <void cv..stylization [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=60, ARG float sigma_r=0.45f]>
java: void stylization(Mat src, Mat dst, float sigma_s, float sigma_r)
java: void stylization(Mat src, Mat dst, float sigma_s)
java: void stylization(Mat src, Mat dst)
FUNC <void cv..textureFlattening [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float low_threshold=30, ARG float high_threshold=45, ARG int kernel_size=3]>
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold, float high_threshold, int kernel_size)
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold, float high_threshold)
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold)
java: void textureFlattening(Mat src, Mat mask, Mat dst)
CLASS cv::.AlignExposures : Algorithm
FUNC <void cv.AlignExposures.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, List<Mat> dst, Mat times, Mat response)
CLASS cv::.CalibrateCRF : Algorithm
FUNC <void cv.CalibrateCRF.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.TonemapDrago : Tonemap
FUNC <float cv.TonemapDrago.getBias []>
java: float getBias()
FUNC <float cv.TonemapDrago.getSaturation []>
java: float getSaturation()
FUNC <void cv.TonemapDrago.setBias [ARG float bias=]>
java: void setBias(float bias)
FUNC <void cv.TonemapDrago.setSaturation [ARG float saturation=]>
java: void setSaturation(float saturation)
CLASS cv::.AlignMTB : AlignExposures
FUNC <Point cv.AlignMTB.calculateShift [ARG Mat img0=, ARG Mat img1=]>
java: Point calculateShift(Mat img0, Mat img1)
FUNC <bool cv.AlignMTB.getCut []>
java: boolean getCut()
FUNC <int cv.AlignMTB.getExcludeRange []>
java: int getExcludeRange()
FUNC <int cv.AlignMTB.getMaxBits []>
java: int getMaxBits()
FUNC <void cv.AlignMTB.computeBitmaps [ARG Mat img=, ARG Mat tb=, ARG Mat eb=]>
java: void computeBitmaps(Mat img, Mat tb, Mat eb)
FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, List<Mat> dst, Mat times, Mat response)
FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=]>
java: void process(List<Mat> src, List<Mat> dst)
FUNC <void cv.AlignMTB.setCut [ARG bool value=]>
java: void setCut(boolean value)
FUNC <void cv.AlignMTB.setExcludeRange [ARG int exclude_range=]>
java: void setExcludeRange(int exclude_range)
FUNC <void cv.AlignMTB.setMaxBits [ARG int max_bits=]>
java: void setMaxBits(int max_bits)
FUNC <void cv.AlignMTB.shiftMat [ARG Mat src=, ARG Mat dst=, ARG Point shift=]>
java: void shiftMat(Mat src, Mat dst, Point shift)
CLASS cv::.MergeDebevec : MergeExposures
FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.MergeExposures : Algorithm
FUNC <void cv.MergeExposures.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
CLASS cv::.MergeRobertson : MergeExposures
FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.Tonemap : Algorithm
FUNC <float cv.Tonemap.getGamma []>
java: float getGamma()
FUNC <void cv.Tonemap.process [ARG Mat src=, ARG Mat dst=]>
java: void process(Mat src, Mat dst)
FUNC <void cv.Tonemap.setGamma [ARG float gamma=]>
java: void setGamma(float gamma)

=== MODULE: plot (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/plot) ===


Files (1):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/plot/include/opencv2/plot.hpp']

Common headers (0):
[]
ok: class CLASS ::.Plot : , name: Plot, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/plot/include/opencv2/plot.hpp =====
Namespaces: set([u'cv', u'cv.plot'])

--- Incoming ---
[u'class cv.plot.Plot2d', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.plot::.Plot2d : Algorithm, name: Plot2d, base: Algorithm

--- Incoming ---
[   u'cv.plot.Plot2d.setMinX',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_plotMinX', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setMinX [ARG double _plotMinX=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setMinY',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_plotMinY', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setMinY [ARG double _plotMinY=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setMaxX',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_plotMaxX', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setMaxX [ARG double _plotMaxX=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setMaxY',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_plotMaxY', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setMaxY [ARG double _plotMaxY=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setPlotLineWidth',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_plotLineWidth', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setPlotLineWidth [ARG int _plotLineWidth=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setNeedPlotLine',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'_needPlotLine', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setNeedPlotLine [ARG bool _needPlotLine=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setPlotLineColor',
    u'void',
    ['/V', '/PV'],
    [[u'Scalar', u'_plotLineColor', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setPlotLineColor [ARG Scalar _plotLineColor=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setPlotBackgroundColor',
    u'void',
    ['/V', '/PV'],
    [[u'Scalar', u'_plotBackgroundColor', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setPlotBackgroundColor [ARG Scalar _plotBackgroundColor=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setPlotAxisColor',
    u'void',
    ['/V', '/PV'],
    [[u'Scalar', u'_plotAxisColor', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setPlotAxisColor [ARG Scalar _plotAxisColor=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setPlotGridColor',
    u'void',
    ['/V', '/PV'],
    [[u'Scalar', u'_plotGridColor', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setPlotGridColor [ARG Scalar _plotGridColor=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setPlotTextColor',
    u'void',
    ['/V', '/PV'],
    [[u'Scalar', u'_plotTextColor', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setPlotTextColor [ARG Scalar _plotTextColor=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setPlotSize',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'_plotSizeWidth', u'', []],
        [u'int', u'_plotSizeHeight', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setPlotSize [ARG int _plotSizeWidth=, ARG int _plotSizeHeight=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setShowGrid',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'needShowGrid', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setShowGrid [ARG bool needShowGrid=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setShowText',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'needShowText', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setShowText [ARG bool needShowText=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setGridLinesNumber',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'gridLinesNumber', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setGridLinesNumber [ARG int gridLinesNumber=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setInvertOrientation',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'_invertOrientation', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setInvertOrientation [ARG bool _invertOrientation=]>

--- Incoming ---
[   u'cv.plot.Plot2d.setPointIdxToPrint',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'pointIdx', u'', []]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.setPointIdxToPrint [ARG int pointIdx=]>

--- Incoming ---
[   u'cv.plot.Plot2d.render',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'_plotResult', '', ['/O']]],
    u'void']
ok: FUNC <void cv.plot.Plot2d.render [ARG Mat _plotResult=]>

--- Incoming ---
[   u'cv.plot.Plot2d.create',
    u'Ptr_Plot2d',
    ['/S'],
    [['Mat', u'data', '', []]],
    u'Ptr<Plot2d>']
ok: FUNC <Ptr_Plot2d cv.plot.Plot2d.create [ARG Mat data=]>

--- Incoming ---
[   u'cv.plot.Plot2d.create',
    u'Ptr_Plot2d',
    ['/S'],
    [['Mat', u'dataX', '', []], ['Mat', u'dataY', '', []]],
    u'Ptr<Plot2d>']
ok: FUNC <Ptr_Plot2d cv.plot.Plot2d.create [ARG Mat dataX=, ARG Mat dataY=]>


===== Generating... =====
CLASS ::.Plot : 
CLASS cv.plot::.Plot2d : Algorithm
FUNC <Ptr_Plot2d cv.plot.Plot2d.create [ARG Mat data=]>
java: Plot2d create(Mat data)
FUNC <Ptr_Plot2d cv.plot.Plot2d.create [ARG Mat dataX=, ARG Mat dataY=]>
java: Plot2d create(Mat dataX, Mat dataY)
FUNC <void cv.plot.Plot2d.render [ARG Mat _plotResult=]>
java: void render(Mat _plotResult)
FUNC <void cv.plot.Plot2d.setGridLinesNumber [ARG int gridLinesNumber=]>
java: void setGridLinesNumber(int gridLinesNumber)
FUNC <void cv.plot.Plot2d.setInvertOrientation [ARG bool _invertOrientation=]>
java: void setInvertOrientation(boolean _invertOrientation)
FUNC <void cv.plot.Plot2d.setMaxX [ARG double _plotMaxX=]>
java: void setMaxX(double _plotMaxX)
FUNC <void cv.plot.Plot2d.setMaxY [ARG double _plotMaxY=]>
java: void setMaxY(double _plotMaxY)
FUNC <void cv.plot.Plot2d.setMinX [ARG double _plotMinX=]>
java: void setMinX(double _plotMinX)
FUNC <void cv.plot.Plot2d.setMinY [ARG double _plotMinY=]>
java: void setMinY(double _plotMinY)
FUNC <void cv.plot.Plot2d.setNeedPlotLine [ARG bool _needPlotLine=]>
java: void setNeedPlotLine(boolean _needPlotLine)
FUNC <void cv.plot.Plot2d.setPlotAxisColor [ARG Scalar _plotAxisColor=]>
java: void setPlotAxisColor(Scalar _plotAxisColor)
FUNC <void cv.plot.Plot2d.setPlotBackgroundColor [ARG Scalar _plotBackgroundColor=]>
java: void setPlotBackgroundColor(Scalar _plotBackgroundColor)
FUNC <void cv.plot.Plot2d.setPlotGridColor [ARG Scalar _plotGridColor=]>
java: void setPlotGridColor(Scalar _plotGridColor)
FUNC <void cv.plot.Plot2d.setPlotLineColor [ARG Scalar _plotLineColor=]>
java: void setPlotLineColor(Scalar _plotLineColor)
FUNC <void cv.plot.Plot2d.setPlotLineWidth [ARG int _plotLineWidth=]>
java: void setPlotLineWidth(int _plotLineWidth)
FUNC <void cv.plot.Plot2d.setPlotSize [ARG int _plotSizeWidth=, ARG int _plotSizeHeight=]>
java: void setPlotSize(int _plotSizeWidth, int _plotSizeHeight)
FUNC <void cv.plot.Plot2d.setPlotTextColor [ARG Scalar _plotTextColor=]>
java: void setPlotTextColor(Scalar _plotTextColor)
FUNC <void cv.plot.Plot2d.setPointIdxToPrint [ARG int pointIdx=]>
java: void setPointIdxToPrint(int pointIdx)
FUNC <void cv.plot.Plot2d.setShowGrid [ARG bool needShowGrid=]>
java: void setShowGrid(boolean needShowGrid)
FUNC <void cv.plot.Plot2d.setShowText [ARG bool needShowText=]>
java: void setShowText(boolean needShowText)

=== MODULE: xphoto (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto) ===


Files (7):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/white_balance.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/dct_image_denoising.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/bm3d_image_denoising.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/oilpainting.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/tonemap.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/inpainting.hpp']

Common headers (0):
[]
ok: class CLASS ::.Xphoto : , name: Xphoto, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/white_balance.hpp =====
Namespaces: set([u'cv', u'cv.xphoto'])

--- Incoming ---
[u'class cv.xphoto.WhiteBalancer', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.xphoto::.WhiteBalancer : Algorithm, name: WhiteBalancer, base: Algorithm

--- Incoming ---
[   u'cv.xphoto.WhiteBalancer.balanceWhite',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.xphoto.WhiteBalancer.balanceWhite [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[u'class cv.xphoto.SimpleWB', u': cv::xphoto::WhiteBalancer', [], [], None]
ok: class CLASS cv.xphoto::.SimpleWB : WhiteBalancer, name: SimpleWB, base: WhiteBalancer

--- Incoming ---
[   u'cv.xphoto.SimpleWB.getInputMin',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.SimpleWB.getInputMin []>

--- Incoming ---
[   u'cv.xphoto.SimpleWB.setInputMin',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.SimpleWB.setInputMin [ARG float val=]>

--- Incoming ---
[   u'cv.xphoto.SimpleWB.getInputMax',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.SimpleWB.getInputMax []>

--- Incoming ---
[   u'cv.xphoto.SimpleWB.setInputMax',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.SimpleWB.setInputMax [ARG float val=]>

--- Incoming ---
[   u'cv.xphoto.SimpleWB.getOutputMin',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.SimpleWB.getOutputMin []>

--- Incoming ---
[   u'cv.xphoto.SimpleWB.setOutputMin',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.SimpleWB.setOutputMin [ARG float val=]>

--- Incoming ---
[   u'cv.xphoto.SimpleWB.getOutputMax',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.SimpleWB.getOutputMax []>

--- Incoming ---
[   u'cv.xphoto.SimpleWB.setOutputMax',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.SimpleWB.setOutputMax [ARG float val=]>

--- Incoming ---
[u'cv.xphoto.SimpleWB.getP', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.xphoto.SimpleWB.getP []>

--- Incoming ---
[   u'cv.xphoto.SimpleWB.setP',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.SimpleWB.setP [ARG float val=]>

--- Incoming ---
[u'cv.xphoto.createSimpleWB', u'Ptr_SimpleWB', [], [], u'Ptr<SimpleWB>']
ok: FUNC <Ptr_SimpleWB cv.xphoto..createSimpleWB []>

--- Incoming ---
[u'class cv.xphoto.GrayworldWB', u': cv::xphoto::WhiteBalancer', [], [], None]
ok: class CLASS cv.xphoto::.GrayworldWB : WhiteBalancer, name: GrayworldWB, base: WhiteBalancer

--- Incoming ---
[   u'cv.xphoto.GrayworldWB.getSaturationThreshold',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.GrayworldWB.getSaturationThreshold []>

--- Incoming ---
[   u'cv.xphoto.GrayworldWB.setSaturationThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.GrayworldWB.setSaturationThreshold [ARG float val=]>

--- Incoming ---
[   u'cv.xphoto.createGrayworldWB',
    u'Ptr_GrayworldWB',
    [],
    [],
    u'Ptr<GrayworldWB>']
ok: FUNC <Ptr_GrayworldWB cv.xphoto..createGrayworldWB []>

--- Incoming ---
[   u'class cv.xphoto.LearningBasedWB',
    u': cv::xphoto::WhiteBalancer',
    [],
    [],
    None]
ok: class CLASS cv.xphoto::.LearningBasedWB : WhiteBalancer, name: LearningBasedWB, base: WhiteBalancer

--- Incoming ---
[   u'cv.xphoto.LearningBasedWB.extractSimpleFeatures',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.xphoto.LearningBasedWB.extractSimpleFeatures [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.xphoto.LearningBasedWB.getRangeMaxVal',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xphoto.LearningBasedWB.getRangeMaxVal []>

--- Incoming ---
[   u'cv.xphoto.LearningBasedWB.setRangeMaxVal',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.LearningBasedWB.setRangeMaxVal [ARG int val=]>

--- Incoming ---
[   u'cv.xphoto.LearningBasedWB.getSaturationThreshold',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.LearningBasedWB.getSaturationThreshold []>

--- Incoming ---
[   u'cv.xphoto.LearningBasedWB.setSaturationThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.LearningBasedWB.setSaturationThreshold [ARG float val=]>

--- Incoming ---
[   u'cv.xphoto.LearningBasedWB.getHistBinNum',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xphoto.LearningBasedWB.getHistBinNum []>

--- Incoming ---
[   u'cv.xphoto.LearningBasedWB.setHistBinNum',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.LearningBasedWB.setHistBinNum [ARG int val=]>

--- Incoming ---
[   u'cv.xphoto.createLearningBasedWB',
    u'Ptr_LearningBasedWB',
    [],
    [[u'String', u'path_to_model', u'String()', ['/C', '/Ref']]],
    u'Ptr<LearningBasedWB>']
ok: FUNC <Ptr_LearningBasedWB cv.xphoto..createLearningBasedWB [ARG String path_to_model=String()]>

--- Incoming ---
[   u'cv.xphoto.applyChannelGains',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'gainB', u'', []],
        [u'float', u'gainG', u'', []],
        [u'float', u'gainR', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto..applyChannelGains [ARG Mat src=, ARG Mat dst=, ARG float gainB=, ARG float gainG=, ARG float gainR=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/dct_image_denoising.hpp =====
Namespaces: set([u'cv', u'cv.xphoto'])

--- Incoming ---
[   u'cv.xphoto.dctDenoising',
    u'void',
    [],
    [   [u'Mat', u'src', u'', ['/C', '/Ref']],
        [u'Mat', u'dst', u'', ['/Ref']],
        [u'double', u'sigma', u'', ['/C']],
        [u'int', u'psize', u'16', ['/C']]],
    u'void']
ok: FUNC <void cv.xphoto..dctDenoising [ARG Mat src=, ARG Mat dst=, ARG double sigma=, ARG int psize=16]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/bm3d_image_denoising.hpp =====
Namespaces: set([u'cv', u'cv.xphoto'])

--- Incoming ---
[   u'enum cv.xphoto.TransformTypes',
    '',
    [],
    [[u'const cv.xphoto.HAAR', u'0', [], [], None, '']],
    None]
ok: CONST HAAR=0

--- Incoming ---
[   u'enum cv.xphoto.Bm3dSteps',
    '',
    [],
    [   [u'const cv.xphoto.BM3D_STEPALL', u'0', [], [], None, ''],
        [u'const cv.xphoto.BM3D_STEP1', u'1', [], [], None, ''],
        [u'const cv.xphoto.BM3D_STEP2', u'2', [], [], None, '']],
    None]
ok: CONST BM3D_STEPALL=0
ok: CONST BM3D_STEP1=1
ok: CONST BM3D_STEP2=2

--- Incoming ---
[   u'cv.xphoto.bm3dDenoising',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dstStep1', '', ['/IO']],
        ['Mat', u'dstStep2', '', ['/O']],
        [u'float', u'h', u'1', []],
        [u'int', u'templateWindowSize', u'4', []],
        [u'int', u'searchWindowSize', u'16', []],
        [u'int', u'blockMatchingStep1', u'2500', []],
        [u'int', u'blockMatchingStep2', u'400', []],
        [u'int', u'groupSize', u'8', []],
        [u'int', u'slidingStep', u'1', []],
        [u'float', u'beta', u'2.0f', []],
        [u'int', u'normType', u'cv::NORM_L2', []],
        [u'int', u'step', u'cv::xphoto::BM3D_STEPALL', []],
        [u'int', u'transformType', u'cv::xphoto::HAAR', []]],
    u'void']
ok: FUNC <void cv.xphoto..bm3dDenoising [ARG Mat src=, ARG Mat dstStep1=, ARG Mat dstStep2=, ARG float h=1, ARG int templateWindowSize=4, ARG int searchWindowSize=16, ARG int blockMatchingStep1=2500, ARG int blockMatchingStep2=400, ARG int groupSize=8, ARG int slidingStep=1, ARG float beta=2.0f, ARG int normType=cv::NORM_L2, ARG int step=cv::xphoto::BM3D_STEPALL, ARG int transformType=cv::xphoto::HAAR]>

--- Incoming ---
[   u'cv.xphoto.bm3dDenoising',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'h', u'1', []],
        [u'int', u'templateWindowSize', u'4', []],
        [u'int', u'searchWindowSize', u'16', []],
        [u'int', u'blockMatchingStep1', u'2500', []],
        [u'int', u'blockMatchingStep2', u'400', []],
        [u'int', u'groupSize', u'8', []],
        [u'int', u'slidingStep', u'1', []],
        [u'float', u'beta', u'2.0f', []],
        [u'int', u'normType', u'cv::NORM_L2', []],
        [u'int', u'step', u'cv::xphoto::BM3D_STEPALL', []],
        [u'int', u'transformType', u'cv::xphoto::HAAR', []]],
    u'void']
ok: FUNC <void cv.xphoto..bm3dDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=1, ARG int templateWindowSize=4, ARG int searchWindowSize=16, ARG int blockMatchingStep1=2500, ARG int blockMatchingStep2=400, ARG int groupSize=8, ARG int slidingStep=1, ARG float beta=2.0f, ARG int normType=cv::NORM_L2, ARG int step=cv::xphoto::BM3D_STEPALL, ARG int transformType=cv::xphoto::HAAR]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/oilpainting.hpp =====
Namespaces: set([u'cv', u'cv.xphoto'])

--- Incoming ---
[   u'cv.xphoto.oilPainting',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'size', u'', []],
        [u'int', u'dynRatio', u'', []],
        [u'int', u'code', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto..oilPainting [ARG Mat src=, ARG Mat dst=, ARG int size=, ARG int dynRatio=, ARG int code=]>

--- Incoming ---
[   u'cv.xphoto.oilPainting',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'size', u'', []],
        [u'int', u'dynRatio', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto..oilPainting [ARG Mat src=, ARG Mat dst=, ARG int size=, ARG int dynRatio=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/tonemap.hpp =====
Namespaces: set([u'cv', u'cv.xphoto'])

--- Incoming ---
[u'class cv.xphoto.TonemapDurand', u': cv::xphoto::Tonemap', [], [], None]
ok: class CLASS cv.xphoto::.TonemapDurand : Tonemap, name: TonemapDurand, base: Tonemap

--- Incoming ---
[   u'cv.xphoto.TonemapDurand.getSaturation',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.TonemapDurand.getSaturation []>

--- Incoming ---
[   u'cv.xphoto.TonemapDurand.setSaturation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'saturation', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.TonemapDurand.setSaturation [ARG float saturation=]>

--- Incoming ---
[   u'cv.xphoto.TonemapDurand.getContrast',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.TonemapDurand.getContrast []>

--- Incoming ---
[   u'cv.xphoto.TonemapDurand.setContrast',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'contrast', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.TonemapDurand.setContrast [ARG float contrast=]>

--- Incoming ---
[   u'cv.xphoto.TonemapDurand.getSigmaSpace',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.TonemapDurand.getSigmaSpace []>

--- Incoming ---
[   u'cv.xphoto.TonemapDurand.setSigmaSpace',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'sigma_space', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.TonemapDurand.setSigmaSpace [ARG float sigma_space=]>

--- Incoming ---
[   u'cv.xphoto.TonemapDurand.getSigmaColor',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xphoto.TonemapDurand.getSigmaColor []>

--- Incoming ---
[   u'cv.xphoto.TonemapDurand.setSigmaColor',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'sigma_color', u'', []]],
    u'void']
ok: FUNC <void cv.xphoto.TonemapDurand.setSigmaColor [ARG float sigma_color=]>

--- Incoming ---
[   u'cv.xphoto.createTonemapDurand',
    u'Ptr_TonemapDurand',
    [],
    [   [u'float', u'gamma', u'1.0f', []],
        [u'float', u'contrast', u'4.0f', []],
        [u'float', u'saturation', u'1.0f', []],
        [u'float', u'sigma_space', u'2.0f', []],
        [u'float', u'sigma_color', u'2.0f', []]],
    u'Ptr<TonemapDurand>']
ok: FUNC <Ptr_TonemapDurand cv.xphoto..createTonemapDurand [ARG float gamma=1.0f, ARG float contrast=4.0f, ARG float saturation=1.0f, ARG float sigma_space=2.0f, ARG float sigma_color=2.0f]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xphoto/include/opencv2/xphoto/inpainting.hpp =====
Namespaces: set([u'cv', u'cv.xphoto'])

--- Incoming ---
[   u'enum cv.xphoto.InpaintTypes',
    '',
    [],
    [[u'const cv.xphoto.INPAINT_SHIFTMAP', u'0', [], [], None, '']],
    None]
ok: CONST INPAINT_SHIFTMAP=0

--- Incoming ---
[   u'cv.xphoto.inpaint',
    u'void',
    [],
    [   [u'Mat', u'src', u'', ['/C', '/Ref']],
        [u'Mat', u'mask', u'', ['/C', '/Ref']],
        [u'Mat', u'dst', u'', ['/Ref']],
        [u'int', u'algorithmType', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.xphoto..inpaint [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG int algorithmType=]>


===== Generating... =====
CLASS ::.Xphoto : 
[CONST BM3D_STEPALL=0, CONST BM3D_STEP1=1, CONST BM3D_STEP2=2]
[CONST INPAINT_SHIFTMAP=0]
[CONST HAAR=0]
FUNC <Ptr_GrayworldWB cv.xphoto..createGrayworldWB []>
java: GrayworldWB createGrayworldWB()
FUNC <Ptr_LearningBasedWB cv.xphoto..createLearningBasedWB [ARG String path_to_model=String()]>
java: LearningBasedWB createLearningBasedWB(String path_to_model)
java: LearningBasedWB createLearningBasedWB()
FUNC <Ptr_SimpleWB cv.xphoto..createSimpleWB []>
java: SimpleWB createSimpleWB()
FUNC <Ptr_TonemapDurand cv.xphoto..createTonemapDurand [ARG float gamma=1.0f, ARG float contrast=4.0f, ARG float saturation=1.0f, ARG float sigma_space=2.0f, ARG float sigma_color=2.0f]>
java: TonemapDurand createTonemapDurand(float gamma, float contrast, float saturation, float sigma_space, float sigma_color)
java: TonemapDurand createTonemapDurand(float gamma, float contrast, float saturation, float sigma_space)
java: TonemapDurand createTonemapDurand(float gamma, float contrast, float saturation)
java: TonemapDurand createTonemapDurand(float gamma, float contrast)
java: TonemapDurand createTonemapDurand(float gamma)
java: TonemapDurand createTonemapDurand()
FUNC <void cv.xphoto..applyChannelGains [ARG Mat src=, ARG Mat dst=, ARG float gainB=, ARG float gainG=, ARG float gainR=]>
java: void applyChannelGains(Mat src, Mat dst, float gainB, float gainG, float gainR)
FUNC <void cv.xphoto..bm3dDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=1, ARG int templateWindowSize=4, ARG int searchWindowSize=16, ARG int blockMatchingStep1=2500, ARG int blockMatchingStep2=400, ARG int groupSize=8, ARG int slidingStep=1, ARG float beta=2.0f, ARG int normType=cv::NORM_L2, ARG int step=cv::xphoto::BM3D_STEPALL, ARG int transformType=cv::xphoto::HAAR]>
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType, int step, int transformType)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType, int step)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize)
java: void bm3dDenoising(Mat src, Mat dst, float h)
java: void bm3dDenoising(Mat src, Mat dst)
FUNC <void cv.xphoto..bm3dDenoising [ARG Mat src=, ARG Mat dstStep1=, ARG Mat dstStep2=, ARG float h=1, ARG int templateWindowSize=4, ARG int searchWindowSize=16, ARG int blockMatchingStep1=2500, ARG int blockMatchingStep2=400, ARG int groupSize=8, ARG int slidingStep=1, ARG float beta=2.0f, ARG int normType=cv::NORM_L2, ARG int step=cv::xphoto::BM3D_STEPALL, ARG int transformType=cv::xphoto::HAAR]>
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType, int step, int transformType)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType, int step)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2)
FUNC <void cv.xphoto..dctDenoising [ARG Mat src=, ARG Mat dst=, ARG double sigma=, ARG int psize=16]>
java: void dctDenoising(Mat src, Mat dst, double sigma, int psize)
java: void dctDenoising(Mat src, Mat dst, double sigma)
FUNC <void cv.xphoto..inpaint [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG int algorithmType=]>
java: void inpaint(Mat src, Mat mask, Mat dst, int algorithmType)
FUNC <void cv.xphoto..oilPainting [ARG Mat src=, ARG Mat dst=, ARG int size=, ARG int dynRatio=, ARG int code=]>
java: void oilPainting(Mat src, Mat dst, int size, int dynRatio, int code)
FUNC <void cv.xphoto..oilPainting [ARG Mat src=, ARG Mat dst=, ARG int size=, ARG int dynRatio=]>
java: void oilPainting(Mat src, Mat dst, int size, int dynRatio)
CLASS cv.xphoto::.TonemapDurand : Tonemap
FUNC <float cv.xphoto.TonemapDurand.getContrast []>
java: float getContrast()
FUNC <float cv.xphoto.TonemapDurand.getSaturation []>
java: float getSaturation()
FUNC <float cv.xphoto.TonemapDurand.getSigmaColor []>
java: float getSigmaColor()
FUNC <float cv.xphoto.TonemapDurand.getSigmaSpace []>
java: float getSigmaSpace()
FUNC <void cv.xphoto.TonemapDurand.setContrast [ARG float contrast=]>
java: void setContrast(float contrast)
FUNC <void cv.xphoto.TonemapDurand.setSaturation [ARG float saturation=]>
java: void setSaturation(float saturation)
FUNC <void cv.xphoto.TonemapDurand.setSigmaColor [ARG float sigma_color=]>
java: void setSigmaColor(float sigma_color)
FUNC <void cv.xphoto.TonemapDurand.setSigmaSpace [ARG float sigma_space=]>
java: void setSigmaSpace(float sigma_space)
CLASS cv.xphoto::.LearningBasedWB : WhiteBalancer
FUNC <float cv.xphoto.LearningBasedWB.getSaturationThreshold []>
java: float getSaturationThreshold()
FUNC <int cv.xphoto.LearningBasedWB.getHistBinNum []>
java: int getHistBinNum()
FUNC <int cv.xphoto.LearningBasedWB.getRangeMaxVal []>
java: int getRangeMaxVal()
FUNC <void cv.xphoto.LearningBasedWB.extractSimpleFeatures [ARG Mat src=, ARG Mat dst=]>
java: void extractSimpleFeatures(Mat src, Mat dst)
FUNC <void cv.xphoto.LearningBasedWB.setHistBinNum [ARG int val=]>
java: void setHistBinNum(int val)
FUNC <void cv.xphoto.LearningBasedWB.setRangeMaxVal [ARG int val=]>
java: void setRangeMaxVal(int val)
FUNC <void cv.xphoto.LearningBasedWB.setSaturationThreshold [ARG float val=]>
java: void setSaturationThreshold(float val)
CLASS cv.xphoto::.GrayworldWB : WhiteBalancer
FUNC <float cv.xphoto.GrayworldWB.getSaturationThreshold []>
java: float getSaturationThreshold()
FUNC <void cv.xphoto.GrayworldWB.setSaturationThreshold [ARG float val=]>
java: void setSaturationThreshold(float val)
CLASS cv.xphoto::.WhiteBalancer : Algorithm
FUNC <void cv.xphoto.WhiteBalancer.balanceWhite [ARG Mat src=, ARG Mat dst=]>
java: void balanceWhite(Mat src, Mat dst)
CLASS cv.xphoto::.SimpleWB : WhiteBalancer
FUNC <float cv.xphoto.SimpleWB.getInputMax []>
java: float getInputMax()
FUNC <float cv.xphoto.SimpleWB.getInputMin []>
java: float getInputMin()
FUNC <float cv.xphoto.SimpleWB.getOutputMax []>
java: float getOutputMax()
FUNC <float cv.xphoto.SimpleWB.getOutputMin []>
java: float getOutputMin()
FUNC <float cv.xphoto.SimpleWB.getP []>
java: float getP()
FUNC <void cv.xphoto.SimpleWB.setInputMax [ARG float val=]>
java: void setInputMax(float val)
FUNC <void cv.xphoto.SimpleWB.setInputMin [ARG float val=]>
java: void setInputMin(float val)
FUNC <void cv.xphoto.SimpleWB.setOutputMax [ARG float val=]>
java: void setOutputMax(float val)
FUNC <void cv.xphoto.SimpleWB.setOutputMin [ARG float val=]>
java: void setOutputMin(float val)
FUNC <void cv.xphoto.SimpleWB.setP [ARG float val=]>
java: void setP(float val)

=== MODULE: dnn (/home/borg/404/scripts_robotica/OpenCV/modules/dnn) ===


Files (8):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/layer.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/version.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/shape_utils.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/dnn.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/all_layers.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/dict.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/utils/inference_engine.hpp']

Common headers (1):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/dnn/misc/java/src/cpp/dnn_converters.hpp']
ok: class CLASS ::.Dnn : , name: Dnn, base: 

===== Common header : /home/borg/404/scripts_robotica/OpenCV/modules/dnn/misc/java/src/cpp/dnn_converters.hpp =====


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/layer.hpp =====
Namespaces: set([u'cv.dnn', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/layer.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/version.hpp =====
Namespaces: set([u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/version.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/shape_utils.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/shape_utils.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/dnn.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])

--- Incoming ---
[   u'enum cv.dnn.Backend',
    '',
    [],
    [   [u'const cv.dnn.DNN_BACKEND_DEFAULT', '0', [], [], None, ''],
        [u'const cv.dnn.DNN_BACKEND_HALIDE', '1', [], [], None, ''],
        [u'const cv.dnn.DNN_BACKEND_INFERENCE_ENGINE', '2', [], [], None, ''],
        [u'const cv.dnn.DNN_BACKEND_OPENCV', '3', [], [], None, ''],
        [u'const cv.dnn.DNN_BACKEND_VKCOM', '4', [], [], None, '']],
    None]
ok: CONST DNN_BACKEND_DEFAULT=0
ok: CONST DNN_BACKEND_HALIDE=1
ok: CONST DNN_BACKEND_INFERENCE_ENGINE=2
ok: CONST DNN_BACKEND_OPENCV=3
ok: CONST DNN_BACKEND_VKCOM=4

--- Incoming ---
[   u'enum cv.dnn.Target',
    '',
    [],
    [   [u'const cv.dnn.DNN_TARGET_CPU', '0', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_OPENCL', '1', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_OPENCL_FP16', '2', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_MYRIAD', '3', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_VULKAN', '4', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_FPGA', '5', [], [], None, '']],
    None]
ok: CONST DNN_TARGET_CPU=0
ok: CONST DNN_TARGET_OPENCL=1
ok: CONST DNN_TARGET_OPENCL_FP16=2
ok: CONST DNN_TARGET_MYRIAD=3
ok: CONST DNN_TARGET_VULKAN=4
ok: CONST DNN_TARGET_FPGA=5

--- Incoming ---
[   u'class cv.dnn.Layer',
    ': cv::Algorithm',
    [],
    [   [u'vector_Mat', u'blobs', '', ['/RW']],
        [u'String', u'name', '', []],
        [u'String', u'type', '', []],
        [u'int', u'preferableTarget', '', []]],
    None]
ok: class CLASS cv.dnn::.Layer : Algorithm, name: Layer, base: Algorithm

--- Incoming ---
[   u'cv.dnn.Layer.finalize',
    u'void',
    ['/V'],
    [   ['vector_Mat', u'inputs', '', []],
        ['vector_Mat', u'outputs', '', ['/O']]],
    u'void']
ok: FUNC <void cv.dnn.Layer.finalize [ARG vector_Mat inputs=, ARG vector_Mat outputs=]>

--- Incoming ---
[   u'cv.dnn.Layer.run',
    u'void',
    [],
    [   [u'vector_Mat', u'inputs', u'', ['/C', '/Ref']],
        [u'vector_Mat', u'outputs', u'', ['/O', '/Ref']],
        [u'vector_Mat', u'internals', u'', ['/IO', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Layer.run [ARG vector_Mat inputs=, ARG vector_Mat outputs=, ARG vector_Mat internals=]>

--- Incoming ---
[   u'cv.dnn.Layer.outputNameToIndex',
    u'int',
    ['/V'],
    [[u'String', u'outputName', u'', ['/C', '/Ref']]],
    u'int']
ok: FUNC <int cv.dnn.Layer.outputNameToIndex [ARG String outputName=]>

--- Incoming ---
[u'class cv.dnn.Net', '', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.Net : , name: Net, base: 

--- Incoming ---
[u'cv.dnn.Net.Net', '', [], [], None]
ok: FUNC < cv.dnn.Net.Net []>

--- Incoming ---
[   u'cv.dnn.Net.readFromModelOptimizer',
    u'Net',
    ['/S'],
    [   [u'String', u'xml', u'', ['/C', '/Ref']],
        [u'String', u'bin', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG String xml=, ARG String bin=]>

--- Incoming ---
[u'cv.dnn.Net.empty', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.dnn.Net.empty []>

--- Incoming ---
[u'cv.dnn.Net.dump', u'String', [], [], u'String']
ok: FUNC <String cv.dnn.Net.dump []>

--- Incoming ---
[   u'cv.dnn.Net.dumpToFile',
    u'void',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.dumpToFile [ARG String path=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayerId',
    u'int',
    [],
    [[u'String', u'layer', u'', ['/C', '/Ref']]],
    u'int']
ok: FUNC <int cv.dnn.Net.getLayerId [ARG String layer=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayerNames',
    u'vector_String',
    ['/C'],
    [],
    u'std::vector<String>']
ok: FUNC <vector_String cv.dnn.Net.getLayerNames []>

--- Incoming ---
[   u'cv.dnn.Net.getLayer',
    u'Ptr_Layer',
    [],
    [[u'LayerId', u'layerId', u'', []]],
    u'Ptr<Layer>']
ok: FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG LayerId layerId=]>

--- Incoming ---
[   u'cv.dnn.Net.connect',
    u'void',
    [],
    [[u'String', u'outPin', u'', []], [u'String', u'inpPin', u'', []]],
    u'void']
ok: FUNC <void cv.dnn.Net.connect [ARG String outPin=, ARG String inpPin=]>

--- Incoming ---
[   u'cv.dnn.Net.setInputsNames',
    u'void',
    [],
    [[u'vector_String', u'inputBlobNames', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setInputsNames [ARG vector_String inputBlobNames=]>

--- Incoming ---
[   u'cv.dnn.Net.forward',
    u'Mat',
    [],
    [[u'String', u'outputName', u'String()', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.dnn.Net.forward [ARG String outputName=String()]>

--- Incoming ---
[   u'cv.dnn.Net.forwardAsync',
    u'AsyncArray',
    [],
    [[u'String', u'outputName', u'String()', ['/C', '/Ref']]],
    u'AsyncArray']
ok: FUNC <AsyncArray cv.dnn.Net.forwardAsync [ARG String outputName=String()]>

--- Incoming ---
[   u'cv.dnn.Net.forward',
    u'void',
    [],
    [   ['vector_Mat', u'outputBlobs', '', ['/O']],
        [u'String', u'outputName', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG String outputName=String()]>

--- Incoming ---
[   u'cv.dnn.Net.forward',
    u'void',
    [],
    [   ['vector_Mat', u'outputBlobs', '', ['/O']],
        [u'vector_String', u'outBlobNames', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>

--- Incoming ---
[   u'cv.dnn.Net.forward',
    u'void',
    [u'=forwardAndRetrieve'],
    [   [u'vector_vector_Mat', u'outputBlobs', u'', ['/O', '/Ref']],
        [u'vector_String', u'outBlobNames', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>

--- Incoming ---
[   u'cv.dnn.Net.setHalideScheduler',
    u'void',
    [],
    [[u'String', u'scheduler', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setHalideScheduler [ARG String scheduler=]>

--- Incoming ---
[   u'cv.dnn.Net.setPreferableBackend',
    u'void',
    [],
    [[u'int', u'backendId', u'', []]],
    u'void']
ok: FUNC <void cv.dnn.Net.setPreferableBackend [ARG int backendId=]>

--- Incoming ---
[   u'cv.dnn.Net.setPreferableTarget',
    u'void',
    [],
    [[u'int', u'targetId', u'', []]],
    u'void']
ok: FUNC <void cv.dnn.Net.setPreferableTarget [ARG int targetId=]>

--- Incoming ---
[   u'cv.dnn.Net.setInput',
    u'void',
    [],
    [   ['Mat', u'blob', '', []],
        [u'String', u'name', u'""', ['/C', '/Ref']],
        [u'double', u'scalefactor', u'1.0', []],
        [u'Scalar', u'mean', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setInput [ARG Mat blob=, ARG String name="", ARG double scalefactor=1.0, ARG Scalar mean=Scalar()]>

--- Incoming ---
[   u'cv.dnn.Net.setParam',
    u'void',
    [],
    [   [u'LayerId', u'layer', u'', []],
        [u'int', u'numParam', u'', []],
        [u'Mat', u'blob', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setParam [ARG LayerId layer=, ARG int numParam=, ARG Mat blob=]>

--- Incoming ---
[   u'cv.dnn.Net.getParam',
    u'Mat',
    [],
    [[u'LayerId', u'layer', u'', []], [u'int', u'numParam', u'0', []]],
    u'Mat']
ok: FUNC <Mat cv.dnn.Net.getParam [ARG LayerId layer=, ARG int numParam=0]>

--- Incoming ---
[   u'cv.dnn.Net.getUnconnectedOutLayers',
    u'vector_int',
    ['/C'],
    [],
    u'std::vector<int>']
ok: FUNC <vector_int cv.dnn.Net.getUnconnectedOutLayers []>

--- Incoming ---
[   u'cv.dnn.Net.getUnconnectedOutLayersNames',
    u'vector_String',
    ['/C'],
    [],
    u'std::vector<String>']
ok: FUNC <vector_String cv.dnn.Net.getUnconnectedOutLayersNames []>

--- Incoming ---
[   u'cv.dnn.Net.getLayersShapes',
    u'void',
    ['/C'],
    [   [u'vector_MatShape', u'netInputShapes', u'', ['/C', '/Ref']],
        [u'vector_int', u'layersIds', u'', ['/O', '/Ref']],
        [u'vector_vector_MatShape', u'inLayersShapes', u'', ['/O', '/Ref']],
        [u'vector_vector_MatShape', u'outLayersShapes', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getLayersShapes [ARG vector_MatShape netInputShapes=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayersShapes',
    u'void',
    ['/C'],
    [   [u'MatShape', u'netInputShape', u'', ['/C', '/Ref']],
        [u'vector_int', u'layersIds', u'', ['/O', '/Ref']],
        [u'vector_vector_MatShape', u'inLayersShapes', u'', ['/O', '/Ref']],
        [u'vector_vector_MatShape', u'outLayersShapes', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getLayersShapes [ARG MatShape netInputShape=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>

--- Incoming ---
[   u'cv.dnn.Net.getFLOPS',
    u'int64',
    ['/C'],
    [[u'vector_MatShape', u'netInputShapes', u'', ['/C', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG vector_MatShape netInputShapes=]>

--- Incoming ---
[   u'cv.dnn.Net.getFLOPS',
    u'int64',
    ['/C'],
    [[u'MatShape', u'netInputShape', u'', ['/C', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG MatShape netInputShape=]>

--- Incoming ---
[   u'cv.dnn.Net.getFLOPS',
    u'int64',
    ['/C'],
    [   [u'int', u'layerId', u'', ['/C']],
        [u'vector_MatShape', u'netInputShapes', u'', ['/C', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG vector_MatShape netInputShapes=]>

--- Incoming ---
[   u'cv.dnn.Net.getFLOPS',
    u'int64',
    ['/C'],
    [   [u'int', u'layerId', u'', ['/C']],
        [u'MatShape', u'netInputShape', u'', ['/C', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG MatShape netInputShape=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayerTypes',
    u'void',
    ['/C'],
    [[u'vector_String', u'layersTypes', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getLayerTypes [ARG vector_String layersTypes=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayersCount',
    u'int',
    ['/C'],
    [[u'String', u'layerType', u'', ['/C', '/Ref']]],
    u'int']
ok: FUNC <int cv.dnn.Net.getLayersCount [ARG String layerType=]>

--- Incoming ---
[   u'cv.dnn.Net.getMemoryConsumption',
    u'void',
    ['/C'],
    [   [u'MatShape', u'netInputShape', u'', ['/C', '/Ref']],
        [u'size_t', u'weights', u'', ['/O', '/Ref']],
        [u'size_t', u'blobs', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
[   u'cv.dnn.Net.getMemoryConsumption',
    u'void',
    ['/C'],
    [   [u'int', u'layerId', u'', ['/C']],
        [u'vector_MatShape', u'netInputShapes', u'', ['/C', '/Ref']],
        [u'size_t', u'weights', u'', ['/O', '/Ref']],
        [u'size_t', u'blobs', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG vector_MatShape netInputShapes=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
[   u'cv.dnn.Net.getMemoryConsumption',
    u'void',
    ['/C'],
    [   [u'int', u'layerId', u'', ['/C']],
        [u'MatShape', u'netInputShape', u'', ['/C', '/Ref']],
        [u'size_t', u'weights', u'', ['/O', '/Ref']],
        [u'size_t', u'blobs', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
[   u'cv.dnn.Net.enableFusion',
    u'void',
    [],
    [[u'bool', u'fusion', u'', []]],
    u'void']
ok: FUNC <void cv.dnn.Net.enableFusion [ARG bool fusion=]>

--- Incoming ---
[   u'cv.dnn.Net.getPerfProfile',
    u'int64',
    [],
    [[u'vector_double', u'timings', u'', ['/O', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getPerfProfile [ARG vector_double timings=]>

--- Incoming ---
[   u'cv.dnn.readNetFromDarknet',
    u'Net',
    [],
    [   [u'String', u'cfgFile', u'', ['/C', '/Ref']],
        [u'String', u'darknetModel', u'String()', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromDarknet [ARG String cfgFile=, ARG String darknetModel=String()]>

--- Incoming ---
[   u'cv.dnn.readNetFromDarknet',
    u'Net',
    [],
    [   [u'vector_uchar', u'bufferCfg', u'', ['/C', '/Ref']],
        [   u'vector_uchar',
            u'bufferModel',
            u'std::vector<uchar>()',
            ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromDarknet [ARG vector_uchar bufferCfg=, ARG vector_uchar bufferModel=std::vector<uchar>()]>

--- Incoming ---
[   u'cv.dnn.readNetFromCaffe',
    u'Net',
    [],
    [   [u'String', u'prototxt', u'', ['/C', '/Ref']],
        [u'String', u'caffeModel', u'String()', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromCaffe [ARG String prototxt=, ARG String caffeModel=String()]>

--- Incoming ---
[   u'cv.dnn.readNetFromCaffe',
    u'Net',
    [],
    [   [u'vector_uchar', u'bufferProto', u'', ['/C', '/Ref']],
        [   u'vector_uchar',
            u'bufferModel',
            u'std::vector<uchar>()',
            ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromCaffe [ARG vector_uchar bufferProto=, ARG vector_uchar bufferModel=std::vector<uchar>()]>

--- Incoming ---
[   u'cv.dnn.readNetFromTensorflow',
    u'Net',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'String()', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromTensorflow [ARG String model=, ARG String config=String()]>

--- Incoming ---
[   u'cv.dnn.readNetFromTensorflow',
    u'Net',
    [],
    [   [u'vector_uchar', u'bufferModel', u'', ['/C', '/Ref']],
        [   u'vector_uchar',
            u'bufferConfig',
            u'std::vector<uchar>()',
            ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromTensorflow [ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>

--- Incoming ---
[   u'cv.dnn.readNetFromTorch',
    u'Net',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'bool', u'isBinary', u'true', []],
        [u'bool', u'evaluate', u'true', []]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromTorch [ARG String model=, ARG bool isBinary=true, ARG bool evaluate=true]>

--- Incoming ---
[   u'cv.dnn.readNet',
    u'Net',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'""', ['/C', '/Ref']],
        [u'String', u'framework', u'""', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNet [ARG String model=, ARG String config="", ARG String framework=""]>

--- Incoming ---
[   u'cv.dnn.readNet',
    u'Net',
    [],
    [   [u'String', u'framework', u'', ['/C', '/Ref']],
        [u'vector_uchar', u'bufferModel', u'', ['/C', '/Ref']],
        [   u'vector_uchar',
            u'bufferConfig',
            u'std::vector<uchar>()',
            ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNet [ARG String framework=, ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>

--- Incoming ---
[   u'cv.dnn.readTorchBlob',
    u'Mat',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'bool', u'isBinary', u'true', []]],
    u'Mat']
ok: FUNC <Mat cv.dnn..readTorchBlob [ARG String filename=, ARG bool isBinary=true]>

--- Incoming ---
[   u'cv.dnn.readNetFromModelOptimizer',
    u'Net',
    [],
    [   [u'String', u'xml', u'', ['/C', '/Ref']],
        [u'String', u'bin', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG String xml=, ARG String bin=]>

--- Incoming ---
[   u'cv.dnn.readNetFromONNX',
    u'Net',
    [],
    [[u'String', u'onnxFile', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromONNX [ARG String onnxFile=]>

--- Incoming ---
[   u'cv.dnn.readNetFromONNX',
    u'Net',
    [],
    [[u'vector_uchar', u'buffer', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromONNX [ARG vector_uchar buffer=]>

--- Incoming ---
[   u'cv.dnn.readTensorFromONNX',
    u'Mat',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.dnn..readTensorFromONNX [ARG String path=]>

--- Incoming ---
[   u'cv.dnn.blobFromImage',
    u'Mat',
    [],
    [   ['Mat', u'image', '', []],
        [u'double', u'scalefactor', u'1.0', []],
        [u'Size', u'size', u'Size()', ['/C', '/Ref']],
        [u'Scalar', u'mean', u'Scalar()', ['/C', '/Ref']],
        [u'bool', u'swapRB', u'false', []],
        [u'bool', u'crop', u'false', []],
        [u'int', u'ddepth', u'CV_32F', []]],
    u'Mat']
ok: FUNC <Mat cv.dnn..blobFromImage [ARG Mat image=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>

--- Incoming ---
[   u'cv.dnn.blobFromImages',
    u'Mat',
    [],
    [   ['vector_Mat', u'images', '', []],
        [u'double', u'scalefactor', u'1.0', []],
        [u'Size', u'size', u'Size()', []],
        [u'Scalar', u'mean', u'Scalar()', ['/C', '/Ref']],
        [u'bool', u'swapRB', u'false', []],
        [u'bool', u'crop', u'false', []],
        [u'int', u'ddepth', u'CV_32F', []]],
    u'Mat']
ok: FUNC <Mat cv.dnn..blobFromImages [ARG vector_Mat images=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>

--- Incoming ---
[   u'cv.dnn.imagesFromBlob',
    u'void',
    [],
    [   [u'Mat', u'blob_', u'', ['/C', '/Ref']],
        ['vector_Mat', u'images_', '', ['/O']]],
    u'void']
ok: FUNC <void cv.dnn..imagesFromBlob [ARG Mat blob_=, ARG vector_Mat images_=]>

--- Incoming ---
[   u'cv.dnn.shrinkCaffeModel',
    u'void',
    [],
    [   [u'String', u'src', u'', ['/C', '/Ref']],
        [u'String', u'dst', u'', ['/C', '/Ref']],
        [   u'vector_String',
            u'layersTypes',
            u'std::vector<String>()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn..shrinkCaffeModel [ARG String src=, ARG String dst=, ARG vector_String layersTypes=std::vector<String>()]>

--- Incoming ---
[   u'cv.dnn.writeTextGraph',
    u'void',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'output', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn..writeTextGraph [ARG String model=, ARG String output=]>

--- Incoming ---
[   u'cv.dnn.NMSBoxes',
    u'void',
    [],
    [   [u'vector_Rect', u'bboxes', u'', ['/C', '/Ref']],
        [u'vector_float', u'scores', u'', ['/C', '/Ref']],
        [u'float', u'score_threshold', u'', ['/C']],
        [u'float', u'nms_threshold', u'', ['/C']],
        [u'vector_int', u'indices', u'', ['/O', '/Ref']],
        [u'float', u'eta', u'1.f', ['/C']],
        [u'int', u'top_k', u'0', ['/C']]],
    u'void']
ok: FUNC <void cv.dnn..NMSBoxes [ARG vector_Rect bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>

--- Incoming ---
[   u'cv.dnn.NMSBoxes',
    u'void',
    [],
    [   [u'vector_Rect2d', u'bboxes', u'', ['/C', '/Ref']],
        [u'vector_float', u'scores', u'', ['/C', '/Ref']],
        [u'float', u'score_threshold', u'', ['/C']],
        [u'float', u'nms_threshold', u'', ['/C']],
        [u'vector_int', u'indices', u'', ['/O', '/Ref']],
        [u'float', u'eta', u'1.f', ['/C']],
        [u'int', u'top_k', u'0', ['/C']]],
    u'void']
ok: FUNC <void cv.dnn..NMSBoxes [ARG vector_Rect2d bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>

--- Incoming ---
[   u'cv.dnn.NMSBoxes',
    u'void',
    [u'=NMSBoxesRotated'],
    [   [u'vector_RotatedRect', u'bboxes', u'', ['/C', '/Ref']],
        [u'vector_float', u'scores', u'', ['/C', '/Ref']],
        [u'float', u'score_threshold', u'', ['/C']],
        [u'float', u'nms_threshold', u'', ['/C']],
        [u'vector_int', u'indices', u'', ['/O', '/Ref']],
        [u'float', u'eta', u'1.f', ['/C']],
        [u'int', u'top_k', u'0', ['/C']]],
    u'void']
ok: FUNC <void cv.dnn..NMSBoxes [ARG vector_RotatedRect bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/all_layers.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/all_layers.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/dict.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])

--- Incoming ---
[u'struct cv.dnn.DictValue', '', [], [], None]
ok: class CLASS cv.dnn::.DictValue : , name: DictValue, base: 

--- Incoming ---
[u'cv.dnn.DictValue.DictValue', '', [], [[u'int', u'i', u'', []]], None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG int i=]>

--- Incoming ---
[u'cv.dnn.DictValue.DictValue', '', [], [[u'double', u'p', u'', []]], None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG double p=]>

--- Incoming ---
[   u'cv.dnn.DictValue.DictValue',
    '',
    [],
    [[u'String', u's', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG String s=]>

--- Incoming ---
[u'cv.dnn.DictValue.isInt', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.dnn.DictValue.isInt []>

--- Incoming ---
[u'cv.dnn.DictValue.isString', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.dnn.DictValue.isString []>

--- Incoming ---
[u'cv.dnn.DictValue.isReal', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.dnn.DictValue.isReal []>

--- Incoming ---
[   u'cv.dnn.DictValue.getIntValue',
    u'int',
    ['/C'],
    [[u'int', u'idx', u'-1', []]],
    u'int']
ok: FUNC <int cv.dnn.DictValue.getIntValue [ARG int idx=-1]>

--- Incoming ---
[   u'cv.dnn.DictValue.getRealValue',
    u'double',
    ['/C'],
    [[u'int', u'idx', u'-1', []]],
    u'double']
ok: FUNC <double cv.dnn.DictValue.getRealValue [ARG int idx=-1]>

--- Incoming ---
[   u'cv.dnn.DictValue.getStringValue',
    u'String',
    ['/C'],
    [[u'int', u'idx', u'-1', []]],
    u'String']
ok: FUNC <String cv.dnn.DictValue.getStringValue [ARG int idx=-1]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/dnn/include/opencv2/dnn/utils/inference_engine.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])

--- Incoming ---
[u'cv.dnn.resetMyriadDevice', u'void', [], [], u'void']
ok: FUNC <void cv.dnn..resetMyriadDevice []>

--- Incoming ---
[u'cv.dnn.getInferenceEngineVPUType', u'String', [], [], u'cv::String']
ok: FUNC <String cv.dnn..getInferenceEngineVPUType []>


===== Generating... =====
CLASS cv.dnn::.Layer : Algorithm
FUNC <int cv.dnn.Layer.outputNameToIndex [ARG String outputName=]>
java: int outputNameToIndex(String outputName)
FUNC <void cv.dnn.Layer.finalize [ARG vector_Mat inputs=, ARG vector_Mat outputs=]>
java: void finalize(List<Mat> inputs, List<Mat> outputs)
FUNC <void cv.dnn.Layer.run [ARG vector_Mat inputs=, ARG vector_Mat outputs=, ARG vector_Mat internals=]>
java: void run(List<Mat> inputs, List<Mat> outputs, List<Mat> internals)
FUNC <vector_Mat cv.dnn.Layer.get_blobs []>
java: List<Mat> get_blobs()
FUNC <void cv.dnn.Layer.set_blobs [ARG vector_Mat blobs=]>
java: void set_blobs(List<Mat> blobs)
FUNC <String cv.dnn.Layer.get_name []>
java: String get_name()
FUNC <String cv.dnn.Layer.get_type []>
java: String get_type()
FUNC <int cv.dnn.Layer.get_preferableTarget []>
java: int get_preferableTarget()
CLASS ::.Dnn : 
[CONST DNN_BACKEND_DEFAULT=0, CONST DNN_BACKEND_HALIDE=1, CONST DNN_BACKEND_INFERENCE_ENGINE=2, CONST DNN_BACKEND_OPENCV=3, CONST DNN_BACKEND_VKCOM=4]
[CONST DNN_TARGET_CPU=0, CONST DNN_TARGET_OPENCL=1, CONST DNN_TARGET_OPENCL_FP16=2, CONST DNN_TARGET_MYRIAD=3, CONST DNN_TARGET_VULKAN=4, CONST DNN_TARGET_FPGA=5]
FUNC <Mat cv.dnn..blobFromImage [ARG Mat image=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop, int ddepth)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean)
java: Mat blobFromImage(Mat image, double scalefactor, Size size)
java: Mat blobFromImage(Mat image, double scalefactor)
java: Mat blobFromImage(Mat image)
FUNC <Mat cv.dnn..blobFromImages [ARG vector_Mat images=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop, int ddepth)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size)
java: Mat blobFromImages(List<Mat> images, double scalefactor)
java: Mat blobFromImages(List<Mat> images)
FUNC <Mat cv.dnn..readTensorFromONNX [ARG String path=]>
java: Mat readTensorFromONNX(String path)
FUNC <Mat cv.dnn..readTorchBlob [ARG String filename=, ARG bool isBinary=true]>
java: Mat readTorchBlob(String filename, boolean isBinary)
java: Mat readTorchBlob(String filename)
FUNC <Net cv.dnn..readNet [ARG String framework=, ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>
java: Net readNet(String framework, MatOfByte bufferModel, MatOfByte bufferConfig)
java: Net readNet(String framework, MatOfByte bufferModel)
FUNC <Net cv.dnn..readNet [ARG String model=, ARG String config="", ARG String framework=""]>
java: Net readNet(String model, String config, String framework)
java: Net readNet(String model, String config)
java: Net readNet(String model)
FUNC <Net cv.dnn..readNetFromCaffe [ARG String prototxt=, ARG String caffeModel=String()]>
java: Net readNetFromCaffe(String prototxt, String caffeModel)
java: Net readNetFromCaffe(String prototxt)
FUNC <Net cv.dnn..readNetFromCaffe [ARG vector_uchar bufferProto=, ARG vector_uchar bufferModel=std::vector<uchar>()]>
java: Net readNetFromCaffe(MatOfByte bufferProto, MatOfByte bufferModel)
java: Net readNetFromCaffe(MatOfByte bufferProto)
FUNC <Net cv.dnn..readNetFromDarknet [ARG String cfgFile=, ARG String darknetModel=String()]>
java: Net readNetFromDarknet(String cfgFile, String darknetModel)
java: Net readNetFromDarknet(String cfgFile)
FUNC <Net cv.dnn..readNetFromDarknet [ARG vector_uchar bufferCfg=, ARG vector_uchar bufferModel=std::vector<uchar>()]>
java: Net readNetFromDarknet(MatOfByte bufferCfg, MatOfByte bufferModel)
java: Net readNetFromDarknet(MatOfByte bufferCfg)
FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG String xml=, ARG String bin=]>
java: Net readNetFromModelOptimizer(String xml, String bin)
FUNC <Net cv.dnn..readNetFromONNX [ARG String onnxFile=]>
java: Net readNetFromONNX(String onnxFile)
FUNC <Net cv.dnn..readNetFromONNX [ARG vector_uchar buffer=]>
java: Net readNetFromONNX(MatOfByte buffer)
FUNC <Net cv.dnn..readNetFromTensorflow [ARG String model=, ARG String config=String()]>
java: Net readNetFromTensorflow(String model, String config)
java: Net readNetFromTensorflow(String model)
FUNC <Net cv.dnn..readNetFromTensorflow [ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>
java: Net readNetFromTensorflow(MatOfByte bufferModel, MatOfByte bufferConfig)
java: Net readNetFromTensorflow(MatOfByte bufferModel)
FUNC <Net cv.dnn..readNetFromTorch [ARG String model=, ARG bool isBinary=true, ARG bool evaluate=true]>
java: Net readNetFromTorch(String model, boolean isBinary, boolean evaluate)
java: Net readNetFromTorch(String model, boolean isBinary)
java: Net readNetFromTorch(String model)
FUNC <String cv.dnn..getInferenceEngineVPUType []>
java: String getInferenceEngineVPUType()
FUNC <void cv.dnn..NMSBoxes [ARG vector_Rect bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>
java: void NMSBoxes(MatOfRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta, int top_k)
java: void NMSBoxes(MatOfRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta)
java: void NMSBoxes(MatOfRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <void cv.dnn..NMSBoxes [ARG vector_Rect2d bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta, int top_k)
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta)
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <void cv.dnn..NMSBoxes [ARG vector_RotatedRect bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta, int top_k)
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta)
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <void cv.dnn..imagesFromBlob [ARG Mat blob_=, ARG vector_Mat images_=]>
java: void imagesFromBlob(Mat blob_, List<Mat> images_)
FUNC <void cv.dnn..resetMyriadDevice []>
java: void resetMyriadDevice()
FUNC <void cv.dnn..shrinkCaffeModel [ARG String src=, ARG String dst=, ARG vector_String layersTypes=std::vector<String>()]>
java: void shrinkCaffeModel(String src, String dst, List<String> layersTypes)
java: void shrinkCaffeModel(String src, String dst)
FUNC <void cv.dnn..writeTextGraph [ARG String model=, ARG String output=]>
java: void writeTextGraph(String model, String output)
CLASS cv.dnn::.Net : 
FUNC < cv.dnn.Net.Net []>
java:  Net()
FUNC <AsyncArray cv.dnn.Net.forwardAsync [ARG String outputName=String()]>
SKIP:AsyncArray cv::dnn::Net::forwardAsync(String outputName = String())	 due to RET type AsyncArray
FUNC <Mat cv.dnn.Net.forward [ARG String outputName=String()]>
java: Mat forward(String outputName)
java: Mat forward()
FUNC <Mat cv.dnn.Net.getParam [ARG LayerId layer=, ARG int numParam=0]>
java: Mat getParam(DictValue layer, int numParam)
java: Mat getParam(DictValue layer)
FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG String xml=, ARG String bin=]>
java: Net readFromModelOptimizer(String xml, String bin)
FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG LayerId layerId=]>
java: Layer getLayer(DictValue layerId)
FUNC <String cv.dnn.Net.dump []>
java: String dump()
FUNC <bool cv.dnn.Net.empty []>
java: boolean empty()
FUNC <int cv.dnn.Net.getLayerId [ARG String layer=]>
java: int getLayerId(String layer)
FUNC <int cv.dnn.Net.getLayersCount [ARG String layerType=]>
java: int getLayersCount(String layerType)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG MatShape netInputShape=]>
java: long getFLOPS(MatOfInt netInputShape)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG MatShape netInputShape=]>
java: long getFLOPS(int layerId, MatOfInt netInputShape)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG vector_MatShape netInputShapes=]>
java: long getFLOPS(int layerId, List<MatOfInt> netInputShapes)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG vector_MatShape netInputShapes=]>
java: long getFLOPS(List<MatOfInt> netInputShapes)
FUNC <int64 cv.dnn.Net.getPerfProfile [ARG vector_double timings=]>
java: long getPerfProfile(MatOfDouble timings)
FUNC <vector_String cv.dnn.Net.getLayerNames []>
java: List<String> getLayerNames()
FUNC <vector_String cv.dnn.Net.getUnconnectedOutLayersNames []>
java: List<String> getUnconnectedOutLayersNames()
FUNC <vector_int cv.dnn.Net.getUnconnectedOutLayers []>
java: MatOfInt getUnconnectedOutLayers()
FUNC <void cv.dnn.Net.connect [ARG String outPin=, ARG String inpPin=]>
java: void connect(String outPin, String inpPin)
FUNC <void cv.dnn.Net.dumpToFile [ARG String path=]>
java: void dumpToFile(String path)
FUNC <void cv.dnn.Net.enableFusion [ARG bool fusion=]>
java: void enableFusion(boolean fusion)
FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG String outputName=String()]>
java: void forward(List<Mat> outputBlobs, String outputName)
java: void forward(List<Mat> outputBlobs)
FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>
java: void forward(List<Mat> outputBlobs, List<String> outBlobNames)
FUNC <void cv.dnn.Net.forward [ARG vector_vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>
SKIP:void cv::dnn::Net::forward(vector_vector_Mat& outputBlobs, vector_String outBlobNames)	 due to ARG type vector_vector_Mat/O
FUNC <void cv.dnn.Net.getLayerTypes [ARG vector_String layersTypes=]>
java: void getLayerTypes(List<String> layersTypes)
FUNC <void cv.dnn.Net.getLayersShapes [ARG MatShape netInputShape=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>
SKIP:void cv::dnn::Net::getLayersShapes(MatShape netInputShape, vector_int& layersIds, vector_vector_MatShape& inLayersShapes, vector_vector_MatShape& outLayersShapes)	 due to ARG type vector_vector_MatShape/O
FUNC <void cv.dnn.Net.getLayersShapes [ARG vector_MatShape netInputShapes=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>
SKIP:void cv::dnn::Net::getLayersShapes(vector_MatShape netInputShapes, vector_int& layersIds, vector_vector_MatShape& inLayersShapes, vector_vector_MatShape& outLayersShapes)	 due to ARG type vector_vector_MatShape/O
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(MatOfInt netInputShape, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(int layerId, MatOfInt netInputShape, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG vector_MatShape netInputShapes=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(int layerId, List<MatOfInt> netInputShapes, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.setHalideScheduler [ARG String scheduler=]>
java: void setHalideScheduler(String scheduler)
FUNC <void cv.dnn.Net.setInput [ARG Mat blob=, ARG String name="", ARG double scalefactor=1.0, ARG Scalar mean=Scalar()]>
java: void setInput(Mat blob, String name, double scalefactor, Scalar mean)
java: void setInput(Mat blob, String name, double scalefactor)
java: void setInput(Mat blob, String name)
java: void setInput(Mat blob)
FUNC <void cv.dnn.Net.setInputsNames [ARG vector_String inputBlobNames=]>
java: void setInputsNames(List<String> inputBlobNames)
FUNC <void cv.dnn.Net.setParam [ARG LayerId layer=, ARG int numParam=, ARG Mat blob=]>
java: void setParam(DictValue layer, int numParam, Mat blob)
FUNC <void cv.dnn.Net.setPreferableBackend [ARG int backendId=]>
java: void setPreferableBackend(int backendId)
FUNC <void cv.dnn.Net.setPreferableTarget [ARG int targetId=]>
java: void setPreferableTarget(int targetId)
CLASS cv.dnn::.DictValue : 
FUNC < cv.dnn.DictValue.DictValue [ARG String s=]>
java:  DictValue(String s)
FUNC < cv.dnn.DictValue.DictValue [ARG double p=]>
java:  DictValue(double p)
FUNC < cv.dnn.DictValue.DictValue [ARG int i=]>
java:  DictValue(int i)
FUNC <String cv.dnn.DictValue.getStringValue [ARG int idx=-1]>
java: String getStringValue(int idx)
java: String getStringValue()
FUNC <bool cv.dnn.DictValue.isInt []>
java: boolean isInt()
FUNC <bool cv.dnn.DictValue.isReal []>
java: boolean isReal()
FUNC <bool cv.dnn.DictValue.isString []>
java: boolean isString()
FUNC <double cv.dnn.DictValue.getRealValue [ARG int idx=-1]>
java: double getRealValue(int idx)
java: double getRealValue()
FUNC <int cv.dnn.DictValue.getIntValue [ARG int idx=-1]>
java: int getIntValue(int idx)
java: int getIntValue()

=== MODULE: features2d (/home/borg/404/scripts_robotica/OpenCV/modules/features2d) ===


Files (1):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/features2d/include/opencv2/features2d.hpp']

Common headers (1):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/features2d/misc/java/src/cpp/features2d_converters.hpp']
ok: class CLASS ::.Features2d : , name: Features2d, base: 

===== Common header : /home/borg/404/scripts_robotica/OpenCV/modules/features2d/misc/java/src/cpp/features2d_converters.hpp =====


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/features2d/include/opencv2/features2d.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'class cv.Feature2D',
    u': cv::Algorithm, cv::class, cv::Feature2D, cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv::.Feature2D : Algorithm, name: Feature2D, base: Algorithm

--- Incoming ---
[   u'cv.Feature2D.detect',
    u'void',
    ['/V'],
    [   ['Mat', u'image', '', []],
        [u'vector_KeyPoint', u'keypoints', u'', ['/O', '/Ref']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.Feature2D.detect [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.Feature2D.detect',
    u'void',
    ['/V'],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_vector_KeyPoint', u'keypoints', u'', ['/O', '/Ref']],
        ['vector_Mat', u'masks', u'vector_Mat()', []]],
    u'void']
ok: FUNC <void cv.Feature2D.detect [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat masks=vector_Mat()]>

--- Incoming ---
[   u'cv.Feature2D.compute',
    u'void',
    ['/V'],
    [   ['Mat', u'image', '', []],
        [u'vector_KeyPoint', u'keypoints', u'', ['/O', '/IO', '/Ref']],
        ['Mat', u'descriptors', '', ['/O']]],
    u'void']
ok: FUNC <void cv.Feature2D.compute [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=]>

--- Incoming ---
[   u'cv.Feature2D.compute',
    u'void',
    ['/V'],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_vector_KeyPoint', u'keypoints', u'', ['/O', '/IO', '/Ref']],
        ['vector_Mat', u'descriptors', '', ['/O']]],
    u'void']
ok: FUNC <void cv.Feature2D.compute [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat descriptors=]>

--- Incoming ---
[   u'cv.Feature2D.detectAndCompute',
    u'void',
    ['/V'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'mask', '', []],
        [u'vector_KeyPoint', u'keypoints', u'', ['/O', '/Ref']],
        ['Mat', u'descriptors', '', ['/O']],
        [u'bool', u'useProvidedKeypoints', u'false', []]],
    u'void']
ok: FUNC <void cv.Feature2D.detectAndCompute [ARG Mat image=, ARG Mat mask=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=, ARG bool useProvidedKeypoints=false]>

--- Incoming ---
[u'cv.Feature2D.descriptorSize', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.Feature2D.descriptorSize []>

--- Incoming ---
[u'cv.Feature2D.descriptorType', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.Feature2D.descriptorType []>

--- Incoming ---
[u'cv.Feature2D.defaultNorm', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.Feature2D.defaultNorm []>

--- Incoming ---
[   u'cv.Feature2D.write',
    u'void',
    ['/C'],
    [[u'String', u'fileName', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Feature2D.write [ARG String fileName=]>

--- Incoming ---
[   u'cv.Feature2D.read',
    u'void',
    [],
    [[u'String', u'fileName', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Feature2D.read [ARG String fileName=]>

--- Incoming ---
[   u'cv.Feature2D.read',
    u'void',
    ['/V'],
    [[u'FileNode', 'arg1', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Feature2D.read [ARG FileNode arg1=]>

--- Incoming ---
[u'cv.Feature2D.empty', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.Feature2D.empty []>

--- Incoming ---
[u'cv.Feature2D.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.Feature2D.getDefaultName []>

--- Incoming ---
[   u'cv.Feature2D.write',
    u'void',
    ['/C'],
    [   [u'Ptr_FileStorage', u'fs', u'', ['/C', '/Ref']],
        [u'String', u'name', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Feature2D.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[u'class cv.BRISK', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.BRISK : Feature2D, name: BRISK, base: Feature2D

--- Incoming ---
[   u'cv.BRISK.create',
    u'Ptr_BRISK',
    ['/S'],
    [   [u'int', u'thresh', u'30', []],
        [u'int', u'octaves', u'3', []],
        [u'float', u'patternScale', u'1.0f', []]],
    u'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=30, ARG int octaves=3, ARG float patternScale=1.0f]>

--- Incoming ---
[   u'cv.BRISK.create',
    u'Ptr_BRISK',
    ['/S'],
    [   [u'vector_float', u'radiusList', u'', ['/C', '/Ref']],
        [u'vector_int', u'numberList', u'', ['/C', '/Ref']],
        [u'float', u'dMax', u'5.85f', []],
        [u'float', u'dMin', u'8.2f', []],
        [   u'vector_int',
            u'indexChange',
            u'std::vector<int>()',
            ['/C', '/Ref']]],
    u'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>

--- Incoming ---
[   u'cv.BRISK.create',
    u'Ptr_BRISK',
    ['/S'],
    [   [u'int', u'thresh', u'', []],
        [u'int', u'octaves', u'', []],
        [u'vector_float', u'radiusList', u'', ['/C', '/Ref']],
        [u'vector_int', u'numberList', u'', ['/C', '/Ref']],
        [u'float', u'dMax', u'5.85f', []],
        [u'float', u'dMin', u'8.2f', []],
        [   u'vector_int',
            u'indexChange',
            u'std::vector<int>()',
            ['/C', '/Ref']]],
    u'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=, ARG int octaves=, ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>

--- Incoming ---
[u'cv.BRISK.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.BRISK.getDefaultName []>

--- Incoming ---
[   u'cv.BRISK.setThreshold',
    u'void',
    ['/V'],
    [[u'int', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BRISK.setThreshold [ARG int threshold=]>

--- Incoming ---
[u'cv.BRISK.getThreshold', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.BRISK.getThreshold []>

--- Incoming ---
[   u'cv.BRISK.setOctaves',
    u'void',
    ['/V'],
    [[u'int', u'octaves', u'', []]],
    u'void']
ok: FUNC <void cv.BRISK.setOctaves [ARG int octaves=]>

--- Incoming ---
[u'cv.BRISK.getOctaves', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.BRISK.getOctaves []>

--- Incoming ---
[u'class cv.ORB', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.ORB : Feature2D, name: ORB, base: Feature2D

--- Incoming ---
[   u'enum cv.ORB.ScoreType',
    '',
    [],
    [   [u'const cv.ORB.HARRIS_SCORE', u'0', [], [], None, ''],
        [u'const cv.ORB.FAST_SCORE', u'1', [], [], None, '']],
    None]
ok: CONST HARRIS_SCORE=0
ok: CONST FAST_SCORE=1

--- Incoming ---
[   u'cv.ORB.create',
    u'Ptr_ORB',
    ['/S'],
    [   [u'int', u'nfeatures', u'500', []],
        [u'float', u'scaleFactor', u'1.2f', []],
        [u'int', u'nlevels', u'8', []],
        [u'int', u'edgeThreshold', u'31', []],
        [u'int', u'firstLevel', u'0', []],
        [u'int', u'WTA_K', u'2', []],
        [u'ORB_ScoreType', u'scoreType', u'ORB::HARRIS_SCORE', []],
        [u'int', u'patchSize', u'31', []],
        [u'int', u'fastThreshold', u'20', []]],
    u'Ptr<ORB>']
ok: FUNC <Ptr_ORB cv.ORB.create [ARG int nfeatures=500, ARG float scaleFactor=1.2f, ARG int nlevels=8, ARG int edgeThreshold=31, ARG int firstLevel=0, ARG int WTA_K=2, ARG ORB_ScoreType scoreType=ORB::HARRIS_SCORE, ARG int patchSize=31, ARG int fastThreshold=20]>

--- Incoming ---
[   u'cv.ORB.setMaxFeatures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxFeatures', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setMaxFeatures [ARG int maxFeatures=]>

--- Incoming ---
[u'cv.ORB.getMaxFeatures', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getMaxFeatures []>

--- Incoming ---
[   u'cv.ORB.setScaleFactor',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'scaleFactor', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setScaleFactor [ARG double scaleFactor=]>

--- Incoming ---
[u'cv.ORB.getScaleFactor', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ORB.getScaleFactor []>

--- Incoming ---
[   u'cv.ORB.setNLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nlevels', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setNLevels [ARG int nlevels=]>

--- Incoming ---
[u'cv.ORB.getNLevels', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getNLevels []>

--- Incoming ---
[   u'cv.ORB.setEdgeThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'edgeThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setEdgeThreshold [ARG int edgeThreshold=]>

--- Incoming ---
[u'cv.ORB.getEdgeThreshold', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getEdgeThreshold []>

--- Incoming ---
[   u'cv.ORB.setFirstLevel',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'firstLevel', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setFirstLevel [ARG int firstLevel=]>

--- Incoming ---
[u'cv.ORB.getFirstLevel', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getFirstLevel []>

--- Incoming ---
[   u'cv.ORB.setWTA_K',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'wta_k', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setWTA_K [ARG int wta_k=]>

--- Incoming ---
[u'cv.ORB.getWTA_K', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getWTA_K []>

--- Incoming ---
[   u'cv.ORB.setScoreType',
    u'void',
    ['/V', '/PV'],
    [[u'ORB_ScoreType', u'scoreType', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setScoreType [ARG ORB_ScoreType scoreType=]>

--- Incoming ---
[   u'cv.ORB.getScoreType',
    u'ORB_ScoreType',
    ['/C', '/V', '/PV'],
    [],
    u'ORB::ScoreType']
ok: FUNC <ORB_ScoreType cv.ORB.getScoreType []>

--- Incoming ---
[   u'cv.ORB.setPatchSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'patchSize', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setPatchSize [ARG int patchSize=]>

--- Incoming ---
[u'cv.ORB.getPatchSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getPatchSize []>

--- Incoming ---
[   u'cv.ORB.setFastThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'fastThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setFastThreshold [ARG int fastThreshold=]>

--- Incoming ---
[u'cv.ORB.getFastThreshold', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getFastThreshold []>

--- Incoming ---
[u'cv.ORB.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.ORB.getDefaultName []>

--- Incoming ---
[u'class cv.MSER', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.MSER : Feature2D, name: MSER, base: Feature2D

--- Incoming ---
[   u'cv.MSER.create',
    u'Ptr_MSER',
    ['/S'],
    [   [u'int', u'_delta', u'5', []],
        [u'int', u'_min_area', u'60', []],
        [u'int', u'_max_area', u'14400', []],
        [u'double', u'_max_variation', u'0.25', []],
        [u'double', u'_min_diversity', u'.2', []],
        [u'int', u'_max_evolution', u'200', []],
        [u'double', u'_area_threshold', u'1.01', []],
        [u'double', u'_min_margin', u'0.003', []],
        [u'int', u'_edge_blur_size', u'5', []]],
    u'Ptr<MSER>']
ok: FUNC <Ptr_MSER cv.MSER.create [ARG int _delta=5, ARG int _min_area=60, ARG int _max_area=14400, ARG double _max_variation=0.25, ARG double _min_diversity=.2, ARG int _max_evolution=200, ARG double _area_threshold=1.01, ARG double _min_margin=0.003, ARG int _edge_blur_size=5]>

--- Incoming ---
[   u'cv.MSER.detectRegions',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        [u'vector_vector_Point', u'msers', u'', ['/O', '/Ref']],
        [u'vector_Rect', u'bboxes', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.MSER.detectRegions [ARG Mat image=, ARG vector_vector_Point msers=, ARG vector_Rect bboxes=]>

--- Incoming ---
[   u'cv.MSER.setDelta',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'delta', u'', []]],
    u'void']
ok: FUNC <void cv.MSER.setDelta [ARG int delta=]>

--- Incoming ---
[u'cv.MSER.getDelta', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.MSER.getDelta []>

--- Incoming ---
[   u'cv.MSER.setMinArea',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'minArea', u'', []]],
    u'void']
ok: FUNC <void cv.MSER.setMinArea [ARG int minArea=]>

--- Incoming ---
[u'cv.MSER.getMinArea', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.MSER.getMinArea []>

--- Incoming ---
[   u'cv.MSER.setMaxArea',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxArea', u'', []]],
    u'void']
ok: FUNC <void cv.MSER.setMaxArea [ARG int maxArea=]>

--- Incoming ---
[u'cv.MSER.getMaxArea', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.MSER.getMaxArea []>

--- Incoming ---
[   u'cv.MSER.setPass2Only',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'f', u'', []]],
    u'void']
ok: FUNC <void cv.MSER.setPass2Only [ARG bool f=]>

--- Incoming ---
[u'cv.MSER.getPass2Only', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.MSER.getPass2Only []>

--- Incoming ---
[u'cv.MSER.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.MSER.getDefaultName []>

--- Incoming ---
[u'class cv.FastFeatureDetector', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.FastFeatureDetector : Feature2D, name: FastFeatureDetector, base: Feature2D

--- Incoming ---
[   u'enum cv.FastFeatureDetector.DetectorType',
    '',
    [],
    [   [u'const cv.FastFeatureDetector.TYPE_5_8', u'0', [], [], None, ''],
        [u'const cv.FastFeatureDetector.TYPE_7_12', u'1', [], [], None, ''],
        [u'const cv.FastFeatureDetector.TYPE_9_16', u'2', [], [], None, '']],
    None]
ok: CONST TYPE_5_8=0
ok: CONST TYPE_7_12=1
ok: CONST TYPE_9_16=2

--- Incoming ---
[   u'enum cv.FastFeatureDetector.<unnamed>',
    '',
    [],
    [   [   u'const cv.FastFeatureDetector.THRESHOLD',
            u'10000',
            [],
            [],
            None,
            ''],
        [   u'const cv.FastFeatureDetector.NONMAX_SUPPRESSION',
            u'10001',
            [],
            [],
            None,
            ''],
        [u'const cv.FastFeatureDetector.FAST_N', u'10002', [], [], None, '']],
    None]
ok: CONST THRESHOLD=10000
ok: CONST NONMAX_SUPPRESSION=10001
ok: CONST FAST_N=10002

--- Incoming ---
[   u'cv.FastFeatureDetector.create',
    u'Ptr_FastFeatureDetector',
    ['/S'],
    [   [u'int', u'threshold', u'10', []],
        [u'bool', u'nonmaxSuppression', u'true', []],
        [   u'FastFeatureDetector_DetectorType',
            u'type',
            u'FastFeatureDetector::TYPE_9_16',
            []]],
    u'Ptr<FastFeatureDetector>']
ok: FUNC <Ptr_FastFeatureDetector cv.FastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG FastFeatureDetector_DetectorType type=FastFeatureDetector::TYPE_9_16]>

--- Incoming ---
[   u'cv.FastFeatureDetector.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.FastFeatureDetector.setThreshold [ARG int threshold=]>

--- Incoming ---
[   u'cv.FastFeatureDetector.getThreshold',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.FastFeatureDetector.getThreshold []>

--- Incoming ---
[   u'cv.FastFeatureDetector.setNonmaxSuppression',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'f', u'', []]],
    u'void']
ok: FUNC <void cv.FastFeatureDetector.setNonmaxSuppression [ARG bool f=]>

--- Incoming ---
[   u'cv.FastFeatureDetector.getNonmaxSuppression',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.FastFeatureDetector.getNonmaxSuppression []>

--- Incoming ---
[   u'cv.FastFeatureDetector.setType',
    u'void',
    ['/V', '/PV'],
    [[u'FastFeatureDetector_DetectorType', u'type', u'', []]],
    u'void']
ok: FUNC <void cv.FastFeatureDetector.setType [ARG FastFeatureDetector_DetectorType type=]>

--- Incoming ---
[   u'cv.FastFeatureDetector.getType',
    u'FastFeatureDetector_DetectorType',
    ['/C', '/V', '/PV'],
    [],
    u'FastFeatureDetector::DetectorType']
ok: FUNC <FastFeatureDetector_DetectorType cv.FastFeatureDetector.getType []>

--- Incoming ---
[   u'cv.FastFeatureDetector.getDefaultName',
    u'String',
    ['/C', '/V'],
    [],
    u'String']
ok: FUNC <String cv.FastFeatureDetector.getDefaultName []>

--- Incoming ---
[u'class cv.AgastFeatureDetector', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.AgastFeatureDetector : Feature2D, name: AgastFeatureDetector, base: Feature2D

--- Incoming ---
[   u'enum cv.AgastFeatureDetector.DetectorType',
    '',
    [],
    [   [u'const cv.AgastFeatureDetector.AGAST_5_8', u'0', [], [], None, ''],
        [   u'const cv.AgastFeatureDetector.AGAST_7_12d',
            u'1',
            [],
            [],
            None,
            ''],
        [   u'const cv.AgastFeatureDetector.AGAST_7_12s',
            u'2',
            [],
            [],
            None,
            ''],
        [u'const cv.AgastFeatureDetector.OAST_9_16', u'3', [], [], None, '']],
    None]
ok: CONST AGAST_5_8=0
ok: CONST AGAST_7_12d=1
ok: CONST AGAST_7_12s=2
ok: CONST OAST_9_16=3

--- Incoming ---
[   u'enum cv.AgastFeatureDetector.<unnamed>',
    '',
    [],
    [   [   u'const cv.AgastFeatureDetector.THRESHOLD',
            u'10000',
            [],
            [],
            None,
            ''],
        [   u'const cv.AgastFeatureDetector.NONMAX_SUPPRESSION',
            u'10001',
            [],
            [],
            None,
            '']],
    None]
ok: CONST THRESHOLD=10000
ok: CONST NONMAX_SUPPRESSION=10001

--- Incoming ---
[   u'cv.AgastFeatureDetector.create',
    u'Ptr_AgastFeatureDetector',
    ['/S'],
    [   [u'int', u'threshold', u'10', []],
        [u'bool', u'nonmaxSuppression', u'true', []],
        [   u'AgastFeatureDetector_DetectorType',
            u'type',
            u'AgastFeatureDetector::OAST_9_16',
            []]],
    u'Ptr<AgastFeatureDetector>']
ok: FUNC <Ptr_AgastFeatureDetector cv.AgastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG AgastFeatureDetector_DetectorType type=AgastFeatureDetector::OAST_9_16]>

--- Incoming ---
[   u'cv.AgastFeatureDetector.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.AgastFeatureDetector.setThreshold [ARG int threshold=]>

--- Incoming ---
[   u'cv.AgastFeatureDetector.getThreshold',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.AgastFeatureDetector.getThreshold []>

--- Incoming ---
[   u'cv.AgastFeatureDetector.setNonmaxSuppression',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'f', u'', []]],
    u'void']
ok: FUNC <void cv.AgastFeatureDetector.setNonmaxSuppression [ARG bool f=]>

--- Incoming ---
[   u'cv.AgastFeatureDetector.getNonmaxSuppression',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.AgastFeatureDetector.getNonmaxSuppression []>

--- Incoming ---
[   u'cv.AgastFeatureDetector.setType',
    u'void',
    ['/V', '/PV'],
    [[u'AgastFeatureDetector_DetectorType', u'type', u'', []]],
    u'void']
ok: FUNC <void cv.AgastFeatureDetector.setType [ARG AgastFeatureDetector_DetectorType type=]>

--- Incoming ---
[   u'cv.AgastFeatureDetector.getType',
    u'AgastFeatureDetector_DetectorType',
    ['/C', '/V', '/PV'],
    [],
    u'AgastFeatureDetector::DetectorType']
ok: FUNC <AgastFeatureDetector_DetectorType cv.AgastFeatureDetector.getType []>

--- Incoming ---
[   u'cv.AgastFeatureDetector.getDefaultName',
    u'String',
    ['/C', '/V'],
    [],
    u'String']
ok: FUNC <String cv.AgastFeatureDetector.getDefaultName []>

--- Incoming ---
[u'class cv.GFTTDetector', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.GFTTDetector : Feature2D, name: GFTTDetector, base: Feature2D

--- Incoming ---
[   u'cv.GFTTDetector.create',
    u'Ptr_GFTTDetector',
    ['/S'],
    [   [u'int', u'maxCorners', u'1000', []],
        [u'double', u'qualityLevel', u'0.01', []],
        [u'double', u'minDistance', u'1', []],
        [u'int', u'blockSize', u'3', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'Ptr<GFTTDetector>']
ok: FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=1000, ARG double qualityLevel=0.01, ARG double minDistance=1, ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.GFTTDetector.create',
    u'Ptr_GFTTDetector',
    ['/S'],
    [   [u'int', u'maxCorners', u'', []],
        [u'double', u'qualityLevel', u'', []],
        [u'double', u'minDistance', u'', []],
        [u'int', u'blockSize', u'', []],
        [u'int', u'gradiantSize', u'', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'Ptr<GFTTDetector>']
ok: FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG int blockSize=, ARG int gradiantSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.GFTTDetector.setMaxFeatures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxFeatures', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setMaxFeatures [ARG int maxFeatures=]>

--- Incoming ---
[u'cv.GFTTDetector.getMaxFeatures', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.GFTTDetector.getMaxFeatures []>

--- Incoming ---
[   u'cv.GFTTDetector.setQualityLevel',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'qlevel', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setQualityLevel [ARG double qlevel=]>

--- Incoming ---
[   u'cv.GFTTDetector.getQualityLevel',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GFTTDetector.getQualityLevel []>

--- Incoming ---
[   u'cv.GFTTDetector.setMinDistance',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minDistance', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setMinDistance [ARG double minDistance=]>

--- Incoming ---
[   u'cv.GFTTDetector.getMinDistance',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GFTTDetector.getMinDistance []>

--- Incoming ---
[   u'cv.GFTTDetector.setBlockSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'blockSize', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setBlockSize [ARG int blockSize=]>

--- Incoming ---
[u'cv.GFTTDetector.getBlockSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.GFTTDetector.getBlockSize []>

--- Incoming ---
[   u'cv.GFTTDetector.setHarrisDetector',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setHarrisDetector [ARG bool val=]>

--- Incoming ---
[   u'cv.GFTTDetector.getHarrisDetector',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.GFTTDetector.getHarrisDetector []>

--- Incoming ---
[   u'cv.GFTTDetector.setK',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'k', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setK [ARG double k=]>

--- Incoming ---
[u'cv.GFTTDetector.getK', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.GFTTDetector.getK []>

--- Incoming ---
[u'cv.GFTTDetector.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.GFTTDetector.getDefaultName []>

--- Incoming ---
[u'class cv.SimpleBlobDetector', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.SimpleBlobDetector : Feature2D, name: SimpleBlobDetector, base: Feature2D

--- Incoming ---
[   u'struct cv.SimpleBlobDetector.Params',
    '',
    ['/Simple'],
    [   [u'float', u'thresholdStep', '', ['/RW']],
        [u'float', u'minThreshold', '', ['/RW']],
        [u'float', u'maxThreshold', '', ['/RW']],
        [u'size_t', u'minRepeatability', '', ['/RW']],
        [u'float', u'minDistBetweenBlobs', '', ['/RW']],
        [u'bool', u'filterByColor', '', ['/RW']],
        [u'uchar', u'blobColor', '', ['/RW']],
        [u'bool', u'filterByArea', '', ['/RW']],
        [u'float', u'minArea', '', ['/RW']],
        [u'float', u'maxArea', '', ['/RW']],
        [u'bool', u'filterByCircularity', '', ['/RW']],
        [u'float', u'minCircularity', '', ['/RW']],
        [u'float', u'maxCircularity', '', ['/RW']],
        [u'bool', u'filterByInertia', '', ['/RW']],
        [u'float', u'minInertiaRatio', '', ['/RW']],
        [u'float', u'maxInertiaRatio', '', ['/RW']],
        [u'bool', u'filterByConvexity', '', ['/RW']],
        [u'float', u'minConvexity', '', ['/RW']],
        [u'float', u'maxConvexity', '', ['/RW']]],
    None]
ok: class CLASS cv::SimpleBlobDetector.Params : , name: Params, base: 

--- Incoming ---
[u'cv.SimpleBlobDetector.Params.Params', '', [], [], None]
ok: FUNC < cv.SimpleBlobDetector.Params.Params []>

--- Incoming ---
[   u'cv.SimpleBlobDetector.create',
    u'Ptr_SimpleBlobDetector',
    ['/S'],
    [   [   u'SimpleBlobDetector_Params',
            u'parameters',
            u'SimpleBlobDetector::Params()',
            ['/C', '/Ref']]],
    u'Ptr<SimpleBlobDetector>']
ok: FUNC <Ptr_SimpleBlobDetector cv.SimpleBlobDetector.create [ARG SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params()]>

--- Incoming ---
[   u'cv.SimpleBlobDetector.getDefaultName',
    u'String',
    ['/C', '/V'],
    [],
    u'String']
ok: FUNC <String cv.SimpleBlobDetector.getDefaultName []>

--- Incoming ---
[u'class cv.KAZE', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.KAZE : Feature2D, name: KAZE, base: Feature2D

--- Incoming ---
[   u'enum cv.KAZE.DiffusivityType',
    '',
    [],
    [   [u'const cv.KAZE.DIFF_PM_G1', u'0', [], [], None, ''],
        [u'const cv.KAZE.DIFF_PM_G2', u'1', [], [], None, ''],
        [u'const cv.KAZE.DIFF_WEICKERT', u'2', [], [], None, ''],
        [u'const cv.KAZE.DIFF_CHARBONNIER', u'3', [], [], None, '']],
    None]
ok: CONST DIFF_PM_G1=0
ok: CONST DIFF_PM_G2=1
ok: CONST DIFF_WEICKERT=2
ok: CONST DIFF_CHARBONNIER=3

--- Incoming ---
[   u'cv.KAZE.create',
    u'Ptr_KAZE',
    ['/S'],
    [   [u'bool', u'extended', u'false', []],
        [u'bool', u'upright', u'false', []],
        [u'float', u'threshold', u'0.001f', []],
        [u'int', u'nOctaves', u'4', []],
        [u'int', u'nOctaveLayers', u'4', []],
        [u'KAZE_DiffusivityType', u'diffusivity', u'KAZE::DIFF_PM_G2', []]],
    u'Ptr<KAZE>']
ok: FUNC <Ptr_KAZE cv.KAZE.create [ARG bool extended=false, ARG bool upright=false, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>

--- Incoming ---
[   u'cv.KAZE.setExtended',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'extended', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setExtended [ARG bool extended=]>

--- Incoming ---
[u'cv.KAZE.getExtended', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.KAZE.getExtended []>

--- Incoming ---
[   u'cv.KAZE.setUpright',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'upright', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setUpright [ARG bool upright=]>

--- Incoming ---
[u'cv.KAZE.getUpright', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.KAZE.getUpright []>

--- Incoming ---
[   u'cv.KAZE.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setThreshold [ARG double threshold=]>

--- Incoming ---
[u'cv.KAZE.getThreshold', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.KAZE.getThreshold []>

--- Incoming ---
[   u'cv.KAZE.setNOctaves',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'octaves', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setNOctaves [ARG int octaves=]>

--- Incoming ---
[u'cv.KAZE.getNOctaves', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.KAZE.getNOctaves []>

--- Incoming ---
[   u'cv.KAZE.setNOctaveLayers',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'octaveLayers', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setNOctaveLayers [ARG int octaveLayers=]>

--- Incoming ---
[u'cv.KAZE.getNOctaveLayers', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.KAZE.getNOctaveLayers []>

--- Incoming ---
[   u'cv.KAZE.setDiffusivity',
    u'void',
    ['/V', '/PV'],
    [[u'KAZE_DiffusivityType', u'diff', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>

--- Incoming ---
[   u'cv.KAZE.getDiffusivity',
    u'KAZE_DiffusivityType',
    ['/C', '/V', '/PV'],
    [],
    u'KAZE::DiffusivityType']
ok: FUNC <KAZE_DiffusivityType cv.KAZE.getDiffusivity []>

--- Incoming ---
[u'cv.KAZE.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.KAZE.getDefaultName []>

--- Incoming ---
[u'class cv.AKAZE', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.AKAZE : Feature2D, name: AKAZE, base: Feature2D

--- Incoming ---
[   u'enum cv.AKAZE.DescriptorType',
    '',
    [],
    [   [u'const cv.AKAZE.DESCRIPTOR_KAZE_UPRIGHT', u'2', [], [], None, ''],
        [u'const cv.AKAZE.DESCRIPTOR_KAZE', u'3', [], [], None, ''],
        [u'const cv.AKAZE.DESCRIPTOR_MLDB_UPRIGHT', u'4', [], [], None, ''],
        [u'const cv.AKAZE.DESCRIPTOR_MLDB', u'5', [], [], None, '']],
    None]
ok: CONST DESCRIPTOR_KAZE_UPRIGHT=2
ok: CONST DESCRIPTOR_KAZE=3
ok: CONST DESCRIPTOR_MLDB_UPRIGHT=4
ok: CONST DESCRIPTOR_MLDB=5

--- Incoming ---
[   u'cv.AKAZE.create',
    u'Ptr_AKAZE',
    ['/S'],
    [   [   u'AKAZE_DescriptorType',
            u'descriptor_type',
            u'AKAZE::DESCRIPTOR_MLDB',
            []],
        [u'int', u'descriptor_size', u'0', []],
        [u'int', u'descriptor_channels', u'3', []],
        [u'float', u'threshold', u'0.001f', []],
        [u'int', u'nOctaves', u'4', []],
        [u'int', u'nOctaveLayers', u'4', []],
        [u'KAZE_DiffusivityType', u'diffusivity', u'KAZE::DIFF_PM_G2', []]],
    u'Ptr<AKAZE>']
ok: FUNC <Ptr_AKAZE cv.AKAZE.create [ARG AKAZE_DescriptorType descriptor_type=AKAZE::DESCRIPTOR_MLDB, ARG int descriptor_size=0, ARG int descriptor_channels=3, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>

--- Incoming ---
[   u'cv.AKAZE.setDescriptorType',
    u'void',
    ['/V', '/PV'],
    [[u'AKAZE_DescriptorType', u'dtype', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setDescriptorType [ARG AKAZE_DescriptorType dtype=]>

--- Incoming ---
[   u'cv.AKAZE.getDescriptorType',
    u'AKAZE_DescriptorType',
    ['/C', '/V', '/PV'],
    [],
    u'AKAZE::DescriptorType']
ok: FUNC <AKAZE_DescriptorType cv.AKAZE.getDescriptorType []>

--- Incoming ---
[   u'cv.AKAZE.setDescriptorSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'dsize', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setDescriptorSize [ARG int dsize=]>

--- Incoming ---
[u'cv.AKAZE.getDescriptorSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AKAZE.getDescriptorSize []>

--- Incoming ---
[   u'cv.AKAZE.setDescriptorChannels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'dch', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setDescriptorChannels [ARG int dch=]>

--- Incoming ---
[u'cv.AKAZE.getDescriptorChannels', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AKAZE.getDescriptorChannels []>

--- Incoming ---
[   u'cv.AKAZE.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setThreshold [ARG double threshold=]>

--- Incoming ---
[u'cv.AKAZE.getThreshold', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.AKAZE.getThreshold []>

--- Incoming ---
[   u'cv.AKAZE.setNOctaves',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'octaves', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setNOctaves [ARG int octaves=]>

--- Incoming ---
[u'cv.AKAZE.getNOctaves', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AKAZE.getNOctaves []>

--- Incoming ---
[   u'cv.AKAZE.setNOctaveLayers',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'octaveLayers', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setNOctaveLayers [ARG int octaveLayers=]>

--- Incoming ---
[u'cv.AKAZE.getNOctaveLayers', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AKAZE.getNOctaveLayers []>

--- Incoming ---
[   u'cv.AKAZE.setDiffusivity',
    u'void',
    ['/V', '/PV'],
    [[u'KAZE_DiffusivityType', u'diff', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>

--- Incoming ---
[   u'cv.AKAZE.getDiffusivity',
    u'KAZE_DiffusivityType',
    ['/C', '/V', '/PV'],
    [],
    u'KAZE::DiffusivityType']
ok: FUNC <KAZE_DiffusivityType cv.AKAZE.getDiffusivity []>

--- Incoming ---
[u'cv.AKAZE.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.AKAZE.getDefaultName []>

--- Incoming ---
[u'class cv.DescriptorMatcher', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.DescriptorMatcher : Algorithm, name: DescriptorMatcher, base: Algorithm

--- Incoming ---
[   u'enum cv.DescriptorMatcher.MatcherType',
    '',
    [],
    [   [u'const cv.DescriptorMatcher.FLANNBASED', u'1', [], [], None, ''],
        [u'const cv.DescriptorMatcher.BRUTEFORCE', u'2', [], [], None, ''],
        [u'const cv.DescriptorMatcher.BRUTEFORCE_L1', u'3', [], [], None, ''],
        [   u'const cv.DescriptorMatcher.BRUTEFORCE_HAMMING',
            u'4',
            [],
            [],
            None,
            ''],
        [   u'const cv.DescriptorMatcher.BRUTEFORCE_HAMMINGLUT',
            u'5',
            [],
            [],
            None,
            ''],
        [   u'const cv.DescriptorMatcher.BRUTEFORCE_SL2',
            u'6',
            [],
            [],
            None,
            '']],
    None]
ok: CONST FLANNBASED=1
ok: CONST BRUTEFORCE=2
ok: CONST BRUTEFORCE_L1=3
ok: CONST BRUTEFORCE_HAMMING=4
ok: CONST BRUTEFORCE_HAMMINGLUT=5
ok: CONST BRUTEFORCE_SL2=6

--- Incoming ---
[   u'cv.DescriptorMatcher.add',
    u'void',
    ['/V'],
    [['vector_Mat', u'descriptors', '', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.add [ARG vector_Mat descriptors=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.getTrainDescriptors',
    u'vector_Mat',
    ['/C'],
    [],
    u'std::vector<Mat>']
ok: FUNC <vector_Mat cv.DescriptorMatcher.getTrainDescriptors []>

--- Incoming ---
[u'cv.DescriptorMatcher.clear', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.DescriptorMatcher.clear []>

--- Incoming ---
[u'cv.DescriptorMatcher.empty', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.DescriptorMatcher.empty []>

--- Incoming ---
[   u'cv.DescriptorMatcher.isMaskSupported',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.DescriptorMatcher.isMaskSupported []>

--- Incoming ---
[u'cv.DescriptorMatcher.train', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.DescriptorMatcher.train []>

--- Incoming ---
[   u'cv.DescriptorMatcher.match',
    u'void',
    ['/C'],
    [   ['Mat', u'queryDescriptors', '', []],
        ['Mat', u'trainDescriptors', '', []],
        [u'vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_DMatch matches=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.DescriptorMatcher.knnMatch',
    u'void',
    ['/C'],
    [   ['Mat', u'queryDescriptors', '', []],
        ['Mat', u'trainDescriptors', '', []],
        [u'vector_vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        [u'int', u'k', u'', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'bool', u'compactResult', u'false', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG Mat mask=Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.radiusMatch',
    u'void',
    ['/C'],
    [   ['Mat', u'queryDescriptors', '', []],
        ['Mat', u'trainDescriptors', '', []],
        [u'vector_vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        [u'float', u'maxDistance', u'', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'bool', u'compactResult', u'false', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG Mat mask=Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.match',
    u'void',
    [],
    [   ['Mat', u'queryDescriptors', '', []],
        [u'vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        ['vector_Mat', u'masks', u'vector_Mat()', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG vector_DMatch matches=, ARG vector_Mat masks=vector_Mat()]>

--- Incoming ---
[   u'cv.DescriptorMatcher.knnMatch',
    u'void',
    [],
    [   ['Mat', u'queryDescriptors', '', []],
        [u'vector_vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        [u'int', u'k', u'', []],
        ['vector_Mat', u'masks', u'vector_Mat()', []],
        [u'bool', u'compactResult', u'false', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.radiusMatch',
    u'void',
    [],
    [   ['Mat', u'queryDescriptors', '', []],
        [u'vector_vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        [u'float', u'maxDistance', u'', []],
        ['vector_Mat', u'masks', u'vector_Mat()', []],
        [u'bool', u'compactResult', u'false', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.write',
    u'void',
    ['/C'],
    [[u'String', u'fileName', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.write [ARG String fileName=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.read',
    u'void',
    [],
    [[u'String', u'fileName', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.read [ARG String fileName=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.read',
    u'void',
    ['/V'],
    [[u'FileNode', 'arg1', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.read [ARG FileNode arg1=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.clone',
    u'Ptr_DescriptorMatcher',
    ['/C', '/V', '/PV'],
    [[u'bool', u'emptyTrainData', u'false', []]],
    u'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.clone [ARG bool emptyTrainData=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.create',
    u'Ptr_DescriptorMatcher',
    ['/S'],
    [[u'String', u'descriptorMatcherType', u'', ['/C', '/Ref']]],
    u'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG String descriptorMatcherType=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.create',
    u'Ptr_DescriptorMatcher',
    ['/S'],
    [[   u'DescriptorMatcher_MatcherType',
            u'matcherType',
            u'',
            ['/C', '/Ref']]],
    u'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG DescriptorMatcher_MatcherType matcherType=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.write',
    u'void',
    ['/C'],
    [   [u'Ptr_FileStorage', u'fs', u'', ['/C', '/Ref']],
        [u'String', u'name', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[u'class cv.BFMatcher', u': cv::DescriptorMatcher', [], [], None]
ok: class CLASS cv::.BFMatcher : DescriptorMatcher, name: BFMatcher, base: DescriptorMatcher

--- Incoming ---
[   u'cv.BFMatcher.BFMatcher',
    '',
    [],
    [   [u'int', u'normType', u'NORM_L2', []],
        [u'bool', u'crossCheck', u'false', []]],
    None]
ok: FUNC < cv.BFMatcher.BFMatcher [ARG int normType=NORM_L2, ARG bool crossCheck=false]>

--- Incoming ---
[   u'cv.BFMatcher.create',
    u'Ptr_BFMatcher',
    ['/S'],
    [   [u'int', u'normType', u'NORM_L2', []],
        [u'bool', u'crossCheck', u'false', []]],
    u'Ptr<BFMatcher>']
ok: FUNC <Ptr_BFMatcher cv.BFMatcher.create [ARG int normType=NORM_L2, ARG bool crossCheck=false]>

--- Incoming ---
[u'class cv.FlannBasedMatcher', u': cv::DescriptorMatcher', [], [], None]
ok: class CLASS cv::.FlannBasedMatcher : DescriptorMatcher, name: FlannBasedMatcher, base: DescriptorMatcher

--- Incoming ---
[   u'cv.FlannBasedMatcher.FlannBasedMatcher',
    '',
    [],
    [   [   u'Ptr_flann_IndexParams',
            u'indexParams',
            u'makePtr<flann::KDTreeIndexParams>()',
            ['/C', '/Ref']],
        [   u'Ptr_flann_SearchParams',
            u'searchParams',
            u'makePtr<flann::SearchParams>()',
            ['/C', '/Ref']]],
    None]
ok: FUNC < cv.FlannBasedMatcher.FlannBasedMatcher [ARG Ptr_flann_IndexParams indexParams=makePtr<flann::KDTreeIndexParams>(), ARG Ptr_flann_SearchParams searchParams=makePtr<flann::SearchParams>()]>

--- Incoming ---
[   u'cv.FlannBasedMatcher.create',
    u'Ptr_FlannBasedMatcher',
    ['/S'],
    [],
    u'Ptr<FlannBasedMatcher>']
ok: FUNC <Ptr_FlannBasedMatcher cv.FlannBasedMatcher.create []>

--- Incoming ---
[   u'enum struct cv.DrawMatchesFlags',
    '',
    [],
    [   [u'const cv.DrawMatchesFlags.DEFAULT', u'0', [], [], None, ''],
        [   u'const cv.DrawMatchesFlags.DRAW_OVER_OUTIMG',
            u'1',
            [],
            [],
            None,
            ''],
        [   u'const cv.DrawMatchesFlags.NOT_DRAW_SINGLE_POINTS',
            u'2',
            [],
            [],
            None,
            ''],
        [   u'const cv.DrawMatchesFlags.DRAW_RICH_KEYPOINTS',
            u'4',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST DEFAULT=0
ok: CONST DrawMatchesFlags_DEFAULT=0
class not found: CONST DRAW_OVER_OUTIMG=1
ok: CONST DrawMatchesFlags_DRAW_OVER_OUTIMG=1
class not found: CONST NOT_DRAW_SINGLE_POINTS=2
ok: CONST DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS=2
class not found: CONST DRAW_RICH_KEYPOINTS=4
ok: CONST DrawMatchesFlags_DRAW_RICH_KEYPOINTS=4

--- Incoming ---
[   u'cv.drawKeypoints',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'vector_KeyPoint', u'keypoints', u'', ['/C', '/Ref']],
        ['Mat', u'outImage', '', ['/IO']],
        [u'Scalar', u'color', u'Scalar::all(-1)', ['/C', '/Ref']],
        [u'DrawMatchesFlags', u'flags', u'DrawMatchesFlags::DEFAULT', []]],
    u'void']
ok: FUNC <void cv..drawKeypoints [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat outImage=, ARG Scalar color=Scalar::all(-1), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[   u'cv.drawMatches',
    u'void',
    [],
    [   ['Mat', u'img1', '', []],
        [u'vector_KeyPoint', u'keypoints1', u'', ['/C', '/Ref']],
        ['Mat', u'img2', '', []],
        [u'vector_KeyPoint', u'keypoints2', u'', ['/C', '/Ref']],
        [u'vector_DMatch', u'matches1to2', u'', ['/C', '/Ref']],
        ['Mat', u'outImg', '', ['/IO']],
        [u'Scalar', u'matchColor', u'Scalar::all(-1)', ['/C', '/Ref']],
        [u'Scalar', u'singlePointColor', u'Scalar::all(-1)', ['/C', '/Ref']],
        [   u'vector_char',
            u'matchesMask',
            u'std::vector<char>()',
            ['/C', '/Ref']],
        [u'DrawMatchesFlags', u'flags', u'DrawMatchesFlags::DEFAULT', []]],
    u'void']
ok: FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_char matchesMask=std::vector<char>(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[   u'cv.drawMatches',
    u'void',
    [u'=drawMatchesKnn'],
    [   ['Mat', u'img1', '', []],
        [u'vector_KeyPoint', u'keypoints1', u'', ['/C', '/Ref']],
        ['Mat', u'img2', '', []],
        [u'vector_KeyPoint', u'keypoints2', u'', ['/C', '/Ref']],
        [u'vector_vector_DMatch', u'matches1to2', u'', ['/C', '/Ref']],
        ['Mat', u'outImg', '', ['/IO']],
        [u'Scalar', u'matchColor', u'Scalar::all(-1)', ['/C', '/Ref']],
        [u'Scalar', u'singlePointColor', u'Scalar::all(-1)', ['/C', '/Ref']],
        [   u'vector_vector_char',
            u'matchesMask',
            u'std::vector<std::vector<char> >()',
            ['/C', '/Ref']],
        [u'DrawMatchesFlags', u'flags', u'DrawMatchesFlags::DEFAULT', []]],
    u'void']
ok: FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_vector_char matchesMask=std::vector<std::vector<char> >(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[u'class cv.BOWTrainer', '', [], [], None]
ok: class CLASS cv::.BOWTrainer : , name: BOWTrainer, base: 

--- Incoming ---
[   u'cv.BOWTrainer.add',
    u'void',
    [],
    [[u'Mat', u'descriptors', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.BOWTrainer.add [ARG Mat descriptors=]>

--- Incoming ---
[   u'cv.BOWTrainer.getDescriptors',
    u'vector_Mat',
    ['/C'],
    [],
    u'std::vector<Mat>']
ok: FUNC <vector_Mat cv.BOWTrainer.getDescriptors []>

--- Incoming ---
[u'cv.BOWTrainer.descriptorsCount', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.BOWTrainer.descriptorsCount []>

--- Incoming ---
[u'cv.BOWTrainer.clear', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.BOWTrainer.clear []>

--- Incoming ---
[u'cv.BOWTrainer.cluster', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.BOWTrainer.cluster []>

--- Incoming ---
[   u'cv.BOWTrainer.cluster',
    u'Mat',
    ['/C', '/V', '/PV'],
    [[u'Mat', u'descriptors', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.BOWTrainer.cluster [ARG Mat descriptors=]>

--- Incoming ---
[u'class cv.BOWKMeansTrainer', u': cv::BOWTrainer', [], [], None]
ok: class CLASS cv::.BOWKMeansTrainer : BOWTrainer, name: BOWKMeansTrainer, base: BOWTrainer

--- Incoming ---
[   u'cv.BOWKMeansTrainer.BOWKMeansTrainer',
    '',
    [],
    [   [u'int', u'clusterCount', u'', []],
        [u'TermCriteria', u'termcrit', u'TermCriteria()', ['/C', '/Ref']],
        [u'int', u'attempts', u'3', []],
        [u'int', u'flags', u'KMEANS_PP_CENTERS', []]],
    None]
ok: FUNC < cv.BOWKMeansTrainer.BOWKMeansTrainer [ARG int clusterCount=, ARG TermCriteria termcrit=TermCriteria(), ARG int attempts=3, ARG int flags=KMEANS_PP_CENTERS]>

--- Incoming ---
[u'cv.BOWKMeansTrainer.cluster', u'Mat', ['/C', '/V'], [], u'Mat']
ok: FUNC <Mat cv.BOWKMeansTrainer.cluster []>

--- Incoming ---
[   u'cv.BOWKMeansTrainer.cluster',
    u'Mat',
    ['/C', '/V'],
    [[u'Mat', u'descriptors', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.BOWKMeansTrainer.cluster [ARG Mat descriptors=]>

--- Incoming ---
[u'class cv.BOWImgDescriptorExtractor', '', [], [], None]
ok: class CLASS cv::.BOWImgDescriptorExtractor : , name: BOWImgDescriptorExtractor, base: 

--- Incoming ---
[   u'cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor',
    '',
    [],
    [   [u'Ptr_DescriptorExtractor', u'dextractor', u'', ['/C', '/Ref']],
        [u'Ptr_DescriptorMatcher', u'dmatcher', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor [ARG Ptr_DescriptorExtractor dextractor=, ARG Ptr_DescriptorMatcher dmatcher=]>

--- Incoming ---
[   u'cv.BOWImgDescriptorExtractor.setVocabulary',
    u'void',
    [],
    [[u'Mat', u'vocabulary', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.BOWImgDescriptorExtractor.setVocabulary [ARG Mat vocabulary=]>

--- Incoming ---
[u'cv.BOWImgDescriptorExtractor.getVocabulary', u'Mat', ['/C'], [], u'Mat']
ok: FUNC <Mat cv.BOWImgDescriptorExtractor.getVocabulary []>

--- Incoming ---
[   u'cv.BOWImgDescriptorExtractor.compute2',
    u'void',
    [u'=compute'],
    [   [u'Mat', u'image', u'', ['/C', '/Ref']],
        [u'vector_KeyPoint', u'keypoints', u'', ['/Ref']],
        [u'Mat', u'imgDescriptor', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.BOWImgDescriptorExtractor.compute2 [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat imgDescriptor=]>

--- Incoming ---
[u'cv.BOWImgDescriptorExtractor.descriptorSize', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.BOWImgDescriptorExtractor.descriptorSize []>

--- Incoming ---
[u'cv.BOWImgDescriptorExtractor.descriptorType', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.BOWImgDescriptorExtractor.descriptorType []>


===== Generating... =====
CLASS cv::.BOWImgDescriptorExtractor : 
FUNC < cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor [ARG Ptr_DescriptorExtractor dextractor=, ARG Ptr_DescriptorMatcher dmatcher=]>
SKIP:cv::BOWImgDescriptorExtractor::BOWImgDescriptorExtractor(Ptr_DescriptorExtractor dextractor, Ptr_DescriptorMatcher dmatcher)	 due to ARG type Ptr_DescriptorExtractor/I
FUNC <Mat cv.BOWImgDescriptorExtractor.getVocabulary []>
java: Mat getVocabulary()
FUNC <int cv.BOWImgDescriptorExtractor.descriptorSize []>
java: int descriptorSize()
FUNC <int cv.BOWImgDescriptorExtractor.descriptorType []>
java: int descriptorType()
FUNC <void cv.BOWImgDescriptorExtractor.compute2 [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat imgDescriptor=]>
java: void compute(Mat image, MatOfKeyPoint keypoints, Mat imgDescriptor)
FUNC <void cv.BOWImgDescriptorExtractor.setVocabulary [ARG Mat vocabulary=]>
java: void setVocabulary(Mat vocabulary)
CLASS cv::.FastFeatureDetector : Feature2D
[CONST TYPE_5_8=0, CONST TYPE_7_12=1, CONST TYPE_9_16=2]
[CONST THRESHOLD=10000, CONST NONMAX_SUPPRESSION=10001, CONST FAST_N=10002]
FUNC <FastFeatureDetector_DetectorType cv.FastFeatureDetector.getType []>
java: int getType()
FUNC <Ptr_FastFeatureDetector cv.FastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG FastFeatureDetector_DetectorType type=FastFeatureDetector::TYPE_9_16]>
java: FastFeatureDetector create(int threshold, boolean nonmaxSuppression, int type)
java: FastFeatureDetector create(int threshold, boolean nonmaxSuppression)
java: FastFeatureDetector create(int threshold)
java: FastFeatureDetector create()
FUNC <String cv.FastFeatureDetector.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.FastFeatureDetector.getNonmaxSuppression []>
java: boolean getNonmaxSuppression()
FUNC <int cv.FastFeatureDetector.getThreshold []>
java: int getThreshold()
FUNC <void cv.FastFeatureDetector.setNonmaxSuppression [ARG bool f=]>
java: void setNonmaxSuppression(boolean f)
FUNC <void cv.FastFeatureDetector.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
FUNC <void cv.FastFeatureDetector.setType [ARG FastFeatureDetector_DetectorType type=]>
java: void setType(int type)
CLASS cv::.Feature2D : Algorithm
FUNC <String cv.Feature2D.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.Feature2D.empty []>
java: boolean empty()
FUNC <int cv.Feature2D.defaultNorm []>
java: int defaultNorm()
FUNC <int cv.Feature2D.descriptorSize []>
java: int descriptorSize()
FUNC <int cv.Feature2D.descriptorType []>
java: int descriptorType()
FUNC <void cv.Feature2D.compute [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=]>
java: void compute(Mat image, MatOfKeyPoint keypoints, Mat descriptors)
FUNC <void cv.Feature2D.compute [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat descriptors=]>
java: void compute(List<Mat> images, List<MatOfKeyPoint> keypoints, List<Mat> descriptors)
FUNC <void cv.Feature2D.detect [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat mask=Mat()]>
java: void detect(Mat image, MatOfKeyPoint keypoints, Mat mask)
java: void detect(Mat image, MatOfKeyPoint keypoints)
FUNC <void cv.Feature2D.detect [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat masks=vector_Mat()]>
java: void detect(List<Mat> images, List<MatOfKeyPoint> keypoints, List<Mat> masks)
java: void detect(List<Mat> images, List<MatOfKeyPoint> keypoints)
FUNC <void cv.Feature2D.detectAndCompute [ARG Mat image=, ARG Mat mask=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=, ARG bool useProvidedKeypoints=false]>
java: void detectAndCompute(Mat image, Mat mask, MatOfKeyPoint keypoints, Mat descriptors, boolean useProvidedKeypoints)
java: void detectAndCompute(Mat image, Mat mask, MatOfKeyPoint keypoints, Mat descriptors)
FUNC <void cv.Feature2D.read [ARG FileNode arg1=]>
SKIP:void cv::Feature2D::read(FileNode arg1)	 due to ARG type FileNode/I
FUNC <void cv.Feature2D.read [ARG String fileName=]>
java: void read(String fileName)
FUNC <void cv.Feature2D.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>
SKIP:void cv::Feature2D::write(Ptr_FileStorage fs, String name = String())	 due to ARG type Ptr_FileStorage/I
FUNC <void cv.Feature2D.write [ARG String fileName=]>
java: void write(String fileName)
CLASS cv::.BRISK : Feature2D
FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=, ARG int octaves=, ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin, MatOfInt indexChange)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList)
FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=30, ARG int octaves=3, ARG float patternScale=1.0f]>
java: BRISK create(int thresh, int octaves, float patternScale)
java: BRISK create(int thresh, int octaves)
java: BRISK create(int thresh)
java: BRISK create()
FUNC <Ptr_BRISK cv.BRISK.create [ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin, MatOfInt indexChange)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList)
FUNC <String cv.BRISK.getDefaultName []>
java: String getDefaultName()
FUNC <int cv.BRISK.getOctaves []>
java: int getOctaves()
FUNC <int cv.BRISK.getThreshold []>
java: int getThreshold()
FUNC <void cv.BRISK.setOctaves [ARG int octaves=]>
java: void setOctaves(int octaves)
FUNC <void cv.BRISK.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
CLASS cv::.SimpleBlobDetector : Feature2D
FUNC <Ptr_SimpleBlobDetector cv.SimpleBlobDetector.create [ARG SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params()]>
java: SimpleBlobDetector create()
java: SimpleBlobDetector create()
FUNC <String cv.SimpleBlobDetector.getDefaultName []>
java: String getDefaultName()
CLASS cv::.AgastFeatureDetector : Feature2D
[CONST AGAST_5_8=0, CONST AGAST_7_12d=1, CONST AGAST_7_12s=2, CONST OAST_9_16=3]
[CONST THRESHOLD=10000, CONST NONMAX_SUPPRESSION=10001]
FUNC <AgastFeatureDetector_DetectorType cv.AgastFeatureDetector.getType []>
java: int getType()
FUNC <Ptr_AgastFeatureDetector cv.AgastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG AgastFeatureDetector_DetectorType type=AgastFeatureDetector::OAST_9_16]>
java: AgastFeatureDetector create(int threshold, boolean nonmaxSuppression, int type)
java: AgastFeatureDetector create(int threshold, boolean nonmaxSuppression)
java: AgastFeatureDetector create(int threshold)
java: AgastFeatureDetector create()
FUNC <String cv.AgastFeatureDetector.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.AgastFeatureDetector.getNonmaxSuppression []>
java: boolean getNonmaxSuppression()
FUNC <int cv.AgastFeatureDetector.getThreshold []>
java: int getThreshold()
FUNC <void cv.AgastFeatureDetector.setNonmaxSuppression [ARG bool f=]>
java: void setNonmaxSuppression(boolean f)
FUNC <void cv.AgastFeatureDetector.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
FUNC <void cv.AgastFeatureDetector.setType [ARG AgastFeatureDetector_DetectorType type=]>
java: void setType(int type)
CLASS cv::.GFTTDetector : Feature2D
FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG int blockSize=, ARG int gradiantSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize, boolean useHarrisDetector, double k)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize, boolean useHarrisDetector)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize)
FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=1000, ARG double qualityLevel=0.01, ARG double minDistance=1, ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, boolean useHarrisDetector, double k)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, boolean useHarrisDetector)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance)
java: GFTTDetector create(int maxCorners, double qualityLevel)
java: GFTTDetector create(int maxCorners)
java: GFTTDetector create()
FUNC <String cv.GFTTDetector.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.GFTTDetector.getHarrisDetector []>
java: boolean getHarrisDetector()
FUNC <double cv.GFTTDetector.getK []>
java: double getK()
FUNC <double cv.GFTTDetector.getMinDistance []>
java: double getMinDistance()
FUNC <double cv.GFTTDetector.getQualityLevel []>
java: double getQualityLevel()
FUNC <int cv.GFTTDetector.getBlockSize []>
java: int getBlockSize()
FUNC <int cv.GFTTDetector.getMaxFeatures []>
java: int getMaxFeatures()
FUNC <void cv.GFTTDetector.setBlockSize [ARG int blockSize=]>
java: void setBlockSize(int blockSize)
FUNC <void cv.GFTTDetector.setHarrisDetector [ARG bool val=]>
java: void setHarrisDetector(boolean val)
FUNC <void cv.GFTTDetector.setK [ARG double k=]>
java: void setK(double k)
FUNC <void cv.GFTTDetector.setMaxFeatures [ARG int maxFeatures=]>
java: void setMaxFeatures(int maxFeatures)
FUNC <void cv.GFTTDetector.setMinDistance [ARG double minDistance=]>
java: void setMinDistance(double minDistance)
FUNC <void cv.GFTTDetector.setQualityLevel [ARG double qlevel=]>
java: void setQualityLevel(double qlevel)
CLASS cv::.DescriptorMatcher : Algorithm
[CONST FLANNBASED=1, CONST BRUTEFORCE=2, CONST BRUTEFORCE_L1=3, CONST BRUTEFORCE_HAMMING=4, CONST BRUTEFORCE_HAMMINGLUT=5, CONST BRUTEFORCE_SL2=6]
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.clone [ARG bool emptyTrainData=false]>
java: DescriptorMatcher clone(boolean emptyTrainData)
java: DescriptorMatcher clone()
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG DescriptorMatcher_MatcherType matcherType=]>
java: DescriptorMatcher create(int matcherType)
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG String descriptorMatcherType=]>
java: DescriptorMatcher create(String descriptorMatcherType)
FUNC <bool cv.DescriptorMatcher.empty []>
java: boolean empty()
FUNC <bool cv.DescriptorMatcher.isMaskSupported []>
java: boolean isMaskSupported()
FUNC <vector_Mat cv.DescriptorMatcher.getTrainDescriptors []>
java: List<Mat> getTrainDescriptors()
FUNC <void cv.DescriptorMatcher.add [ARG vector_Mat descriptors=]>
java: void add(List<Mat> descriptors)
FUNC <void cv.DescriptorMatcher.clear []>
java: void clear()
FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG Mat mask=Mat(), ARG bool compactResult=false]>
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k, Mat mask, boolean compactResult)
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k, Mat mask)
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k)
FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k, List<Mat> masks, boolean compactResult)
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k, List<Mat> masks)
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k)
FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_DMatch matches=, ARG Mat mask=Mat()]>
java: void match(Mat queryDescriptors, Mat trainDescriptors, MatOfDMatch matches, Mat mask)
java: void match(Mat queryDescriptors, Mat trainDescriptors, MatOfDMatch matches)
FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG vector_DMatch matches=, ARG vector_Mat masks=vector_Mat()]>
java: void match(Mat queryDescriptors, MatOfDMatch matches, List<Mat> masks)
java: void match(Mat queryDescriptors, MatOfDMatch matches)
FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG Mat mask=Mat(), ARG bool compactResult=false]>
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance, Mat mask, boolean compactResult)
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance, Mat mask)
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance)
FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance, List<Mat> masks, boolean compactResult)
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance, List<Mat> masks)
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance)
FUNC <void cv.DescriptorMatcher.read [ARG FileNode arg1=]>
SKIP:void cv::DescriptorMatcher::read(FileNode arg1)	 due to ARG type FileNode/I
FUNC <void cv.DescriptorMatcher.read [ARG String fileName=]>
java: void read(String fileName)
FUNC <void cv.DescriptorMatcher.train []>
java: void train()
FUNC <void cv.DescriptorMatcher.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>
SKIP:void cv::DescriptorMatcher::write(Ptr_FileStorage fs, String name = String())	 due to ARG type Ptr_FileStorage/I
FUNC <void cv.DescriptorMatcher.write [ARG String fileName=]>
java: void write(String fileName)
CLASS cv::.KAZE : Feature2D
[CONST DIFF_PM_G1=0, CONST DIFF_PM_G2=1, CONST DIFF_WEICKERT=2, CONST DIFF_CHARBONNIER=3]
FUNC <KAZE_DiffusivityType cv.KAZE.getDiffusivity []>
java: int getDiffusivity()
FUNC <Ptr_KAZE cv.KAZE.create [ARG bool extended=false, ARG bool upright=false, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves, int nOctaveLayers, int diffusivity)
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves, int nOctaveLayers)
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves)
java: KAZE create(boolean extended, boolean upright, float threshold)
java: KAZE create(boolean extended, boolean upright)
java: KAZE create(boolean extended)
java: KAZE create()
FUNC <String cv.KAZE.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.KAZE.getExtended []>
java: boolean getExtended()
FUNC <bool cv.KAZE.getUpright []>
java: boolean getUpright()
FUNC <double cv.KAZE.getThreshold []>
java: double getThreshold()
FUNC <int cv.KAZE.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <int cv.KAZE.getNOctaves []>
java: int getNOctaves()
FUNC <void cv.KAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>
java: void setDiffusivity(int diff)
FUNC <void cv.KAZE.setExtended [ARG bool extended=]>
java: void setExtended(boolean extended)
FUNC <void cv.KAZE.setNOctaveLayers [ARG int octaveLayers=]>
java: void setNOctaveLayers(int octaveLayers)
FUNC <void cv.KAZE.setNOctaves [ARG int octaves=]>
java: void setNOctaves(int octaves)
FUNC <void cv.KAZE.setThreshold [ARG double threshold=]>
java: void setThreshold(double threshold)
FUNC <void cv.KAZE.setUpright [ARG bool upright=]>
java: void setUpright(boolean upright)
CLASS ::.Features2d : 
[CONST DrawMatchesFlags_DEFAULT=0, CONST DrawMatchesFlags_DRAW_OVER_OUTIMG=1, CONST DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS=2, CONST DrawMatchesFlags_DRAW_RICH_KEYPOINTS=4]
FUNC <void cv..drawKeypoints [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat outImage=, ARG Scalar color=Scalar::all(-1), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage, Scalar color, int flags)
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage, Scalar color)
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage)
FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_char matchesMask=std::vector<char>(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask, int flags)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg)
FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_vector_char matchesMask=std::vector<std::vector<char> >(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, List<MatOfByte> matchesMask, int flags)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, List<MatOfByte> matchesMask)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg)
CLASS cv::.AKAZE : Feature2D
[CONST DESCRIPTOR_KAZE_UPRIGHT=2, CONST DESCRIPTOR_KAZE=3, CONST DESCRIPTOR_MLDB_UPRIGHT=4, CONST DESCRIPTOR_MLDB=5]
FUNC <AKAZE_DescriptorType cv.AKAZE.getDescriptorType []>
java: int getDescriptorType()
FUNC <KAZE_DiffusivityType cv.AKAZE.getDiffusivity []>
java: int getDiffusivity()
FUNC <Ptr_AKAZE cv.AKAZE.create [ARG AKAZE_DescriptorType descriptor_type=AKAZE::DESCRIPTOR_MLDB, ARG int descriptor_size=0, ARG int descriptor_channels=3, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves, int nOctaveLayers, int diffusivity)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves, int nOctaveLayers)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels)
java: AKAZE create(int descriptor_type, int descriptor_size)
java: AKAZE create(int descriptor_type)
java: AKAZE create()
FUNC <String cv.AKAZE.getDefaultName []>
java: String getDefaultName()
FUNC <double cv.AKAZE.getThreshold []>
java: double getThreshold()
FUNC <int cv.AKAZE.getDescriptorChannels []>
java: int getDescriptorChannels()
FUNC <int cv.AKAZE.getDescriptorSize []>
java: int getDescriptorSize()
FUNC <int cv.AKAZE.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <int cv.AKAZE.getNOctaves []>
java: int getNOctaves()
FUNC <void cv.AKAZE.setDescriptorChannels [ARG int dch=]>
java: void setDescriptorChannels(int dch)
FUNC <void cv.AKAZE.setDescriptorSize [ARG int dsize=]>
java: void setDescriptorSize(int dsize)
FUNC <void cv.AKAZE.setDescriptorType [ARG AKAZE_DescriptorType dtype=]>
java: void setDescriptorType(int dtype)
FUNC <void cv.AKAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>
java: void setDiffusivity(int diff)
FUNC <void cv.AKAZE.setNOctaveLayers [ARG int octaveLayers=]>
java: void setNOctaveLayers(int octaveLayers)
FUNC <void cv.AKAZE.setNOctaves [ARG int octaves=]>
java: void setNOctaves(int octaves)
FUNC <void cv.AKAZE.setThreshold [ARG double threshold=]>
java: void setThreshold(double threshold)
CLASS cv::SimpleBlobDetector.Params : 
FUNC < cv.SimpleBlobDetector.Params.Params []>
java:  Params()
FUNC <float cv.SimpleBlobDetector.Params.get_thresholdStep []>
java: float get_thresholdStep()
FUNC <void cv.SimpleBlobDetector.Params.set_thresholdStep [ARG float thresholdStep=]>
java: void set_thresholdStep(float thresholdStep)
FUNC <float cv.SimpleBlobDetector.Params.get_minThreshold []>
java: float get_minThreshold()
FUNC <void cv.SimpleBlobDetector.Params.set_minThreshold [ARG float minThreshold=]>
java: void set_minThreshold(float minThreshold)
FUNC <float cv.SimpleBlobDetector.Params.get_maxThreshold []>
java: float get_maxThreshold()
FUNC <void cv.SimpleBlobDetector.Params.set_maxThreshold [ARG float maxThreshold=]>
java: void set_maxThreshold(float maxThreshold)
FUNC <size_t cv.SimpleBlobDetector.Params.get_minRepeatability []>
java: long get_minRepeatability()
FUNC <void cv.SimpleBlobDetector.Params.set_minRepeatability [ARG size_t minRepeatability=]>
java: void set_minRepeatability(long minRepeatability)
FUNC <float cv.SimpleBlobDetector.Params.get_minDistBetweenBlobs []>
java: float get_minDistBetweenBlobs()
FUNC <void cv.SimpleBlobDetector.Params.set_minDistBetweenBlobs [ARG float minDistBetweenBlobs=]>
java: void set_minDistBetweenBlobs(float minDistBetweenBlobs)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByColor []>
java: boolean get_filterByColor()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByColor [ARG bool filterByColor=]>
java: void set_filterByColor(boolean filterByColor)
FUNC <uchar cv.SimpleBlobDetector.Params.get_blobColor []>
SKIP:uchar Params::blobColor	 due to RET type uchar
FUNC <void cv.SimpleBlobDetector.Params.set_blobColor [ARG uchar blobColor=]>
SKIP:void Params::blobColor	 due to ARG type uchar/I
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByArea []>
java: boolean get_filterByArea()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByArea [ARG bool filterByArea=]>
java: void set_filterByArea(boolean filterByArea)
FUNC <float cv.SimpleBlobDetector.Params.get_minArea []>
java: float get_minArea()
FUNC <void cv.SimpleBlobDetector.Params.set_minArea [ARG float minArea=]>
java: void set_minArea(float minArea)
FUNC <float cv.SimpleBlobDetector.Params.get_maxArea []>
java: float get_maxArea()
FUNC <void cv.SimpleBlobDetector.Params.set_maxArea [ARG float maxArea=]>
java: void set_maxArea(float maxArea)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByCircularity []>
java: boolean get_filterByCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByCircularity [ARG bool filterByCircularity=]>
java: void set_filterByCircularity(boolean filterByCircularity)
FUNC <float cv.SimpleBlobDetector.Params.get_minCircularity []>
java: float get_minCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_minCircularity [ARG float minCircularity=]>
java: void set_minCircularity(float minCircularity)
FUNC <float cv.SimpleBlobDetector.Params.get_maxCircularity []>
java: float get_maxCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_maxCircularity [ARG float maxCircularity=]>
java: void set_maxCircularity(float maxCircularity)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByInertia []>
java: boolean get_filterByInertia()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByInertia [ARG bool filterByInertia=]>
java: void set_filterByInertia(boolean filterByInertia)
FUNC <float cv.SimpleBlobDetector.Params.get_minInertiaRatio []>
java: float get_minInertiaRatio()
FUNC <void cv.SimpleBlobDetector.Params.set_minInertiaRatio [ARG float minInertiaRatio=]>
java: void set_minInertiaRatio(float minInertiaRatio)
FUNC <float cv.SimpleBlobDetector.Params.get_maxInertiaRatio []>
java: float get_maxInertiaRatio()
FUNC <void cv.SimpleBlobDetector.Params.set_maxInertiaRatio [ARG float maxInertiaRatio=]>
java: void set_maxInertiaRatio(float maxInertiaRatio)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByConvexity []>
java: boolean get_filterByConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByConvexity [ARG bool filterByConvexity=]>
java: void set_filterByConvexity(boolean filterByConvexity)
FUNC <float cv.SimpleBlobDetector.Params.get_minConvexity []>
java: float get_minConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_minConvexity [ARG float minConvexity=]>
java: void set_minConvexity(float minConvexity)
FUNC <float cv.SimpleBlobDetector.Params.get_maxConvexity []>
java: float get_maxConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_maxConvexity [ARG float maxConvexity=]>
java: void set_maxConvexity(float maxConvexity)
CLASS cv::.BFMatcher : DescriptorMatcher
FUNC < cv.BFMatcher.BFMatcher [ARG int normType=NORM_L2, ARG bool crossCheck=false]>
java:  BFMatcher(int normType, boolean crossCheck)
java:  BFMatcher(int normType)
java:  BFMatcher()
FUNC <Ptr_BFMatcher cv.BFMatcher.create [ARG int normType=NORM_L2, ARG bool crossCheck=false]>
java: BFMatcher create(int normType, boolean crossCheck)
java: BFMatcher create(int normType)
java: BFMatcher create()
CLASS cv::.BOWTrainer : 
FUNC <Mat cv.BOWTrainer.cluster [ARG Mat descriptors=]>
java: Mat cluster(Mat descriptors)
FUNC <Mat cv.BOWTrainer.cluster []>
java: Mat cluster()
FUNC <int cv.BOWTrainer.descriptorsCount []>
java: int descriptorsCount()
FUNC <vector_Mat cv.BOWTrainer.getDescriptors []>
java: List<Mat> getDescriptors()
FUNC <void cv.BOWTrainer.add [ARG Mat descriptors=]>
java: void add(Mat descriptors)
FUNC <void cv.BOWTrainer.clear []>
java: void clear()
CLASS cv::.ORB : Feature2D
[CONST HARRIS_SCORE=0, CONST FAST_SCORE=1]
FUNC <ORB_ScoreType cv.ORB.getScoreType []>
java: int getScoreType()
FUNC <Ptr_ORB cv.ORB.create [ARG int nfeatures=500, ARG float scaleFactor=1.2f, ARG int nlevels=8, ARG int edgeThreshold=31, ARG int firstLevel=0, ARG int WTA_K=2, ARG ORB_ScoreType scoreType=ORB::HARRIS_SCORE, ARG int patchSize=31, ARG int fastThreshold=20]>
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType, int patchSize, int fastThreshold)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType, int patchSize)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold)
java: ORB create(int nfeatures, float scaleFactor, int nlevels)
java: ORB create(int nfeatures, float scaleFactor)
java: ORB create(int nfeatures)
java: ORB create()
FUNC <String cv.ORB.getDefaultName []>
java: String getDefaultName()
FUNC <double cv.ORB.getScaleFactor []>
java: double getScaleFactor()
FUNC <int cv.ORB.getEdgeThreshold []>
java: int getEdgeThreshold()
FUNC <int cv.ORB.getFastThreshold []>
java: int getFastThreshold()
FUNC <int cv.ORB.getFirstLevel []>
java: int getFirstLevel()
FUNC <int cv.ORB.getMaxFeatures []>
java: int getMaxFeatures()
FUNC <int cv.ORB.getNLevels []>
java: int getNLevels()
FUNC <int cv.ORB.getPatchSize []>
java: int getPatchSize()
FUNC <int cv.ORB.getWTA_K []>
java: int getWTA_K()
FUNC <void cv.ORB.setEdgeThreshold [ARG int edgeThreshold=]>
java: void setEdgeThreshold(int edgeThreshold)
FUNC <void cv.ORB.setFastThreshold [ARG int fastThreshold=]>
java: void setFastThreshold(int fastThreshold)
FUNC <void cv.ORB.setFirstLevel [ARG int firstLevel=]>
java: void setFirstLevel(int firstLevel)
FUNC <void cv.ORB.setMaxFeatures [ARG int maxFeatures=]>
java: void setMaxFeatures(int maxFeatures)
FUNC <void cv.ORB.setNLevels [ARG int nlevels=]>
java: void setNLevels(int nlevels)
FUNC <void cv.ORB.setPatchSize [ARG int patchSize=]>
java: void setPatchSize(int patchSize)
FUNC <void cv.ORB.setScaleFactor [ARG double scaleFactor=]>
java: void setScaleFactor(double scaleFactor)
FUNC <void cv.ORB.setScoreType [ARG ORB_ScoreType scoreType=]>
java: void setScoreType(int scoreType)
FUNC <void cv.ORB.setWTA_K [ARG int wta_k=]>
java: void setWTA_K(int wta_k)
CLASS cv::.MSER : Feature2D
FUNC <Ptr_MSER cv.MSER.create [ARG int _delta=5, ARG int _min_area=60, ARG int _max_area=14400, ARG double _max_variation=0.25, ARG double _min_diversity=.2, ARG int _max_evolution=200, ARG double _area_threshold=1.01, ARG double _min_margin=0.003, ARG int _edge_blur_size=5]>
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation)
java: MSER create(int _delta, int _min_area, int _max_area)
java: MSER create(int _delta, int _min_area)
java: MSER create(int _delta)
java: MSER create()
FUNC <String cv.MSER.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.MSER.getPass2Only []>
java: boolean getPass2Only()
FUNC <int cv.MSER.getDelta []>
java: int getDelta()
FUNC <int cv.MSER.getMaxArea []>
java: int getMaxArea()
FUNC <int cv.MSER.getMinArea []>
java: int getMinArea()
FUNC <void cv.MSER.detectRegions [ARG Mat image=, ARG vector_vector_Point msers=, ARG vector_Rect bboxes=]>
java: void detectRegions(Mat image, List<MatOfPoint> msers, MatOfRect bboxes)
FUNC <void cv.MSER.setDelta [ARG int delta=]>
java: void setDelta(int delta)
FUNC <void cv.MSER.setMaxArea [ARG int maxArea=]>
java: void setMaxArea(int maxArea)
FUNC <void cv.MSER.setMinArea [ARG int minArea=]>
java: void setMinArea(int minArea)
FUNC <void cv.MSER.setPass2Only [ARG bool f=]>
java: void setPass2Only(boolean f)
CLASS cv::.BOWKMeansTrainer : BOWTrainer
FUNC < cv.BOWKMeansTrainer.BOWKMeansTrainer [ARG int clusterCount=, ARG TermCriteria termcrit=TermCriteria(), ARG int attempts=3, ARG int flags=KMEANS_PP_CENTERS]>
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit, int attempts, int flags)
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit, int attempts)
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit)
java:  BOWKMeansTrainer(int clusterCount)
FUNC <Mat cv.BOWKMeansTrainer.cluster [ARG Mat descriptors=]>
java: Mat cluster(Mat descriptors)
FUNC <Mat cv.BOWKMeansTrainer.cluster []>
java: Mat cluster()
CLASS cv::.FlannBasedMatcher : DescriptorMatcher
FUNC < cv.FlannBasedMatcher.FlannBasedMatcher [ARG Ptr_flann_IndexParams indexParams=makePtr<flann::KDTreeIndexParams>(), ARG Ptr_flann_SearchParams searchParams=makePtr<flann::SearchParams>()]>
java:  FlannBasedMatcher()
java:  FlannBasedMatcher()
java:  FlannBasedMatcher()
FUNC <Ptr_FlannBasedMatcher cv.FlannBasedMatcher.create []>
java: FlannBasedMatcher create()

=== MODULE: img_hash (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash) ===


Files (8):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/phash.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/average_hash.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/radial_variance_hash.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/color_moment_hash.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/block_mean_hash.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/img_hash_base.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/marr_hildreth_hash.hpp']

Common headers (0):
[]
ok: class CLASS ::.Img_hash : , name: Img_hash, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/phash.hpp =====
Namespaces: set([u'cv.img_hash', u'cv'])

--- Incoming ---
[u'class cv.img_hash.PHash', u': cv::img_hash::ImgHashBase', [], [], None]
ok: class CLASS cv.img_hash::.PHash : ImgHashBase, name: PHash, base: ImgHashBase

--- Incoming ---
[u'cv.img_hash.PHash.create', u'Ptr_PHash', ['/S'], [], u'Ptr<PHash>']
ok: FUNC <Ptr_PHash cv.img_hash.PHash.create []>

--- Incoming ---
[   u'cv.img_hash.pHash',
    u'void',
    [],
    [['Mat', u'inputArr', '', []], ['Mat', u'outputArr', '', ['/O']]],
    u'void']
ok: FUNC <void cv.img_hash..pHash [ARG Mat inputArr=, ARG Mat outputArr=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/average_hash.hpp =====
Namespaces: set([u'cv.img_hash', u'cv'])

--- Incoming ---
[   u'class cv.img_hash.AverageHash',
    u': cv::img_hash::ImgHashBase',
    [],
    [],
    None]
ok: class CLASS cv.img_hash::.AverageHash : ImgHashBase, name: AverageHash, base: ImgHashBase

--- Incoming ---
[   u'cv.img_hash.AverageHash.create',
    u'Ptr_AverageHash',
    ['/S'],
    [],
    u'Ptr<AverageHash>']
ok: FUNC <Ptr_AverageHash cv.img_hash.AverageHash.create []>

--- Incoming ---
[   u'cv.img_hash.averageHash',
    u'void',
    [],
    [['Mat', u'inputArr', '', []], ['Mat', u'outputArr', '', ['/O']]],
    u'void']
ok: FUNC <void cv.img_hash..averageHash [ARG Mat inputArr=, ARG Mat outputArr=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/radial_variance_hash.hpp =====
Namespaces: set([u'cv.img_hash', u'cv'])

--- Incoming ---
[   u'class cv.img_hash.RadialVarianceHash',
    u': cv::img_hash::ImgHashBase',
    [],
    [],
    None]
ok: class CLASS cv.img_hash::.RadialVarianceHash : ImgHashBase, name: RadialVarianceHash, base: ImgHashBase

--- Incoming ---
[   u'cv.img_hash.RadialVarianceHash.create',
    u'Ptr_RadialVarianceHash',
    ['/S'],
    [[u'double', u'sigma', u'1', []], [u'int', u'numOfAngleLine', u'180', []]],
    u'Ptr<RadialVarianceHash>']
ok: FUNC <Ptr_RadialVarianceHash cv.img_hash.RadialVarianceHash.create [ARG double sigma=1, ARG int numOfAngleLine=180]>

--- Incoming ---
[   u'cv.img_hash.RadialVarianceHash.getNumOfAngleLine',
    u'int',
    ['/C'],
    [],
    u'int']
ok: FUNC <int cv.img_hash.RadialVarianceHash.getNumOfAngleLine []>

--- Incoming ---
[u'cv.img_hash.RadialVarianceHash.getSigma', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.img_hash.RadialVarianceHash.getSigma []>

--- Incoming ---
[   u'cv.img_hash.RadialVarianceHash.setNumOfAngleLine',
    u'void',
    [],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.img_hash.RadialVarianceHash.setNumOfAngleLine [ARG int value=]>

--- Incoming ---
[   u'cv.img_hash.RadialVarianceHash.setSigma',
    u'void',
    [],
    [[u'double', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.img_hash.RadialVarianceHash.setSigma [ARG double value=]>

--- Incoming ---
[   u'cv.img_hash.radialVarianceHash',
    u'void',
    [],
    [   ['Mat', u'inputArr', '', []],
        ['Mat', u'outputArr', '', ['/O']],
        [u'double', u'sigma', u'1', []],
        [u'int', u'numOfAngleLine', u'180', []]],
    u'void']
ok: FUNC <void cv.img_hash..radialVarianceHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG double sigma=1, ARG int numOfAngleLine=180]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/color_moment_hash.hpp =====
Namespaces: set([u'cv.img_hash', u'cv'])

--- Incoming ---
[   u'class cv.img_hash.ColorMomentHash',
    u': cv::img_hash::ImgHashBase',
    [],
    [],
    None]
ok: class CLASS cv.img_hash::.ColorMomentHash : ImgHashBase, name: ColorMomentHash, base: ImgHashBase

--- Incoming ---
[   u'cv.img_hash.ColorMomentHash.create',
    u'Ptr_ColorMomentHash',
    ['/S'],
    [],
    u'Ptr<ColorMomentHash>']
ok: FUNC <Ptr_ColorMomentHash cv.img_hash.ColorMomentHash.create []>

--- Incoming ---
[   u'cv.img_hash.colorMomentHash',
    u'void',
    [],
    [['Mat', u'inputArr', '', []], ['Mat', u'outputArr', '', ['/O']]],
    u'void']
ok: FUNC <void cv.img_hash..colorMomentHash [ARG Mat inputArr=, ARG Mat outputArr=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/block_mean_hash.hpp =====
Namespaces: set([u'cv.img_hash', u'cv'])

--- Incoming ---
[   u'enum cv.img_hash.BlockMeanHashMode',
    '',
    [],
    [   [u'const cv.img_hash.BLOCK_MEAN_HASH_MODE_0', u'0', [], [], None, ''],
        [u'const cv.img_hash.BLOCK_MEAN_HASH_MODE_1', u'1', [], [], None, '']],
    None]
ok: CONST BLOCK_MEAN_HASH_MODE_0=0
ok: CONST BLOCK_MEAN_HASH_MODE_1=1

--- Incoming ---
[   u'class cv.img_hash.BlockMeanHash',
    u': cv::img_hash::ImgHashBase',
    [],
    [],
    None]
ok: class CLASS cv.img_hash::.BlockMeanHash : ImgHashBase, name: BlockMeanHash, base: ImgHashBase

--- Incoming ---
[   u'cv.img_hash.BlockMeanHash.setMode',
    u'void',
    [],
    [[u'int', u'mode', u'', []]],
    u'void']
ok: FUNC <void cv.img_hash.BlockMeanHash.setMode [ARG int mode=]>

--- Incoming ---
[   u'cv.img_hash.BlockMeanHash.getMean',
    u'vector_double',
    ['/C'],
    [],
    u'std::vector<double>']
ok: FUNC <vector_double cv.img_hash.BlockMeanHash.getMean []>

--- Incoming ---
[   u'cv.img_hash.BlockMeanHash.create',
    u'Ptr_BlockMeanHash',
    ['/S'],
    [[u'int', u'mode', u'BLOCK_MEAN_HASH_MODE_0', []]],
    u'Ptr<BlockMeanHash>']
ok: FUNC <Ptr_BlockMeanHash cv.img_hash.BlockMeanHash.create [ARG int mode=BLOCK_MEAN_HASH_MODE_0]>

--- Incoming ---
[   u'cv.img_hash.blockMeanHash',
    u'void',
    [],
    [   ['Mat', u'inputArr', '', []],
        ['Mat', u'outputArr', '', ['/O']],
        [u'int', u'mode', u'BLOCK_MEAN_HASH_MODE_0', []]],
    u'void']
ok: FUNC <void cv.img_hash..blockMeanHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG int mode=BLOCK_MEAN_HASH_MODE_0]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/img_hash_base.hpp =====
Namespaces: set([u'cv.img_hash', u'cv'])

--- Incoming ---
[u'class cv.img_hash.ImgHashBase', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.img_hash::.ImgHashBase : Algorithm, name: ImgHashBase, base: Algorithm

--- Incoming ---
[   u'cv.img_hash.ImgHashBase.compute',
    u'void',
    [],
    [['Mat', u'inputArr', '', []], ['Mat', u'outputArr', '', ['/O']]],
    u'void']
ok: FUNC <void cv.img_hash.ImgHashBase.compute [ARG Mat inputArr=, ARG Mat outputArr=]>

--- Incoming ---
[   u'cv.img_hash.ImgHashBase.compare',
    u'double',
    ['/C'],
    [['Mat', u'hashOne', '', []], ['Mat', u'hashTwo', '', []]],
    u'double']
ok: FUNC <double cv.img_hash.ImgHashBase.compare [ARG Mat hashOne=, ARG Mat hashTwo=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/img_hash/include/opencv2/img_hash/marr_hildreth_hash.hpp =====
Namespaces: set([u'cv.img_hash', u'cv'])

--- Incoming ---
[   u'class cv.img_hash.MarrHildrethHash',
    u': cv::img_hash::ImgHashBase',
    [],
    [],
    None]
ok: class CLASS cv.img_hash::.MarrHildrethHash : ImgHashBase, name: MarrHildrethHash, base: ImgHashBase

--- Incoming ---
[u'cv.img_hash.MarrHildrethHash.getAlpha', u'float', ['/C'], [], u'float']
ok: FUNC <float cv.img_hash.MarrHildrethHash.getAlpha []>

--- Incoming ---
[u'cv.img_hash.MarrHildrethHash.getScale', u'float', ['/C'], [], u'float']
ok: FUNC <float cv.img_hash.MarrHildrethHash.getScale []>

--- Incoming ---
[   u'cv.img_hash.MarrHildrethHash.setKernelParam',
    u'void',
    [],
    [[u'float', u'alpha', u'', []], [u'float', u'scale', u'', []]],
    u'void']
ok: FUNC <void cv.img_hash.MarrHildrethHash.setKernelParam [ARG float alpha=, ARG float scale=]>

--- Incoming ---
[   u'cv.img_hash.MarrHildrethHash.create',
    u'Ptr_MarrHildrethHash',
    ['/S'],
    [[u'float', u'alpha', u'2.0f', []], [u'float', u'scale', u'1.0f', []]],
    u'Ptr<MarrHildrethHash>']
ok: FUNC <Ptr_MarrHildrethHash cv.img_hash.MarrHildrethHash.create [ARG float alpha=2.0f, ARG float scale=1.0f]>

--- Incoming ---
[   u'cv.img_hash.marrHildrethHash',
    u'void',
    [],
    [   ['Mat', u'inputArr', '', []],
        ['Mat', u'outputArr', '', ['/O']],
        [u'float', u'alpha', u'2.0f', []],
        [u'float', u'scale', u'1.0f', []]],
    u'void']
ok: FUNC <void cv.img_hash..marrHildrethHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG float alpha=2.0f, ARG float scale=1.0f]>


===== Generating... =====
CLASS cv.img_hash::.ColorMomentHash : ImgHashBase
FUNC <Ptr_ColorMomentHash cv.img_hash.ColorMomentHash.create []>
java: ColorMomentHash create()
CLASS cv.img_hash::.AverageHash : ImgHashBase
FUNC <Ptr_AverageHash cv.img_hash.AverageHash.create []>
java: AverageHash create()
CLASS cv.img_hash::.MarrHildrethHash : ImgHashBase
FUNC <Ptr_MarrHildrethHash cv.img_hash.MarrHildrethHash.create [ARG float alpha=2.0f, ARG float scale=1.0f]>
java: MarrHildrethHash create(float alpha, float scale)
java: MarrHildrethHash create(float alpha)
java: MarrHildrethHash create()
FUNC <float cv.img_hash.MarrHildrethHash.getAlpha []>
java: float getAlpha()
FUNC <float cv.img_hash.MarrHildrethHash.getScale []>
java: float getScale()
FUNC <void cv.img_hash.MarrHildrethHash.setKernelParam [ARG float alpha=, ARG float scale=]>
java: void setKernelParam(float alpha, float scale)
CLASS cv.img_hash::.ImgHashBase : Algorithm
FUNC <double cv.img_hash.ImgHashBase.compare [ARG Mat hashOne=, ARG Mat hashTwo=]>
java: double compare(Mat hashOne, Mat hashTwo)
FUNC <void cv.img_hash.ImgHashBase.compute [ARG Mat inputArr=, ARG Mat outputArr=]>
java: void compute(Mat inputArr, Mat outputArr)
CLASS cv.img_hash::.PHash : ImgHashBase
FUNC <Ptr_PHash cv.img_hash.PHash.create []>
java: PHash create()
CLASS cv.img_hash::.RadialVarianceHash : ImgHashBase
FUNC <Ptr_RadialVarianceHash cv.img_hash.RadialVarianceHash.create [ARG double sigma=1, ARG int numOfAngleLine=180]>
java: RadialVarianceHash create(double sigma, int numOfAngleLine)
java: RadialVarianceHash create(double sigma)
java: RadialVarianceHash create()
FUNC <double cv.img_hash.RadialVarianceHash.getSigma []>
java: double getSigma()
FUNC <int cv.img_hash.RadialVarianceHash.getNumOfAngleLine []>
java: int getNumOfAngleLine()
FUNC <void cv.img_hash.RadialVarianceHash.setNumOfAngleLine [ARG int value=]>
java: void setNumOfAngleLine(int value)
FUNC <void cv.img_hash.RadialVarianceHash.setSigma [ARG double value=]>
java: void setSigma(double value)
CLASS ::.Img_hash : 
[CONST BLOCK_MEAN_HASH_MODE_0=0, CONST BLOCK_MEAN_HASH_MODE_1=1]
FUNC <void cv.img_hash..averageHash [ARG Mat inputArr=, ARG Mat outputArr=]>
java: void averageHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..blockMeanHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG int mode=BLOCK_MEAN_HASH_MODE_0]>
java: void blockMeanHash(Mat inputArr, Mat outputArr, int mode)
java: void blockMeanHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..colorMomentHash [ARG Mat inputArr=, ARG Mat outputArr=]>
java: void colorMomentHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..marrHildrethHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG float alpha=2.0f, ARG float scale=1.0f]>
java: void marrHildrethHash(Mat inputArr, Mat outputArr, float alpha, float scale)
java: void marrHildrethHash(Mat inputArr, Mat outputArr, float alpha)
java: void marrHildrethHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..pHash [ARG Mat inputArr=, ARG Mat outputArr=]>
java: void pHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..radialVarianceHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG double sigma=1, ARG int numOfAngleLine=180]>
java: void radialVarianceHash(Mat inputArr, Mat outputArr, double sigma, int numOfAngleLine)
java: void radialVarianceHash(Mat inputArr, Mat outputArr, double sigma)
java: void radialVarianceHash(Mat inputArr, Mat outputArr)
CLASS cv.img_hash::.BlockMeanHash : ImgHashBase
FUNC <Ptr_BlockMeanHash cv.img_hash.BlockMeanHash.create [ARG int mode=BLOCK_MEAN_HASH_MODE_0]>
java: BlockMeanHash create(int mode)
java: BlockMeanHash create()
FUNC <vector_double cv.img_hash.BlockMeanHash.getMean []>
java: MatOfDouble getMean()
FUNC <void cv.img_hash.BlockMeanHash.setMode [ARG int mode=]>
java: void setMode(int mode)

=== MODULE: imgcodecs (/home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs) ===


Files (4):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/ios.h',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp']

Common headers (0):
[]
ok: class CLASS ::.Imgcodecs : , name: Imgcodecs, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/ios.h =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/ios.h


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'enum cv.ImreadModes',
    '',
    [],
    [   [u'const cv.IMREAD_UNCHANGED', u'-1', [], [], None, ''],
        [u'const cv.IMREAD_GRAYSCALE', u'0', [], [], None, ''],
        [u'const cv.IMREAD_COLOR', u'1', [], [], None, ''],
        [u'const cv.IMREAD_ANYDEPTH', u'2', [], [], None, ''],
        [u'const cv.IMREAD_ANYCOLOR', u'4', [], [], None, ''],
        [u'const cv.IMREAD_LOAD_GDAL', u'8', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_GRAYSCALE_2', u'16', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_COLOR_2', u'17', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_GRAYSCALE_4', u'32', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_COLOR_4', u'33', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_GRAYSCALE_8', u'64', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_COLOR_8', u'65', [], [], None, ''],
        [u'const cv.IMREAD_IGNORE_ORIENTATION', u'128', [], [], None, '']],
    None]
ok: CONST IMREAD_UNCHANGED=-1
ok: CONST IMREAD_GRAYSCALE=0
ok: CONST IMREAD_COLOR=1
ok: CONST IMREAD_ANYDEPTH=2
ok: CONST IMREAD_ANYCOLOR=4
ok: CONST IMREAD_LOAD_GDAL=8
ok: CONST IMREAD_REDUCED_GRAYSCALE_2=16
ok: CONST IMREAD_REDUCED_COLOR_2=17
ok: CONST IMREAD_REDUCED_GRAYSCALE_4=32
ok: CONST IMREAD_REDUCED_COLOR_4=33
ok: CONST IMREAD_REDUCED_GRAYSCALE_8=64
ok: CONST IMREAD_REDUCED_COLOR_8=65
ok: CONST IMREAD_IGNORE_ORIENTATION=128

--- Incoming ---
[   u'enum cv.ImwriteFlags',
    '',
    [],
    [   [u'const cv.IMWRITE_JPEG_QUALITY', u'1', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_PROGRESSIVE', u'2', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_OPTIMIZE', u'3', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_RST_INTERVAL', u'4', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_LUMA_QUALITY', u'5', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_CHROMA_QUALITY', u'6', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_COMPRESSION', u'16', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_STRATEGY', u'17', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_BILEVEL', u'18', [], [], None, ''],
        [u'const cv.IMWRITE_PXM_BINARY', u'32', [], [], None, ''],
        [u'const cv.IMWRITE_EXR_TYPE', u'(3 << 4) + 0', [], [], None, ''],
        [u'const cv.IMWRITE_WEBP_QUALITY', u'64', [], [], None, ''],
        [u'const cv.IMWRITE_PAM_TUPLETYPE', u'128', [], [], None, ''],
        [u'const cv.IMWRITE_TIFF_RESUNIT', u'256', [], [], None, ''],
        [u'const cv.IMWRITE_TIFF_XDPI', u'257', [], [], None, ''],
        [u'const cv.IMWRITE_TIFF_YDPI', u'258', [], [], None, ''],
        [u'const cv.IMWRITE_TIFF_COMPRESSION', u'259', [], [], None, ''],
        [   u'const cv.IMWRITE_JPEG2000_COMPRESSION_X1000',
            u'272',
            [],
            [],
            None,
            '']],
    None]
ok: CONST IMWRITE_JPEG_QUALITY=1
ok: CONST IMWRITE_JPEG_PROGRESSIVE=2
ok: CONST IMWRITE_JPEG_OPTIMIZE=3
ok: CONST IMWRITE_JPEG_RST_INTERVAL=4
ok: CONST IMWRITE_JPEG_LUMA_QUALITY=5
ok: CONST IMWRITE_JPEG_CHROMA_QUALITY=6
ok: CONST IMWRITE_PNG_COMPRESSION=16
ok: CONST IMWRITE_PNG_STRATEGY=17
ok: CONST IMWRITE_PNG_BILEVEL=18
ok: CONST IMWRITE_PXM_BINARY=32
ok: CONST IMWRITE_EXR_TYPE=(3 << 4) + 0
ok: CONST IMWRITE_WEBP_QUALITY=64
ok: CONST IMWRITE_PAM_TUPLETYPE=128
ok: CONST IMWRITE_TIFF_RESUNIT=256
ok: CONST IMWRITE_TIFF_XDPI=257
ok: CONST IMWRITE_TIFF_YDPI=258
ok: CONST IMWRITE_TIFF_COMPRESSION=259
ok: CONST IMWRITE_JPEG2000_COMPRESSION_X1000=272

--- Incoming ---
[   u'enum cv.ImwriteEXRTypeFlags',
    '',
    [],
    [   [u'const cv.IMWRITE_EXR_TYPE_HALF', u'1', [], [], None, ''],
        [u'const cv.IMWRITE_EXR_TYPE_FLOAT', u'2', [], [], None, '']],
    None]
ok: CONST IMWRITE_EXR_TYPE_HALF=1
ok: CONST IMWRITE_EXR_TYPE_FLOAT=2

--- Incoming ---
[   u'enum cv.ImwritePNGFlags',
    '',
    [],
    [   [u'const cv.IMWRITE_PNG_STRATEGY_DEFAULT', u'0', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_STRATEGY_FILTERED', u'1', [], [], None, ''],
        [   u'const cv.IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY',
            u'2',
            [],
            [],
            None,
            ''],
        [u'const cv.IMWRITE_PNG_STRATEGY_RLE', u'3', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_STRATEGY_FIXED', u'4', [], [], None, '']],
    None]
ok: CONST IMWRITE_PNG_STRATEGY_DEFAULT=0
ok: CONST IMWRITE_PNG_STRATEGY_FILTERED=1
ok: CONST IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY=2
ok: CONST IMWRITE_PNG_STRATEGY_RLE=3
ok: CONST IMWRITE_PNG_STRATEGY_FIXED=4

--- Incoming ---
[   u'enum cv.ImwritePAMFlags',
    '',
    [],
    [   [u'const cv.IMWRITE_PAM_FORMAT_NULL', u'0', [], [], None, ''],
        [   u'const cv.IMWRITE_PAM_FORMAT_BLACKANDWHITE',
            u'1',
            [],
            [],
            None,
            ''],
        [u'const cv.IMWRITE_PAM_FORMAT_GRAYSCALE', u'2', [], [], None, ''],
        [   u'const cv.IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA',
            u'3',
            [],
            [],
            None,
            ''],
        [u'const cv.IMWRITE_PAM_FORMAT_RGB', u'4', [], [], None, ''],
        [u'const cv.IMWRITE_PAM_FORMAT_RGB_ALPHA', u'5', [], [], None, '']],
    None]
ok: CONST IMWRITE_PAM_FORMAT_NULL=0
ok: CONST IMWRITE_PAM_FORMAT_BLACKANDWHITE=1
ok: CONST IMWRITE_PAM_FORMAT_GRAYSCALE=2
ok: CONST IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA=3
ok: CONST IMWRITE_PAM_FORMAT_RGB=4
ok: CONST IMWRITE_PAM_FORMAT_RGB_ALPHA=5

--- Incoming ---
[   u'cv.imread',
    u'Mat',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'flags', u'IMREAD_COLOR', []]],
    u'Mat']
ok: FUNC <Mat cv..imread [ARG String filename=, ARG int flags=IMREAD_COLOR]>

--- Incoming ---
[   u'cv.imreadmulti',
    u'bool',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'vector_Mat', u'mats', u'', ['/O', '/Ref']],
        [u'int', u'flags', u'IMREAD_ANYCOLOR', []]],
    u'bool']
ok: FUNC <bool cv..imreadmulti [ARG String filename=, ARG vector_Mat mats=, ARG int flags=IMREAD_ANYCOLOR]>

--- Incoming ---
[   u'cv.imwrite',
    u'bool',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        ['Mat', u'img', '', []],
        [u'vector_int', u'params', u'std::vector<int>()', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..imwrite [ARG String filename=, ARG Mat img=, ARG vector_int params=std::vector<int>()]>

--- Incoming ---
[   u'cv.imdecode',
    u'Mat',
    [],
    [['Mat', u'buf', '', []], [u'int', u'flags', u'', []]],
    u'Mat']
ok: FUNC <Mat cv..imdecode [ARG Mat buf=, ARG int flags=]>

--- Incoming ---
[   u'cv.imencode',
    u'bool',
    [],
    [   [u'String', u'ext', u'', ['/C', '/Ref']],
        ['Mat', u'img', '', []],
        [u'vector_uchar', u'buf', u'', ['/O', '/Ref']],
        [u'vector_int', u'params', u'std::vector<int>()', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..imencode [ARG String ext=, ARG Mat img=, ARG vector_uchar buf=, ARG vector_int params=std::vector<int>()]>

--- Incoming ---
[   u'cv.haveImageReader',
    u'bool',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..haveImageReader [ARG String filename=]>

--- Incoming ---
[   u'cv.haveImageWriter',
    u'bool',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..haveImageWriter [ARG String filename=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp =====
Namespaces: set([u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp


===== Generating... =====
CLASS ::.Imgcodecs : 
[CONST IMWRITE_JPEG_QUALITY=1, CONST IMWRITE_JPEG_PROGRESSIVE=2, CONST IMWRITE_JPEG_OPTIMIZE=3, CONST IMWRITE_JPEG_RST_INTERVAL=4, CONST IMWRITE_JPEG_LUMA_QUALITY=5, CONST IMWRITE_JPEG_CHROMA_QUALITY=6, CONST IMWRITE_PNG_COMPRESSION=16, CONST IMWRITE_PNG_STRATEGY=17, CONST IMWRITE_PNG_BILEVEL=18, CONST IMWRITE_PXM_BINARY=32, CONST IMWRITE_EXR_TYPE=(3 << 4) + 0, CONST IMWRITE_WEBP_QUALITY=64, CONST IMWRITE_PAM_TUPLETYPE=128, CONST IMWRITE_TIFF_RESUNIT=256, CONST IMWRITE_TIFF_XDPI=257, CONST IMWRITE_TIFF_YDPI=258, CONST IMWRITE_TIFF_COMPRESSION=259, CONST IMWRITE_JPEG2000_COMPRESSION_X1000=272]
[CONST IMREAD_UNCHANGED=-1, CONST IMREAD_GRAYSCALE=0, CONST IMREAD_COLOR=1, CONST IMREAD_ANYDEPTH=2, CONST IMREAD_ANYCOLOR=4, CONST IMREAD_LOAD_GDAL=8, CONST IMREAD_REDUCED_GRAYSCALE_2=16, CONST IMREAD_REDUCED_COLOR_2=17, CONST IMREAD_REDUCED_GRAYSCALE_4=32, CONST IMREAD_REDUCED_COLOR_4=33, CONST IMREAD_REDUCED_GRAYSCALE_8=64, CONST IMREAD_REDUCED_COLOR_8=65, CONST IMREAD_IGNORE_ORIENTATION=128]
[CONST IMWRITE_PAM_FORMAT_NULL=0, CONST IMWRITE_PAM_FORMAT_BLACKANDWHITE=1, CONST IMWRITE_PAM_FORMAT_GRAYSCALE=2, CONST IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA=3, CONST IMWRITE_PAM_FORMAT_RGB=4, CONST IMWRITE_PAM_FORMAT_RGB_ALPHA=5]
[CONST IMWRITE_EXR_TYPE_HALF=1, CONST IMWRITE_EXR_TYPE_FLOAT=2]
[CONST IMWRITE_PNG_STRATEGY_DEFAULT=0, CONST IMWRITE_PNG_STRATEGY_FILTERED=1, CONST IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY=2, CONST IMWRITE_PNG_STRATEGY_RLE=3, CONST IMWRITE_PNG_STRATEGY_FIXED=4]
FUNC <Mat cv..imdecode [ARG Mat buf=, ARG int flags=]>
java: Mat imdecode(Mat buf, int flags)
FUNC <Mat cv..imread [ARG String filename=, ARG int flags=IMREAD_COLOR]>
java: Mat imread(String filename, int flags)
java: Mat imread(String filename)
FUNC <bool cv..haveImageReader [ARG String filename=]>
java: boolean haveImageReader(String filename)
FUNC <bool cv..haveImageWriter [ARG String filename=]>
java: boolean haveImageWriter(String filename)
FUNC <bool cv..imencode [ARG String ext=, ARG Mat img=, ARG vector_uchar buf=, ARG vector_int params=std::vector<int>()]>
java: boolean imencode(String ext, Mat img, MatOfByte buf, MatOfInt params)
java: boolean imencode(String ext, Mat img, MatOfByte buf)
FUNC <bool cv..imreadmulti [ARG String filename=, ARG vector_Mat mats=, ARG int flags=IMREAD_ANYCOLOR]>
java: boolean imreadmulti(String filename, List<Mat> mats, int flags)
java: boolean imreadmulti(String filename, List<Mat> mats)
FUNC <bool cv..imwrite [ARG String filename=, ARG Mat img=, ARG vector_int params=std::vector<int>()]>
java: boolean imwrite(String filename, Mat img, MatOfInt params)
java: boolean imwrite(String filename, Mat img)

=== MODULE: videoio (/home/borg/404/scripts_robotica/OpenCV/modules/videoio) ===


Files (5):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/videoio_c.h',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/cap_ios.h',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/registry.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/videoio.hpp']

Common headers (0):
[]
ok: class CLASS ::.Videoio : , name: Videoio, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/videoio_c.h =====
Namespaces: set([''])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/videoio_c.h


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/cap_ios.h =====
Namespaces: set([''])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/cap_ios.h


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[   u'enum cv.VideoCaptureAPIs',
    '',
    [],
    [   [u'const cv.CAP_ANY', u'0', [], [], None, ''],
        [u'const cv.CAP_VFW', u'200', [], [], None, ''],
        [u'const cv.CAP_V4L', u'200', [], [], None, ''],
        [u'const cv.CAP_V4L2', u'CAP_V4L', [], [], None, ''],
        [u'const cv.CAP_FIREWIRE', u'300', [], [], None, ''],
        [u'const cv.CAP_FIREWARE', u'CAP_FIREWIRE', [], [], None, ''],
        [u'const cv.CAP_IEEE1394', u'CAP_FIREWIRE', [], [], None, ''],
        [u'const cv.CAP_DC1394', u'CAP_FIREWIRE', [], [], None, ''],
        [u'const cv.CAP_CMU1394', u'CAP_FIREWIRE', [], [], None, ''],
        [u'const cv.CAP_QT', u'500', [], [], None, ''],
        [u'const cv.CAP_UNICAP', u'600', [], [], None, ''],
        [u'const cv.CAP_DSHOW', u'700', [], [], None, ''],
        [u'const cv.CAP_PVAPI', u'800', [], [], None, ''],
        [u'const cv.CAP_OPENNI', u'900', [], [], None, ''],
        [u'const cv.CAP_OPENNI_ASUS', u'910', [], [], None, ''],
        [u'const cv.CAP_ANDROID', u'1000', [], [], None, ''],
        [u'const cv.CAP_XIAPI', u'1100', [], [], None, ''],
        [u'const cv.CAP_AVFOUNDATION', u'1200', [], [], None, ''],
        [u'const cv.CAP_GIGANETIX', u'1300', [], [], None, ''],
        [u'const cv.CAP_MSMF', u'1400', [], [], None, ''],
        [u'const cv.CAP_WINRT', u'1410', [], [], None, ''],
        [u'const cv.CAP_INTELPERC', u'1500', [], [], None, ''],
        [u'const cv.CAP_REALSENSE', u'1500', [], [], None, ''],
        [u'const cv.CAP_OPENNI2', u'1600', [], [], None, ''],
        [u'const cv.CAP_OPENNI2_ASUS', u'1610', [], [], None, ''],
        [u'const cv.CAP_GPHOTO2', u'1700', [], [], None, ''],
        [u'const cv.CAP_GSTREAMER', u'1800', [], [], None, ''],
        [u'const cv.CAP_FFMPEG', u'1900', [], [], None, ''],
        [u'const cv.CAP_IMAGES', u'2000', [], [], None, ''],
        [u'const cv.CAP_ARAVIS', u'2100', [], [], None, ''],
        [u'const cv.CAP_OPENCV_MJPEG', u'2200', [], [], None, ''],
        [u'const cv.CAP_INTEL_MFX', u'2300', [], [], None, ''],
        [u'const cv.CAP_XINE', u'2400', [], [], None, '']],
    None]
ok: CONST CAP_ANY=0
ok: CONST CAP_VFW=200
ok: CONST CAP_V4L=200
ok: CONST CAP_V4L2=CAP_V4L
ok: CONST CAP_FIREWIRE=300
ok: CONST CAP_FIREWARE=CAP_FIREWIRE
ok: CONST CAP_IEEE1394=CAP_FIREWIRE
ok: CONST CAP_DC1394=CAP_FIREWIRE
ok: CONST CAP_CMU1394=CAP_FIREWIRE
ok: CONST CAP_QT=500
ok: CONST CAP_UNICAP=600
ok: CONST CAP_DSHOW=700
ok: CONST CAP_PVAPI=800
ok: CONST CAP_OPENNI=900
ok: CONST CAP_OPENNI_ASUS=910
ok: CONST CAP_ANDROID=1000
ok: CONST CAP_XIAPI=1100
ok: CONST CAP_AVFOUNDATION=1200
ok: CONST CAP_GIGANETIX=1300
ok: CONST CAP_MSMF=1400
ok: CONST CAP_WINRT=1410
ok: CONST CAP_INTELPERC=1500
ok: CONST CAP_REALSENSE=1500
ok: CONST CAP_OPENNI2=1600
ok: CONST CAP_OPENNI2_ASUS=1610
ok: CONST CAP_GPHOTO2=1700
ok: CONST CAP_GSTREAMER=1800
ok: CONST CAP_FFMPEG=1900
ok: CONST CAP_IMAGES=2000
ok: CONST CAP_ARAVIS=2100
ok: CONST CAP_OPENCV_MJPEG=2200
ok: CONST CAP_INTEL_MFX=2300
ok: CONST CAP_XINE=2400

--- Incoming ---
[   u'enum cv.VideoCaptureProperties',
    '',
    [],
    [   [u'const cv.CAP_PROP_POS_MSEC', u'0', [], [], None, ''],
        [u'const cv.CAP_PROP_POS_FRAMES', u'1', [], [], None, ''],
        [u'const cv.CAP_PROP_POS_AVI_RATIO', u'2', [], [], None, ''],
        [u'const cv.CAP_PROP_FRAME_WIDTH', u'3', [], [], None, ''],
        [u'const cv.CAP_PROP_FRAME_HEIGHT', u'4', [], [], None, ''],
        [u'const cv.CAP_PROP_FPS', u'5', [], [], None, ''],
        [u'const cv.CAP_PROP_FOURCC', u'6', [], [], None, ''],
        [u'const cv.CAP_PROP_FRAME_COUNT', u'7', [], [], None, ''],
        [u'const cv.CAP_PROP_FORMAT', u'8', [], [], None, ''],
        [u'const cv.CAP_PROP_MODE', u'9', [], [], None, ''],
        [u'const cv.CAP_PROP_BRIGHTNESS', u'10', [], [], None, ''],
        [u'const cv.CAP_PROP_CONTRAST', u'11', [], [], None, ''],
        [u'const cv.CAP_PROP_SATURATION', u'12', [], [], None, ''],
        [u'const cv.CAP_PROP_HUE', u'13', [], [], None, ''],
        [u'const cv.CAP_PROP_GAIN', u'14', [], [], None, ''],
        [u'const cv.CAP_PROP_EXPOSURE', u'15', [], [], None, ''],
        [u'const cv.CAP_PROP_CONVERT_RGB', u'16', [], [], None, ''],
        [u'const cv.CAP_PROP_WHITE_BALANCE_BLUE_U', u'17', [], [], None, ''],
        [u'const cv.CAP_PROP_RECTIFICATION', u'18', [], [], None, ''],
        [u'const cv.CAP_PROP_MONOCHROME', u'19', [], [], None, ''],
        [u'const cv.CAP_PROP_SHARPNESS', u'20', [], [], None, ''],
        [u'const cv.CAP_PROP_AUTO_EXPOSURE', u'21', [], [], None, ''],
        [u'const cv.CAP_PROP_GAMMA', u'22', [], [], None, ''],
        [u'const cv.CAP_PROP_TEMPERATURE', u'23', [], [], None, ''],
        [u'const cv.CAP_PROP_TRIGGER', u'24', [], [], None, ''],
        [u'const cv.CAP_PROP_TRIGGER_DELAY', u'25', [], [], None, ''],
        [u'const cv.CAP_PROP_WHITE_BALANCE_RED_V', u'26', [], [], None, ''],
        [u'const cv.CAP_PROP_ZOOM', u'27', [], [], None, ''],
        [u'const cv.CAP_PROP_FOCUS', u'28', [], [], None, ''],
        [u'const cv.CAP_PROP_GUID', u'29', [], [], None, ''],
        [u'const cv.CAP_PROP_ISO_SPEED', u'30', [], [], None, ''],
        [u'const cv.CAP_PROP_BACKLIGHT', u'32', [], [], None, ''],
        [u'const cv.CAP_PROP_PAN', u'33', [], [], None, ''],
        [u'const cv.CAP_PROP_TILT', u'34', [], [], None, ''],
        [u'const cv.CAP_PROP_ROLL', u'35', [], [], None, ''],
        [u'const cv.CAP_PROP_IRIS', u'36', [], [], None, ''],
        [u'const cv.CAP_PROP_SETTINGS', u'37', [], [], None, ''],
        [u'const cv.CAP_PROP_BUFFERSIZE', u'38', [], [], None, ''],
        [u'const cv.CAP_PROP_AUTOFOCUS', u'39', [], [], None, ''],
        [u'const cv.CAP_PROP_SAR_NUM', u'40', [], [], None, ''],
        [u'const cv.CAP_PROP_SAR_DEN', u'41', [], [], None, ''],
        [u'const cv.CAP_PROP_BACKEND', u'42', [], [], None, ''],
        [u'const cv.CAP_PROP_CHANNEL', u'43', [], [], None, ''],
        [u'const cv.CAP_PROP_AUTO_WB', u'44', [], [], None, ''],
        [u'const cv.CAP_PROP_WB_TEMPERATURE', u'45', [], [], None, '']],
    None]
ok: CONST CAP_PROP_POS_MSEC=0
ok: CONST CAP_PROP_POS_FRAMES=1
ok: CONST CAP_PROP_POS_AVI_RATIO=2
ok: CONST CAP_PROP_FRAME_WIDTH=3
ok: CONST CAP_PROP_FRAME_HEIGHT=4
ok: CONST CAP_PROP_FPS=5
ok: CONST CAP_PROP_FOURCC=6
ok: CONST CAP_PROP_FRAME_COUNT=7
ok: CONST CAP_PROP_FORMAT=8
ok: CONST CAP_PROP_MODE=9
ok: CONST CAP_PROP_BRIGHTNESS=10
ok: CONST CAP_PROP_CONTRAST=11
ok: CONST CAP_PROP_SATURATION=12
ok: CONST CAP_PROP_HUE=13
ok: CONST CAP_PROP_GAIN=14
ok: CONST CAP_PROP_EXPOSURE=15
ok: CONST CAP_PROP_CONVERT_RGB=16
ok: CONST CAP_PROP_WHITE_BALANCE_BLUE_U=17
ok: CONST CAP_PROP_RECTIFICATION=18
ok: CONST CAP_PROP_MONOCHROME=19
ok: CONST CAP_PROP_SHARPNESS=20
ok: CONST CAP_PROP_AUTO_EXPOSURE=21
ok: CONST CAP_PROP_GAMMA=22
ok: CONST CAP_PROP_TEMPERATURE=23
ok: CONST CAP_PROP_TRIGGER=24
ok: CONST CAP_PROP_TRIGGER_DELAY=25
ok: CONST CAP_PROP_WHITE_BALANCE_RED_V=26
ok: CONST CAP_PROP_ZOOM=27
ok: CONST CAP_PROP_FOCUS=28
ok: CONST CAP_PROP_GUID=29
ok: CONST CAP_PROP_ISO_SPEED=30
ok: CONST CAP_PROP_BACKLIGHT=32
ok: CONST CAP_PROP_PAN=33
ok: CONST CAP_PROP_TILT=34
ok: CONST CAP_PROP_ROLL=35
ok: CONST CAP_PROP_IRIS=36
ok: CONST CAP_PROP_SETTINGS=37
ok: CONST CAP_PROP_BUFFERSIZE=38
ok: CONST CAP_PROP_AUTOFOCUS=39
ok: CONST CAP_PROP_SAR_NUM=40
ok: CONST CAP_PROP_SAR_DEN=41
ok: CONST CAP_PROP_BACKEND=42
ok: CONST CAP_PROP_CHANNEL=43
ok: CONST CAP_PROP_AUTO_WB=44
ok: CONST CAP_PROP_WB_TEMPERATURE=45

--- Incoming ---
[   u'enum cv.VideoWriterProperties',
    '',
    [],
    [   [u'const cv.VIDEOWRITER_PROP_QUALITY', u'1', [], [], None, ''],
        [u'const cv.VIDEOWRITER_PROP_FRAMEBYTES', u'2', [], [], None, ''],
        [u'const cv.VIDEOWRITER_PROP_NSTRIPES', u'3', [], [], None, '']],
    None]
ok: CONST VIDEOWRITER_PROP_QUALITY=1
ok: CONST VIDEOWRITER_PROP_FRAMEBYTES=2
ok: CONST VIDEOWRITER_PROP_NSTRIPES=3

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_DC1394_OFF', u'-4', [], [], None, ''],
        [u'const cv.CAP_PROP_DC1394_MODE_MANUAL', u'-3', [], [], None, ''],
        [u'const cv.CAP_PROP_DC1394_MODE_AUTO', u'-2', [], [], None, ''],
        [   u'const cv.CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO',
            u'-1',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_DC1394_MAX', u'31', [], [], None, '']],
    None]
ok: CONST CAP_PROP_DC1394_OFF=-4
ok: CONST CAP_PROP_DC1394_MODE_MANUAL=-3
ok: CONST CAP_PROP_DC1394_MODE_AUTO=-2
ok: CONST CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO=-1
ok: CONST CAP_PROP_DC1394_MAX=31

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR',
            u'1 << 31',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_IMAGE_GENERATOR',
            u'1 << 30',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_OPENNI_IR_GENERATOR', u'1 << 29', [], [], None, ''],
        [   u'const cv.CAP_OPENNI_GENERATORS_MASK',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_OPENNI_DEPTH_GENERATOR=1 << 31
ok: CONST CAP_OPENNI_IMAGE_GENERATOR=1 << 30
ok: CONST CAP_OPENNI_IR_GENERATOR=1 << 29
ok: CONST CAP_OPENNI_GENERATORS_MASK=CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_OPENNI_OUTPUT_MODE', u'100', [], [], None, ''],
        [   u'const cv.CAP_PROP_OPENNI_FRAME_MAX_DEPTH',
            u'101',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_OPENNI_BASELINE', u'102', [], [], None, ''],
        [u'const cv.CAP_PROP_OPENNI_FOCAL_LENGTH', u'103', [], [], None, ''],
        [u'const cv.CAP_PROP_OPENNI_REGISTRATION', u'104', [], [], None, ''],
        [   u'const cv.CAP_PROP_OPENNI_REGISTRATION_ON',
            u'CAP_PROP_OPENNI_REGISTRATION',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_OPENNI_APPROX_FRAME_SYNC',
            u'105',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_OPENNI_MAX_BUFFER_SIZE',
            u'106',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_OPENNI_CIRCLE_BUFFER', u'107', [], [], None, ''],
        [   u'const cv.CAP_PROP_OPENNI_MAX_TIME_DURATION',
            u'108',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_OPENNI_GENERATOR_PRESENT',
            u'109',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_OPENNI2_SYNC', u'110', [], [], None, ''],
        [u'const cv.CAP_PROP_OPENNI2_MIRROR', u'111', [], [], None, '']],
    None]
ok: CONST CAP_PROP_OPENNI_OUTPUT_MODE=100
ok: CONST CAP_PROP_OPENNI_FRAME_MAX_DEPTH=101
ok: CONST CAP_PROP_OPENNI_BASELINE=102
ok: CONST CAP_PROP_OPENNI_FOCAL_LENGTH=103
ok: CONST CAP_PROP_OPENNI_REGISTRATION=104
ok: CONST CAP_PROP_OPENNI_REGISTRATION_ON=CAP_PROP_OPENNI_REGISTRATION
ok: CONST CAP_PROP_OPENNI_APPROX_FRAME_SYNC=105
ok: CONST CAP_PROP_OPENNI_MAX_BUFFER_SIZE=106
ok: CONST CAP_PROP_OPENNI_CIRCLE_BUFFER=107
ok: CONST CAP_PROP_OPENNI_MAX_TIME_DURATION=108
ok: CONST CAP_PROP_OPENNI_GENERATOR_PRESENT=109
ok: CONST CAP_PROP_OPENNI2_SYNC=110
ok: CONST CAP_PROP_OPENNI2_MIRROR=111

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_OPENNI_IMAGE_GENERATOR_PRESENT',
            u'CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE',
            u'CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_PRESENT',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_BASELINE',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON',
            u'CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_IR_GENERATOR_PRESENT',
            u'CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_OPENNI_IMAGE_GENERATOR_PRESENT=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT
ok: CONST CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_PRESENT=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_BASELINE=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON=CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION
ok: CONST CAP_OPENNI_IR_GENERATOR_PRESENT=CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_OPENNI_DEPTH_MAP', u'0', [], [], None, ''],
        [u'const cv.CAP_OPENNI_POINT_CLOUD_MAP', u'1', [], [], None, ''],
        [u'const cv.CAP_OPENNI_DISPARITY_MAP', u'2', [], [], None, ''],
        [u'const cv.CAP_OPENNI_DISPARITY_MAP_32F', u'3', [], [], None, ''],
        [u'const cv.CAP_OPENNI_VALID_DEPTH_MASK', u'4', [], [], None, ''],
        [u'const cv.CAP_OPENNI_BGR_IMAGE', u'5', [], [], None, ''],
        [u'const cv.CAP_OPENNI_GRAY_IMAGE', u'6', [], [], None, ''],
        [u'const cv.CAP_OPENNI_IR_IMAGE', u'7', [], [], None, '']],
    None]
ok: CONST CAP_OPENNI_DEPTH_MAP=0
ok: CONST CAP_OPENNI_POINT_CLOUD_MAP=1
ok: CONST CAP_OPENNI_DISPARITY_MAP=2
ok: CONST CAP_OPENNI_DISPARITY_MAP_32F=3
ok: CONST CAP_OPENNI_VALID_DEPTH_MASK=4
ok: CONST CAP_OPENNI_BGR_IMAGE=5
ok: CONST CAP_OPENNI_GRAY_IMAGE=6
ok: CONST CAP_OPENNI_IR_IMAGE=7

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_OPENNI_VGA_30HZ', u'0', [], [], None, ''],
        [u'const cv.CAP_OPENNI_SXGA_15HZ', u'1', [], [], None, ''],
        [u'const cv.CAP_OPENNI_SXGA_30HZ', u'2', [], [], None, ''],
        [u'const cv.CAP_OPENNI_QVGA_30HZ', u'3', [], [], None, ''],
        [u'const cv.CAP_OPENNI_QVGA_60HZ', u'4', [], [], None, '']],
    None]
ok: CONST CAP_OPENNI_VGA_30HZ=0
ok: CONST CAP_OPENNI_SXGA_15HZ=1
ok: CONST CAP_OPENNI_SXGA_30HZ=2
ok: CONST CAP_OPENNI_QVGA_30HZ=3
ok: CONST CAP_OPENNI_QVGA_60HZ=4

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [[   u'const cv.CAP_PROP_GSTREAMER_QUEUE_LENGTH',
            u'200',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_GSTREAMER_QUEUE_LENGTH=200

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_PVAPI_MULTICASTIP', u'300', [], [], None, ''],
        [   u'const cv.CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE',
            u'301',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_PVAPI_DECIMATIONHORIZONTAL',
            u'302',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_PVAPI_DECIMATIONVERTICAL',
            u'303',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_PVAPI_BINNINGX', u'304', [], [], None, ''],
        [u'const cv.CAP_PROP_PVAPI_BINNINGY', u'305', [], [], None, ''],
        [u'const cv.CAP_PROP_PVAPI_PIXELFORMAT', u'306', [], [], None, '']],
    None]
ok: CONST CAP_PROP_PVAPI_MULTICASTIP=300
ok: CONST CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE=301
ok: CONST CAP_PROP_PVAPI_DECIMATIONHORIZONTAL=302
ok: CONST CAP_PROP_PVAPI_DECIMATIONVERTICAL=303
ok: CONST CAP_PROP_PVAPI_BINNINGX=304
ok: CONST CAP_PROP_PVAPI_BINNINGY=305
ok: CONST CAP_PROP_PVAPI_PIXELFORMAT=306

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PVAPI_FSTRIGMODE_FREERUN', u'0', [], [], None, ''],
        [u'const cv.CAP_PVAPI_FSTRIGMODE_SYNCIN1', u'1', [], [], None, ''],
        [u'const cv.CAP_PVAPI_FSTRIGMODE_SYNCIN2', u'2', [], [], None, ''],
        [u'const cv.CAP_PVAPI_FSTRIGMODE_FIXEDRATE', u'3', [], [], None, ''],
        [u'const cv.CAP_PVAPI_FSTRIGMODE_SOFTWARE', u'4', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_FSTRIGMODE_FREERUN=0
ok: CONST CAP_PVAPI_FSTRIGMODE_SYNCIN1=1
ok: CONST CAP_PVAPI_FSTRIGMODE_SYNCIN2=2
ok: CONST CAP_PVAPI_FSTRIGMODE_FIXEDRATE=3
ok: CONST CAP_PVAPI_FSTRIGMODE_SOFTWARE=4

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PVAPI_DECIMATION_OFF', u'1', [], [], None, ''],
        [u'const cv.CAP_PVAPI_DECIMATION_2OUTOF4', u'2', [], [], None, ''],
        [u'const cv.CAP_PVAPI_DECIMATION_2OUTOF8', u'4', [], [], None, ''],
        [u'const cv.CAP_PVAPI_DECIMATION_2OUTOF16', u'8', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_DECIMATION_OFF=1
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF4=2
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF8=4
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF16=8

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PVAPI_PIXELFORMAT_MONO8', u'1', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_MONO16', u'2', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_BAYER8', u'3', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_BAYER16', u'4', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_RGB24', u'5', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_BGR24', u'6', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_RGBA32', u'7', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_BGRA32', u'8', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_PIXELFORMAT_MONO8=1
ok: CONST CAP_PVAPI_PIXELFORMAT_MONO16=2
ok: CONST CAP_PVAPI_PIXELFORMAT_BAYER8=3
ok: CONST CAP_PVAPI_PIXELFORMAT_BAYER16=4
ok: CONST CAP_PVAPI_PIXELFORMAT_RGB24=5
ok: CONST CAP_PVAPI_PIXELFORMAT_BGR24=6
ok: CONST CAP_PVAPI_PIXELFORMAT_RGBA32=7
ok: CONST CAP_PVAPI_PIXELFORMAT_BGRA32=8

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_XI_DOWNSAMPLING', u'400', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DATA_FORMAT', u'401', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_OFFSET_X', u'402', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_OFFSET_Y', u'403', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TRG_SOURCE', u'404', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TRG_SOFTWARE', u'405', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPI_SELECTOR', u'406', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPI_MODE', u'407', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPI_LEVEL', u'408', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPO_SELECTOR', u'409', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPO_MODE', u'410', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LED_SELECTOR', u'411', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LED_MODE', u'412', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_MANUAL_WB', u'413', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AUTO_WB', u'414', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG', u'415', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_EXP_PRIORITY', u'416', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AE_MAX_LIMIT', u'417', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AG_MAX_LIMIT', u'418', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_LEVEL', u'419', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TIMEOUT', u'420', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_EXPOSURE', u'421', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_EXPOSURE_BURST_COUNT',
            u'422',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_GAIN_SELECTOR', u'423', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GAIN', u'424', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DOWNSAMPLING_TYPE', u'426', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_BINNING_SELECTOR', u'427', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_BINNING_VERTICAL', u'428', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_BINNING_HORIZONTAL',
            u'429',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_BINNING_PATTERN', u'430', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_DECIMATION_SELECTOR',
            u'431',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_DECIMATION_VERTICAL',
            u'432',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_DECIMATION_HORIZONTAL',
            u'433',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_DECIMATION_PATTERN',
            u'434',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR',
            u'587',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_TEST_PATTERN', u'588', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_IMAGE_DATA_FORMAT', u'435', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_SHUTTER_TYPE', u'436', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_SENSOR_TAPS', u'437', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_ROI_OFFSET_X', u'439', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_ROI_OFFSET_Y', u'440', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_ROI_WIDTH', u'441', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_ROI_HEIGHT', u'442', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_BPC', u'445', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_WB_KR', u'448', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_WB_KG', u'449', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_WB_KB', u'450', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_WIDTH', u'451', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HEIGHT', u'452', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_REGION_SELECTOR', u'589', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_REGION_MODE', u'595', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LIMIT_BANDWIDTH', u'459', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH',
            u'460',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH',
            u'461',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH',
            u'462',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_OUTPUT_DATA_PACKING',
            u'463',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE',
            u'464',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_IS_COOLED', u'465', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_COOLING', u'466', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TARGET_TEMP', u'467', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CHIP_TEMP', u'468', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HOUS_TEMP', u'469', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_HOUS_BACK_SIDE_TEMP',
            u'590',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_SENSOR_BOARD_TEMP', u'596', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CMS', u'470', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_APPLY_CMS', u'471', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_IMAGE_IS_COLOR', u'474', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_COLOR_FILTER_ARRAY',
            u'475',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_GAMMAY', u'476', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GAMMAC', u'477', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_SHARPNESS', u'478', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_00', u'479', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_01', u'480', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_02', u'481', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_03', u'482', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_10', u'483', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_11', u'484', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_12', u'485', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_13', u'486', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_20', u'487', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_21', u'488', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_22', u'489', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_23', u'490', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_30', u'491', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_31', u'492', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_32', u'493', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_33', u'494', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEFAULT_CC_MATRIX', u'495', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TRG_SELECTOR', u'498', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_ACQ_FRAME_BURST_COUNT',
            u'499',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_DEBOUNCE_EN', u'507', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEBOUNCE_T0', u'508', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEBOUNCE_T1', u'509', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEBOUNCE_POL', u'510', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LENS_MODE', u'511', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_LENS_APERTURE_VALUE',
            u'512',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE',
            u'513',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_LENS_FOCUS_MOVE', u'514', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_LENS_FOCUS_DISTANCE',
            u'515',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_LENS_FOCAL_LENGTH', u'516', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_LENS_FEATURE_SELECTOR',
            u'517',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_LENS_FEATURE', u'518', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEVICE_MODEL_ID', u'521', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEVICE_SN', u'522', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA',
            u'529',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_IMAGE_PAYLOAD_SIZE',
            u'530',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT',
            u'531',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ',
            u'532',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX',
            u'533',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT',
            u'534',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_FRAMERATE', u'535', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_COUNTER_SELECTOR', u'536', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_COUNTER_VALUE', u'537', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_ACQ_TIMING_MODE', u'538', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_AVAILABLE_BANDWIDTH',
            u'539',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_BUFFER_POLICY', u'540', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LUT_EN', u'541', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LUT_INDEX', u'542', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LUT_VALUE', u'543', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TRG_DELAY', u'544', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TS_RST_MODE', u'545', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TS_RST_SOURCE', u'546', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_IS_DEVICE_EXIST', u'547', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_ACQ_BUFFER_SIZE', u'548', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT',
            u'549',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE',
            u'550',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_BUFFERS_QUEUE_SIZE',
            u'551',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT',
            u'552',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_RECENT_FRAME', u'553', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEVICE_RESET', u'554', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_COLUMN_FPN_CORRECTION',
            u'555',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_ROW_FPN_CORRECTION',
            u'591',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_SENSOR_MODE', u'558', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HDR', u'559', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_HDR_KNEEPOINT_COUNT',
            u'560',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_HDR_T1', u'561', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HDR_T2', u'562', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_KNEEPOINT1', u'563', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_KNEEPOINT2', u'564', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_IMAGE_BLACK_LEVEL', u'565', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HW_REVISION', u'571', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEBUG_LEVEL', u'572', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION',
            u'573',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_FFS_FILE_ID', u'594', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_FFS_FILE_SIZE', u'580', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_FREE_FFS_SIZE', u'581', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_USED_FFS_SIZE', u'582', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_FFS_ACCESS_KEY', u'583', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_FEATURE_SELECTOR',
            u'585',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_FEATURE_VALUE',
            u'586',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_XI_DOWNSAMPLING=400
ok: CONST CAP_PROP_XI_DATA_FORMAT=401
ok: CONST CAP_PROP_XI_OFFSET_X=402
ok: CONST CAP_PROP_XI_OFFSET_Y=403
ok: CONST CAP_PROP_XI_TRG_SOURCE=404
ok: CONST CAP_PROP_XI_TRG_SOFTWARE=405
ok: CONST CAP_PROP_XI_GPI_SELECTOR=406
ok: CONST CAP_PROP_XI_GPI_MODE=407
ok: CONST CAP_PROP_XI_GPI_LEVEL=408
ok: CONST CAP_PROP_XI_GPO_SELECTOR=409
ok: CONST CAP_PROP_XI_GPO_MODE=410
ok: CONST CAP_PROP_XI_LED_SELECTOR=411
ok: CONST CAP_PROP_XI_LED_MODE=412
ok: CONST CAP_PROP_XI_MANUAL_WB=413
ok: CONST CAP_PROP_XI_AUTO_WB=414
ok: CONST CAP_PROP_XI_AEAG=415
ok: CONST CAP_PROP_XI_EXP_PRIORITY=416
ok: CONST CAP_PROP_XI_AE_MAX_LIMIT=417
ok: CONST CAP_PROP_XI_AG_MAX_LIMIT=418
ok: CONST CAP_PROP_XI_AEAG_LEVEL=419
ok: CONST CAP_PROP_XI_TIMEOUT=420
ok: CONST CAP_PROP_XI_EXPOSURE=421
ok: CONST CAP_PROP_XI_EXPOSURE_BURST_COUNT=422
ok: CONST CAP_PROP_XI_GAIN_SELECTOR=423
ok: CONST CAP_PROP_XI_GAIN=424
ok: CONST CAP_PROP_XI_DOWNSAMPLING_TYPE=426
ok: CONST CAP_PROP_XI_BINNING_SELECTOR=427
ok: CONST CAP_PROP_XI_BINNING_VERTICAL=428
ok: CONST CAP_PROP_XI_BINNING_HORIZONTAL=429
ok: CONST CAP_PROP_XI_BINNING_PATTERN=430
ok: CONST CAP_PROP_XI_DECIMATION_SELECTOR=431
ok: CONST CAP_PROP_XI_DECIMATION_VERTICAL=432
ok: CONST CAP_PROP_XI_DECIMATION_HORIZONTAL=433
ok: CONST CAP_PROP_XI_DECIMATION_PATTERN=434
ok: CONST CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR=587
ok: CONST CAP_PROP_XI_TEST_PATTERN=588
ok: CONST CAP_PROP_XI_IMAGE_DATA_FORMAT=435
ok: CONST CAP_PROP_XI_SHUTTER_TYPE=436
ok: CONST CAP_PROP_XI_SENSOR_TAPS=437
ok: CONST CAP_PROP_XI_AEAG_ROI_OFFSET_X=439
ok: CONST CAP_PROP_XI_AEAG_ROI_OFFSET_Y=440
ok: CONST CAP_PROP_XI_AEAG_ROI_WIDTH=441
ok: CONST CAP_PROP_XI_AEAG_ROI_HEIGHT=442
ok: CONST CAP_PROP_XI_BPC=445
ok: CONST CAP_PROP_XI_WB_KR=448
ok: CONST CAP_PROP_XI_WB_KG=449
ok: CONST CAP_PROP_XI_WB_KB=450
ok: CONST CAP_PROP_XI_WIDTH=451
ok: CONST CAP_PROP_XI_HEIGHT=452
ok: CONST CAP_PROP_XI_REGION_SELECTOR=589
ok: CONST CAP_PROP_XI_REGION_MODE=595
ok: CONST CAP_PROP_XI_LIMIT_BANDWIDTH=459
ok: CONST CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH=460
ok: CONST CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH=461
ok: CONST CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH=462
ok: CONST CAP_PROP_XI_OUTPUT_DATA_PACKING=463
ok: CONST CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE=464
ok: CONST CAP_PROP_XI_IS_COOLED=465
ok: CONST CAP_PROP_XI_COOLING=466
ok: CONST CAP_PROP_XI_TARGET_TEMP=467
ok: CONST CAP_PROP_XI_CHIP_TEMP=468
ok: CONST CAP_PROP_XI_HOUS_TEMP=469
ok: CONST CAP_PROP_XI_HOUS_BACK_SIDE_TEMP=590
ok: CONST CAP_PROP_XI_SENSOR_BOARD_TEMP=596
ok: CONST CAP_PROP_XI_CMS=470
ok: CONST CAP_PROP_XI_APPLY_CMS=471
ok: CONST CAP_PROP_XI_IMAGE_IS_COLOR=474
ok: CONST CAP_PROP_XI_COLOR_FILTER_ARRAY=475
ok: CONST CAP_PROP_XI_GAMMAY=476
ok: CONST CAP_PROP_XI_GAMMAC=477
ok: CONST CAP_PROP_XI_SHARPNESS=478
ok: CONST CAP_PROP_XI_CC_MATRIX_00=479
ok: CONST CAP_PROP_XI_CC_MATRIX_01=480
ok: CONST CAP_PROP_XI_CC_MATRIX_02=481
ok: CONST CAP_PROP_XI_CC_MATRIX_03=482
ok: CONST CAP_PROP_XI_CC_MATRIX_10=483
ok: CONST CAP_PROP_XI_CC_MATRIX_11=484
ok: CONST CAP_PROP_XI_CC_MATRIX_12=485
ok: CONST CAP_PROP_XI_CC_MATRIX_13=486
ok: CONST CAP_PROP_XI_CC_MATRIX_20=487
ok: CONST CAP_PROP_XI_CC_MATRIX_21=488
ok: CONST CAP_PROP_XI_CC_MATRIX_22=489
ok: CONST CAP_PROP_XI_CC_MATRIX_23=490
ok: CONST CAP_PROP_XI_CC_MATRIX_30=491
ok: CONST CAP_PROP_XI_CC_MATRIX_31=492
ok: CONST CAP_PROP_XI_CC_MATRIX_32=493
ok: CONST CAP_PROP_XI_CC_MATRIX_33=494
ok: CONST CAP_PROP_XI_DEFAULT_CC_MATRIX=495
ok: CONST CAP_PROP_XI_TRG_SELECTOR=498
ok: CONST CAP_PROP_XI_ACQ_FRAME_BURST_COUNT=499
ok: CONST CAP_PROP_XI_DEBOUNCE_EN=507
ok: CONST CAP_PROP_XI_DEBOUNCE_T0=508
ok: CONST CAP_PROP_XI_DEBOUNCE_T1=509
ok: CONST CAP_PROP_XI_DEBOUNCE_POL=510
ok: CONST CAP_PROP_XI_LENS_MODE=511
ok: CONST CAP_PROP_XI_LENS_APERTURE_VALUE=512
ok: CONST CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE=513
ok: CONST CAP_PROP_XI_LENS_FOCUS_MOVE=514
ok: CONST CAP_PROP_XI_LENS_FOCUS_DISTANCE=515
ok: CONST CAP_PROP_XI_LENS_FOCAL_LENGTH=516
ok: CONST CAP_PROP_XI_LENS_FEATURE_SELECTOR=517
ok: CONST CAP_PROP_XI_LENS_FEATURE=518
ok: CONST CAP_PROP_XI_DEVICE_MODEL_ID=521
ok: CONST CAP_PROP_XI_DEVICE_SN=522
ok: CONST CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA=529
ok: CONST CAP_PROP_XI_IMAGE_PAYLOAD_SIZE=530
ok: CONST CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT=531
ok: CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ=532
ok: CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX=533
ok: CONST CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT=534
ok: CONST CAP_PROP_XI_FRAMERATE=535
ok: CONST CAP_PROP_XI_COUNTER_SELECTOR=536
ok: CONST CAP_PROP_XI_COUNTER_VALUE=537
ok: CONST CAP_PROP_XI_ACQ_TIMING_MODE=538
ok: CONST CAP_PROP_XI_AVAILABLE_BANDWIDTH=539
ok: CONST CAP_PROP_XI_BUFFER_POLICY=540
ok: CONST CAP_PROP_XI_LUT_EN=541
ok: CONST CAP_PROP_XI_LUT_INDEX=542
ok: CONST CAP_PROP_XI_LUT_VALUE=543
ok: CONST CAP_PROP_XI_TRG_DELAY=544
ok: CONST CAP_PROP_XI_TS_RST_MODE=545
ok: CONST CAP_PROP_XI_TS_RST_SOURCE=546
ok: CONST CAP_PROP_XI_IS_DEVICE_EXIST=547
ok: CONST CAP_PROP_XI_ACQ_BUFFER_SIZE=548
ok: CONST CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT=549
ok: CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE=550
ok: CONST CAP_PROP_XI_BUFFERS_QUEUE_SIZE=551
ok: CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT=552
ok: CONST CAP_PROP_XI_RECENT_FRAME=553
ok: CONST CAP_PROP_XI_DEVICE_RESET=554
ok: CONST CAP_PROP_XI_COLUMN_FPN_CORRECTION=555
ok: CONST CAP_PROP_XI_ROW_FPN_CORRECTION=591
ok: CONST CAP_PROP_XI_SENSOR_MODE=558
ok: CONST CAP_PROP_XI_HDR=559
ok: CONST CAP_PROP_XI_HDR_KNEEPOINT_COUNT=560
ok: CONST CAP_PROP_XI_HDR_T1=561
ok: CONST CAP_PROP_XI_HDR_T2=562
ok: CONST CAP_PROP_XI_KNEEPOINT1=563
ok: CONST CAP_PROP_XI_KNEEPOINT2=564
ok: CONST CAP_PROP_XI_IMAGE_BLACK_LEVEL=565
ok: CONST CAP_PROP_XI_HW_REVISION=571
ok: CONST CAP_PROP_XI_DEBUG_LEVEL=572
ok: CONST CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION=573
ok: CONST CAP_PROP_XI_FFS_FILE_ID=594
ok: CONST CAP_PROP_XI_FFS_FILE_SIZE=580
ok: CONST CAP_PROP_XI_FREE_FFS_SIZE=581
ok: CONST CAP_PROP_XI_USED_FFS_SIZE=582
ok: CONST CAP_PROP_XI_FFS_ACCESS_KEY=583
ok: CONST CAP_PROP_XI_SENSOR_FEATURE_SELECTOR=585
ok: CONST CAP_PROP_XI_SENSOR_FEATURE_VALUE=586

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_IOS_DEVICE_FOCUS', u'9001', [], [], None, ''],
        [u'const cv.CAP_PROP_IOS_DEVICE_EXPOSURE', u'9002', [], [], None, ''],
        [u'const cv.CAP_PROP_IOS_DEVICE_FLASH', u'9003', [], [], None, ''],
        [   u'const cv.CAP_PROP_IOS_DEVICE_WHITEBALANCE',
            u'9004',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_IOS_DEVICE_TORCH', u'9005', [], [], None, '']],
    None]
ok: CONST CAP_PROP_IOS_DEVICE_FOCUS=9001
ok: CONST CAP_PROP_IOS_DEVICE_EXPOSURE=9002
ok: CONST CAP_PROP_IOS_DEVICE_FLASH=9003
ok: CONST CAP_PROP_IOS_DEVICE_WHITEBALANCE=9004
ok: CONST CAP_PROP_IOS_DEVICE_TORCH=9005

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_PROP_GIGA_FRAME_OFFSET_X',
            u'10001',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_OFFSET_Y',
            u'10002',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_WIDTH_MAX',
            u'10003',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_HEIGH_MAX',
            u'10004',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_SENS_WIDTH',
            u'10005',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_SENS_HEIGH',
            u'10006',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_GIGA_FRAME_OFFSET_X=10001
ok: CONST CAP_PROP_GIGA_FRAME_OFFSET_Y=10002
ok: CONST CAP_PROP_GIGA_FRAME_WIDTH_MAX=10003
ok: CONST CAP_PROP_GIGA_FRAME_HEIGH_MAX=10004
ok: CONST CAP_PROP_GIGA_FRAME_SENS_WIDTH=10005
ok: CONST CAP_PROP_GIGA_FRAME_SENS_HEIGH=10006

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_PROP_INTELPERC_PROFILE_COUNT',
            u'11001',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_PROFILE_IDX',
            u'11002',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE',
            u'11003',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE',
            u'11004',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD',
            u'11005',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ',
            u'11006',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT',
            u'11007',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_INTELPERC_PROFILE_COUNT=11001
ok: CONST CAP_PROP_INTELPERC_PROFILE_IDX=11002
ok: CONST CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE=11003
ok: CONST CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE=11004
ok: CONST CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD=11005
ok: CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ=11006
ok: CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT=11007

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_INTELPERC_DEPTH_GENERATOR',
            u'1 << 29',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_INTELPERC_IMAGE_GENERATOR',
            u'1 << 28',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_INTELPERC_IR_GENERATOR',
            u'1 << 27',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_INTELPERC_GENERATORS_MASK',
            u'CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + CAP_INTELPERC_IR_GENERATOR',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_INTELPERC_DEPTH_GENERATOR=1 << 29
ok: CONST CAP_INTELPERC_IMAGE_GENERATOR=1 << 28
ok: CONST CAP_INTELPERC_IR_GENERATOR=1 << 27
ok: CONST CAP_INTELPERC_GENERATORS_MASK=CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + CAP_INTELPERC_IR_GENERATOR

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_INTELPERC_DEPTH_MAP', u'0', [], [], None, ''],
        [u'const cv.CAP_INTELPERC_UVDEPTH_MAP', u'1', [], [], None, ''],
        [u'const cv.CAP_INTELPERC_IR_MAP', u'2', [], [], None, ''],
        [u'const cv.CAP_INTELPERC_IMAGE', u'3', [], [], None, '']],
    None]
ok: CONST CAP_INTELPERC_DEPTH_MAP=0
ok: CONST CAP_INTELPERC_UVDEPTH_MAP=1
ok: CONST CAP_INTELPERC_IR_MAP=2
ok: CONST CAP_INTELPERC_IMAGE=3

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_GPHOTO2_PREVIEW', u'17001', [], [], None, ''],
        [   u'const cv.CAP_PROP_GPHOTO2_WIDGET_ENUMERATE',
            u'17002',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GPHOTO2_RELOAD_CONFIG',
            u'17003',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE',
            u'17004',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GPHOTO2_COLLECT_MSGS',
            u'17005',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_GPHOTO2_FLUSH_MSGS', u'17006', [], [], None, ''],
        [u'const cv.CAP_PROP_SPEED', u'17007', [], [], None, ''],
        [u'const cv.CAP_PROP_APERTURE', u'17008', [], [], None, ''],
        [u'const cv.CAP_PROP_EXPOSUREPROGRAM', u'17009', [], [], None, ''],
        [u'const cv.CAP_PROP_VIEWFINDER', u'17010', [], [], None, '']],
    None]
ok: CONST CAP_PROP_GPHOTO2_PREVIEW=17001
ok: CONST CAP_PROP_GPHOTO2_WIDGET_ENUMERATE=17002
ok: CONST CAP_PROP_GPHOTO2_RELOAD_CONFIG=17003
ok: CONST CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE=17004
ok: CONST CAP_PROP_GPHOTO2_COLLECT_MSGS=17005
ok: CONST CAP_PROP_GPHOTO2_FLUSH_MSGS=17006
ok: CONST CAP_PROP_SPEED=17007
ok: CONST CAP_PROP_APERTURE=17008
ok: CONST CAP_PROP_EXPOSUREPROGRAM=17009
ok: CONST CAP_PROP_VIEWFINDER=17010

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_IMAGES_BASE', u'18000', [], [], None, ''],
        [u'const cv.CAP_PROP_IMAGES_LAST', u'19000', [], [], None, '']],
    None]
ok: CONST CAP_PROP_IMAGES_BASE=18000
ok: CONST CAP_PROP_IMAGES_LAST=19000

--- Incoming ---
[u'class cv.VideoCapture', '', [], [], None]
ok: class CLASS cv::.VideoCapture : , name: VideoCapture, base: 

--- Incoming ---
[u'cv.VideoCapture.VideoCapture', '', [], [], None]
ok: FUNC < cv.VideoCapture.VideoCapture []>

--- Incoming ---
[   u'cv.VideoCapture.VideoCapture',
    '',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'apiPreference', u'CAP_ANY', []]],
    None]
ok: FUNC < cv.VideoCapture.VideoCapture [ARG String filename=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   u'cv.VideoCapture.VideoCapture',
    '',
    [],
    [[u'int', u'index', u'', []], [u'int', u'apiPreference', u'CAP_ANY', []]],
    None]
ok: FUNC < cv.VideoCapture.VideoCapture [ARG int index=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   u'cv.VideoCapture.open',
    u'bool',
    ['/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'apiPreference', u'CAP_ANY', []]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.open [ARG String filename=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   u'cv.VideoCapture.open',
    u'bool',
    ['/V'],
    [[u'int', u'index', u'', []], [u'int', u'apiPreference', u'CAP_ANY', []]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.open [ARG int index=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[u'cv.VideoCapture.isOpened', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.VideoCapture.isOpened []>

--- Incoming ---
[u'cv.VideoCapture.release', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.VideoCapture.release []>

--- Incoming ---
[u'cv.VideoCapture.grab', u'bool', ['/V'], [], u'bool']
ok: FUNC <bool cv.VideoCapture.grab []>

--- Incoming ---
[   u'cv.VideoCapture.retrieve',
    u'bool',
    ['/V'],
    [['Mat', u'image', '', ['/O']], [u'int', u'flag', u'0', []]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.retrieve [ARG Mat image=, ARG int flag=0]>

--- Incoming ---
[   u'cv.VideoCapture.read',
    u'bool',
    ['/V'],
    [['Mat', u'image', '', ['/O']]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.read [ARG Mat image=]>

--- Incoming ---
[   u'cv.VideoCapture.set',
    u'bool',
    ['/V'],
    [[u'int', u'propId', u'', []], [u'double', u'value', u'', []]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.set [ARG int propId=, ARG double value=]>

--- Incoming ---
[   u'cv.VideoCapture.get',
    u'double',
    ['/C', '/V'],
    [[u'int', u'propId', u'', []]],
    u'double']
ok: FUNC <double cv.VideoCapture.get [ARG int propId=]>

--- Incoming ---
[u'cv.VideoCapture.getBackendName', u'String', ['/C'], [], u'String']
ok: FUNC <String cv.VideoCapture.getBackendName []>

--- Incoming ---
[   u'cv.VideoCapture.setExceptionMode',
    u'void',
    [],
    [[u'bool', u'enable', u'', []]],
    u'void']
ok: FUNC <void cv.VideoCapture.setExceptionMode [ARG bool enable=]>

--- Incoming ---
[u'cv.VideoCapture.getExceptionMode', u'bool', [], [], u'bool']
ok: FUNC <bool cv.VideoCapture.getExceptionMode []>

--- Incoming ---
[u'class cv.VideoWriter', '', [], [], None]
ok: class CLASS cv::.VideoWriter : , name: VideoWriter, base: 

--- Incoming ---
[u'cv.VideoWriter.VideoWriter', '', [], [], None]
ok: FUNC < cv.VideoWriter.VideoWriter []>

--- Incoming ---
[   u'cv.VideoWriter.VideoWriter',
    '',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'fourcc', u'', []],
        [u'double', u'fps', u'', []],
        [u'Size', u'frameSize', u'', []],
        [u'bool', u'isColor', u'true', []]],
    None]
ok: FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   u'cv.VideoWriter.VideoWriter',
    '',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'apiPreference', u'', []],
        [u'int', u'fourcc', u'', []],
        [u'double', u'fps', u'', []],
        [u'Size', u'frameSize', u'', []],
        [u'bool', u'isColor', u'true', []]],
    None]
ok: FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   u'cv.VideoWriter.open',
    u'bool',
    ['/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'fourcc', u'', []],
        [u'double', u'fps', u'', []],
        [u'Size', u'frameSize', u'', []],
        [u'bool', u'isColor', u'true', []]],
    u'bool']
ok: FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   u'cv.VideoWriter.open',
    u'bool',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'apiPreference', u'', []],
        [u'int', u'fourcc', u'', []],
        [u'double', u'fps', u'', []],
        [u'Size', u'frameSize', u'', []],
        [u'bool', u'isColor', u'true', []]],
    u'bool']
ok: FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[u'cv.VideoWriter.isOpened', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.VideoWriter.isOpened []>

--- Incoming ---
[u'cv.VideoWriter.release', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.VideoWriter.release []>

--- Incoming ---
[   u'cv.VideoWriter.write',
    u'void',
    ['/V'],
    [['Mat', u'image', '', []]],
    u'void']
ok: FUNC <void cv.VideoWriter.write [ARG Mat image=]>

--- Incoming ---
[   u'cv.VideoWriter.set',
    u'bool',
    ['/V'],
    [[u'int', u'propId', u'', []], [u'double', u'value', u'', []]],
    u'bool']
ok: FUNC <bool cv.VideoWriter.set [ARG int propId=, ARG double value=]>

--- Incoming ---
[   u'cv.VideoWriter.get',
    u'double',
    ['/C', '/V'],
    [[u'int', u'propId', u'', []]],
    u'double']
ok: FUNC <double cv.VideoWriter.get [ARG int propId=]>

--- Incoming ---
[   u'cv.VideoWriter.fourcc',
    u'int',
    ['/S'],
    [   [u'char', u'c1', u'', []],
        [u'char', u'c2', u'', []],
        [u'char', u'c3', u'', []],
        [u'char', u'c4', u'', []]],
    u'int']
ok: FUNC <int cv.VideoWriter.fourcc [ARG char c1=, ARG char c2=, ARG char c3=, ARG char c4=]>

--- Incoming ---
[u'cv.VideoWriter.getBackendName', u'String', ['/C'], [], u'String']
ok: FUNC <String cv.VideoWriter.getBackendName []>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/registry.hpp =====
Namespaces: set(['', u'cv', u'cv.videoio_registry'])

--- Incoming ---
[   u'cv.videoio_registry.getBackendName',
    u'String',
    [],
    [[u'VideoCaptureAPIs', u'api', u'', []]],
    u'cv::String']
ok: FUNC <String cv.videoio_registry..getBackendName [ARG VideoCaptureAPIs api=]>

--- Incoming ---
[   u'cv.videoio_registry.getBackends',
    u'vector_VideoCaptureAPIs',
    [],
    [],
    u'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getBackends []>

--- Incoming ---
[   u'cv.videoio_registry.getCameraBackends',
    u'vector_VideoCaptureAPIs',
    [],
    [],
    u'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getCameraBackends []>

--- Incoming ---
[   u'cv.videoio_registry.getStreamBackends',
    u'vector_VideoCaptureAPIs',
    [],
    [],
    u'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getStreamBackends []>

--- Incoming ---
[   u'cv.videoio_registry.getWriterBackends',
    u'vector_VideoCaptureAPIs',
    [],
    [],
    u'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getWriterBackends []>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/videoio.hpp =====
Namespaces: set(['', u'cv', u'cv.videoio_registry'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/videoio/include/opencv2/videoio/videoio.hpp


===== Generating... =====
CLASS cv::.VideoWriter : 
FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java:  VideoWriter(String filename, int apiPreference, int fourcc, double fps, Size frameSize, boolean isColor)
java:  VideoWriter(String filename, int apiPreference, int fourcc, double fps, Size frameSize)
FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java:  VideoWriter(String filename, int fourcc, double fps, Size frameSize, boolean isColor)
java:  VideoWriter(String filename, int fourcc, double fps, Size frameSize)
FUNC < cv.VideoWriter.VideoWriter []>
java:  VideoWriter()
FUNC <String cv.VideoWriter.getBackendName []>
java: String getBackendName()
FUNC <bool cv.VideoWriter.isOpened []>
java: boolean isOpened()
FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java: boolean open(String filename, int apiPreference, int fourcc, double fps, Size frameSize, boolean isColor)
java: boolean open(String filename, int apiPreference, int fourcc, double fps, Size frameSize)
FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java: boolean open(String filename, int fourcc, double fps, Size frameSize, boolean isColor)
java: boolean open(String filename, int fourcc, double fps, Size frameSize)
FUNC <bool cv.VideoWriter.set [ARG int propId=, ARG double value=]>
java: boolean set(int propId, double value)
FUNC <double cv.VideoWriter.get [ARG int propId=]>
java: double get(int propId)
FUNC <int cv.VideoWriter.fourcc [ARG char c1=, ARG char c2=, ARG char c3=, ARG char c4=]>
java: int fourcc(char c1, char c2, char c3, char c4)
FUNC <void cv.VideoWriter.release []>
java: void release()
FUNC <void cv.VideoWriter.write [ARG Mat image=]>
java: void write(Mat image)
CLASS ::.Videoio : 
[CONST VIDEOWRITER_PROP_QUALITY=1, CONST VIDEOWRITER_PROP_FRAMEBYTES=2, CONST VIDEOWRITER_PROP_NSTRIPES=3]
[CONST CAP_PROP_POS_MSEC=0, CONST CAP_PROP_POS_FRAMES=1, CONST CAP_PROP_POS_AVI_RATIO=2, CONST CAP_PROP_FRAME_WIDTH=3, CONST CAP_PROP_FRAME_HEIGHT=4, CONST CAP_PROP_FPS=5, CONST CAP_PROP_FOURCC=6, CONST CAP_PROP_FRAME_COUNT=7, CONST CAP_PROP_FORMAT=8, CONST CAP_PROP_MODE=9, CONST CAP_PROP_BRIGHTNESS=10, CONST CAP_PROP_CONTRAST=11, CONST CAP_PROP_SATURATION=12, CONST CAP_PROP_HUE=13, CONST CAP_PROP_GAIN=14, CONST CAP_PROP_EXPOSURE=15, CONST CAP_PROP_CONVERT_RGB=16, CONST CAP_PROP_WHITE_BALANCE_BLUE_U=17, CONST CAP_PROP_RECTIFICATION=18, CONST CAP_PROP_MONOCHROME=19, CONST CAP_PROP_SHARPNESS=20, CONST CAP_PROP_AUTO_EXPOSURE=21, CONST CAP_PROP_GAMMA=22, CONST CAP_PROP_TEMPERATURE=23, CONST CAP_PROP_TRIGGER=24, CONST CAP_PROP_TRIGGER_DELAY=25, CONST CAP_PROP_WHITE_BALANCE_RED_V=26, CONST CAP_PROP_ZOOM=27, CONST CAP_PROP_FOCUS=28, CONST CAP_PROP_GUID=29, CONST CAP_PROP_ISO_SPEED=30, CONST CAP_PROP_BACKLIGHT=32, CONST CAP_PROP_PAN=33, CONST CAP_PROP_TILT=34, CONST CAP_PROP_ROLL=35, CONST CAP_PROP_IRIS=36, CONST CAP_PROP_SETTINGS=37, CONST CAP_PROP_BUFFERSIZE=38, CONST CAP_PROP_AUTOFOCUS=39, CONST CAP_PROP_SAR_NUM=40, CONST CAP_PROP_SAR_DEN=41, CONST CAP_PROP_BACKEND=42, CONST CAP_PROP_CHANNEL=43, CONST CAP_PROP_AUTO_WB=44, CONST CAP_PROP_WB_TEMPERATURE=45]
[CONST CAP_ANY=0, CONST CAP_VFW=200, CONST CAP_V4L=200, CONST CAP_V4L2=CAP_V4L, CONST CAP_FIREWIRE=300, CONST CAP_FIREWARE=CAP_FIREWIRE, CONST CAP_IEEE1394=CAP_FIREWIRE, CONST CAP_DC1394=CAP_FIREWIRE, CONST CAP_CMU1394=CAP_FIREWIRE, CONST CAP_QT=500, CONST CAP_UNICAP=600, CONST CAP_DSHOW=700, CONST CAP_PVAPI=800, CONST CAP_OPENNI=900, CONST CAP_OPENNI_ASUS=910, CONST CAP_ANDROID=1000, CONST CAP_XIAPI=1100, CONST CAP_AVFOUNDATION=1200, CONST CAP_GIGANETIX=1300, CONST CAP_MSMF=1400, CONST CAP_WINRT=1410, CONST CAP_INTELPERC=1500, CONST CAP_REALSENSE=1500, CONST CAP_OPENNI2=1600, CONST CAP_OPENNI2_ASUS=1610, CONST CAP_GPHOTO2=1700, CONST CAP_GSTREAMER=1800, CONST CAP_FFMPEG=1900, CONST CAP_IMAGES=2000, CONST CAP_ARAVIS=2100, CONST CAP_OPENCV_MJPEG=2200, CONST CAP_INTEL_MFX=2300, CONST CAP_XINE=2400]
[CONST CAP_PROP_DC1394_OFF=-4, CONST CAP_PROP_DC1394_MODE_MANUAL=-3, CONST CAP_PROP_DC1394_MODE_AUTO=-2, CONST CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO=-1, CONST CAP_PROP_DC1394_MAX=31, CONST CAP_OPENNI_DEPTH_GENERATOR=1 << 31, CONST CAP_OPENNI_IMAGE_GENERATOR=1 << 30, CONST CAP_OPENNI_IR_GENERATOR=1 << 29, CONST CAP_OPENNI_GENERATORS_MASK=CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR, CONST CAP_PROP_OPENNI_OUTPUT_MODE=100, CONST CAP_PROP_OPENNI_FRAME_MAX_DEPTH=101, CONST CAP_PROP_OPENNI_BASELINE=102, CONST CAP_PROP_OPENNI_FOCAL_LENGTH=103, CONST CAP_PROP_OPENNI_REGISTRATION=104, CONST CAP_PROP_OPENNI_REGISTRATION_ON=CAP_PROP_OPENNI_REGISTRATION, CONST CAP_PROP_OPENNI_APPROX_FRAME_SYNC=105, CONST CAP_PROP_OPENNI_MAX_BUFFER_SIZE=106, CONST CAP_PROP_OPENNI_CIRCLE_BUFFER=107, CONST CAP_PROP_OPENNI_MAX_TIME_DURATION=108, CONST CAP_PROP_OPENNI_GENERATOR_PRESENT=109, CONST CAP_PROP_OPENNI2_SYNC=110, CONST CAP_PROP_OPENNI2_MIRROR=111, CONST CAP_OPENNI_IMAGE_GENERATOR_PRESENT=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE, CONST CAP_OPENNI_DEPTH_GENERATOR_PRESENT=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_DEPTH_GENERATOR_BASELINE=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE, CONST CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH, CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION, CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON=CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION, CONST CAP_OPENNI_IR_GENERATOR_PRESENT=CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_DEPTH_MAP=0, CONST CAP_OPENNI_POINT_CLOUD_MAP=1, CONST CAP_OPENNI_DISPARITY_MAP=2, CONST CAP_OPENNI_DISPARITY_MAP_32F=3, CONST CAP_OPENNI_VALID_DEPTH_MASK=4, CONST CAP_OPENNI_BGR_IMAGE=5, CONST CAP_OPENNI_GRAY_IMAGE=6, CONST CAP_OPENNI_IR_IMAGE=7, CONST CAP_OPENNI_VGA_30HZ=0, CONST CAP_OPENNI_SXGA_15HZ=1, CONST CAP_OPENNI_SXGA_30HZ=2, CONST CAP_OPENNI_QVGA_30HZ=3, CONST CAP_OPENNI_QVGA_60HZ=4, CONST CAP_PROP_GSTREAMER_QUEUE_LENGTH=200, CONST CAP_PROP_PVAPI_MULTICASTIP=300, CONST CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE=301, CONST CAP_PROP_PVAPI_DECIMATIONHORIZONTAL=302, CONST CAP_PROP_PVAPI_DECIMATIONVERTICAL=303, CONST CAP_PROP_PVAPI_BINNINGX=304, CONST CAP_PROP_PVAPI_BINNINGY=305, CONST CAP_PROP_PVAPI_PIXELFORMAT=306, CONST CAP_PVAPI_FSTRIGMODE_FREERUN=0, CONST CAP_PVAPI_FSTRIGMODE_SYNCIN1=1, CONST CAP_PVAPI_FSTRIGMODE_SYNCIN2=2, CONST CAP_PVAPI_FSTRIGMODE_FIXEDRATE=3, CONST CAP_PVAPI_FSTRIGMODE_SOFTWARE=4, CONST CAP_PVAPI_DECIMATION_OFF=1, CONST CAP_PVAPI_DECIMATION_2OUTOF4=2, CONST CAP_PVAPI_DECIMATION_2OUTOF8=4, CONST CAP_PVAPI_DECIMATION_2OUTOF16=8, CONST CAP_PVAPI_PIXELFORMAT_MONO8=1, CONST CAP_PVAPI_PIXELFORMAT_MONO16=2, CONST CAP_PVAPI_PIXELFORMAT_BAYER8=3, CONST CAP_PVAPI_PIXELFORMAT_BAYER16=4, CONST CAP_PVAPI_PIXELFORMAT_RGB24=5, CONST CAP_PVAPI_PIXELFORMAT_BGR24=6, CONST CAP_PVAPI_PIXELFORMAT_RGBA32=7, CONST CAP_PVAPI_PIXELFORMAT_BGRA32=8, CONST CAP_PROP_XI_DOWNSAMPLING=400, CONST CAP_PROP_XI_DATA_FORMAT=401, CONST CAP_PROP_XI_OFFSET_X=402, CONST CAP_PROP_XI_OFFSET_Y=403, CONST CAP_PROP_XI_TRG_SOURCE=404, CONST CAP_PROP_XI_TRG_SOFTWARE=405, CONST CAP_PROP_XI_GPI_SELECTOR=406, CONST CAP_PROP_XI_GPI_MODE=407, CONST CAP_PROP_XI_GPI_LEVEL=408, CONST CAP_PROP_XI_GPO_SELECTOR=409, CONST CAP_PROP_XI_GPO_MODE=410, CONST CAP_PROP_XI_LED_SELECTOR=411, CONST CAP_PROP_XI_LED_MODE=412, CONST CAP_PROP_XI_MANUAL_WB=413, CONST CAP_PROP_XI_AUTO_WB=414, CONST CAP_PROP_XI_AEAG=415, CONST CAP_PROP_XI_EXP_PRIORITY=416, CONST CAP_PROP_XI_AE_MAX_LIMIT=417, CONST CAP_PROP_XI_AG_MAX_LIMIT=418, CONST CAP_PROP_XI_AEAG_LEVEL=419, CONST CAP_PROP_XI_TIMEOUT=420, CONST CAP_PROP_XI_EXPOSURE=421, CONST CAP_PROP_XI_EXPOSURE_BURST_COUNT=422, CONST CAP_PROP_XI_GAIN_SELECTOR=423, CONST CAP_PROP_XI_GAIN=424, CONST CAP_PROP_XI_DOWNSAMPLING_TYPE=426, CONST CAP_PROP_XI_BINNING_SELECTOR=427, CONST CAP_PROP_XI_BINNING_VERTICAL=428, CONST CAP_PROP_XI_BINNING_HORIZONTAL=429, CONST CAP_PROP_XI_BINNING_PATTERN=430, CONST CAP_PROP_XI_DECIMATION_SELECTOR=431, CONST CAP_PROP_XI_DECIMATION_VERTICAL=432, CONST CAP_PROP_XI_DECIMATION_HORIZONTAL=433, CONST CAP_PROP_XI_DECIMATION_PATTERN=434, CONST CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR=587, CONST CAP_PROP_XI_TEST_PATTERN=588, CONST CAP_PROP_XI_IMAGE_DATA_FORMAT=435, CONST CAP_PROP_XI_SHUTTER_TYPE=436, CONST CAP_PROP_XI_SENSOR_TAPS=437, CONST CAP_PROP_XI_AEAG_ROI_OFFSET_X=439, CONST CAP_PROP_XI_AEAG_ROI_OFFSET_Y=440, CONST CAP_PROP_XI_AEAG_ROI_WIDTH=441, CONST CAP_PROP_XI_AEAG_ROI_HEIGHT=442, CONST CAP_PROP_XI_BPC=445, CONST CAP_PROP_XI_WB_KR=448, CONST CAP_PROP_XI_WB_KG=449, CONST CAP_PROP_XI_WB_KB=450, CONST CAP_PROP_XI_WIDTH=451, CONST CAP_PROP_XI_HEIGHT=452, CONST CAP_PROP_XI_REGION_SELECTOR=589, CONST CAP_PROP_XI_REGION_MODE=595, CONST CAP_PROP_XI_LIMIT_BANDWIDTH=459, CONST CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH=460, CONST CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH=461, CONST CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH=462, CONST CAP_PROP_XI_OUTPUT_DATA_PACKING=463, CONST CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE=464, CONST CAP_PROP_XI_IS_COOLED=465, CONST CAP_PROP_XI_COOLING=466, CONST CAP_PROP_XI_TARGET_TEMP=467, CONST CAP_PROP_XI_CHIP_TEMP=468, CONST CAP_PROP_XI_HOUS_TEMP=469, CONST CAP_PROP_XI_HOUS_BACK_SIDE_TEMP=590, CONST CAP_PROP_XI_SENSOR_BOARD_TEMP=596, CONST CAP_PROP_XI_CMS=470, CONST CAP_PROP_XI_APPLY_CMS=471, CONST CAP_PROP_XI_IMAGE_IS_COLOR=474, CONST CAP_PROP_XI_COLOR_FILTER_ARRAY=475, CONST CAP_PROP_XI_GAMMAY=476, CONST CAP_PROP_XI_GAMMAC=477, CONST CAP_PROP_XI_SHARPNESS=478, CONST CAP_PROP_XI_CC_MATRIX_00=479, CONST CAP_PROP_XI_CC_MATRIX_01=480, CONST CAP_PROP_XI_CC_MATRIX_02=481, CONST CAP_PROP_XI_CC_MATRIX_03=482, CONST CAP_PROP_XI_CC_MATRIX_10=483, CONST CAP_PROP_XI_CC_MATRIX_11=484, CONST CAP_PROP_XI_CC_MATRIX_12=485, CONST CAP_PROP_XI_CC_MATRIX_13=486, CONST CAP_PROP_XI_CC_MATRIX_20=487, CONST CAP_PROP_XI_CC_MATRIX_21=488, CONST CAP_PROP_XI_CC_MATRIX_22=489, CONST CAP_PROP_XI_CC_MATRIX_23=490, CONST CAP_PROP_XI_CC_MATRIX_30=491, CONST CAP_PROP_XI_CC_MATRIX_31=492, CONST CAP_PROP_XI_CC_MATRIX_32=493, CONST CAP_PROP_XI_CC_MATRIX_33=494, CONST CAP_PROP_XI_DEFAULT_CC_MATRIX=495, CONST CAP_PROP_XI_TRG_SELECTOR=498, CONST CAP_PROP_XI_ACQ_FRAME_BURST_COUNT=499, CONST CAP_PROP_XI_DEBOUNCE_EN=507, CONST CAP_PROP_XI_DEBOUNCE_T0=508, CONST CAP_PROP_XI_DEBOUNCE_T1=509, CONST CAP_PROP_XI_DEBOUNCE_POL=510, CONST CAP_PROP_XI_LENS_MODE=511, CONST CAP_PROP_XI_LENS_APERTURE_VALUE=512, CONST CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE=513, CONST CAP_PROP_XI_LENS_FOCUS_MOVE=514, CONST CAP_PROP_XI_LENS_FOCUS_DISTANCE=515, CONST CAP_PROP_XI_LENS_FOCAL_LENGTH=516, CONST CAP_PROP_XI_LENS_FEATURE_SELECTOR=517, CONST CAP_PROP_XI_LENS_FEATURE=518, CONST CAP_PROP_XI_DEVICE_MODEL_ID=521, CONST CAP_PROP_XI_DEVICE_SN=522, CONST CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA=529, CONST CAP_PROP_XI_IMAGE_PAYLOAD_SIZE=530, CONST CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT=531, CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ=532, CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX=533, CONST CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT=534, CONST CAP_PROP_XI_FRAMERATE=535, CONST CAP_PROP_XI_COUNTER_SELECTOR=536, CONST CAP_PROP_XI_COUNTER_VALUE=537, CONST CAP_PROP_XI_ACQ_TIMING_MODE=538, CONST CAP_PROP_XI_AVAILABLE_BANDWIDTH=539, CONST CAP_PROP_XI_BUFFER_POLICY=540, CONST CAP_PROP_XI_LUT_EN=541, CONST CAP_PROP_XI_LUT_INDEX=542, CONST CAP_PROP_XI_LUT_VALUE=543, CONST CAP_PROP_XI_TRG_DELAY=544, CONST CAP_PROP_XI_TS_RST_MODE=545, CONST CAP_PROP_XI_TS_RST_SOURCE=546, CONST CAP_PROP_XI_IS_DEVICE_EXIST=547, CONST CAP_PROP_XI_ACQ_BUFFER_SIZE=548, CONST CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT=549, CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE=550, CONST CAP_PROP_XI_BUFFERS_QUEUE_SIZE=551, CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT=552, CONST CAP_PROP_XI_RECENT_FRAME=553, CONST CAP_PROP_XI_DEVICE_RESET=554, CONST CAP_PROP_XI_COLUMN_FPN_CORRECTION=555, CONST CAP_PROP_XI_ROW_FPN_CORRECTION=591, CONST CAP_PROP_XI_SENSOR_MODE=558, CONST CAP_PROP_XI_HDR=559, CONST CAP_PROP_XI_HDR_KNEEPOINT_COUNT=560, CONST CAP_PROP_XI_HDR_T1=561, CONST CAP_PROP_XI_HDR_T2=562, CONST CAP_PROP_XI_KNEEPOINT1=563, CONST CAP_PROP_XI_KNEEPOINT2=564, CONST CAP_PROP_XI_IMAGE_BLACK_LEVEL=565, CONST CAP_PROP_XI_HW_REVISION=571, CONST CAP_PROP_XI_DEBUG_LEVEL=572, CONST CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION=573, CONST CAP_PROP_XI_FFS_FILE_ID=594, CONST CAP_PROP_XI_FFS_FILE_SIZE=580, CONST CAP_PROP_XI_FREE_FFS_SIZE=581, CONST CAP_PROP_XI_USED_FFS_SIZE=582, CONST CAP_PROP_XI_FFS_ACCESS_KEY=583, CONST CAP_PROP_XI_SENSOR_FEATURE_SELECTOR=585, CONST CAP_PROP_XI_SENSOR_FEATURE_VALUE=586, CONST CAP_PROP_IOS_DEVICE_FOCUS=9001, CONST CAP_PROP_IOS_DEVICE_EXPOSURE=9002, CONST CAP_PROP_IOS_DEVICE_FLASH=9003, CONST CAP_PROP_IOS_DEVICE_WHITEBALANCE=9004, CONST CAP_PROP_IOS_DEVICE_TORCH=9005, CONST CAP_PROP_GIGA_FRAME_OFFSET_X=10001, CONST CAP_PROP_GIGA_FRAME_OFFSET_Y=10002, CONST CAP_PROP_GIGA_FRAME_WIDTH_MAX=10003, CONST CAP_PROP_GIGA_FRAME_HEIGH_MAX=10004, CONST CAP_PROP_GIGA_FRAME_SENS_WIDTH=10005, CONST CAP_PROP_GIGA_FRAME_SENS_HEIGH=10006, CONST CAP_PROP_INTELPERC_PROFILE_COUNT=11001, CONST CAP_PROP_INTELPERC_PROFILE_IDX=11002, CONST CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE=11003, CONST CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE=11004, CONST CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD=11005, CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ=11006, CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT=11007, CONST CAP_INTELPERC_DEPTH_GENERATOR=1 << 29, CONST CAP_INTELPERC_IMAGE_GENERATOR=1 << 28, CONST CAP_INTELPERC_IR_GENERATOR=1 << 27, CONST CAP_INTELPERC_GENERATORS_MASK=CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + CAP_INTELPERC_IR_GENERATOR, CONST CAP_INTELPERC_DEPTH_MAP=0, CONST CAP_INTELPERC_UVDEPTH_MAP=1, CONST CAP_INTELPERC_IR_MAP=2, CONST CAP_INTELPERC_IMAGE=3, CONST CAP_PROP_GPHOTO2_PREVIEW=17001, CONST CAP_PROP_GPHOTO2_WIDGET_ENUMERATE=17002, CONST CAP_PROP_GPHOTO2_RELOAD_CONFIG=17003, CONST CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE=17004, CONST CAP_PROP_GPHOTO2_COLLECT_MSGS=17005, CONST CAP_PROP_GPHOTO2_FLUSH_MSGS=17006, CONST CAP_PROP_SPEED=17007, CONST CAP_PROP_APERTURE=17008, CONST CAP_PROP_EXPOSUREPROGRAM=17009, CONST CAP_PROP_VIEWFINDER=17010, CONST CAP_PROP_IMAGES_BASE=18000, CONST CAP_PROP_IMAGES_LAST=19000]
FUNC <String cv.videoio_registry..getBackendName [ARG VideoCaptureAPIs api=]>
java: String getBackendName(int api)
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getCameraBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getCameraBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getStreamBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getStreamBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getWriterBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getWriterBackends()	 due to RET type vector_VideoCaptureAPIs
CLASS cv::.VideoCapture : 
FUNC < cv.VideoCapture.VideoCapture [ARG String filename=, ARG int apiPreference=CAP_ANY]>
java:  VideoCapture(String filename, int apiPreference)
java:  VideoCapture(String filename)
FUNC < cv.VideoCapture.VideoCapture [ARG int index=, ARG int apiPreference=CAP_ANY]>
java:  VideoCapture(int index, int apiPreference)
java:  VideoCapture(int index)
FUNC < cv.VideoCapture.VideoCapture []>
java:  VideoCapture()
FUNC <String cv.VideoCapture.getBackendName []>
java: String getBackendName()
FUNC <bool cv.VideoCapture.getExceptionMode []>
java: boolean getExceptionMode()
FUNC <bool cv.VideoCapture.grab []>
java: boolean grab()
FUNC <bool cv.VideoCapture.isOpened []>
java: boolean isOpened()
FUNC <bool cv.VideoCapture.open [ARG String filename=, ARG int apiPreference=CAP_ANY]>
java: boolean open(String filename, int apiPreference)
java: boolean open(String filename)
FUNC <bool cv.VideoCapture.open [ARG int index=, ARG int apiPreference=CAP_ANY]>
java: boolean open(int index, int apiPreference)
java: boolean open(int index)
FUNC <bool cv.VideoCapture.read [ARG Mat image=]>
java: boolean read(Mat image)
FUNC <bool cv.VideoCapture.retrieve [ARG Mat image=, ARG int flag=0]>
java: boolean retrieve(Mat image, int flag)
java: boolean retrieve(Mat image)
FUNC <bool cv.VideoCapture.set [ARG int propId=, ARG double value=]>
java: boolean set(int propId, double value)
FUNC <double cv.VideoCapture.get [ARG int propId=]>
java: double get(int propId)
FUNC <void cv.VideoCapture.release []>
java: void release()
FUNC <void cv.VideoCapture.setExceptionMode [ARG bool enable=]>
java: void setExceptionMode(boolean enable)

=== MODULE: calib3d (/home/borg/404/scripts_robotica/OpenCV/modules/calib3d) ===


Files (3):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/calib3d/include/opencv2/calib3d/calib3d_c.h',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/calib3d/include/opencv2/calib3d.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/calib3d/include/opencv2/calib3d/calib3d.hpp']

Common headers (0):
[]
ok: class CLASS ::.Calib3d : , name: Calib3d, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/calib3d/include/opencv2/calib3d/calib3d_c.h =====
Namespaces: set([''])

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_ITERATIVE', u'0', [], [], None, ''],
        [u'const CV_EPNP', u'1', [], [], None, ''],
        [u'const CV_P3P', u'2', [], [], None, ''],
        [u'const CV_DLS', u'3', [], [], None, '']],
    None]
ok: CONST CV_ITERATIVE=0
ok: CONST CV_EPNP=1
ok: CONST CV_P3P=2
ok: CONST CV_DLS=3

--- Incoming ---
[   u'enum CvLevMarq.<unnamed>',
    '',
    [],
    [   [u'const CvLevMarq.DONE', u'0', [], [], None, ''],
        [u'const CvLevMarq.STARTED', u'1', [], [], None, ''],
        [u'const CvLevMarq.CALC_J', u'2', [], [], None, ''],
        [u'const CvLevMarq.CHECK_ERR', u'3', [], [], None, '']],
    None]
class not found: CONST DONE=0
ok: CONST CvLevMarq_DONE=0
class not found: CONST STARTED=1
ok: CONST CvLevMarq_STARTED=1
class not found: CONST CALC_J=2
ok: CONST CvLevMarq_CALC_J=2
class not found: CONST CHECK_ERR=3
ok: CONST CvLevMarq_CHECK_ERR=3


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/calib3d/include/opencv2/calib3d.hpp =====
Namespaces: set(['', u'cv.fisheye', u'cv'])

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.LMEDS', u'4', [], [], None, ''],
        [u'const cv.RANSAC', u'8', [], [], None, ''],
        [u'const cv.RHO', u'16', [], [], None, '']],
    None]
ok: CONST LMEDS=4
ok: CONST RANSAC=8
ok: CONST RHO=16

--- Incoming ---
[   u'enum cv.SolvePnPMethod',
    '',
    [],
    [   [u'const cv.SOLVEPNP_ITERATIVE', u'0', [], [], None, ''],
        [u'const cv.SOLVEPNP_EPNP', u'1', [], [], None, ''],
        [u'const cv.SOLVEPNP_P3P', u'2', [], [], None, ''],
        [u'const cv.SOLVEPNP_DLS', u'3', [], [], None, ''],
        [u'const cv.SOLVEPNP_UPNP', u'4', [], [], None, ''],
        [u'const cv.SOLVEPNP_AP3P', u'5', [], [], None, ''],
        [u'const cv.SOLVEPNP_IPPE', u'6', [], [], None, ''],
        [u'const cv.SOLVEPNP_IPPE_SQUARE', u'7', [], [], None, ''],
        [u'const cv.SOLVEPNP_MAX_COUNT', u'7+1', [], [], None, '']],
    None]
ok: CONST SOLVEPNP_ITERATIVE=0
ok: CONST SOLVEPNP_EPNP=1
ok: CONST SOLVEPNP_P3P=2
ok: CONST SOLVEPNP_DLS=3
ok: CONST SOLVEPNP_UPNP=4
ok: CONST SOLVEPNP_AP3P=5
ok: CONST SOLVEPNP_IPPE=6
ok: CONST SOLVEPNP_IPPE_SQUARE=7
ok: CONST SOLVEPNP_MAX_COUNT=7+1

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CALIB_CB_ADAPTIVE_THRESH', u'1', [], [], None, ''],
        [u'const cv.CALIB_CB_NORMALIZE_IMAGE', u'2', [], [], None, ''],
        [u'const cv.CALIB_CB_FILTER_QUADS', u'4', [], [], None, ''],
        [u'const cv.CALIB_CB_FAST_CHECK', u'8', [], [], None, ''],
        [u'const cv.CALIB_CB_EXHAUSTIVE', u'16', [], [], None, ''],
        [u'const cv.CALIB_CB_ACCURACY', u'32', [], [], None, '']],
    None]
ok: CONST CALIB_CB_ADAPTIVE_THRESH=1
ok: CONST CALIB_CB_NORMALIZE_IMAGE=2
ok: CONST CALIB_CB_FILTER_QUADS=4
ok: CONST CALIB_CB_FAST_CHECK=8
ok: CONST CALIB_CB_EXHAUSTIVE=16
ok: CONST CALIB_CB_ACCURACY=32

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CALIB_CB_SYMMETRIC_GRID', u'1', [], [], None, ''],
        [u'const cv.CALIB_CB_ASYMMETRIC_GRID', u'2', [], [], None, ''],
        [u'const cv.CALIB_CB_CLUSTERING', u'4', [], [], None, '']],
    None]
ok: CONST CALIB_CB_SYMMETRIC_GRID=1
ok: CONST CALIB_CB_ASYMMETRIC_GRID=2
ok: CONST CALIB_CB_CLUSTERING=4

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CALIB_NINTRINSIC', u'18', [], [], None, ''],
        [u'const cv.CALIB_USE_INTRINSIC_GUESS', u'0x00001', [], [], None, ''],
        [u'const cv.CALIB_FIX_ASPECT_RATIO', u'0x00002', [], [], None, ''],
        [u'const cv.CALIB_FIX_PRINCIPAL_POINT', u'0x00004', [], [], None, ''],
        [u'const cv.CALIB_ZERO_TANGENT_DIST', u'0x00008', [], [], None, ''],
        [u'const cv.CALIB_FIX_FOCAL_LENGTH', u'0x00010', [], [], None, ''],
        [u'const cv.CALIB_FIX_K1', u'0x00020', [], [], None, ''],
        [u'const cv.CALIB_FIX_K2', u'0x00040', [], [], None, ''],
        [u'const cv.CALIB_FIX_K3', u'0x00080', [], [], None, ''],
        [u'const cv.CALIB_FIX_K4', u'0x00800', [], [], None, ''],
        [u'const cv.CALIB_FIX_K5', u'0x01000', [], [], None, ''],
        [u'const cv.CALIB_FIX_K6', u'0x02000', [], [], None, ''],
        [u'const cv.CALIB_RATIONAL_MODEL', u'0x04000', [], [], None, ''],
        [u'const cv.CALIB_THIN_PRISM_MODEL', u'0x08000', [], [], None, ''],
        [u'const cv.CALIB_FIX_S1_S2_S3_S4', u'0x10000', [], [], None, ''],
        [u'const cv.CALIB_TILTED_MODEL', u'0x40000', [], [], None, ''],
        [u'const cv.CALIB_FIX_TAUX_TAUY', u'0x80000', [], [], None, ''],
        [u'const cv.CALIB_USE_QR', u'0x100000', [], [], None, ''],
        [u'const cv.CALIB_FIX_TANGENT_DIST', u'0x200000', [], [], None, ''],
        [u'const cv.CALIB_FIX_INTRINSIC', u'0x00100', [], [], None, ''],
        [u'const cv.CALIB_SAME_FOCAL_LENGTH', u'0x00200', [], [], None, ''],
        [u'const cv.CALIB_ZERO_DISPARITY', u'0x00400', [], [], None, ''],
        [u'const cv.CALIB_USE_LU', u'(1 << 17)', [], [], None, ''],
        [   u'const cv.CALIB_USE_EXTRINSIC_GUESS',
            u'(1 << 22)',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CALIB_NINTRINSIC=18
ok: CONST CALIB_USE_INTRINSIC_GUESS=0x00001
ok: CONST CALIB_FIX_ASPECT_RATIO=0x00002
ok: CONST CALIB_FIX_PRINCIPAL_POINT=0x00004
ok: CONST CALIB_ZERO_TANGENT_DIST=0x00008
ok: CONST CALIB_FIX_FOCAL_LENGTH=0x00010
ok: CONST CALIB_FIX_K1=0x00020
ok: CONST CALIB_FIX_K2=0x00040
ok: CONST CALIB_FIX_K3=0x00080
ok: CONST CALIB_FIX_K4=0x00800
ok: CONST CALIB_FIX_K5=0x01000
ok: CONST CALIB_FIX_K6=0x02000
ok: CONST CALIB_RATIONAL_MODEL=0x04000
ok: CONST CALIB_THIN_PRISM_MODEL=0x08000
ok: CONST CALIB_FIX_S1_S2_S3_S4=0x10000
ok: CONST CALIB_TILTED_MODEL=0x40000
ok: CONST CALIB_FIX_TAUX_TAUY=0x80000
ok: CONST CALIB_USE_QR=0x100000
ok: CONST CALIB_FIX_TANGENT_DIST=0x200000
ok: CONST CALIB_FIX_INTRINSIC=0x00100
ok: CONST CALIB_SAME_FOCAL_LENGTH=0x00200
ok: CONST CALIB_ZERO_DISPARITY=0x00400
ok: CONST CALIB_USE_LU=(1 << 17)
ok: CONST CALIB_USE_EXTRINSIC_GUESS=(1 << 22)

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.FM_7POINT', u'1', [], [], None, ''],
        [u'const cv.FM_8POINT', u'2', [], [], None, ''],
        [u'const cv.FM_LMEDS', u'4', [], [], None, ''],
        [u'const cv.FM_RANSAC', u'8', [], [], None, '']],
    None]
ok: CONST FM_7POINT=1
ok: CONST FM_8POINT=2
ok: CONST FM_LMEDS=4
ok: CONST FM_RANSAC=8

--- Incoming ---
[   u'enum cv.HandEyeCalibrationMethod',
    '',
    [],
    [   [u'const cv.CALIB_HAND_EYE_TSAI', u'0', [], [], None, ''],
        [u'const cv.CALIB_HAND_EYE_PARK', u'1', [], [], None, ''],
        [u'const cv.CALIB_HAND_EYE_HORAUD', u'2', [], [], None, ''],
        [u'const cv.CALIB_HAND_EYE_ANDREFF', u'3', [], [], None, ''],
        [u'const cv.CALIB_HAND_EYE_DANIILIDIS', u'4', [], [], None, '']],
    None]
ok: CONST CALIB_HAND_EYE_TSAI=0
ok: CONST CALIB_HAND_EYE_PARK=1
ok: CONST CALIB_HAND_EYE_HORAUD=2
ok: CONST CALIB_HAND_EYE_ANDREFF=3
ok: CONST CALIB_HAND_EYE_DANIILIDIS=4

--- Incoming ---
[   u'cv.Rodrigues',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'jacobian', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   u'cv.findHomography',
    u'Mat',
    [],
    [   ['Mat', u'srcPoints', '', []],
        ['Mat', u'dstPoints', '', []],
        [u'int', u'method', u'0', []],
        [u'double', u'ransacReprojThreshold', u'3', []],
        ['Mat', u'mask', u'Mat()', ['/O']],
        [u'int', u'maxIters', u'2000', ['/C']],
        [u'double', u'confidence', u'0.995', ['/C']]],
    u'Mat']
ok: FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>

--- Incoming ---
[   u'cv.RQDecomp3x3',
    u'Vec3d',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mtxR', '', ['/O']],
        ['Mat', u'mtxQ', '', ['/O']],
        ['Mat', u'Qx', u'Mat()', ['/O']],
        ['Mat', u'Qy', u'Mat()', ['/O']],
        ['Mat', u'Qz', u'Mat()', ['/O']]],
    u'Vec3d']
ok: FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>

--- Incoming ---
[   u'cv.decomposeProjectionMatrix',
    u'void',
    [],
    [   ['Mat', u'projMatrix', '', []],
        ['Mat', u'cameraMatrix', '', ['/O']],
        ['Mat', u'rotMatrix', '', ['/O']],
        ['Mat', u'transVect', '', ['/O']],
        ['Mat', u'rotMatrixX', u'Mat()', ['/O']],
        ['Mat', u'rotMatrixY', u'Mat()', ['/O']],
        ['Mat', u'rotMatrixZ', u'Mat()', ['/O']],
        ['Mat', u'eulerAngles', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>

--- Incoming ---
[   u'cv.matMulDeriv',
    u'void',
    [],
    [   ['Mat', u'A', '', []],
        ['Mat', u'B', '', []],
        ['Mat', u'dABdA', '', ['/O']],
        ['Mat', u'dABdB', '', ['/O']]],
    u'void']
ok: FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>

--- Incoming ---
[   u'cv.composeRT',
    u'void',
    [],
    [   ['Mat', u'rvec1', '', []],
        ['Mat', u'tvec1', '', []],
        ['Mat', u'rvec2', '', []],
        ['Mat', u'tvec2', '', []],
        ['Mat', u'rvec3', '', ['/O']],
        ['Mat', u'tvec3', '', ['/O']],
        ['Mat', u'dr3dr1', u'Mat()', ['/O']],
        ['Mat', u'dr3dt1', u'Mat()', ['/O']],
        ['Mat', u'dr3dr2', u'Mat()', ['/O']],
        ['Mat', u'dr3dt2', u'Mat()', ['/O']],
        ['Mat', u'dt3dr1', u'Mat()', ['/O']],
        ['Mat', u'dt3dt1', u'Mat()', ['/O']],
        ['Mat', u'dt3dr2', u'Mat()', ['/O']],
        ['Mat', u'dt3dt2', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>

--- Incoming ---
[   u'cv.projectPoints',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'imagePoints', '', ['/O']],
        ['Mat', u'jacobian', u'Mat()', ['/O']],
        [u'double', u'aspectRatio', u'0', []]],
    u'void']
ok: FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>

--- Incoming ---
[   u'cv.solvePnP',
    u'bool',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/O']],
        ['Mat', u'tvec', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []],
        [u'int', u'flags', u'SOLVEPNP_ITERATIVE', []]],
    u'bool']
ok: FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   u'cv.solvePnPRansac',
    u'bool',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/O']],
        ['Mat', u'tvec', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []],
        [u'int', u'iterationsCount', u'100', []],
        [u'float', u'reprojectionError', u'8.0', []],
        [u'double', u'confidence', u'0.99', []],
        ['Mat', u'inliers', u'Mat()', ['/O']],
        [u'int', u'flags', u'SOLVEPNP_ITERATIVE', []]],
    u'bool']
ok: FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   u'cv.solveP3P',
    u'int',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'int']
ok: FUNC <int cv..solveP3P [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=]>

--- Incoming ---
[   u'cv.solvePnPRefineLM',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/IO']],
        ['Mat', u'tvec', '', ['/IO']],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)',
            []]],
    u'void']
ok: FUNC <void cv..solvePnPRefineLM [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)]>

--- Incoming ---
[   u'cv.solvePnPRefineVVS',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/IO']],
        ['Mat', u'tvec', '', ['/IO']],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)',
            []],
        [u'double', u'VVSlambda', u'1', []]],
    u'void']
ok: FUNC <void cv..solvePnPRefineVVS [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON), ARG double VVSlambda=1]>

--- Incoming ---
[   u'cv.solvePnPGeneric',
    u'int',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []],
        [u'SolvePnPMethod', u'flags', u'SOLVEPNP_ITERATIVE', []],
        ['Mat', u'rvec', u'Mat()', []],
        ['Mat', u'tvec', u'Mat()', []],
        ['Mat', u'reprojectionError', u'Mat()', ['/O']]],
    u'int']
ok: FUNC <int cv..solvePnPGeneric [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG bool useExtrinsicGuess=false, ARG SolvePnPMethod flags=SOLVEPNP_ITERATIVE, ARG Mat rvec=Mat(), ARG Mat tvec=Mat(), ARG Mat reprojectionError=Mat()]>

--- Incoming ---
[   u'cv.initCameraMatrix2D',
    u'Mat',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'aspectRatio', u'1.0', []]],
    u'Mat']
ok: FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>

--- Incoming ---
[   u'cv.findChessboardCorners',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', ['/O']],
        [   u'int',
            u'flags',
            u'CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE',
            []]],
    u'bool']
ok: FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>

--- Incoming ---
[   u'cv.checkChessboard',
    u'bool',
    [],
    [['Mat', u'img', '', []], [u'Size', u'size', u'', []]],
    u'bool']
ok: FUNC <bool cv..checkChessboard [ARG Mat img=, ARG Size size=]>

--- Incoming ---
[   u'cv.findChessboardCornersSB',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'bool']
ok: FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=0]>

--- Incoming ---
[   u'cv.find4QuadCornerSubpix',
    u'bool',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'corners', '', ['/IO']],
        [u'Size', u'region_size', u'', []]],
    u'bool']
ok: FUNC <bool cv..find4QuadCornerSubpix [ARG Mat img=, ARG Mat corners=, ARG Size region_size=]>

--- Incoming ---
[   u'cv.drawChessboardCorners',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', []],
        [u'bool', u'patternWasFound', u'', []]],
    u'void']
ok: FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>

--- Incoming ---
[   u'cv.drawFrameAxes',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        [u'float', u'length', u'', []],
        [u'int', u'thickness', u'3', []]],
    u'void']
ok: FUNC <void cv..drawFrameAxes [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=, ARG int thickness=3]>

--- Incoming ---
[   u'struct cv.CirclesGridFinderParameters',
    '',
    ['/Simple'],
    [   [u'Size2f', u'densityNeighborhoodSize', '', ['/RW']],
        [u'float', u'minDensity', '', ['/RW']],
        [u'int', u'kmeansAttempts', '', ['/RW']],
        [u'int', u'minDistanceToAddKeypoint', '', ['/RW']],
        [u'int', u'keypointScale', '', ['/RW']],
        [u'float', u'minGraphConfidence', '', ['/RW']],
        [u'float', u'vertexGain', '', ['/RW']],
        [u'float', u'vertexPenalty', '', ['/RW']],
        [u'float', u'existingVertexGain', '', ['/RW']],
        [u'float', u'edgeGain', '', ['/RW']],
        [u'float', u'edgePenalty', '', ['/RW']],
        [u'float', u'convexHullFactor', '', ['/RW']],
        [u'float', u'minRNGEdgeSwitchDist', '', ['/RW']],
        [u'float', u'squareSize', '', ['/RW']],
        [u'float', u'maxRectifiedDistance', '', ['/RW']]],
    None]
ignored: CLASS cv::.CirclesGridFinderParameters : 

--- Incoming ---
[   u'cv.CirclesGridFinderParameters.CirclesGridFinderParameters',
    '',
    [],
    [],
    None]
ignored: FUNC < cv.CirclesGridFinderParameters.CirclesGridFinderParameters []>

--- Incoming ---
[   u'enum cv.CirclesGridFinderParameters.GridType',
    '',
    [],
    [   [   u'const cv.CirclesGridFinderParameters.SYMMETRIC_GRID',
            '0',
            [],
            [],
            None,
            ''],
        [   u'const cv.CirclesGridFinderParameters.ASYMMETRIC_GRID',
            '1',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST SYMMETRIC_GRID=0
ok: CONST CirclesGridFinderParameters_SYMMETRIC_GRID=0
class not found: CONST ASYMMETRIC_GRID=1
ok: CONST CirclesGridFinderParameters_ASYMMETRIC_GRID=1

--- Incoming ---
[   u'cv.findCirclesGrid',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'centers', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'Ptr_FeatureDetector', u'blobDetector', u'', ['/C', '/Ref']],
        [u'CirclesGridFinderParameters', u'parameters', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=, ARG Ptr_FeatureDetector blobDetector=, ARG CirclesGridFinderParameters parameters=]>

--- Incoming ---
[   u'cv.findCirclesGrid',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'centers', '', ['/O']],
        [u'int', u'flags', u'CALIB_CB_SYMMETRIC_GRID', []],
        [   u'Ptr_FeatureDetector',
            u'blobDetector',
            u'SimpleBlobDetector::create()',
            ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>

--- Incoming ---
[   u'cv.calibrateCamera',
    u'double',
    [u'=calibrateCameraExtended'],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrateCamera',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrateCameraRO',
    u'double',
    [u'=calibrateCameraROExtended'],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'int', u'iFixedPoint', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'newObjPoints', '', ['/O']],
        ['Mat', u'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsObjPoints', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat stdDeviationsObjPoints=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrateCameraRO',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'int', u'iFixedPoint', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'newObjPoints', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrationMatrixValues',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'apertureWidth', u'', []],
        [u'double', u'apertureHeight', u'', []],
        [u'double', u'fovx', u'', ['/O', '/Ref']],
        [u'double', u'fovy', u'', ['/O', '/Ref']],
        [u'double', u'focalLength', u'', ['/O', '/Ref']],
        [u'Point2d', u'principalPoint', u'', ['/O', '/Ref']],
        [u'double', u'aspectRatio', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>

--- Incoming ---
[   u'cv.stereoCalibrate',
    u'double',
    [u'=stereoCalibrateExtended'],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints1', '', []],
        ['vector_Mat', u'imagePoints2', '', []],
        ['Mat', u'cameraMatrix1', '', ['/IO']],
        ['Mat', u'distCoeffs1', '', ['/IO']],
        ['Mat', u'cameraMatrix2', '', ['/IO']],
        ['Mat', u'distCoeffs2', '', ['/IO']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', ['/IO']],
        ['Mat', u'T', '', ['/IO']],
        ['Mat', u'E', '', ['/O']],
        ['Mat', u'F', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'CALIB_FIX_INTRINSIC', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    u'double']
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG Mat perViewErrors=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   u'cv.stereoCalibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints1', '', []],
        ['vector_Mat', u'imagePoints2', '', []],
        ['Mat', u'cameraMatrix1', '', ['/IO']],
        ['Mat', u'distCoeffs1', '', ['/IO']],
        ['Mat', u'cameraMatrix2', '', ['/IO']],
        ['Mat', u'distCoeffs2', '', ['/IO']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u'T', '', ['/O']],
        ['Mat', u'E', '', ['/O']],
        ['Mat', u'F', '', ['/O']],
        [u'int', u'flags', u'CALIB_FIX_INTRINSIC', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    u'double']
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   u'cv.stereoRectify',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix1', '', []],
        ['Mat', u'distCoeffs1', '', []],
        ['Mat', u'cameraMatrix2', '', []],
        ['Mat', u'distCoeffs2', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', []],
        ['Mat', u'T', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'int', u'flags', u'CALIB_ZERO_DISPARITY', []],
        [u'double', u'alpha', u'-1', []],
        [u'Size', u'newImageSize', u'Size()', []],
        [u'Rect*', u'validPixROI1', u'0', ['/O']],
        [u'Rect*', u'validPixROI2', u'0', ['/O']]],
    u'void']
ok: FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>

--- Incoming ---
[   u'cv.stereoRectifyUncalibrated',
    u'bool',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'F', '', []],
        [u'Size', u'imgSize', u'', []],
        ['Mat', u'H1', '', ['/O']],
        ['Mat', u'H2', '', ['/O']],
        [u'double', u'threshold', u'5', []]],
    u'bool']
ok: FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>

--- Incoming ---
[   u'cv.rectify3Collinear',
    u'float',
    [],
    [   ['Mat', u'cameraMatrix1', '', []],
        ['Mat', u'distCoeffs1', '', []],
        ['Mat', u'cameraMatrix2', '', []],
        ['Mat', u'distCoeffs2', '', []],
        ['Mat', u'cameraMatrix3', '', []],
        ['Mat', u'distCoeffs3', '', []],
        ['vector_Mat', u'imgpt1', '', []],
        ['vector_Mat', u'imgpt3', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R12', '', []],
        ['Mat', u'T12', '', []],
        ['Mat', u'R13', '', []],
        ['Mat', u'T13', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'R3', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'P3', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'double', u'alpha', u'', []],
        [u'Size', u'newImgSize', u'', []],
        [u'Rect*', u'roi1', u'', ['/O']],
        [u'Rect*', u'roi2', u'', ['/O']],
        [u'int', u'flags', u'', []]],
    u'float']
ok: FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>

--- Incoming ---
[   u'cv.getOptimalNewCameraMatrix',
    u'Mat',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'alpha', u'', []],
        [u'Size', u'newImgSize', u'Size()', []],
        [u'Rect*', u'validPixROI', u'0', ['/O']],
        [u'bool', u'centerPrincipalPoint', u'false', []]],
    u'Mat']
ok: FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   u'cv.calibrateHandEye',
    u'void',
    [],
    [   ['vector_Mat', u'R_gripper2base', '', []],
        ['vector_Mat', u't_gripper2base', '', []],
        ['vector_Mat', u'R_target2cam', '', []],
        ['vector_Mat', u't_target2cam', '', []],
        ['Mat', u'R_cam2gripper', '', ['/O']],
        ['Mat', u't_cam2gripper', '', ['/O']],
        [u'HandEyeCalibrationMethod', u'method', u'CALIB_HAND_EYE_TSAI', []]],
    u'void']
ok: FUNC <void cv..calibrateHandEye [ARG vector_Mat R_gripper2base=, ARG vector_Mat t_gripper2base=, ARG vector_Mat R_target2cam=, ARG vector_Mat t_target2cam=, ARG Mat R_cam2gripper=, ARG Mat t_cam2gripper=, ARG HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI]>

--- Incoming ---
[   u'cv.convertPointsToHomogeneous',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.convertPointsFromHomogeneous',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.findFundamentalMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        [u'int', u'method', u'FM_RANSAC', []],
        [u'double', u'ransacReprojThreshold', u'3.', []],
        [u'double', u'confidence', u'0.99', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double ransacReprojThreshold=3., ARG double confidence=0.99, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.findEssentialMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'cameraMatrix', '', []],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'prob', u'0.999', []],
        [u'double', u'threshold', u'1.0', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.findEssentialMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        [u'double', u'focal', u'1.0', []],
        [u'Point2d', u'pp', u'Point2d(0, 0)', []],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'prob', u'0.999', []],
        [u'double', u'threshold', u'1.0', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.decomposeEssentialMat',
    u'void',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u't', '', ['/O']]],
    u'void']
ok: FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>

--- Incoming ---
[   u'cv.recoverPose',
    u'int',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u't', '', ['/O']],
        ['Mat', u'mask', u'Mat()', ['/IO']]],
    u'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.recoverPose',
    u'int',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u't', '', ['/O']],
        [u'double', u'focal', u'1.0', []],
        [u'Point2d', u'pp', u'Point2d(0, 0)', []],
        ['Mat', u'mask', u'Mat()', ['/IO']]],
    u'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.recoverPose',
    u'int',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u't', '', ['/O']],
        [u'double', u'distanceThresh', u'', []],
        ['Mat', u'mask', u'Mat()', ['/IO']],
        ['Mat', u'triangulatedPoints', u'Mat()', ['/O']]],
    u'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG double distanceThresh=, ARG Mat mask=Mat(), ARG Mat triangulatedPoints=Mat()]>

--- Incoming ---
[   u'cv.computeCorrespondEpilines',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        [u'int', u'whichImage', u'', []],
        ['Mat', u'F', '', []],
        ['Mat', u'lines', '', ['/O']]],
    u'void']
ok: FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>

--- Incoming ---
[   u'cv.triangulatePoints',
    u'void',
    [],
    [   ['Mat', u'projMatr1', '', []],
        ['Mat', u'projMatr2', '', []],
        ['Mat', u'projPoints1', '', []],
        ['Mat', u'projPoints2', '', []],
        ['Mat', u'points4D', '', ['/O']]],
    u'void']
ok: FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>

--- Incoming ---
[   u'cv.correctMatches',
    u'void',
    [],
    [   ['Mat', u'F', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'newPoints1', '', ['/O']],
        ['Mat', u'newPoints2', '', ['/O']]],
    u'void']
ok: FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>

--- Incoming ---
[   u'cv.filterSpeckles',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'double', u'newVal', u'', []],
        [u'int', u'maxSpeckleSize', u'', []],
        [u'double', u'maxDiff', u'', []],
        ['Mat', u'buf', u'Mat()', ['/IO']]],
    u'void']
ok: FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>

--- Incoming ---
[   u'cv.getValidDisparityROI',
    u'Rect',
    [],
    [   [u'Rect', u'roi1', u'', []],
        [u'Rect', u'roi2', u'', []],
        [u'int', u'minDisparity', u'', []],
        [u'int', u'numberOfDisparities', u'', []],
        [u'int', u'SADWindowSize', u'', []]],
    u'Rect']
ok: FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int SADWindowSize=]>

--- Incoming ---
[   u'cv.validateDisparity',
    u'void',
    [],
    [   ['Mat', u'disparity', '', ['/IO']],
        ['Mat', u'cost', '', []],
        [u'int', u'minDisparity', u'', []],
        [u'int', u'numberOfDisparities', u'', []],
        [u'int', u'disp12MaxDisp', u'1', []]],
    u'void']
ok: FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>

--- Incoming ---
[   u'cv.reprojectImageTo3D',
    u'void',
    [],
    [   ['Mat', u'disparity', '', []],
        ['Mat', u'_3dImage', '', ['/O']],
        ['Mat', u'Q', '', []],
        [u'bool', u'handleMissingValues', u'false', []],
        [u'int', u'ddepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>

--- Incoming ---
[   u'cv.sampsonDistance',
    u'double',
    [],
    [['Mat', u'pt1', '', []], ['Mat', u'pt2', '', []], ['Mat', u'F', '', []]],
    u'double']
ok: FUNC <double cv..sampsonDistance [ARG Mat pt1=, ARG Mat pt2=, ARG Mat F=]>

--- Incoming ---
[   u'cv.estimateAffine3D',
    u'int',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        ['Mat', u'out', '', ['/O']],
        ['Mat', u'inliers', '', ['/O']],
        [u'double', u'ransacThreshold', u'3', []],
        [u'double', u'confidence', u'0.99', []]],
    u'int']
ok: FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>

--- Incoming ---
[   u'cv.estimateAffine2D',
    u'Mat',
    [],
    [   ['Mat', u'from', '', []],
        ['Mat', u'to', '', []],
        ['Mat', u'inliers', u'Mat()', ['/O']],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'ransacReprojThreshold', u'3', []],
        [u'size_t', u'maxIters', u'2000', []],
        [u'double', u'confidence', u'0.99', []],
        [u'size_t', u'refineIters', u'10', []]],
    u'cv::Mat']
ok: FUNC <Mat cv..estimateAffine2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>

--- Incoming ---
[   u'cv.estimateAffinePartial2D',
    u'Mat',
    [],
    [   ['Mat', u'from', '', []],
        ['Mat', u'to', '', []],
        ['Mat', u'inliers', u'Mat()', ['/O']],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'ransacReprojThreshold', u'3', []],
        [u'size_t', u'maxIters', u'2000', []],
        [u'double', u'confidence', u'0.99', []],
        [u'size_t', u'refineIters', u'10', []]],
    u'cv::Mat']
ok: FUNC <Mat cv..estimateAffinePartial2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>

--- Incoming ---
[   u'cv.decomposeHomographyMat',
    u'int',
    [],
    [   ['Mat', u'H', '', []],
        ['Mat', u'K', '', []],
        ['vector_Mat', u'rotations', '', ['/O']],
        ['vector_Mat', u'translations', '', ['/O']],
        ['vector_Mat', u'normals', '', ['/O']]],
    u'int']
ok: FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>

--- Incoming ---
[   u'cv.filterHomographyDecompByVisibleRefpoints',
    u'void',
    [],
    [   ['vector_Mat', u'rotations', '', []],
        ['vector_Mat', u'normals', '', []],
        ['Mat', u'beforePoints', '', []],
        ['Mat', u'afterPoints', '', []],
        ['Mat', u'possibleSolutions', '', ['/O']],
        ['Mat', u'pointsMask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..filterHomographyDecompByVisibleRefpoints [ARG vector_Mat rotations=, ARG vector_Mat normals=, ARG Mat beforePoints=, ARG Mat afterPoints=, ARG Mat possibleSolutions=, ARG Mat pointsMask=Mat()]>

--- Incoming ---
[u'class cv.StereoMatcher', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.StereoMatcher : Algorithm, name: StereoMatcher, base: Algorithm

--- Incoming ---
[   u'enum cv.StereoMatcher.<unnamed>',
    '',
    [],
    [   [u'const cv.StereoMatcher.DISP_SHIFT', u'4', [], [], None, ''],
        [   u'const cv.StereoMatcher.DISP_SCALE',
            u'(1 << DISP_SHIFT)',
            [],
            [],
            None,
            '']],
    None]
ok: CONST DISP_SHIFT=4
ok: CONST DISP_SCALE=(1 << DISP_SHIFT)

--- Incoming ---
[   u'cv.StereoMatcher.compute',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'left', '', []],
        ['Mat', u'right', '', []],
        ['Mat', u'disparity', '', ['/O']]],
    u'void']
ok: FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>

--- Incoming ---
[u'cv.StereoMatcher.getMinDisparity', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoMatcher.getMinDisparity []>

--- Incoming ---
[   u'cv.StereoMatcher.setMinDisparity',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'minDisparity', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>

--- Incoming ---
[   u'cv.StereoMatcher.getNumDisparities',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.StereoMatcher.getNumDisparities []>

--- Incoming ---
[   u'cv.StereoMatcher.setNumDisparities',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'numDisparities', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>

--- Incoming ---
[u'cv.StereoMatcher.getBlockSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoMatcher.getBlockSize []>

--- Incoming ---
[   u'cv.StereoMatcher.setBlockSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'blockSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>

--- Incoming ---
[   u'cv.StereoMatcher.getSpeckleWindowSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>

--- Incoming ---
[   u'cv.StereoMatcher.setSpeckleWindowSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'speckleWindowSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>

--- Incoming ---
[u'cv.StereoMatcher.getSpeckleRange', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoMatcher.getSpeckleRange []>

--- Incoming ---
[   u'cv.StereoMatcher.setSpeckleRange',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'speckleRange', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>

--- Incoming ---
[u'cv.StereoMatcher.getDisp12MaxDiff', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>

--- Incoming ---
[   u'cv.StereoMatcher.setDisp12MaxDiff',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'disp12MaxDiff', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>

--- Incoming ---
[u'class cv.StereoBM', u': cv::StereoMatcher', [], [], None]
ok: class CLASS cv::.StereoBM : StereoMatcher, name: StereoBM, base: StereoMatcher

--- Incoming ---
[   u'enum cv.StereoBM.<unnamed>',
    '',
    [],
    [   [   u'const cv.StereoBM.PREFILTER_NORMALIZED_RESPONSE',
            u'0',
            [],
            [],
            None,
            ''],
        [u'const cv.StereoBM.PREFILTER_XSOBEL', u'1', [], [], None, '']],
    None]
ok: CONST PREFILTER_NORMALIZED_RESPONSE=0
ok: CONST PREFILTER_XSOBEL=1

--- Incoming ---
[u'cv.StereoBM.getPreFilterType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterType []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'preFilterType', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>

--- Incoming ---
[u'cv.StereoBM.getPreFilterSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterSize []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'preFilterSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>

--- Incoming ---
[u'cv.StereoBM.getPreFilterCap', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterCap []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterCap',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'preFilterCap', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
[u'cv.StereoBM.getTextureThreshold', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getTextureThreshold []>

--- Incoming ---
[   u'cv.StereoBM.setTextureThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'textureThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>

--- Incoming ---
[u'cv.StereoBM.getUniquenessRatio', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getUniquenessRatio []>

--- Incoming ---
[   u'cv.StereoBM.setUniquenessRatio',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'uniquenessRatio', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
[u'cv.StereoBM.getSmallerBlockSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getSmallerBlockSize []>

--- Incoming ---
[   u'cv.StereoBM.setSmallerBlockSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'blockSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>

--- Incoming ---
[u'cv.StereoBM.getROI1', u'Rect', ['/C', '/V', '/PV'], [], u'Rect']
ok: FUNC <Rect cv.StereoBM.getROI1 []>

--- Incoming ---
[   u'cv.StereoBM.setROI1',
    u'void',
    ['/V', '/PV'],
    [[u'Rect', u'roi1', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>

--- Incoming ---
[u'cv.StereoBM.getROI2', u'Rect', ['/C', '/V', '/PV'], [], u'Rect']
ok: FUNC <Rect cv.StereoBM.getROI2 []>

--- Incoming ---
[   u'cv.StereoBM.setROI2',
    u'void',
    ['/V', '/PV'],
    [[u'Rect', u'roi2', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>

--- Incoming ---
[   u'cv.StereoBM.create',
    u'Ptr_StereoBM',
    ['/S'],
    [[u'int', u'numDisparities', u'0', []], [u'int', u'blockSize', u'21', []]],
    u'Ptr<StereoBM>']
ok: FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>

--- Incoming ---
[u'class cv.StereoSGBM', u': cv::StereoMatcher', [], [], None]
ok: class CLASS cv::.StereoSGBM : StereoMatcher, name: StereoSGBM, base: StereoMatcher

--- Incoming ---
[   u'enum cv.StereoSGBM.<unnamed>',
    '',
    [],
    [   [u'const cv.StereoSGBM.MODE_SGBM', u'0', [], [], None, ''],
        [u'const cv.StereoSGBM.MODE_HH', u'1', [], [], None, ''],
        [u'const cv.StereoSGBM.MODE_SGBM_3WAY', u'2', [], [], None, ''],
        [u'const cv.StereoSGBM.MODE_HH4', u'3', [], [], None, '']],
    None]
ok: CONST MODE_SGBM=0
ok: CONST MODE_HH=1
ok: CONST MODE_SGBM_3WAY=2
ok: CONST MODE_HH4=3

--- Incoming ---
[u'cv.StereoSGBM.getPreFilterCap', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getPreFilterCap []>

--- Incoming ---
[   u'cv.StereoSGBM.setPreFilterCap',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'preFilterCap', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
[u'cv.StereoSGBM.getUniquenessRatio', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getUniquenessRatio []>

--- Incoming ---
[   u'cv.StereoSGBM.setUniquenessRatio',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'uniquenessRatio', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
[u'cv.StereoSGBM.getP1', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getP1 []>

--- Incoming ---
[   u'cv.StereoSGBM.setP1',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'P1', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>

--- Incoming ---
[u'cv.StereoSGBM.getP2', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getP2 []>

--- Incoming ---
[   u'cv.StereoSGBM.setP2',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'P2', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>

--- Incoming ---
[u'cv.StereoSGBM.getMode', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getMode []>

--- Incoming ---
[   u'cv.StereoSGBM.setMode',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'mode', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>

--- Incoming ---
[   u'cv.StereoSGBM.create',
    u'Ptr_StereoSGBM',
    ['/S'],
    [   [u'int', u'minDisparity', u'0', []],
        [u'int', u'numDisparities', u'16', []],
        [u'int', u'blockSize', u'3', []],
        [u'int', u'P1', u'0', []],
        [u'int', u'P2', u'0', []],
        [u'int', u'disp12MaxDiff', u'0', []],
        [u'int', u'preFilterCap', u'0', []],
        [u'int', u'uniquenessRatio', u'0', []],
        [u'int', u'speckleWindowSize', u'0', []],
        [u'int', u'speckleRange', u'0', []],
        [u'int', u'mode', u'StereoSGBM::MODE_SGBM', []]],
    u'Ptr<StereoSGBM>']
ok: FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=0, ARG int numDisparities=16, ARG int blockSize=3, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>

--- Incoming ---
[   u'enum cv.UndistortTypes',
    '',
    [],
    [   [u'const cv.PROJ_SPHERICAL_ORTHO', u'0', [], [], None, ''],
        [u'const cv.PROJ_SPHERICAL_EQRECT', u'1', [], [], None, '']],
    None]
ok: CONST PROJ_SPHERICAL_ORTHO=0
ok: CONST PROJ_SPHERICAL_EQRECT=1

--- Incoming ---
[   u'cv.undistort',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'newCameraMatrix', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..undistort [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat newCameraMatrix=Mat()]>

--- Incoming ---
[   u'cv.initUndistortRectifyMap',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'newCameraMatrix', '', []],
        [u'Size', u'size', u'', []],
        [u'int', u'm1type', u'', []],
        ['Mat', u'map1', '', ['/O']],
        ['Mat', u'map2', '', ['/O']]],
    u'void']
ok: FUNC <void cv..initUndistortRectifyMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   u'cv.getDefaultNewCameraMatrix',
    u'Mat',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        [u'Size', u'imgsize', u'Size()', []],
        [u'bool', u'centerPrincipalPoint', u'false', []]],
    u'Mat']
ok: FUNC <Mat cv..getDefaultNewCameraMatrix [ARG Mat cameraMatrix=, ARG Size imgsize=Size(), ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   u'cv.undistortPoints',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', u'Mat()', []],
        ['Mat', u'P', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..undistortPoints [ARG vector_Point2f src=, ARG vector_Point2f dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=Mat(), ARG Mat P=Mat()]>

--- Incoming ---
[   u'cv.undistortPoints',
    u'void',
    [u'=undistortPointsIter'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', []],
        [u'TermCriteria', u'criteria', u'', []]],
    u'void']
ok: FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat P=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'enum cv.fisheye.<unnamed>',
    '',
    [],
    [   [   u'const cv.fisheye.CALIB_USE_INTRINSIC_GUESS',
            u'1 << 0',
            [],
            [],
            None,
            ''],
        [   u'const cv.fisheye.CALIB_RECOMPUTE_EXTRINSIC',
            u'1 << 1',
            [],
            [],
            None,
            ''],
        [u'const cv.fisheye.CALIB_CHECK_COND', u'1 << 2', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_SKEW', u'1 << 3', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_K1', u'1 << 4', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_K2', u'1 << 5', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_K3', u'1 << 6', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_K4', u'1 << 7', [], [], None, ''],
        [   u'const cv.fisheye.CALIB_FIX_INTRINSIC',
            u'1 << 8',
            [],
            [],
            None,
            ''],
        [   u'const cv.fisheye.CALIB_FIX_PRINCIPAL_POINT',
            u'1 << 9',
            [],
            [],
            None,
            '']],
    None]
ok: CONST fisheye_CALIB_USE_INTRINSIC_GUESS=1 << 0
ok: CONST fisheye_CALIB_RECOMPUTE_EXTRINSIC=1 << 1
ok: CONST fisheye_CALIB_CHECK_COND=1 << 2
ok: CONST fisheye_CALIB_FIX_SKEW=1 << 3
ok: CONST fisheye_CALIB_FIX_K1=1 << 4
ok: CONST fisheye_CALIB_FIX_K2=1 << 5
ok: CONST fisheye_CALIB_FIX_K3=1 << 6
ok: CONST fisheye_CALIB_FIX_K4=1 << 7
ok: CONST fisheye_CALIB_FIX_INTRINSIC=1 << 8
ok: CONST fisheye_CALIB_FIX_PRINCIPAL_POINT=1 << 9

--- Incoming ---
[   u'cv.fisheye.projectPoints',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', ['/O']],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'double', u'alpha', u'0', []],
        ['Mat', u'jacobian', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.fisheye..projectPoints [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat K=, ARG Mat D=, ARG double alpha=0, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   u'cv.fisheye.distortPoints',
    u'void',
    [],
    [   ['Mat', u'undistorted', '', []],
        ['Mat', u'distorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'double', u'alpha', u'0', []]],
    u'void']
ok: FUNC <void cv.fisheye..distortPoints [ARG Mat undistorted=, ARG Mat distorted=, ARG Mat K=, ARG Mat D=, ARG double alpha=0]>

--- Incoming ---
[   u'cv.fisheye.undistortPoints',
    u'void',
    [],
    [   ['Mat', u'distorted', '', []],
        ['Mat', u'undistorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'R', u'Mat()', []],
        ['Mat', u'P', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.fisheye..undistortPoints [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat R=Mat(), ARG Mat P=Mat()]>

--- Incoming ---
[   u'cv.fisheye.initUndistortRectifyMap',
    u'void',
    [],
    [   ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', []],
        [u'Size', u'size', u'', ['/C', '/Ref']],
        [u'int', u'm1type', u'', []],
        ['Mat', u'map1', '', ['/O']],
        ['Mat', u'map2', '', ['/O']]],
    u'void']
ok: FUNC <void cv.fisheye..initUndistortRectifyMap [ARG Mat K=, ARG Mat D=, ARG Mat R=, ARG Mat P=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   u'cv.fisheye.undistortImage',
    u'void',
    [],
    [   ['Mat', u'distorted', '', []],
        ['Mat', u'undistorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'Knew', u'cv::Mat()', []],
        [u'Size', u'new_size', u'Size()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.fisheye..undistortImage [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat Knew=cv::Mat(), ARG Size new_size=Size()]>

--- Incoming ---
[   u'cv.fisheye.estimateNewCameraMatrixForUndistortRectify',
    u'void',
    [],
    [   ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'Size', u'image_size', u'', ['/C', '/Ref']],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', ['/O']],
        [u'double', u'balance', u'0.0', []],
        [u'Size', u'new_size', u'Size()', ['/C', '/Ref']],
        [u'double', u'fov_scale', u'1.0', []]],
    u'void']
ok: FUNC <void cv.fisheye..estimateNewCameraMatrixForUndistortRectify [ARG Mat K=, ARG Mat D=, ARG Size image_size=, ARG Mat R=, ARG Mat P=, ARG double balance=0.0, ARG Size new_size=Size(), ARG double fov_scale=1.0]>

--- Incoming ---
[   u'cv.fisheye.calibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'image_size', u'', ['/C', '/Ref']],
        ['Mat', u'K', '', ['/IO']],
        ['Mat', u'D', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.fisheye..calibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size image_size=, ARG Mat K=, ARG Mat D=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.fisheye.stereoRectify',
    u'void',
    [],
    [   ['Mat', u'K1', '', []],
        ['Mat', u'D1', '', []],
        ['Mat', u'K2', '', []],
        ['Mat', u'D2', '', []],
        [u'Size', u'imageSize', u'', ['/C', '/Ref']],
        ['Mat', u'R', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'Size', u'newImageSize', u'Size()', ['/C', '/Ref']],
        [u'double', u'balance', u'0.0', []],
        [u'double', u'fov_scale', u'1.0', []]],
    u'void']
ok: FUNC <void cv.fisheye..stereoRectify [ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat tvec=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=, ARG Size newImageSize=Size(), ARG double balance=0.0, ARG double fov_scale=1.0]>

--- Incoming ---
[   u'cv.fisheye.stereoCalibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints1', '', []],
        ['vector_Mat', u'imagePoints2', '', []],
        ['Mat', u'K1', '', ['/IO']],
        ['Mat', u'D1', '', ['/IO']],
        ['Mat', u'K2', '', ['/IO']],
        ['Mat', u'D2', '', ['/IO']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u'T', '', ['/O']],
        [u'int', u'flags', u'fisheye::CALIB_FIX_INTRINSIC', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>

--- Incoming ---
[   u'enum CvLevMarq.<unnamed>',
    '',
    [],
    [   [u'const CvLevMarq.DONE', u'0', [], [], None, ''],
        [u'const CvLevMarq.STARTED', u'1', [], [], None, ''],
        [u'const CvLevMarq.CALC_J', u'2', [], [], None, ''],
        [u'const CvLevMarq.CHECK_ERR', u'3', [], [], None, '']],
    None]
class not found: CONST DONE=0
duplicated: CONST CvLevMarq_DONE=0
class not found: CONST STARTED=1
duplicated: CONST CvLevMarq_STARTED=1
class not found: CONST CALC_J=2
duplicated: CONST CvLevMarq_CALC_J=2
class not found: CONST CHECK_ERR=3
duplicated: CONST CvLevMarq_CHECK_ERR=3


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/calib3d/include/opencv2/calib3d/calib3d.hpp =====
Namespaces: set(['', u'cv.fisheye', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/calib3d/include/opencv2/calib3d/calib3d.hpp


===== Generating... =====
CLASS cv::.StereoSGBM : StereoMatcher
[CONST MODE_SGBM=0, CONST MODE_HH=1, CONST MODE_SGBM_3WAY=2, CONST MODE_HH4=3]
FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=0, ARG int numDisparities=16, ARG int blockSize=3, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange, int mode)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize)
java: StereoSGBM create(int minDisparity, int numDisparities)
java: StereoSGBM create(int minDisparity)
java: StereoSGBM create()
FUNC <int cv.StereoSGBM.getMode []>
java: int getMode()
FUNC <int cv.StereoSGBM.getP1 []>
java: int getP1()
FUNC <int cv.StereoSGBM.getP2 []>
java: int getP2()
FUNC <int cv.StereoSGBM.getPreFilterCap []>
java: int getPreFilterCap()
FUNC <int cv.StereoSGBM.getUniquenessRatio []>
java: int getUniquenessRatio()
FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>
java: void setMode(int mode)
FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>
java: void setP1(int P1)
FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>
java: void setP2(int P2)
FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>
java: void setPreFilterCap(int preFilterCap)
FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>
java: void setUniquenessRatio(int uniquenessRatio)
CLASS cv::.StereoBM : StereoMatcher
[CONST PREFILTER_NORMALIZED_RESPONSE=0, CONST PREFILTER_XSOBEL=1]
FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>
java: StereoBM create(int numDisparities, int blockSize)
java: StereoBM create(int numDisparities)
java: StereoBM create()
FUNC <Rect cv.StereoBM.getROI1 []>
java: Rect getROI1()
FUNC <Rect cv.StereoBM.getROI2 []>
java: Rect getROI2()
FUNC <int cv.StereoBM.getPreFilterCap []>
java: int getPreFilterCap()
FUNC <int cv.StereoBM.getPreFilterSize []>
java: int getPreFilterSize()
FUNC <int cv.StereoBM.getPreFilterType []>
java: int getPreFilterType()
FUNC <int cv.StereoBM.getSmallerBlockSize []>
java: int getSmallerBlockSize()
FUNC <int cv.StereoBM.getTextureThreshold []>
java: int getTextureThreshold()
FUNC <int cv.StereoBM.getUniquenessRatio []>
java: int getUniquenessRatio()
FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>
java: void setPreFilterCap(int preFilterCap)
FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>
java: void setPreFilterSize(int preFilterSize)
FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>
java: void setPreFilterType(int preFilterType)
FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>
java: void setROI1(Rect roi1)
FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>
java: void setROI2(Rect roi2)
FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>
java: void setSmallerBlockSize(int blockSize)
FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>
java: void setTextureThreshold(int textureThreshold)
FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>
java: void setUniquenessRatio(int uniquenessRatio)
CLASS cv::.StereoMatcher : Algorithm
[CONST DISP_SHIFT=4, CONST DISP_SCALE=(1 << DISP_SHIFT)]
FUNC <int cv.StereoMatcher.getBlockSize []>
java: int getBlockSize()
FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>
java: int getDisp12MaxDiff()
FUNC <int cv.StereoMatcher.getMinDisparity []>
java: int getMinDisparity()
FUNC <int cv.StereoMatcher.getNumDisparities []>
java: int getNumDisparities()
FUNC <int cv.StereoMatcher.getSpeckleRange []>
java: int getSpeckleRange()
FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>
java: int getSpeckleWindowSize()
FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>
java: void compute(Mat left, Mat right, Mat disparity)
FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>
java: void setBlockSize(int blockSize)
FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>
java: void setDisp12MaxDiff(int disp12MaxDiff)
FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>
java: void setMinDisparity(int minDisparity)
FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>
java: void setNumDisparities(int numDisparities)
FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>
java: void setSpeckleRange(int speckleRange)
FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>
java: void setSpeckleWindowSize(int speckleWindowSize)
CLASS ::.Calib3d : 
[CONST PROJ_SPHERICAL_ORTHO=0, CONST PROJ_SPHERICAL_EQRECT=1]
[CONST SOLVEPNP_ITERATIVE=0, CONST SOLVEPNP_EPNP=1, CONST SOLVEPNP_P3P=2, CONST SOLVEPNP_DLS=3, CONST SOLVEPNP_UPNP=4, CONST SOLVEPNP_AP3P=5, CONST SOLVEPNP_IPPE=6, CONST SOLVEPNP_IPPE_SQUARE=7, CONST SOLVEPNP_MAX_COUNT=7+1]
[CONST CALIB_HAND_EYE_TSAI=0, CONST CALIB_HAND_EYE_PARK=1, CONST CALIB_HAND_EYE_HORAUD=2, CONST CALIB_HAND_EYE_ANDREFF=3, CONST CALIB_HAND_EYE_DANIILIDIS=4]
[CONST CV_ITERATIVE=0, CONST CV_EPNP=1, CONST CV_P3P=2, CONST CV_DLS=3, CONST CvLevMarq_DONE=0, CONST CvLevMarq_STARTED=1, CONST CvLevMarq_CALC_J=2, CONST CvLevMarq_CHECK_ERR=3, CONST LMEDS=4, CONST RANSAC=8, CONST RHO=16, CONST CALIB_CB_ADAPTIVE_THRESH=1, CONST CALIB_CB_NORMALIZE_IMAGE=2, CONST CALIB_CB_FILTER_QUADS=4, CONST CALIB_CB_FAST_CHECK=8, CONST CALIB_CB_EXHAUSTIVE=16, CONST CALIB_CB_ACCURACY=32, CONST CALIB_CB_SYMMETRIC_GRID=1, CONST CALIB_CB_ASYMMETRIC_GRID=2, CONST CALIB_CB_CLUSTERING=4, CONST CALIB_NINTRINSIC=18, CONST CALIB_USE_INTRINSIC_GUESS=0x00001, CONST CALIB_FIX_ASPECT_RATIO=0x00002, CONST CALIB_FIX_PRINCIPAL_POINT=0x00004, CONST CALIB_ZERO_TANGENT_DIST=0x00008, CONST CALIB_FIX_FOCAL_LENGTH=0x00010, CONST CALIB_FIX_K1=0x00020, CONST CALIB_FIX_K2=0x00040, CONST CALIB_FIX_K3=0x00080, CONST CALIB_FIX_K4=0x00800, CONST CALIB_FIX_K5=0x01000, CONST CALIB_FIX_K6=0x02000, CONST CALIB_RATIONAL_MODEL=0x04000, CONST CALIB_THIN_PRISM_MODEL=0x08000, CONST CALIB_FIX_S1_S2_S3_S4=0x10000, CONST CALIB_TILTED_MODEL=0x40000, CONST CALIB_FIX_TAUX_TAUY=0x80000, CONST CALIB_USE_QR=0x100000, CONST CALIB_FIX_TANGENT_DIST=0x200000, CONST CALIB_FIX_INTRINSIC=0x00100, CONST CALIB_SAME_FOCAL_LENGTH=0x00200, CONST CALIB_ZERO_DISPARITY=0x00400, CONST CALIB_USE_LU=(1 << 17), CONST CALIB_USE_EXTRINSIC_GUESS=(1 << 22), CONST FM_7POINT=1, CONST FM_8POINT=2, CONST FM_LMEDS=4, CONST FM_RANSAC=8, CONST fisheye_CALIB_USE_INTRINSIC_GUESS=1 << 0, CONST fisheye_CALIB_RECOMPUTE_EXTRINSIC=1 << 1, CONST fisheye_CALIB_CHECK_COND=1 << 2, CONST fisheye_CALIB_FIX_SKEW=1 << 3, CONST fisheye_CALIB_FIX_K1=1 << 4, CONST fisheye_CALIB_FIX_K2=1 << 5, CONST fisheye_CALIB_FIX_K3=1 << 6, CONST fisheye_CALIB_FIX_K4=1 << 7, CONST fisheye_CALIB_FIX_INTRINSIC=1 << 8, CONST fisheye_CALIB_FIX_PRINCIPAL_POINT=1 << 9]
[CONST CirclesGridFinderParameters_SYMMETRIC_GRID=0, CONST CirclesGridFinderParameters_ASYMMETRIC_GRID=1]
FUNC <Mat cv..estimateAffine2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers)
java: Mat estimateAffine2D(Mat from, Mat to)
FUNC <Mat cv..estimateAffinePartial2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers)
java: Mat estimateAffinePartial2D(Mat from, Mat to)
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold, Mat mask)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix)
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold, Mat mask)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal)
java: Mat findEssentialMat(Mat points1, Mat points2)
FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double ransacReprojThreshold=3., ARG double confidence=0.99, ARG Mat mask=Mat()]>
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, Mat mask)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2)
FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask, int maxIters, double confidence)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask, int maxIters)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints)
FUNC <Mat cv..getDefaultNewCameraMatrix [ARG Mat cameraMatrix=, ARG Size imgsize=Size(), ARG bool centerPrincipalPoint=false]>
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize, boolean centerPrincipalPoint)
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize)
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix)
FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect validPixROI, boolean centerPrincipalPoint)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect validPixROI)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha)
FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>
java: Mat initCameraMatrix2D(List<MatOfPoint3f> objectPoints, List<MatOfPoint2f> imagePoints, Size imageSize, double aspectRatio)
java: Mat initCameraMatrix2D(List<MatOfPoint3f> objectPoints, List<MatOfPoint2f> imagePoints, Size imageSize)
FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int SADWindowSize=]>
java: Rect getValidDisparityROI(Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int SADWindowSize)
FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx, Mat Qy, Mat Qz)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx, Mat Qy)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ)
FUNC <bool cv..checkChessboard [ARG Mat img=, ARG Size size=]>
java: boolean checkChessboard(Mat img, Size size)
FUNC <bool cv..find4QuadCornerSubpix [ARG Mat img=, ARG Mat corners=, ARG Size region_size=]>
java: boolean find4QuadCornerSubpix(Mat img, Mat corners, Size region_size)
FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>
java: boolean findChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners, int flags)
java: boolean findChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners)
FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=0]>
java: boolean findChessboardCornersSB(Mat image, Size patternSize, Mat corners, int flags)
java: boolean findChessboardCornersSB(Mat image, Size patternSize, Mat corners)
FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=, ARG Ptr_FeatureDetector blobDetector=, ARG CirclesGridFinderParameters parameters=]>
SKIP:bool cv::findCirclesGrid(Mat image, Size patternSize, Mat& centers, int flags, Ptr_FeatureDetector blobDetector, CirclesGridFinderParameters parameters)	 due to ARG type Ptr_FeatureDetector/I
FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers, int flags)
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers, int flags)
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers)
FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int flags)
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec)
FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, Mat inliers, int flags)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, Mat inliers)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec)
FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>
java: boolean stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat H1, Mat H2, double threshold)
java: boolean stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat H1, Mat H2)
FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat stdDeviationsObjPoints=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors, int flags)
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors)
FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, int flags, TermCriteria criteria)
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, int flags)
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints)
FUNC <double cv..sampsonDistance [ARG Mat pt1=, ARG Mat pt2=, ARG Mat F=]>
java: double sampsonDistance(Mat pt1, Mat pt2, Mat F)
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG Mat perViewErrors=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors, int flags, TermCriteria criteria)
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors, int flags)
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors)
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, int flags, TermCriteria criteria)
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, int flags)
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F)
FUNC <double cv.fisheye..calibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size image_size=, ARG Mat K=, ARG Mat D=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs)
FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, int flags, TermCriteria criteria)
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, int flags)
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T)
FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>
java: float rectify3Collinear(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat cameraMatrix3, Mat distCoeffs3, List<Mat> imgpt1, List<Mat> imgpt3, Size imageSize, Mat R12, Mat T12, Mat R13, Mat T13, Mat R1, Mat R2, Mat R3, Mat P1, Mat P2, Mat P3, Mat Q, double alpha, Size newImgSize, Rect roi1, Rect roi2, int flags)
FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>
java: int decomposeHomographyMat(Mat H, Mat K, List<Mat> rotations, List<Mat> translations, List<Mat> normals)
FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold, double confidence)
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold)
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal, Point pp, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal, Point pp)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG Mat mask=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG double distanceThresh=, ARG Mat mask=Mat(), ARG Mat triangulatedPoints=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh, Mat mask, Mat triangulatedPoints)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh)
FUNC <int cv..solveP3P [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=]>
java: int solveP3P(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
FUNC <int cv..solvePnPGeneric [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG bool useExtrinsicGuess=false, ARG SolvePnPMethod flags=SOLVEPNP_ITERATIVE, ARG Mat rvec=Mat(), ARG Mat tvec=Mat(), ARG Mat reprojectionError=Mat()]>
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec, Mat tvec, Mat reprojectionError)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec, Mat tvec)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>
java: void Rodrigues(Mat src, Mat dst, Mat jacobian)
java: void Rodrigues(Mat src, Mat dst)
FUNC <void cv..calibrateHandEye [ARG vector_Mat R_gripper2base=, ARG vector_Mat t_gripper2base=, ARG vector_Mat R_target2cam=, ARG vector_Mat t_target2cam=, ARG Mat R_cam2gripper=, ARG Mat t_cam2gripper=, ARG HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI]>
java: void calibrateHandEye(List<Mat> R_gripper2base, List<Mat> t_gripper2base, List<Mat> R_target2cam, List<Mat> t_target2cam, Mat R_cam2gripper, Mat t_cam2gripper, int method)
java: void calibrateHandEye(List<Mat> R_gripper2base, List<Mat> t_gripper2base, List<Mat> R_target2cam, List<Mat> t_target2cam, Mat R_cam2gripper, Mat t_cam2gripper)
FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>
java: void calibrationMatrixValues(Mat cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double[] fovx, double[] fovy, double[] focalLength, Point principalPoint, double[] aspectRatio)
FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1, Mat dt3dr2, Mat dt3dt2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1, Mat dt3dr2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3)
FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>
java: void computeCorrespondEpilines(Mat points, int whichImage, Mat F, Mat lines)
FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>
java: void convertPointsFromHomogeneous(Mat src, Mat dst)
FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>
java: void convertPointsToHomogeneous(Mat src, Mat dst)
FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>
java: void correctMatches(Mat F, Mat points1, Mat points2, Mat newPoints1, Mat newPoints2)
FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>
java: void decomposeEssentialMat(Mat E, Mat R1, Mat R2, Mat t)
FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY, Mat rotMatrixZ, Mat eulerAngles)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY, Mat rotMatrixZ)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect)
FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>
java: void drawChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners, boolean patternWasFound)
FUNC <void cv..drawFrameAxes [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=, ARG int thickness=3]>
java: void drawFrameAxes(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length, int thickness)
java: void drawFrameAxes(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length)
FUNC <void cv..filterHomographyDecompByVisibleRefpoints [ARG vector_Mat rotations=, ARG vector_Mat normals=, ARG Mat beforePoints=, ARG Mat afterPoints=, ARG Mat possibleSolutions=, ARG Mat pointsMask=Mat()]>
java: void filterHomographyDecompByVisibleRefpoints(List<Mat> rotations, List<Mat> normals, Mat beforePoints, Mat afterPoints, Mat possibleSolutions, Mat pointsMask)
java: void filterHomographyDecompByVisibleRefpoints(List<Mat> rotations, List<Mat> normals, Mat beforePoints, Mat afterPoints, Mat possibleSolutions)
FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>
java: void filterSpeckles(Mat img, double newVal, int maxSpeckleSize, double maxDiff, Mat buf)
java: void filterSpeckles(Mat img, double newVal, int maxSpeckleSize, double maxDiff)
FUNC <void cv..initUndistortRectifyMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
java: void initUndistortRectifyMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat map1, Mat map2)
FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>
java: void matMulDeriv(Mat A, Mat B, Mat dABdA, Mat dABdB)
FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints, Mat jacobian, double aspectRatio)
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints, Mat jacobian)
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints)
FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q, boolean handleMissingValues, int ddepth)
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q, boolean handleMissingValues)
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q)
FUNC <void cv..solvePnPRefineLM [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)]>
java: void solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria)
java: void solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <void cv..solvePnPRefineVVS [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON), ARG double VVSlambda=1]>
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria, double VVSlambda)
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria)
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize, Rect validPixROI1, Rect validPixROI2)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize, Rect validPixROI1)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q)
FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>
java: void triangulatePoints(Mat projMatr1, Mat projMatr2, Mat projPoints1, Mat projPoints2, Mat points4D)
FUNC <void cv..undistort [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat newCameraMatrix=Mat()]>
java: void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat newCameraMatrix)
java: void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat P=, ARG TermCriteria criteria=]>
java: void undistortPointsIter(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P, TermCriteria criteria)
FUNC <void cv..undistortPoints [ARG vector_Point2f src=, ARG vector_Point2f dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=Mat(), ARG Mat P=Mat()]>
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P)
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs, Mat R)
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>
java: void validateDisparity(Mat disparity, Mat cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp)
java: void validateDisparity(Mat disparity, Mat cost, int minDisparity, int numberOfDisparities)
FUNC <void cv.fisheye..distortPoints [ARG Mat undistorted=, ARG Mat distorted=, ARG Mat K=, ARG Mat D=, ARG double alpha=0]>
java: void fisheye_distortPoints(Mat undistorted, Mat distorted, Mat K, Mat D, double alpha)
java: void fisheye_distortPoints(Mat undistorted, Mat distorted, Mat K, Mat D)
FUNC <void cv.fisheye..estimateNewCameraMatrixForUndistortRectify [ARG Mat K=, ARG Mat D=, ARG Size image_size=, ARG Mat R=, ARG Mat P=, ARG double balance=0.0, ARG Size new_size=Size(), ARG double fov_scale=1.0]>
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance, Size new_size, double fov_scale)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance, Size new_size)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P)
FUNC <void cv.fisheye..initUndistortRectifyMap [ARG Mat K=, ARG Mat D=, ARG Mat R=, ARG Mat P=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
java: void fisheye_initUndistortRectifyMap(Mat K, Mat D, Mat R, Mat P, Size size, int m1type, Mat map1, Mat map2)
FUNC <void cv.fisheye..projectPoints [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat K=, ARG Mat D=, ARG double alpha=0, ARG Mat jacobian=Mat()]>
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha, Mat jacobian)
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha)
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D)
FUNC <void cv.fisheye..stereoRectify [ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat tvec=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=, ARG Size newImageSize=Size(), ARG double balance=0.0, ARG double fov_scale=1.0]>
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize, double balance, double fov_scale)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize, double balance)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags)
FUNC <void cv.fisheye..undistortImage [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat Knew=cv::Mat(), ARG Size new_size=Size()]>
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D, Mat Knew, Size new_size)
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D, Mat Knew)
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D)
FUNC <void cv.fisheye..undistortPoints [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat R=Mat(), ARG Mat P=Mat()]>
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R, Mat P)
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R)
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D)

=== MODULE: highgui (/home/borg/404/scripts_robotica/OpenCV/modules/highgui) ===


Files (0):
[]

Common headers (0):
[]
No generated code for module: highgui

=== MODULE: objdetect (/home/borg/404/scripts_robotica/OpenCV/modules/objdetect) ===


Files (3):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/objdetect/include/opencv2/objdetect.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/objdetect/include/opencv2/objdetect/objdetect.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/objdetect/include/opencv2/objdetect/detection_based_tracker.hpp']

Common headers (0):
[]
ok: class CLASS ::.Objdetect : , name: Objdetect, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/objdetect/include/opencv2/objdetect.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'cv.groupRectangles',
    u'void',
    [],
    [   [u'vector_Rect', u'rectList', u'', ['/IO', '/Ref']],
        [u'vector_int', u'weights', u'', ['/O', '/Ref']],
        [u'int', u'groupThreshold', u'', []],
        [u'double', u'eps', u'0.2', []]],
    u'void']
ok: FUNC <void cv..groupRectangles [ARG vector_Rect rectList=, ARG vector_int weights=, ARG int groupThreshold=, ARG double eps=0.2]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CASCADE_DO_CANNY_PRUNING', u'1', [], [], None, ''],
        [u'const cv.CASCADE_SCALE_IMAGE', u'2', [], [], None, ''],
        [u'const cv.CASCADE_FIND_BIGGEST_OBJECT', u'4', [], [], None, ''],
        [u'const cv.CASCADE_DO_ROUGH_SEARCH', u'8', [], [], None, '']],
    None]
ok: CONST CASCADE_DO_CANNY_PRUNING=1
ok: CONST CASCADE_SCALE_IMAGE=2
ok: CONST CASCADE_FIND_BIGGEST_OBJECT=4
ok: CONST CASCADE_DO_ROUGH_SEARCH=8

--- Incoming ---
[u'class cv.BaseCascadeClassifier', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.BaseCascadeClassifier : Algorithm, name: BaseCascadeClassifier, base: Algorithm

--- Incoming ---
[u'class cv.CascadeClassifier', '', [], [], None]
ok: class CLASS cv::.CascadeClassifier : , name: CascadeClassifier, base: 

--- Incoming ---
[u'cv.CascadeClassifier.CascadeClassifier', '', [], [], None]
ok: FUNC < cv.CascadeClassifier.CascadeClassifier []>

--- Incoming ---
[   u'cv.CascadeClassifier.CascadeClassifier',
    '',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.CascadeClassifier.CascadeClassifier [ARG String filename=]>

--- Incoming ---
[u'cv.CascadeClassifier.empty', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.CascadeClassifier.empty []>

--- Incoming ---
[   u'cv.CascadeClassifier.load',
    u'bool',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.CascadeClassifier.load [ARG String filename=]>

--- Incoming ---
[   u'cv.CascadeClassifier.read',
    u'bool',
    [],
    [[u'FileNode', u'node', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.CascadeClassifier.read [ARG FileNode node=]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []]],
    u'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [u'=detectMultiScale2'],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'vector_int', u'numDetections', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []]],
    u'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int numDetections=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [u'=detectMultiScale3'],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'vector_int', u'rejectLevels', u'', ['/O', '/Ref']],
        [u'vector_double', u'levelWeights', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []],
        [u'bool', u'outputRejectLevels', u'false', []]],
    u'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int rejectLevels=, ARG vector_double levelWeights=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size(), ARG bool outputRejectLevels=false]>

--- Incoming ---
[u'cv.CascadeClassifier.isOldFormatCascade', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.CascadeClassifier.isOldFormatCascade []>

--- Incoming ---
[u'cv.CascadeClassifier.getOriginalWindowSize', u'Size', ['/C'], [], u'Size']
ok: FUNC <Size cv.CascadeClassifier.getOriginalWindowSize []>

--- Incoming ---
[u'cv.CascadeClassifier.getFeatureType', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.CascadeClassifier.getFeatureType []>

--- Incoming ---
[   u'cv.CascadeClassifier.convert',
    u'bool',
    ['/S'],
    [   [u'String', u'oldcascade', u'', ['/C', '/Ref']],
        [u'String', u'newcascade', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.CascadeClassifier.convert [ARG String oldcascade=, ARG String newcascade=]>

--- Incoming ---
[   u'struct cv.HOGDescriptor',
    '',
    [],
    [   [u'Size', u'winSize', '', []],
        [u'Size', u'blockSize', '', []],
        [u'Size', u'blockStride', '', []],
        [u'Size', u'cellSize', '', []],
        [u'int', u'nbins', '', []],
        [u'int', u'derivAperture', '', []],
        [u'double', u'winSigma', '', []],
        [u'HOGDescriptor_HistogramNormType', u'histogramNormType', '', []],
        [u'double', u'L2HysThreshold', '', []],
        [u'bool', u'gammaCorrection', '', []],
        [u'vector_float', u'svmDetector', '', []],
        [u'int', u'nlevels', '', []],
        [u'bool', u'signedGradient', '', []]],
    None]
ok: class CLASS cv::.HOGDescriptor : , name: HOGDescriptor, base: 

--- Incoming ---
[   u'enum cv.HOGDescriptor.HistogramNormType',
    '',
    [],
    [[u'const cv.HOGDescriptor.L2Hys', u'0', [], [], None, '']],
    None]
ok: CONST L2Hys=0

--- Incoming ---
[   u'enum cv.HOGDescriptor.<unnamed>',
    '',
    [],
    [[u'const cv.HOGDescriptor.DEFAULT_NLEVELS', u'64', [], [], None, '']],
    None]
ok: CONST DEFAULT_NLEVELS=64

--- Incoming ---
[   u'enum cv.HOGDescriptor.DescriptorStorageFormat',
    '',
    [],
    [   [   u'const cv.HOGDescriptor.DESCR_FORMAT_COL_BY_COL',
            '0',
            [],
            [],
            None,
            ''],
        [   u'const cv.HOGDescriptor.DESCR_FORMAT_ROW_BY_ROW',
            '1',
            [],
            [],
            None,
            '']],
    None]
ok: CONST DESCR_FORMAT_COL_BY_COL=0
ok: CONST DESCR_FORMAT_ROW_BY_ROW=1

--- Incoming ---
[u'cv.HOGDescriptor.HOGDescriptor', '', [], [], None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor []>

--- Incoming ---
[   u'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [   [u'Size', u'_winSize', u'', []],
        [u'Size', u'_blockSize', u'', []],
        [u'Size', u'_blockStride', u'', []],
        [u'Size', u'_cellSize', u'', []],
        [u'int', u'_nbins', u'', []],
        [u'int', u'_derivAperture', u'1', []],
        [u'double', u'_winSigma', u'-1', []],
        [   u'HOGDescriptor_HistogramNormType',
            u'_histogramNormType',
            u'HOGDescriptor::L2Hys',
            []],
        [u'double', u'_L2HysThreshold', u'0.2', []],
        [u'bool', u'_gammaCorrection', u'false', []],
        [u'int', u'_nlevels', u'HOGDescriptor::DEFAULT_NLEVELS', []],
        [u'bool', u'_signedGradient', u'false', []]],
    None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor [ARG Size _winSize=, ARG Size _blockSize=, ARG Size _blockStride=, ARG Size _cellSize=, ARG int _nbins=, ARG int _derivAperture=1, ARG double _winSigma=-1, ARG HOGDescriptor_HistogramNormType _histogramNormType=HOGDescriptor::L2Hys, ARG double _L2HysThreshold=0.2, ARG bool _gammaCorrection=false, ARG int _nlevels=HOGDescriptor::DEFAULT_NLEVELS, ARG bool _signedGradient=false]>

--- Incoming ---
[   u'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor [ARG String filename=]>

--- Incoming ---
[u'cv.HOGDescriptor.getDescriptorSize', u'size_t', ['/C'], [], u'size_t']
ok: FUNC <size_t cv.HOGDescriptor.getDescriptorSize []>

--- Incoming ---
[u'cv.HOGDescriptor.checkDetectorSize', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.HOGDescriptor.checkDetectorSize []>

--- Incoming ---
[u'cv.HOGDescriptor.getWinSigma', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.HOGDescriptor.getWinSigma []>

--- Incoming ---
[   u'cv.HOGDescriptor.setSVMDetector',
    u'void',
    ['/V'],
    [['Mat', u'svmdetector', '', []]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.setSVMDetector [ARG Mat svmdetector=]>

--- Incoming ---
[   u'cv.HOGDescriptor.load',
    u'bool',
    ['/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'objname', u'String()', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.HOGDescriptor.load [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   u'cv.HOGDescriptor.save',
    u'void',
    ['/C', '/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'objname', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.save [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   u'cv.HOGDescriptor.compute',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        [u'vector_float', u'descriptors', u'', ['/O', '/Ref']],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [   u'vector_Point',
            u'locations',
            u'std::vector<Point>()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.compute [ARG Mat img=, ARG vector_float descriptors=, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point locations=std::vector<Point>()]>

--- Incoming ---
[   u'cv.HOGDescriptor.detect',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        [u'vector_Point', u'foundLocations', u'', ['/O', '/Ref']],
        [u'vector_double', u'weights', u'', ['/O', '/Ref']],
        [u'double', u'hitThreshold', u'0', []],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [   u'vector_Point',
            u'searchLocations',
            u'std::vector<Point>()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.detect [ARG Mat img=, ARG vector_Point foundLocations=, ARG vector_double weights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point searchLocations=std::vector<Point>()]>

--- Incoming ---
[   u'cv.HOGDescriptor.detectMultiScale',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        [u'vector_Rect', u'foundLocations', u'', ['/O', '/Ref']],
        [u'vector_double', u'foundWeights', u'', ['/O', '/Ref']],
        [u'double', u'hitThreshold', u'0', []],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [u'double', u'scale', u'1.05', []],
        [u'double', u'finalThreshold', u'2.0', []],
        [u'bool', u'useMeanshiftGrouping', u'false', []]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.detectMultiScale [ARG Mat img=, ARG vector_Rect foundLocations=, ARG vector_double foundWeights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG double scale=1.05, ARG double finalThreshold=2.0, ARG bool useMeanshiftGrouping=false]>

--- Incoming ---
[   u'cv.HOGDescriptor.computeGradient',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        ['Mat', u'grad', '', ['/IO']],
        ['Mat', u'angleOfs', '', ['/IO']],
        [u'Size', u'paddingTL', u'Size()', []],
        [u'Size', u'paddingBR', u'Size()', []]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.computeGradient [ARG Mat img=, ARG Mat grad=, ARG Mat angleOfs=, ARG Size paddingTL=Size(), ARG Size paddingBR=Size()]>

--- Incoming ---
[   u'cv.HOGDescriptor.getDefaultPeopleDetector',
    u'vector_float',
    ['/S'],
    [],
    u'std::vector<float>']
ok: FUNC <vector_float cv.HOGDescriptor.getDefaultPeopleDetector []>

--- Incoming ---
[   u'cv.HOGDescriptor.getDaimlerPeopleDetector',
    u'vector_float',
    ['/S'],
    [],
    u'std::vector<float>']
ok: FUNC <vector_float cv.HOGDescriptor.getDaimlerPeopleDetector []>

--- Incoming ---
[u'class cv.QRCodeDetector', '', [], [], None]
ok: class CLASS cv::.QRCodeDetector : , name: QRCodeDetector, base: 

--- Incoming ---
[u'cv.QRCodeDetector.QRCodeDetector', '', [], [], None]
ok: FUNC < cv.QRCodeDetector.QRCodeDetector []>

--- Incoming ---
[   u'cv.QRCodeDetector.setEpsX',
    u'void',
    [],
    [[u'double', u'epsX', u'', []]],
    u'void']
ok: FUNC <void cv.QRCodeDetector.setEpsX [ARG double epsX=]>

--- Incoming ---
[   u'cv.QRCodeDetector.setEpsY',
    u'void',
    [],
    [[u'double', u'epsY', u'', []]],
    u'void']
ok: FUNC <void cv.QRCodeDetector.setEpsY [ARG double epsY=]>

--- Incoming ---
[   u'cv.QRCodeDetector.detect',
    u'bool',
    ['/C'],
    [['Mat', u'img', '', []], ['Mat', u'points', '', ['/O']]],
    u'bool']
ok: FUNC <bool cv.QRCodeDetector.detect [ARG Mat img=, ARG Mat points=]>

--- Incoming ---
[   u'cv.QRCodeDetector.decode',
    u'string',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'points', '', []],
        ['Mat', u'straight_qrcode', u'Mat()', ['/O']]],
    u'std::string']
ok: FUNC <string cv.QRCodeDetector.decode [ARG Mat img=, ARG Mat points=, ARG Mat straight_qrcode=Mat()]>

--- Incoming ---
[   u'cv.QRCodeDetector.detectAndDecode',
    u'string',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'points', u'Mat()', ['/O']],
        ['Mat', u'straight_qrcode', u'Mat()', ['/O']]],
    u'std::string']
ok: FUNC <string cv.QRCodeDetector.detectAndDecode [ARG Mat img=, ARG Mat points=Mat(), ARG Mat straight_qrcode=Mat()]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/objdetect/include/opencv2/objdetect/objdetect.hpp =====
Namespaces: set([u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/objdetect/include/opencv2/objdetect/objdetect.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/objdetect/include/opencv2/objdetect/detection_based_tracker.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'enum cv.DetectionBasedTracker.ObjectStatus',
    '',
    [],
    [   [   u'const cv.DetectionBasedTracker.DETECTED_NOT_SHOWN_YET',
            '0',
            [],
            [],
            None,
            ''],
        [u'const cv.DetectionBasedTracker.DETECTED', '1', [], [], None, ''],
        [   u'const cv.DetectionBasedTracker.DETECTED_TEMPORARY_LOST',
            '2',
            [],
            [],
            None,
            ''],
        [   u'const cv.DetectionBasedTracker.WRONG_OBJECT',
            '3',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST DETECTED_NOT_SHOWN_YET=0
ok: CONST DetectionBasedTracker_DETECTED_NOT_SHOWN_YET=0
class not found: CONST DETECTED=1
ok: CONST DetectionBasedTracker_DETECTED=1
class not found: CONST DETECTED_TEMPORARY_LOST=2
ok: CONST DetectionBasedTracker_DETECTED_TEMPORARY_LOST=2
class not found: CONST WRONG_OBJECT=3
ok: CONST DetectionBasedTracker_WRONG_OBJECT=3


===== Generating... =====
CLASS cv::.HOGDescriptor : 
[CONST DESCR_FORMAT_COL_BY_COL=0, CONST DESCR_FORMAT_ROW_BY_ROW=1]
[CONST L2Hys=0]
[CONST DEFAULT_NLEVELS=64]
FUNC < cv.HOGDescriptor.HOGDescriptor [ARG Size _winSize=, ARG Size _blockSize=, ARG Size _blockStride=, ARG Size _cellSize=, ARG int _nbins=, ARG int _derivAperture=1, ARG double _winSigma=-1, ARG HOGDescriptor_HistogramNormType _histogramNormType=HOGDescriptor::L2Hys, ARG double _L2HysThreshold=0.2, ARG bool _gammaCorrection=false, ARG int _nlevels=HOGDescriptor::DEFAULT_NLEVELS, ARG bool _signedGradient=false]>
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels, boolean _signedGradient)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins)
FUNC < cv.HOGDescriptor.HOGDescriptor [ARG String filename=]>
java:  HOGDescriptor(String filename)
FUNC < cv.HOGDescriptor.HOGDescriptor []>
java:  HOGDescriptor()
FUNC <bool cv.HOGDescriptor.checkDetectorSize []>
java: boolean checkDetectorSize()
FUNC <bool cv.HOGDescriptor.load [ARG String filename=, ARG String objname=String()]>
java: boolean load(String filename, String objname)
java: boolean load(String filename)
FUNC <double cv.HOGDescriptor.getWinSigma []>
java: double getWinSigma()
FUNC <size_t cv.HOGDescriptor.getDescriptorSize []>
java: long getDescriptorSize()
FUNC <vector_float cv.HOGDescriptor.getDaimlerPeopleDetector []>
java: MatOfFloat getDaimlerPeopleDetector()
FUNC <vector_float cv.HOGDescriptor.getDefaultPeopleDetector []>
java: MatOfFloat getDefaultPeopleDetector()
FUNC <void cv.HOGDescriptor.compute [ARG Mat img=, ARG vector_float descriptors=, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point locations=std::vector<Point>()]>
java: void compute(Mat img, MatOfFloat descriptors, Size winStride, Size padding, MatOfPoint locations)
java: void compute(Mat img, MatOfFloat descriptors, Size winStride, Size padding)
java: void compute(Mat img, MatOfFloat descriptors, Size winStride)
java: void compute(Mat img, MatOfFloat descriptors)
FUNC <void cv.HOGDescriptor.computeGradient [ARG Mat img=, ARG Mat grad=, ARG Mat angleOfs=, ARG Size paddingTL=Size(), ARG Size paddingBR=Size()]>
java: void computeGradient(Mat img, Mat grad, Mat angleOfs, Size paddingTL, Size paddingBR)
java: void computeGradient(Mat img, Mat grad, Mat angleOfs, Size paddingTL)
java: void computeGradient(Mat img, Mat grad, Mat angleOfs)
FUNC <void cv.HOGDescriptor.detect [ARG Mat img=, ARG vector_Point foundLocations=, ARG vector_double weights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point searchLocations=std::vector<Point>()]>
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride, Size padding, MatOfPoint searchLocations)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride, Size padding)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights)
FUNC <void cv.HOGDescriptor.detectMultiScale [ARG Mat img=, ARG vector_Rect foundLocations=, ARG vector_double foundWeights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG double scale=1.05, ARG double finalThreshold=2.0, ARG bool useMeanshiftGrouping=false]>
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale, double finalThreshold, boolean useMeanshiftGrouping)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale, double finalThreshold)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights)
FUNC <void cv.HOGDescriptor.save [ARG String filename=, ARG String objname=String()]>
java: void save(String filename, String objname)
java: void save(String filename)
FUNC <void cv.HOGDescriptor.setSVMDetector [ARG Mat svmdetector=]>
java: void setSVMDetector(Mat svmdetector)
FUNC <Size cv.HOGDescriptor.get_winSize []>
java: Size get_winSize()
FUNC <Size cv.HOGDescriptor.get_blockSize []>
java: Size get_blockSize()
FUNC <Size cv.HOGDescriptor.get_blockStride []>
java: Size get_blockStride()
FUNC <Size cv.HOGDescriptor.get_cellSize []>
java: Size get_cellSize()
FUNC <int cv.HOGDescriptor.get_nbins []>
java: int get_nbins()
FUNC <int cv.HOGDescriptor.get_derivAperture []>
java: int get_derivAperture()
FUNC <double cv.HOGDescriptor.get_winSigma []>
java: double get_winSigma()
FUNC <HOGDescriptor_HistogramNormType cv.HOGDescriptor.get_histogramNormType []>
java: int get_histogramNormType()
FUNC <double cv.HOGDescriptor.get_L2HysThreshold []>
java: double get_L2HysThreshold()
FUNC <bool cv.HOGDescriptor.get_gammaCorrection []>
java: boolean get_gammaCorrection()
FUNC <vector_float cv.HOGDescriptor.get_svmDetector []>
java: MatOfFloat get_svmDetector()
FUNC <int cv.HOGDescriptor.get_nlevels []>
java: int get_nlevels()
FUNC <bool cv.HOGDescriptor.get_signedGradient []>
java: boolean get_signedGradient()
CLASS cv::.QRCodeDetector : 
FUNC < cv.QRCodeDetector.QRCodeDetector []>
java:  QRCodeDetector()
FUNC <bool cv.QRCodeDetector.detect [ARG Mat img=, ARG Mat points=]>
java: boolean detect(Mat img, Mat points)
FUNC <string cv.QRCodeDetector.decode [ARG Mat img=, ARG Mat points=, ARG Mat straight_qrcode=Mat()]>
java: String decode(Mat img, Mat points, Mat straight_qrcode)
java: String decode(Mat img, Mat points)
FUNC <string cv.QRCodeDetector.detectAndDecode [ARG Mat img=, ARG Mat points=Mat(), ARG Mat straight_qrcode=Mat()]>
java: String detectAndDecode(Mat img, Mat points, Mat straight_qrcode)
java: String detectAndDecode(Mat img, Mat points)
java: String detectAndDecode(Mat img)
FUNC <void cv.QRCodeDetector.setEpsX [ARG double epsX=]>
java: void setEpsX(double epsX)
FUNC <void cv.QRCodeDetector.setEpsY [ARG double epsY=]>
java: void setEpsY(double epsY)
CLASS cv::.CascadeClassifier : 
FUNC < cv.CascadeClassifier.CascadeClassifier [ARG String filename=]>
java:  CascadeClassifier(String filename)
FUNC < cv.CascadeClassifier.CascadeClassifier []>
java:  CascadeClassifier()
FUNC <Size cv.CascadeClassifier.getOriginalWindowSize []>
java: Size getOriginalWindowSize()
FUNC <bool cv.CascadeClassifier.convert [ARG String oldcascade=, ARG String newcascade=]>
java: boolean convert(String oldcascade, String newcascade)
FUNC <bool cv.CascadeClassifier.empty []>
java: boolean empty()
FUNC <bool cv.CascadeClassifier.isOldFormatCascade []>
java: boolean isOldFormatCascade()
FUNC <bool cv.CascadeClassifier.load [ARG String filename=]>
java: boolean load(String filename)
FUNC <bool cv.CascadeClassifier.read [ARG FileNode node=]>
SKIP:bool cv::CascadeClassifier::read(FileNode node)	 due to ARG type FileNode/I
FUNC <int cv.CascadeClassifier.getFeatureType []>
java: int getFeatureType()
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor)
java: void detectMultiScale(Mat image, MatOfRect objects)
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int numDetections=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections)
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int rejectLevels=, ARG vector_double levelWeights=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size(), ARG bool outputRejectLevels=false]>
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize, boolean outputRejectLevels)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights)
CLASS cv::.BaseCascadeClassifier : Algorithm
CLASS ::.Objdetect : 
[CONST DetectionBasedTracker_DETECTED_NOT_SHOWN_YET=0, CONST DetectionBasedTracker_DETECTED=1, CONST DetectionBasedTracker_DETECTED_TEMPORARY_LOST=2, CONST DetectionBasedTracker_WRONG_OBJECT=3]
[CONST CASCADE_DO_CANNY_PRUNING=1, CONST CASCADE_SCALE_IMAGE=2, CONST CASCADE_FIND_BIGGEST_OBJECT=4, CONST CASCADE_DO_ROUGH_SEARCH=8]
FUNC <void cv..groupRectangles [ARG vector_Rect rectList=, ARG vector_int weights=, ARG int groupThreshold=, ARG double eps=0.2]>
java: void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold, double eps)
java: void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold)

=== MODULE: structured_light (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light) ===


Files (4):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light/sinusoidalpattern.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light/graycodepattern.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light/structured_light.hpp']

Common headers (0):
[]
ok: class CLASS ::.Structured_light : , name: Structured_light, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light/sinusoidalpattern.hpp =====
Namespaces: set([u'cv.structured_light', u'cv'])

--- Incoming ---
[   u'enum cv.structured_light.<unnamed>',
    '',
    [],
    [   [u'const cv.structured_light.FTP', u'0', [], [], None, ''],
        [u'const cv.structured_light.PSP', u'1', [], [], None, ''],
        [u'const cv.structured_light.FAPS', u'2', [], [], None, '']],
    None]
ok: CONST FTP=0
ok: CONST PSP=1
ok: CONST FAPS=2

--- Incoming ---
[   u'class cv.structured_light.SinusoidalPattern',
    u': cv::structured_light::StructuredLightPattern',
    [],
    [],
    None]
ok: class CLASS cv.structured_light::.SinusoidalPattern : StructuredLightPattern, name: SinusoidalPattern, base: StructuredLightPattern

--- Incoming ---
[   u'struct cv.structured_light.SinusoidalPattern.Params',
    '',
    [],
    [   [u'int', u'width', '', ['/RW']],
        [u'int', u'height', '', ['/RW']],
        [u'int', u'nbrOfPeriods', '', ['/RW']],
        [u'float', u'shiftValue', '', ['/RW']],
        [u'int', u'methodId', '', ['/RW']],
        [u'int', u'nbrOfPixelsBetweenMarkers', '', ['/RW']],
        [u'bool', u'horizontal', '', ['/RW']],
        [u'bool', u'setMarkers', '', ['/RW']]],
    None]
duplicated: CLASS cv.structured_light::SinusoidalPattern.Params : 

--- Incoming ---
[u'cv.structured_light.SinusoidalPattern.Params.Params', '', [], [], None]
ok: FUNC < cv.structured_light.SinusoidalPattern.Params.Params []>

--- Incoming ---
[   u'cv.structured_light.SinusoidalPattern.create',
    u'Ptr_SinusoidalPattern',
    ['/S'],
    [   [   u'Ptr_SinusoidalPattern_Params',
            u'parameters',
            u'makePtr<SinusoidalPattern::Params>()',
            []]],
    u'Ptr<SinusoidalPattern>']
ok: FUNC <Ptr_SinusoidalPattern cv.structured_light.SinusoidalPattern.create [ARG Ptr_SinusoidalPattern_Params parameters=makePtr<SinusoidalPattern::Params>()]>

--- Incoming ---
[   u'cv.structured_light.SinusoidalPattern.computePhaseMap',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'patternImages', '', []],
        ['Mat', u'wrappedPhaseMap', '', ['/O']],
        ['Mat', u'shadowMask', u'Mat()', ['/O']],
        ['Mat', u'fundamental', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.structured_light.SinusoidalPattern.computePhaseMap [ARG vector_Mat patternImages=, ARG Mat wrappedPhaseMap=, ARG Mat shadowMask=Mat(), ARG Mat fundamental=Mat()]>

--- Incoming ---
[   u'cv.structured_light.SinusoidalPattern.unwrapPhaseMap',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'wrappedPhaseMap', '', []],
        ['Mat', u'unwrappedPhaseMap', '', ['/O']],
        [u'Size', u'camSize', u'', []],
        ['Mat', u'shadowMask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.structured_light.SinusoidalPattern.unwrapPhaseMap [ARG vector_Mat wrappedPhaseMap=, ARG Mat unwrappedPhaseMap=, ARG Size camSize=, ARG Mat shadowMask=Mat()]>

--- Incoming ---
[   u'cv.structured_light.SinusoidalPattern.findProCamMatches',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'projUnwrappedPhaseMap', '', []],
        ['Mat', u'camUnwrappedPhaseMap', '', []],
        ['vector_Mat', u'matches', '', ['/O']]],
    u'void']
ok: FUNC <void cv.structured_light.SinusoidalPattern.findProCamMatches [ARG Mat projUnwrappedPhaseMap=, ARG Mat camUnwrappedPhaseMap=, ARG vector_Mat matches=]>

--- Incoming ---
[   u'cv.structured_light.SinusoidalPattern.computeDataModulationTerm',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'patternImages', '', []],
        ['Mat', u'dataModulationTerm', '', ['/O']],
        ['Mat', u'shadowMask', '', []]],
    u'void']
ok: FUNC <void cv.structured_light.SinusoidalPattern.computeDataModulationTerm [ARG vector_Mat patternImages=, ARG Mat dataModulationTerm=, ARG Mat shadowMask=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light/graycodepattern.hpp =====
Namespaces: set([u'cv.structured_light', u'cv'])

--- Incoming ---
[   u'class cv.structured_light.GrayCodePattern',
    u': cv::structured_light::StructuredLightPattern',
    [],
    [],
    None]
ok: class CLASS cv.structured_light::.GrayCodePattern : StructuredLightPattern, name: GrayCodePattern, base: StructuredLightPattern

--- Incoming ---
[   u'cv.structured_light.GrayCodePattern.create',
    u'Ptr_GrayCodePattern',
    ['/S'],
    [[u'int', u'width', u'', []], [u'int', u'height', u'', []]],
    u'Ptr<GrayCodePattern>']
ok: FUNC <Ptr_GrayCodePattern cv.structured_light.GrayCodePattern.create [ARG int width=, ARG int height=]>

--- Incoming ---
[   u'cv.structured_light.GrayCodePattern.getNumberOfPatternImages',
    u'size_t',
    ['/C', '/V', '/PV'],
    [],
    u'size_t']
ok: FUNC <size_t cv.structured_light.GrayCodePattern.getNumberOfPatternImages []>

--- Incoming ---
[   u'cv.structured_light.GrayCodePattern.setWhiteThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'size_t', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.structured_light.GrayCodePattern.setWhiteThreshold [ARG size_t value=]>

--- Incoming ---
[   u'cv.structured_light.GrayCodePattern.setBlackThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'size_t', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.structured_light.GrayCodePattern.setBlackThreshold [ARG size_t value=]>

--- Incoming ---
[   u'cv.structured_light.GrayCodePattern.getImagesForShadowMasks',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'blackImage', '', ['/IO']], ['Mat', u'whiteImage', '', ['/IO']]],
    u'void']
ok: FUNC <void cv.structured_light.GrayCodePattern.getImagesForShadowMasks [ARG Mat blackImage=, ARG Mat whiteImage=]>

--- Incoming ---
[   u'cv.structured_light.GrayCodePattern.getProjPixel',
    u'bool',
    ['/C', '/V', '/PV'],
    [   ['vector_Mat', u'patternImages', '', []],
        [u'int', u'x', u'', []],
        [u'int', u'y', u'', []],
        [u'Point', u'projPix', u'', ['/O', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.structured_light.GrayCodePattern.getProjPixel [ARG vector_Mat patternImages=, ARG int x=, ARG int y=, ARG Point projPix=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/structured_light/include/opencv2/structured_light/structured_light.hpp =====
Namespaces: set([u'cv.structured_light', u'cv'])

--- Incoming ---
[   u'enum cv.structured_light.<unnamed>',
    '',
    [],
    [   [   u'const cv.structured_light.DECODE_3D_UNDERWORLD',
            u'0',
            [],
            [],
            None,
            '']],
    None]
ok: CONST DECODE_3D_UNDERWORLD=0

--- Incoming ---
[   u'class cv.structured_light.StructuredLightPattern',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.structured_light::.StructuredLightPattern : Algorithm, name: StructuredLightPattern, base: Algorithm

--- Incoming ---
[   u'cv.structured_light.StructuredLightPattern.generate',
    u'bool',
    ['/V', '/PV'],
    [['vector_Mat', u'patternImages', '', ['/O']]],
    u'bool']
ok: FUNC <bool cv.structured_light.StructuredLightPattern.generate [ARG vector_Mat patternImages=]>

--- Incoming ---
[   u'cv.structured_light.StructuredLightPattern.decode',
    u'bool',
    ['/C', '/V', '/PV'],
    [   [u'vector_vector_Mat', u'patternImages', u'', ['/C', '/Ref']],
        ['Mat', u'disparityMap', '', ['/O']],
        ['vector_Mat', u'blackImages', u'vector_Mat()', []],
        ['vector_Mat', u'whiteImages', u'vector_Mat()', []],
        [u'int', u'flags', u'DECODE_3D_UNDERWORLD', []]],
    u'bool']
ok: FUNC <bool cv.structured_light.StructuredLightPattern.decode [ARG vector_vector_Mat patternImages=, ARG Mat disparityMap=, ARG vector_Mat blackImages=vector_Mat(), ARG vector_Mat whiteImages=vector_Mat(), ARG int flags=DECODE_3D_UNDERWORLD]>


===== Generating... =====
CLASS cv.structured_light::.SinusoidalPattern : StructuredLightPattern
FUNC <Ptr_SinusoidalPattern cv.structured_light.SinusoidalPattern.create [ARG Ptr_SinusoidalPattern_Params parameters=makePtr<SinusoidalPattern::Params>()]>
java: SinusoidalPattern create()
java: SinusoidalPattern create()
FUNC <void cv.structured_light.SinusoidalPattern.computeDataModulationTerm [ARG vector_Mat patternImages=, ARG Mat dataModulationTerm=, ARG Mat shadowMask=]>
java: void computeDataModulationTerm(List<Mat> patternImages, Mat dataModulationTerm, Mat shadowMask)
FUNC <void cv.structured_light.SinusoidalPattern.computePhaseMap [ARG vector_Mat patternImages=, ARG Mat wrappedPhaseMap=, ARG Mat shadowMask=Mat(), ARG Mat fundamental=Mat()]>
java: void computePhaseMap(List<Mat> patternImages, Mat wrappedPhaseMap, Mat shadowMask, Mat fundamental)
java: void computePhaseMap(List<Mat> patternImages, Mat wrappedPhaseMap, Mat shadowMask)
java: void computePhaseMap(List<Mat> patternImages, Mat wrappedPhaseMap)
FUNC <void cv.structured_light.SinusoidalPattern.findProCamMatches [ARG Mat projUnwrappedPhaseMap=, ARG Mat camUnwrappedPhaseMap=, ARG vector_Mat matches=]>
java: void findProCamMatches(Mat projUnwrappedPhaseMap, Mat camUnwrappedPhaseMap, List<Mat> matches)
FUNC <void cv.structured_light.SinusoidalPattern.unwrapPhaseMap [ARG vector_Mat wrappedPhaseMap=, ARG Mat unwrappedPhaseMap=, ARG Size camSize=, ARG Mat shadowMask=Mat()]>
java: void unwrapPhaseMap(List<Mat> wrappedPhaseMap, Mat unwrappedPhaseMap, Size camSize, Mat shadowMask)
java: void unwrapPhaseMap(List<Mat> wrappedPhaseMap, Mat unwrappedPhaseMap, Size camSize)
CLASS ::.Structured_light : 
[CONST FTP=0, CONST PSP=1, CONST FAPS=2, CONST DECODE_3D_UNDERWORLD=0]
CLASS cv.structured_light::.StructuredLightPattern : Algorithm
FUNC <bool cv.structured_light.StructuredLightPattern.decode [ARG vector_vector_Mat patternImages=, ARG Mat disparityMap=, ARG vector_Mat blackImages=vector_Mat(), ARG vector_Mat whiteImages=vector_Mat(), ARG int flags=DECODE_3D_UNDERWORLD]>
SKIP:bool cv::structured_light::StructuredLightPattern::decode(vector_vector_Mat patternImages, Mat& disparityMap, vector_Mat blackImages = vector_Mat(), vector_Mat whiteImages = vector_Mat(), int flags = DECODE_3D_UNDERWORLD)	 due to ARG type vector_vector_Mat/I
FUNC <bool cv.structured_light.StructuredLightPattern.generate [ARG vector_Mat patternImages=]>
java: boolean generate(List<Mat> patternImages)
CLASS cv.structured_light::SinusoidalPattern.Params : 
FUNC < cv.structured_light.SinusoidalPattern.Params.Params []>
java:  Params()
CLASS cv.structured_light::.GrayCodePattern : StructuredLightPattern
FUNC <Ptr_GrayCodePattern cv.structured_light.GrayCodePattern.create [ARG int width=, ARG int height=]>
java: GrayCodePattern create(int width, int height)
FUNC <bool cv.structured_light.GrayCodePattern.getProjPixel [ARG vector_Mat patternImages=, ARG int x=, ARG int y=, ARG Point projPix=]>
java: boolean getProjPixel(List<Mat> patternImages, int x, int y, Point projPix)
FUNC <size_t cv.structured_light.GrayCodePattern.getNumberOfPatternImages []>
java: long getNumberOfPatternImages()
FUNC <void cv.structured_light.GrayCodePattern.getImagesForShadowMasks [ARG Mat blackImage=, ARG Mat whiteImage=]>
java: void getImagesForShadowMasks(Mat blackImage, Mat whiteImage)
FUNC <void cv.structured_light.GrayCodePattern.setBlackThreshold [ARG size_t value=]>
java: void setBlackThreshold(long value)
FUNC <void cv.structured_light.GrayCodePattern.setWhiteThreshold [ARG size_t value=]>
java: void setWhiteThreshold(long value)

=== MODULE: text (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text) ===


Files (4):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text/erfilter.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text/ocr.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text/textDetector.hpp']

Common headers (0):
[]
ok: class CLASS ::.Text : , name: Text, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text/erfilter.hpp =====
Namespaces: set([u'cv.text', u'cv'])

--- Incoming ---
[u'class cv.text.ERFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.text::.ERFilter : Algorithm, name: ERFilter, base: Algorithm

--- Incoming ---
[u'class cv.text.ERFilter.Callback', '', [], [], None]
ok: class CLASS cv.text::ERFilter.Callback : , name: Callback, base: 

--- Incoming ---
[   u'cv.text.createERFilterNM1',
    u'Ptr_ERFilter',
    [],
    [   [u'Ptr_ERFilter_Callback', u'cb', u'', ['/C', '/Ref']],
        [u'int', u'thresholdDelta', u'1', []],
        [u'float', u'minArea', u'(float)0.00025', []],
        [u'float', u'maxArea', u'(float)0.13', []],
        [u'float', u'minProbability', u'(float)0.4', []],
        [u'bool', u'nonMaxSuppression', u'true', []],
        [u'float', u'minProbabilityDiff', u'(float)0.1', []]],
    u'Ptr<ERFilter>']
ok: FUNC <Ptr_ERFilter cv.text..createERFilterNM1 [ARG Ptr_ERFilter_Callback cb=, ARG int thresholdDelta=1, ARG float minArea=(float)0.00025, ARG float maxArea=(float)0.13, ARG float minProbability=(float)0.4, ARG bool nonMaxSuppression=true, ARG float minProbabilityDiff=(float)0.1]>

--- Incoming ---
[   u'cv.text.createERFilterNM2',
    u'Ptr_ERFilter',
    [],
    [   [u'Ptr_ERFilter_Callback', u'cb', u'', ['/C', '/Ref']],
        [u'float', u'minProbability', u'(float)0.3', []]],
    u'Ptr<ERFilter>']
ok: FUNC <Ptr_ERFilter cv.text..createERFilterNM2 [ARG Ptr_ERFilter_Callback cb=, ARG float minProbability=(float)0.3]>

--- Incoming ---
[   u'cv.text.createERFilterNM1',
    u'Ptr_ERFilter',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'thresholdDelta', u'1', []],
        [u'float', u'minArea', u'(float)0.00025', []],
        [u'float', u'maxArea', u'(float)0.13', []],
        [u'float', u'minProbability', u'(float)0.4', []],
        [u'bool', u'nonMaxSuppression', u'true', []],
        [u'float', u'minProbabilityDiff', u'(float)0.1', []]],
    u'Ptr<ERFilter>']
ok: FUNC <Ptr_ERFilter cv.text..createERFilterNM1 [ARG String filename=, ARG int thresholdDelta=1, ARG float minArea=(float)0.00025, ARG float maxArea=(float)0.13, ARG float minProbability=(float)0.4, ARG bool nonMaxSuppression=true, ARG float minProbabilityDiff=(float)0.1]>

--- Incoming ---
[   u'cv.text.createERFilterNM2',
    u'Ptr_ERFilter',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'float', u'minProbability', u'(float)0.3', []]],
    u'Ptr<ERFilter>']
ok: FUNC <Ptr_ERFilter cv.text..createERFilterNM2 [ARG String filename=, ARG float minProbability=(float)0.3]>

--- Incoming ---
[   u'cv.text.loadClassifierNM1',
    u'Ptr_ERFilter_Callback',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'Ptr<ERFilter::Callback>']
ok: FUNC <Ptr_ERFilter_Callback cv.text..loadClassifierNM1 [ARG String filename=]>

--- Incoming ---
[   u'cv.text.loadClassifierNM2',
    u'Ptr_ERFilter_Callback',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'Ptr<ERFilter::Callback>']
ok: FUNC <Ptr_ERFilter_Callback cv.text..loadClassifierNM2 [ARG String filename=]>

--- Incoming ---
[   u'enum cv.text.<unnamed>',
    '',
    [],
    [   [u'const cv.text.ERFILTER_NM_RGBLGrad', '0', [], [], None, ''],
        [u'const cv.text.ERFILTER_NM_IHSGrad', '1', [], [], None, '']],
    None]
ok: CONST ERFILTER_NM_RGBLGrad=0
ok: CONST ERFILTER_NM_IHSGrad=1

--- Incoming ---
[   u'cv.text.computeNMChannels',
    u'void',
    [],
    [   ['Mat', u'_src', '', []],
        ['vector_Mat', u'_channels', '', ['/O', '/O']],
        [u'int', u'_mode', u'ERFILTER_NM_RGBLGrad', []]],
    u'void']
ok: FUNC <void cv.text..computeNMChannels [ARG Mat _src=, ARG vector_Mat _channels=, ARG int _mode=ERFILTER_NM_RGBLGrad]>

--- Incoming ---
[   u'enum cv.text.erGrouping_Modes',
    '',
    [],
    [   [   u'const cv.text.ERGROUPING_ORIENTATION_HORIZ',
            '0',
            [],
            [],
            None,
            ''],
        [u'const cv.text.ERGROUPING_ORIENTATION_ANY', '1', [], [], None, '']],
    None]
ok: CONST ERGROUPING_ORIENTATION_HORIZ=0
ok: CONST ERGROUPING_ORIENTATION_ANY=1

--- Incoming ---
[   u'cv.text.erGrouping',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'channel', '', []],
        [u'vector_vector_Point', u'regions', u'', []],
        [u'vector_Rect', u'groups_rects', u'', ['/O', '/Ref']],
        [u'int', u'method', u'ERGROUPING_ORIENTATION_HORIZ', []],
        [u'String', u'filename', u'String()', ['/C', '/Ref']],
        [u'float', u'minProbablity', u'(float)0.5', []]],
    u'void']
ok: FUNC <void cv.text..erGrouping [ARG Mat image=, ARG Mat channel=, ARG vector_vector_Point regions=, ARG vector_Rect groups_rects=, ARG int method=ERGROUPING_ORIENTATION_HORIZ, ARG String filename=String(), ARG float minProbablity=(float)0.5]>

--- Incoming ---
[   u'cv.text.detectRegions',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Ptr_ERFilter', u'er_filter1', u'', ['/C', '/Ref']],
        [u'Ptr_ERFilter', u'er_filter2', u'', ['/C', '/Ref']],
        [u'vector_vector_Point', u'regions', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.text..detectRegions [ARG Mat image=, ARG Ptr_ERFilter er_filter1=, ARG Ptr_ERFilter er_filter2=, ARG vector_vector_Point regions=]>

--- Incoming ---
[   u'cv.text.detectRegions',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Ptr_ERFilter', u'er_filter1', u'', ['/C', '/Ref']],
        [u'Ptr_ERFilter', u'er_filter2', u'', ['/C', '/Ref']],
        [u'vector_Rect', u'groups_rects', u'', ['/O', '/Ref']],
        [u'int', u'method', u'ERGROUPING_ORIENTATION_HORIZ', []],
        [u'String', u'filename', u'String()', ['/C', '/Ref']],
        [u'float', u'minProbability', u'(float)0.5', []]],
    u'void']
ok: FUNC <void cv.text..detectRegions [ARG Mat image=, ARG Ptr_ERFilter er_filter1=, ARG Ptr_ERFilter er_filter2=, ARG vector_Rect groups_rects=, ARG int method=ERGROUPING_ORIENTATION_HORIZ, ARG String filename=String(), ARG float minProbability=(float)0.5]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text/ocr.hpp =====
Namespaces: set([u'cv.text', u'cv'])

--- Incoming ---
[   u'enum cv.text.<unnamed>',
    '',
    [],
    [   [u'const cv.text.OCR_LEVEL_WORD', '0', [], [], None, ''],
        [u'const cv.text.OCR_LEVEL_TEXTLINE', '1', [], [], None, '']],
    None]
ok: CONST OCR_LEVEL_WORD=0
ok: CONST OCR_LEVEL_TEXTLINE=1

--- Incoming ---
[   u'enum cv.text.page_seg_mode',
    '',
    [],
    [   [u'const cv.text.PSM_OSD_ONLY', '0', [], [], None, ''],
        [u'const cv.text.PSM_AUTO_OSD', '1', [], [], None, ''],
        [u'const cv.text.PSM_AUTO_ONLY', '2', [], [], None, ''],
        [u'const cv.text.PSM_AUTO', '3', [], [], None, ''],
        [u'const cv.text.PSM_SINGLE_COLUMN', '4', [], [], None, ''],
        [u'const cv.text.PSM_SINGLE_BLOCK_VERT_TEXT', '5', [], [], None, ''],
        [u'const cv.text.PSM_SINGLE_BLOCK', '6', [], [], None, ''],
        [u'const cv.text.PSM_SINGLE_LINE', '7', [], [], None, ''],
        [u'const cv.text.PSM_SINGLE_WORD', '8', [], [], None, ''],
        [u'const cv.text.PSM_CIRCLE_WORD', '9', [], [], None, ''],
        [u'const cv.text.PSM_SINGLE_CHAR', '10', [], [], None, '']],
    None]
ok: CONST PSM_OSD_ONLY=0
ok: CONST PSM_AUTO_OSD=1
ok: CONST PSM_AUTO_ONLY=2
ok: CONST PSM_AUTO=3
ok: CONST PSM_SINGLE_COLUMN=4
ok: CONST PSM_SINGLE_BLOCK_VERT_TEXT=5
ok: CONST PSM_SINGLE_BLOCK=6
ok: CONST PSM_SINGLE_LINE=7
ok: CONST PSM_SINGLE_WORD=8
ok: CONST PSM_CIRCLE_WORD=9
ok: CONST PSM_SINGLE_CHAR=10

--- Incoming ---
[   u'enum cv.text.ocr_engine_mode',
    '',
    [],
    [   [u'const cv.text.OEM_TESSERACT_ONLY', '0', [], [], None, ''],
        [u'const cv.text.OEM_CUBE_ONLY', '1', [], [], None, ''],
        [u'const cv.text.OEM_TESSERACT_CUBE_COMBINED', '2', [], [], None, ''],
        [u'const cv.text.OEM_DEFAULT', '3', [], [], None, '']],
    None]
ok: CONST OEM_TESSERACT_ONLY=0
ok: CONST OEM_CUBE_ONLY=1
ok: CONST OEM_TESSERACT_CUBE_COMBINED=2
ok: CONST OEM_DEFAULT=3

--- Incoming ---
[u'class cv.text.BaseOCR', '', [], [], None]
ok: class CLASS cv.text::.BaseOCR : , name: BaseOCR, base: 

--- Incoming ---
[u'class cv.text.OCRTesseract', u': cv::text::BaseOCR', [], [], None]
ok: class CLASS cv.text::.OCRTesseract : BaseOCR, name: OCRTesseract, base: BaseOCR

--- Incoming ---
[   u'cv.text.OCRTesseract.run',
    u'String',
    [],
    [   ['Mat', u'image', '', []],
        [u'int', u'min_confidence', u'', []],
        [u'int', u'component_level', u'0', []]],
    u'String']
ok: FUNC <String cv.text.OCRTesseract.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   u'cv.text.OCRTesseract.run',
    u'String',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'mask', '', []],
        [u'int', u'min_confidence', u'', []],
        [u'int', u'component_level', u'0', []]],
    u'String']
ok: FUNC <String cv.text.OCRTesseract.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   u'cv.text.OCRTesseract.setWhiteList',
    u'void',
    ['/V', '/PV'],
    [[u'String', u'char_whitelist', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.text.OCRTesseract.setWhiteList [ARG String char_whitelist=]>

--- Incoming ---
[   u'cv.text.OCRTesseract.create',
    u'Ptr_OCRTesseract',
    ['/S'],
    [   [u'c_string', u'datapath', u'0', ['/C']],
        [u'c_string', u'language', u'0', ['/C']],
        [u'c_string', u'char_whitelist', u'0', ['/C']],
        [u'int', u'oem', u'OEM_DEFAULT', []],
        [u'int', u'psmode', u'PSM_AUTO', []]],
    u'Ptr<OCRTesseract>']
ok: FUNC <Ptr_OCRTesseract cv.text.OCRTesseract.create [ARG c_string datapath=0, ARG c_string language=0, ARG c_string char_whitelist=0, ARG int oem=OEM_DEFAULT, ARG int psmode=PSM_AUTO]>

--- Incoming ---
[   u'enum cv.text.decoder_mode',
    '',
    [],
    [[u'const cv.text.OCR_DECODER_VITERBI', u'0', [], [], None, '']],
    None]
ok: CONST OCR_DECODER_VITERBI=0

--- Incoming ---
[   u'enum cv.text.classifier_type',
    '',
    [],
    [   [u'const cv.text.OCR_KNN_CLASSIFIER', u'0', [], [], None, ''],
        [u'const cv.text.OCR_CNN_CLASSIFIER', u'1', [], [], None, '']],
    None]
ok: CONST OCR_KNN_CLASSIFIER=0
ok: CONST OCR_CNN_CLASSIFIER=1

--- Incoming ---
[u'class cv.text.OCRHMMDecoder', u': cv::text::BaseOCR', [], [], None]
ok: class CLASS cv.text::.OCRHMMDecoder : BaseOCR, name: OCRHMMDecoder, base: BaseOCR

--- Incoming ---
[u'class cv.text.OCRHMMDecoder.ClassifierCallback', '', [], [], None]
ok: class CLASS cv.text::OCRHMMDecoder.ClassifierCallback : , name: ClassifierCallback, base: 

--- Incoming ---
[   u'cv.text.OCRHMMDecoder.run',
    u'String',
    [],
    [   ['Mat', u'image', '', []],
        [u'int', u'min_confidence', u'', []],
        [u'int', u'component_level', u'0', []]],
    u'String']
ok: FUNC <String cv.text.OCRHMMDecoder.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   u'cv.text.OCRHMMDecoder.run',
    u'String',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'mask', '', []],
        [u'int', u'min_confidence', u'', []],
        [u'int', u'component_level', u'0', []]],
    u'String']
ok: FUNC <String cv.text.OCRHMMDecoder.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   u'cv.text.OCRHMMDecoder.create',
    u'Ptr_OCRHMMDecoder',
    ['/S'],
    [   [u'Ptr_OCRHMMDecoder_ClassifierCallback', u'classifier', u'', ['/C']],
        [u'String', u'vocabulary', u'', ['/C', '/Ref']],
        ['Mat', u'transition_probabilities_table', '', []],
        ['Mat', u'emission_probabilities_table', '', []],
        [u'int', u'mode', u'OCR_DECODER_VITERBI', []]],
    u'Ptr<OCRHMMDecoder>']
ok: FUNC <Ptr_OCRHMMDecoder cv.text.OCRHMMDecoder.create [ARG Ptr_OCRHMMDecoder_ClassifierCallback classifier=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI]>

--- Incoming ---
[   u'cv.text.OCRHMMDecoder.create',
    u'Ptr_OCRHMMDecoder',
    ['/S'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'vocabulary', u'', ['/C', '/Ref']],
        ['Mat', u'transition_probabilities_table', '', []],
        ['Mat', u'emission_probabilities_table', '', []],
        [u'int', u'mode', u'OCR_DECODER_VITERBI', []],
        [u'int', u'classifier', u'OCR_KNN_CLASSIFIER', []]],
    u'Ptr<OCRHMMDecoder>']
ok: FUNC <Ptr_OCRHMMDecoder cv.text.OCRHMMDecoder.create [ARG String filename=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI, ARG int classifier=OCR_KNN_CLASSIFIER]>

--- Incoming ---
[   u'cv.text.loadOCRHMMClassifierNM',
    u'Ptr_OCRHMMDecoder_ClassifierCallback',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'Ptr<OCRHMMDecoder::ClassifierCallback>']
ok: FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifierNM [ARG String filename=]>

--- Incoming ---
[   u'cv.text.loadOCRHMMClassifierCNN',
    u'Ptr_OCRHMMDecoder_ClassifierCallback',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'Ptr<OCRHMMDecoder::ClassifierCallback>']
ok: FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifierCNN [ARG String filename=]>

--- Incoming ---
[   u'cv.text.loadOCRHMMClassifier',
    u'Ptr_OCRHMMDecoder_ClassifierCallback',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'classifier', u'', []]],
    u'Ptr<OCRHMMDecoder::ClassifierCallback>']
ok: FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifier [ARG String filename=, ARG int classifier=]>

--- Incoming ---
[   u'cv.text.createOCRHMMTransitionsTable',
    u'Mat',
    [],
    [   [u'String', u'vocabulary', u'', ['/C', '/Ref']],
        [u'vector_String', u'lexicon', u'', ['/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.text..createOCRHMMTransitionsTable [ARG String vocabulary=, ARG vector_String lexicon=]>

--- Incoming ---
[u'class cv.text.OCRBeamSearchDecoder', u': cv::text::BaseOCR', [], [], None]
ok: class CLASS cv.text::.OCRBeamSearchDecoder : BaseOCR, name: OCRBeamSearchDecoder, base: BaseOCR

--- Incoming ---
[u'class cv.text.OCRBeamSearchDecoder.ClassifierCallback', '', [], [], None]
duplicated: CLASS cv.text::OCRBeamSearchDecoder.ClassifierCallback : 

--- Incoming ---
[   u'cv.text.OCRBeamSearchDecoder.run',
    u'String',
    [],
    [   ['Mat', u'image', '', []],
        [u'int', u'min_confidence', u'', []],
        [u'int', u'component_level', u'0', []]],
    u'String']
ok: FUNC <String cv.text.OCRBeamSearchDecoder.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   u'cv.text.OCRBeamSearchDecoder.run',
    u'String',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'mask', '', []],
        [u'int', u'min_confidence', u'', []],
        [u'int', u'component_level', u'0', []]],
    u'String']
ok: FUNC <String cv.text.OCRBeamSearchDecoder.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   u'cv.text.OCRBeamSearchDecoder.create',
    u'Ptr_OCRBeamSearchDecoder',
    ['/S'],
    [   [   u'Ptr_OCRBeamSearchDecoder_ClassifierCallback',
            u'classifier',
            u'',
            ['/C']],
        [u'String', u'vocabulary', u'', ['/C', '/Ref']],
        ['Mat', u'transition_probabilities_table', '', []],
        ['Mat', u'emission_probabilities_table', '', []],
        [u'int', u'mode', u'OCR_DECODER_VITERBI', []],
        [u'int', u'beam_size', u'500', []]],
    u'Ptr<OCRBeamSearchDecoder>']
ok: FUNC <Ptr_OCRBeamSearchDecoder cv.text.OCRBeamSearchDecoder.create [ARG Ptr_OCRBeamSearchDecoder_ClassifierCallback classifier=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI, ARG int beam_size=500]>

--- Incoming ---
[   u'cv.text.OCRBeamSearchDecoder.create',
    u'Ptr_OCRBeamSearchDecoder',
    ['/S'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'vocabulary', u'', ['/C', '/Ref']],
        ['Mat', u'transition_probabilities_table', '', []],
        ['Mat', u'emission_probabilities_table', '', []],
        [u'int', u'mode', u'OCR_DECODER_VITERBI', []],
        [u'int', u'beam_size', u'500', []]],
    u'Ptr<OCRBeamSearchDecoder>']
ok: FUNC <Ptr_OCRBeamSearchDecoder cv.text.OCRBeamSearchDecoder.create [ARG String filename=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI, ARG int beam_size=500]>

--- Incoming ---
[   u'cv.text.loadOCRBeamSearchClassifierCNN',
    u'Ptr_OCRBeamSearchDecoder_ClassifierCallback',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'Ptr<OCRBeamSearchDecoder::ClassifierCallback>']
ok: FUNC <Ptr_OCRBeamSearchDecoder_ClassifierCallback cv.text..loadOCRBeamSearchClassifierCNN [ARG String filename=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/text/include/opencv2/text/textDetector.hpp =====
Namespaces: set([u'cv.text', u'cv'])

--- Incoming ---
[u'class cv.text.TextDetector', '', [], [], None]
ok: class CLASS cv.text::.TextDetector : , name: TextDetector, base: 

--- Incoming ---
[   u'cv.text.TextDetector.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'inputImage', '', []],
        [u'vector_Rect', u'Bbox', u'', ['/O', '/Ref']],
        [u'vector_float', u'confidence', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.text.TextDetector.detect [ARG Mat inputImage=, ARG vector_Rect Bbox=, ARG vector_float confidence=]>

--- Incoming ---
[u'class cv.text.TextDetectorCNN', u': cv::text::TextDetector', [], [], None]
ok: class CLASS cv.text::.TextDetectorCNN : TextDetector, name: TextDetectorCNN, base: TextDetector

--- Incoming ---
[   u'cv.text.TextDetectorCNN.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'inputImage', '', []],
        [u'vector_Rect', u'Bbox', u'', ['/O', '/Ref']],
        [u'vector_float', u'confidence', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.text.TextDetectorCNN.detect [ARG Mat inputImage=, ARG vector_Rect Bbox=, ARG vector_float confidence=]>

--- Incoming ---
[   u'cv.text.TextDetectorCNN.create',
    u'Ptr_TextDetectorCNN',
    ['/S'],
    [   [u'String', u'modelArchFilename', u'', ['/C', '/Ref']],
        [u'String', u'modelWeightsFilename', u'', ['/C', '/Ref']]],
    u'Ptr<TextDetectorCNN>']
ok: FUNC <Ptr_TextDetectorCNN cv.text.TextDetectorCNN.create [ARG String modelArchFilename=, ARG String modelWeightsFilename=]>


===== Generating... =====
CLASS cv.text::OCRHMMDecoder.ClassifierCallback : 
CLASS cv.text::.BaseOCR : 
CLASS cv.text::.ERFilter : Algorithm
CLASS ::.Text : 
[CONST ERFILTER_NM_RGBLGrad=0, CONST ERFILTER_NM_IHSGrad=1, CONST OCR_LEVEL_WORD=0, CONST OCR_LEVEL_TEXTLINE=1]
[CONST OCR_DECODER_VITERBI=0]
[CONST ERGROUPING_ORIENTATION_HORIZ=0, CONST ERGROUPING_ORIENTATION_ANY=1]
[CONST PSM_OSD_ONLY=0, CONST PSM_AUTO_OSD=1, CONST PSM_AUTO_ONLY=2, CONST PSM_AUTO=3, CONST PSM_SINGLE_COLUMN=4, CONST PSM_SINGLE_BLOCK_VERT_TEXT=5, CONST PSM_SINGLE_BLOCK=6, CONST PSM_SINGLE_LINE=7, CONST PSM_SINGLE_WORD=8, CONST PSM_CIRCLE_WORD=9, CONST PSM_SINGLE_CHAR=10]
[CONST OCR_KNN_CLASSIFIER=0, CONST OCR_CNN_CLASSIFIER=1]
[CONST OEM_TESSERACT_ONLY=0, CONST OEM_CUBE_ONLY=1, CONST OEM_TESSERACT_CUBE_COMBINED=2, CONST OEM_DEFAULT=3]
FUNC <Mat cv.text..createOCRHMMTransitionsTable [ARG String vocabulary=, ARG vector_String lexicon=]>
java: Mat createOCRHMMTransitionsTable(String vocabulary, List<String> lexicon)
FUNC <Ptr_ERFilter cv.text..createERFilterNM1 [ARG Ptr_ERFilter_Callback cb=, ARG int thresholdDelta=1, ARG float minArea=(float)0.00025, ARG float maxArea=(float)0.13, ARG float minProbability=(float)0.4, ARG bool nonMaxSuppression=true, ARG float minProbabilityDiff=(float)0.1]>
SKIP:Ptr_ERFilter cv::text::createERFilterNM1(Ptr_ERFilter_Callback cb, int thresholdDelta = 1, float minArea = (float)0.00025, float maxArea = (float)0.13, float minProbability = (float)0.4, bool nonMaxSuppression = true, float minProbabilityDiff = (float)0.1)	 due to ARG type Ptr_ERFilter_Callback/I
FUNC <Ptr_ERFilter cv.text..createERFilterNM1 [ARG String filename=, ARG int thresholdDelta=1, ARG float minArea=(float)0.00025, ARG float maxArea=(float)0.13, ARG float minProbability=(float)0.4, ARG bool nonMaxSuppression=true, ARG float minProbabilityDiff=(float)0.1]>
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea, float maxArea, float minProbability, boolean nonMaxSuppression, float minProbabilityDiff)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea, float maxArea, float minProbability, boolean nonMaxSuppression)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea, float maxArea, float minProbability)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea, float maxArea)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta)
java: ERFilter createERFilterNM1(String filename)
FUNC <Ptr_ERFilter cv.text..createERFilterNM2 [ARG Ptr_ERFilter_Callback cb=, ARG float minProbability=(float)0.3]>
SKIP:Ptr_ERFilter cv::text::createERFilterNM2(Ptr_ERFilter_Callback cb, float minProbability = (float)0.3)	 due to ARG type Ptr_ERFilter_Callback/I
FUNC <Ptr_ERFilter cv.text..createERFilterNM2 [ARG String filename=, ARG float minProbability=(float)0.3]>
java: ERFilter createERFilterNM2(String filename, float minProbability)
java: ERFilter createERFilterNM2(String filename)
FUNC <Ptr_ERFilter_Callback cv.text..loadClassifierNM1 [ARG String filename=]>
SKIP:Ptr_ERFilter_Callback cv::text::loadClassifierNM1(String filename)	 due to RET type Ptr_ERFilter_Callback
FUNC <Ptr_ERFilter_Callback cv.text..loadClassifierNM2 [ARG String filename=]>
SKIP:Ptr_ERFilter_Callback cv::text::loadClassifierNM2(String filename)	 due to RET type Ptr_ERFilter_Callback
FUNC <Ptr_OCRBeamSearchDecoder_ClassifierCallback cv.text..loadOCRBeamSearchClassifierCNN [ARG String filename=]>
SKIP:Ptr_OCRBeamSearchDecoder_ClassifierCallback cv::text::loadOCRBeamSearchClassifierCNN(String filename)	 due to RET type Ptr_OCRBeamSearchDecoder_ClassifierCallback
FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifier [ARG String filename=, ARG int classifier=]>
SKIP:Ptr_OCRHMMDecoder_ClassifierCallback cv::text::loadOCRHMMClassifier(String filename, int classifier)	 due to RET type Ptr_OCRHMMDecoder_ClassifierCallback
FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifierCNN [ARG String filename=]>
SKIP:Ptr_OCRHMMDecoder_ClassifierCallback cv::text::loadOCRHMMClassifierCNN(String filename)	 due to RET type Ptr_OCRHMMDecoder_ClassifierCallback
FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifierNM [ARG String filename=]>
SKIP:Ptr_OCRHMMDecoder_ClassifierCallback cv::text::loadOCRHMMClassifierNM(String filename)	 due to RET type Ptr_OCRHMMDecoder_ClassifierCallback
FUNC <void cv.text..computeNMChannels [ARG Mat _src=, ARG vector_Mat _channels=, ARG int _mode=ERFILTER_NM_RGBLGrad]>
java: void computeNMChannels(Mat _src, List<Mat> _channels, int _mode)
java: void computeNMChannels(Mat _src, List<Mat> _channels)
FUNC <void cv.text..detectRegions [ARG Mat image=, ARG Ptr_ERFilter er_filter1=, ARG Ptr_ERFilter er_filter2=, ARG vector_Rect groups_rects=, ARG int method=ERGROUPING_ORIENTATION_HORIZ, ARG String filename=String(), ARG float minProbability=(float)0.5]>
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, MatOfRect groups_rects, int method, String filename, float minProbability)
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, MatOfRect groups_rects, int method, String filename)
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, MatOfRect groups_rects, int method)
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, MatOfRect groups_rects)
FUNC <void cv.text..detectRegions [ARG Mat image=, ARG Ptr_ERFilter er_filter1=, ARG Ptr_ERFilter er_filter2=, ARG vector_vector_Point regions=]>
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, List<MatOfPoint> regions)
FUNC <void cv.text..erGrouping [ARG Mat image=, ARG Mat channel=, ARG vector_vector_Point regions=, ARG vector_Rect groups_rects=, ARG int method=ERGROUPING_ORIENTATION_HORIZ, ARG String filename=String(), ARG float minProbablity=(float)0.5]>
java: void erGrouping(Mat image, Mat channel, List<MatOfPoint> regions, MatOfRect groups_rects, int method, String filename, float minProbablity)
java: void erGrouping(Mat image, Mat channel, List<MatOfPoint> regions, MatOfRect groups_rects, int method, String filename)
java: void erGrouping(Mat image, Mat channel, List<MatOfPoint> regions, MatOfRect groups_rects, int method)
java: void erGrouping(Mat image, Mat channel, List<MatOfPoint> regions, MatOfRect groups_rects)
CLASS cv.text::.OCRBeamSearchDecoder : BaseOCR
FUNC <Ptr_OCRBeamSearchDecoder cv.text.OCRBeamSearchDecoder.create [ARG Ptr_OCRBeamSearchDecoder_ClassifierCallback classifier=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI, ARG int beam_size=500]>
SKIP:static Ptr_OCRBeamSearchDecoder cv::text::OCRBeamSearchDecoder::create(Ptr_OCRBeamSearchDecoder_ClassifierCallback classifier, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode = OCR_DECODER_VITERBI, int beam_size = 500)	 due to ARG type Ptr_OCRBeamSearchDecoder_ClassifierCallback/I
FUNC <Ptr_OCRBeamSearchDecoder cv.text.OCRBeamSearchDecoder.create [ARG String filename=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI, ARG int beam_size=500]>
java: OCRBeamSearchDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode, int beam_size)
java: OCRBeamSearchDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode)
java: OCRBeamSearchDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table)
FUNC <String cv.text.OCRBeamSearchDecoder.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, Mat mask, int min_confidence, int component_level)
java: String run(Mat image, Mat mask, int min_confidence)
FUNC <String cv.text.OCRBeamSearchDecoder.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, int min_confidence, int component_level)
java: String run(Mat image, int min_confidence)
CLASS cv.text::ERFilter.Callback : 
CLASS cv.text::.TextDetector : 
FUNC <void cv.text.TextDetector.detect [ARG Mat inputImage=, ARG vector_Rect Bbox=, ARG vector_float confidence=]>
java: void detect(Mat inputImage, MatOfRect Bbox, MatOfFloat confidence)
CLASS cv.text::.OCRTesseract : BaseOCR
FUNC <Ptr_OCRTesseract cv.text.OCRTesseract.create [ARG c_string datapath=0, ARG c_string language=0, ARG c_string char_whitelist=0, ARG int oem=OEM_DEFAULT, ARG int psmode=PSM_AUTO]>
java: OCRTesseract create(String datapath, String language, String char_whitelist, int oem, int psmode)
java: OCRTesseract create(String datapath, String language, String char_whitelist, int oem)
java: OCRTesseract create(String datapath, String language, String char_whitelist)
java: OCRTesseract create(String datapath, String language)
java: OCRTesseract create(String datapath)
java: OCRTesseract create()
FUNC <String cv.text.OCRTesseract.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, Mat mask, int min_confidence, int component_level)
java: String run(Mat image, Mat mask, int min_confidence)
FUNC <String cv.text.OCRTesseract.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, int min_confidence, int component_level)
java: String run(Mat image, int min_confidence)
FUNC <void cv.text.OCRTesseract.setWhiteList [ARG String char_whitelist=]>
java: void setWhiteList(String char_whitelist)
CLASS cv.text::.OCRHMMDecoder : BaseOCR
FUNC <Ptr_OCRHMMDecoder cv.text.OCRHMMDecoder.create [ARG Ptr_OCRHMMDecoder_ClassifierCallback classifier=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI]>
SKIP:static Ptr_OCRHMMDecoder cv::text::OCRHMMDecoder::create(Ptr_OCRHMMDecoder_ClassifierCallback classifier, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode = OCR_DECODER_VITERBI)	 due to ARG type Ptr_OCRHMMDecoder_ClassifierCallback/I
FUNC <Ptr_OCRHMMDecoder cv.text.OCRHMMDecoder.create [ARG String filename=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI, ARG int classifier=OCR_KNN_CLASSIFIER]>
java: OCRHMMDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode, int classifier)
java: OCRHMMDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode)
java: OCRHMMDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table)
FUNC <String cv.text.OCRHMMDecoder.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, Mat mask, int min_confidence, int component_level)
java: String run(Mat image, Mat mask, int min_confidence)
FUNC <String cv.text.OCRHMMDecoder.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, int min_confidence, int component_level)
java: String run(Mat image, int min_confidence)
CLASS cv.text::.TextDetectorCNN : TextDetector
FUNC <Ptr_TextDetectorCNN cv.text.TextDetectorCNN.create [ARG String modelArchFilename=, ARG String modelWeightsFilename=]>
java: TextDetectorCNN create(String modelArchFilename, String modelWeightsFilename)
FUNC <void cv.text.TextDetectorCNN.detect [ARG Mat inputImage=, ARG vector_Rect Bbox=, ARG vector_float confidence=]>
java: void detect(Mat inputImage, MatOfRect Bbox, MatOfFloat confidence)

=== MODULE: video (/home/borg/404/scripts_robotica/OpenCV/modules/video) ===


Files (4):
[u'/home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video/video.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video/background_segm.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video/tracking.hpp']

Common headers (0):
[]
ok: class CLASS ::.Video : , name: Video, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video/video.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video/video.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video/background_segm.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[u'class cv.BackgroundSubtractor', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.BackgroundSubtractor : Algorithm, name: BackgroundSubtractor, base: Algorithm

--- Incoming ---
[   u'cv.BackgroundSubtractor.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.BackgroundSubtractor.getBackgroundImage',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'backgroundImage', '', ['/O']]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[   u'class cv.BackgroundSubtractorMOG2',
    u': cv::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor, name: BackgroundSubtractorMOG2, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getHistory',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setHistory',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'history', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getNMixtures',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setNMixtures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nmixtures', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getBackgroundRatio',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setBackgroundRatio',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'ratio', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarThresholdGen',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarThresholdGen',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varThresholdGen', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarInit',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarInit',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varInit', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarMin',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarMin',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varMin', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarMax',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarMax',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varMax', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'ct', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getDetectShadows',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setDetectShadows',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'detectShadows', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getShadowValue',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setShadowValue',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getShadowThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setShadowThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.createBackgroundSubtractorMOG2',
    u'Ptr_BackgroundSubtractorMOG2',
    [],
    [   [u'int', u'history', u'500', []],
        [u'double', u'varThreshold', u'16', []],
        [u'bool', u'detectShadows', u'true', []]],
    u'Ptr<BackgroundSubtractorMOG2>']
ok: FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>

--- Incoming ---
[   u'class cv.BackgroundSubtractorKNN',
    u': cv::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor, name: BackgroundSubtractorKNN, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getHistory',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getHistory []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setHistory',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'history', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getNSamples',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setNSamples',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_nN', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getDist2Threshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setDist2Threshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_dist2Threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getkNNSamples',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setkNNSamples',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_nkNN', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getDetectShadows',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setDetectShadows',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'detectShadows', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getShadowValue',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setShadowValue',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getShadowThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setShadowThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   u'cv.createBackgroundSubtractorKNN',
    u'Ptr_BackgroundSubtractorKNN',
    [],
    [   [u'int', u'history', u'500', []],
        [u'double', u'dist2Threshold', u'400.0', []],
        [u'bool', u'detectShadows', u'true', []]],
    u'Ptr<BackgroundSubtractorKNN>']
ok: FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/modules/video/include/opencv2/video/tracking.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.OPTFLOW_USE_INITIAL_FLOW', u'4', [], [], None, ''],
        [u'const cv.OPTFLOW_LK_GET_MIN_EIGENVALS', u'8', [], [], None, ''],
        [u'const cv.OPTFLOW_FARNEBACK_GAUSSIAN', u'256', [], [], None, '']],
    None]
ok: CONST OPTFLOW_USE_INITIAL_FLOW=4
ok: CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8
ok: CONST OPTFLOW_FARNEBACK_GAUSSIAN=256

--- Incoming ---
[   u'cv.CamShift',
    u'RotatedRect',
    [],
    [   ['Mat', u'probImage', '', []],
        [u'Rect', u'window', u'', ['/IO', '/Ref']],
        [u'TermCriteria', u'criteria', u'', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.meanShift',
    u'int',
    [],
    [   ['Mat', u'probImage', '', []],
        [u'Rect', u'window', u'', ['/IO', '/Ref']],
        [u'TermCriteria', u'criteria', u'', []]],
    u'int']
ok: FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.buildOpticalFlowPyramid',
    u'int',
    [],
    [   ['Mat', u'img', '', []],
        ['vector_Mat', u'pyramid', '', ['/O']],
        [u'Size', u'winSize', u'', []],
        [u'int', u'maxLevel', u'', []],
        [u'bool', u'withDerivatives', u'true', []],
        [u'int', u'pyrBorder', u'BORDER_REFLECT_101', []],
        [u'int', u'derivBorder', u'BORDER_CONSTANT', []],
        [u'bool', u'tryReuseInputImage', u'true', []]],
    u'int']
ok: FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>

--- Incoming ---
[   u'cv.calcOpticalFlowPyrLK',
    u'void',
    [],
    [   ['Mat', u'prevImg', '', []],
        ['Mat', u'nextImg', '', []],
        ['Mat', u'prevPts', '', []],
        ['Mat', u'nextPts', '', ['/IO']],
        ['Mat', u'status', '', ['/O']],
        ['Mat', u'err', '', ['/O']],
        [u'Size', u'winSize', u'Size(21,21)', []],
        [u'int', u'maxLevel', u'3', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        [u'int', u'flags', u'0', []],
        [u'double', u'minEigThreshold', u'1e-4', []]],
    u'void']
ok: FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>

--- Incoming ---
[   u'cv.calcOpticalFlowFarneback',
    u'void',
    [],
    [   ['Mat', u'prev', '', []],
        ['Mat', u'next', '', []],
        ['Mat', u'flow', '', ['/IO']],
        [u'double', u'pyr_scale', u'', []],
        [u'int', u'levels', u'', []],
        [u'int', u'winsize', u'', []],
        [u'int', u'iterations', u'', []],
        [u'int', u'poly_n', u'', []],
        [u'double', u'poly_sigma', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.MOTION_TRANSLATION', u'0', [], [], None, ''],
        [u'const cv.MOTION_EUCLIDEAN', u'1', [], [], None, ''],
        [u'const cv.MOTION_AFFINE', u'2', [], [], None, ''],
        [u'const cv.MOTION_HOMOGRAPHY', u'3', [], [], None, '']],
    None]
ok: CONST MOTION_TRANSLATION=0
ok: CONST MOTION_EUCLIDEAN=1
ok: CONST MOTION_AFFINE=2
ok: CONST MOTION_HOMOGRAPHY=3

--- Incoming ---
[   u'cv.computeECC',
    u'double',
    [],
    [   ['Mat', u'templateImage', '', []],
        ['Mat', u'inputImage', '', []],
        ['Mat', u'inputMask', u'Mat()', []]],
    u'double']
ok: FUNC <double cv..computeECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat inputMask=Mat()]>

--- Incoming ---
[   u'cv.findTransformECC',
    u'double',
    [],
    [   ['Mat', u'templateImage', '', []],
        ['Mat', u'inputImage', '', []],
        ['Mat', u'warpMatrix', '', ['/IO']],
        [u'int', u'motionType', u'', []],
        [u'TermCriteria', u'criteria', u'', []],
        ['Mat', u'inputMask', '', []],
        [u'int', u'gaussFiltSize', u'', []]],
    u'double']
ok: FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=, ARG TermCriteria criteria=, ARG Mat inputMask=, ARG int gaussFiltSize=]>

--- Incoming ---
[   u'class cv.KalmanFilter',
    '',
    [],
    [   [u'Mat', u'statePre', '', ['/RW']],
        [u'Mat', u'statePost', '', ['/RW']],
        [u'Mat', u'transitionMatrix', '', ['/RW']],
        [u'Mat', u'controlMatrix', '', ['/RW']],
        [u'Mat', u'measurementMatrix', '', ['/RW']],
        [u'Mat', u'processNoiseCov', '', ['/RW']],
        [u'Mat', u'measurementNoiseCov', '', ['/RW']],
        [u'Mat', u'errorCovPre', '', ['/RW']],
        [u'Mat', u'gain', '', ['/RW']],
        [u'Mat', u'errorCovPost', '', ['/RW']]],
    None]
ok: class CLASS cv::.KalmanFilter : , name: KalmanFilter, base: 

--- Incoming ---
[u'cv.KalmanFilter.KalmanFilter', '', [], [], None]
ok: FUNC < cv.KalmanFilter.KalmanFilter []>

--- Incoming ---
[   u'cv.KalmanFilter.KalmanFilter',
    '',
    [],
    [   [u'int', u'dynamParams', u'', []],
        [u'int', u'measureParams', u'', []],
        [u'int', u'controlParams', u'0', []],
        [u'int', u'type', u'CV_32F', []]],
    None]
ok: FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>

--- Incoming ---
[   u'cv.KalmanFilter.predict',
    u'Mat',
    [],
    [[u'Mat', u'control', u'Mat()', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>

--- Incoming ---
[   u'cv.KalmanFilter.correct',
    u'Mat',
    [],
    [[u'Mat', u'measurement', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>

--- Incoming ---
[   u'cv.readOpticalFlow',
    u'Mat',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv..readOpticalFlow [ARG String path=]>

--- Incoming ---
[   u'cv.writeOpticalFlow',
    u'bool',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']], ['Mat', u'flow', '', []]],
    u'bool']
ok: FUNC <bool cv..writeOpticalFlow [ARG String path=, ARG Mat flow=]>

--- Incoming ---
[u'class cv.DenseOpticalFlow', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.DenseOpticalFlow : Algorithm, name: DenseOpticalFlow, base: Algorithm

--- Incoming ---
[   u'cv.DenseOpticalFlow.calc',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'I0', '', []],
        ['Mat', u'I1', '', []],
        ['Mat', u'flow', '', ['/IO']]],
    u'void']
ok: FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>

--- Incoming ---
[u'cv.DenseOpticalFlow.collectGarbage', u'void', ['/V', '/PV'], [], u'void']
ok: FUNC <void cv.DenseOpticalFlow.collectGarbage []>

--- Incoming ---
[u'class cv.SparseOpticalFlow', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.SparseOpticalFlow : Algorithm, name: SparseOpticalFlow, base: Algorithm

--- Incoming ---
[   u'cv.SparseOpticalFlow.calc',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'prevImg', '', []],
        ['Mat', u'nextImg', '', []],
        ['Mat', u'prevPts', '', []],
        ['Mat', u'nextPts', '', ['/IO']],
        ['Mat', u'status', '', ['/O']],
        ['Mat', u'err', u'cv::Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>

--- Incoming ---
[u'class cv.FarnebackOpticalFlow', u': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow, name: FarnebackOpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getNumLevels',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setNumLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'numLevels', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getPyrScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPyrScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'pyrScale', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getFastPyramids',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setFastPyramids',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'fastPyramids', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getWinSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getWinSize []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setWinSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'winSize', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getNumIters',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumIters []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setNumIters',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'numIters', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getPolyN', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getPolyN []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPolyN',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'polyN', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getPolySigma',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPolySigma',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'polySigma', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getFlags', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getFlags []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setFlags',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.create',
    u'Ptr_FarnebackOpticalFlow',
    ['/S'],
    [   [u'int', u'numLevels', u'5', []],
        [u'double', u'pyrScale', u'0.5', []],
        [u'bool', u'fastPyramids', u'false', []],
        [u'int', u'winSize', u'13', []],
        [u'int', u'numIters', u'10', []],
        [u'int', u'polyN', u'5', []],
        [u'double', u'polySigma', u'1.1', []],
        [u'int', u'flags', u'0', []]],
    u'Ptr<FarnebackOpticalFlow>']
ok: FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>

--- Incoming ---
[u'class cv.VariationalRefinement', u': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.VariationalRefinement : DenseOpticalFlow, name: VariationalRefinement, base: DenseOpticalFlow

--- Incoming ---
[   u'cv.VariationalRefinement.calcUV',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'I0', '', []],
        ['Mat', u'I1', '', []],
        ['Mat', u'flow_u', '', ['/IO']],
        ['Mat', u'flow_v', '', ['/IO']]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.calcUV [ARG Mat I0=, ARG Mat I1=, ARG Mat flow_u=, ARG Mat flow_v=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getFixedPointIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.VariationalRefinement.getFixedPointIterations []>

--- Incoming ---
[   u'cv.VariationalRefinement.setFixedPointIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setFixedPointIterations [ARG int val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getSorIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.VariationalRefinement.getSorIterations []>

--- Incoming ---
[   u'cv.VariationalRefinement.setSorIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setSorIterations [ARG int val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getOmega',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.VariationalRefinement.getOmega []>

--- Incoming ---
[   u'cv.VariationalRefinement.setOmega',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setOmega [ARG float val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getAlpha',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.VariationalRefinement.getAlpha []>

--- Incoming ---
[   u'cv.VariationalRefinement.setAlpha',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setAlpha [ARG float val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getDelta',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.VariationalRefinement.getDelta []>

--- Incoming ---
[   u'cv.VariationalRefinement.setDelta',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setDelta [ARG float val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getGamma',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.VariationalRefinement.getGamma []>

--- Incoming ---
[   u'cv.VariationalRefinement.setGamma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setGamma [ARG float val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.create',
    u'Ptr_VariationalRefinement',
    ['/S'],
    [],
    u'Ptr<VariationalRefinement>']
ok: FUNC <Ptr_VariationalRefinement cv.VariationalRefinement.create []>

--- Incoming ---
[u'class cv.DISOpticalFlow', u': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.DISOpticalFlow : DenseOpticalFlow, name: DISOpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[   u'enum cv.DISOpticalFlow.<unnamed>',
    '',
    [],
    [   [u'const cv.DISOpticalFlow.PRESET_ULTRAFAST', u'0', [], [], None, ''],
        [u'const cv.DISOpticalFlow.PRESET_FAST', u'1', [], [], None, ''],
        [u'const cv.DISOpticalFlow.PRESET_MEDIUM', u'2', [], [], None, '']],
    None]
ok: CONST PRESET_ULTRAFAST=0
ok: CONST PRESET_FAST=1
ok: CONST PRESET_MEDIUM=2

--- Incoming ---
[u'cv.DISOpticalFlow.getFinestScale', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.DISOpticalFlow.getFinestScale []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setFinestScale',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setFinestScale [ARG int val=]>

--- Incoming ---
[u'cv.DISOpticalFlow.getPatchSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.DISOpticalFlow.getPatchSize []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setPatchSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setPatchSize [ARG int val=]>

--- Incoming ---
[u'cv.DISOpticalFlow.getPatchStride', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.DISOpticalFlow.getPatchStride []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setPatchStride',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setPatchStride [ARG int val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getGradientDescentIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.DISOpticalFlow.getGradientDescentIterations []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setGradientDescentIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setGradientDescentIterations [ARG int val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getVariationalRefinementIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.DISOpticalFlow.getVariationalRefinementIterations []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setVariationalRefinementIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementIterations [ARG int val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getVariationalRefinementAlpha',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementAlpha []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setVariationalRefinementAlpha',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementAlpha [ARG float val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getVariationalRefinementDelta',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementDelta []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setVariationalRefinementDelta',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementDelta [ARG float val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getVariationalRefinementGamma',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementGamma []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setVariationalRefinementGamma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementGamma [ARG float val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getUseMeanNormalization',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.DISOpticalFlow.getUseMeanNormalization []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setUseMeanNormalization',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setUseMeanNormalization [ARG bool val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getUseSpatialPropagation',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.DISOpticalFlow.getUseSpatialPropagation []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setUseSpatialPropagation',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setUseSpatialPropagation [ARG bool val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.create',
    u'Ptr_DISOpticalFlow',
    ['/S'],
    [[u'int', u'preset', u'DISOpticalFlow::PRESET_FAST', []]],
    u'Ptr<DISOpticalFlow>']
ok: FUNC <Ptr_DISOpticalFlow cv.DISOpticalFlow.create [ARG int preset=DISOpticalFlow::PRESET_FAST]>

--- Incoming ---
[u'class cv.SparsePyrLKOpticalFlow', u': cv::SparseOpticalFlow', [], [], None]
ok: class CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow, name: SparsePyrLKOpticalFlow, base: SparseOpticalFlow

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getWinSize',
    u'Size',
    ['/C', '/V', '/PV'],
    [],
    u'Size']
ok: FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setWinSize',
    u'void',
    ['/V', '/PV'],
    [[u'Size', u'winSize', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getMaxLevel',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setMaxLevel',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxLevel', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'crit', u'', ['/Ref']]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getFlags',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setFlags',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getMinEigThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setMinEigThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minEigThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.create',
    u'Ptr_SparsePyrLKOpticalFlow',
    ['/S'],
    [   [u'Size', u'winSize', u'Size(21, 21)', []],
        [u'int', u'maxLevel', u'3', []],
        [   u'TermCriteria',
            u'crit',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        [u'int', u'flags', u'0', []],
        [u'double', u'minEigThreshold', u'1e-4', []]],
    u'Ptr<SparsePyrLKOpticalFlow>']
ok: FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>


===== Generating... =====
CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow
FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit, int flags, double minEigThreshold)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit, int flags)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel)
java: SparsePyrLKOpticalFlow create(Size winSize)
java: SparsePyrLKOpticalFlow create()
FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>
java: Size getWinSize()
FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>
java: double getMinEigThreshold()
FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>
java: int getFlags()
FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>
java: int getMaxLevel()
FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>
java: void setMaxLevel(int maxLevel)
FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>
java: void setMinEigThreshold(double minEigThreshold)
FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>
java: void setTermCriteria(TermCriteria crit)
FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>
java: void setWinSize(Size winSize)
CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow
FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN, double polySigma, int flags)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN, double polySigma)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale)
java: FarnebackOpticalFlow create(int numLevels)
java: FarnebackOpticalFlow create()
FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>
java: boolean getFastPyramids()
FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>
java: double getPolySigma()
FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>
java: double getPyrScale()
FUNC <int cv.FarnebackOpticalFlow.getFlags []>
java: int getFlags()
FUNC <int cv.FarnebackOpticalFlow.getNumIters []>
java: int getNumIters()
FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>
java: int getNumLevels()
FUNC <int cv.FarnebackOpticalFlow.getPolyN []>
java: int getPolyN()
FUNC <int cv.FarnebackOpticalFlow.getWinSize []>
java: int getWinSize()
FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>
java: void setFastPyramids(boolean fastPyramids)
FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>
java: void setNumIters(int numIters)
FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>
java: void setNumLevels(int numLevels)
FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>
java: void setPolyN(int polyN)
FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>
java: void setPolySigma(double polySigma)
FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>
java: void setPyrScale(double pyrScale)
FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>
java: void setWinSize(int winSize)
CLASS cv::.SparseOpticalFlow : Algorithm
FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status, Mat err)
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status)
CLASS cv::.DenseOpticalFlow : Algorithm
FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>
java: void calc(Mat I0, Mat I1, Mat flow)
FUNC <void cv.DenseOpticalFlow.collectGarbage []>
java: void collectGarbage()
CLASS cv::.BackgroundSubtractor : Algorithm
FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS ::.Video : 
[CONST CV_LKFLOW_INITIAL_GUESSES=4(manual), CONST CV_LKFLOW_GET_MIN_EIGENVALS=8(manual)]
[CONST OPTFLOW_USE_INITIAL_FLOW=4, CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8, CONST OPTFLOW_FARNEBACK_GAUSSIAN=256, CONST MOTION_TRANSLATION=0, CONST MOTION_EUCLIDEAN=1, CONST MOTION_AFFINE=2, CONST MOTION_HOMOGRAPHY=3]
FUNC <Mat cv..readOpticalFlow [ARG String path=]>
java: Mat readOpticalFlow(String path)
FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history, double dist2Threshold, boolean detectShadows)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history, double dist2Threshold)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN()
FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history, double varThreshold, boolean detectShadows)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history, double varThreshold)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2()
FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: RotatedRect CamShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <bool cv..writeOpticalFlow [ARG String path=, ARG Mat flow=]>
java: boolean writeOpticalFlow(String path, Mat flow)
FUNC <double cv..computeECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat inputMask=Mat()]>
java: double computeECC(Mat templateImage, Mat inputImage, Mat inputMask)
java: double computeECC(Mat templateImage, Mat inputImage)
FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=, ARG TermCriteria criteria=, ARG Mat inputMask=, ARG int gaussFiltSize=]>
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType, TermCriteria criteria, Mat inputMask, int gaussFiltSize)
FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder, int derivBorder, boolean tryReuseInputImage)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder, int derivBorder)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel)
FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: int meanShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>
java: void calcOpticalFlowFarneback(Mat prev, Mat next, Mat flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)
FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria, int flags)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err)
CLASS cv::.DISOpticalFlow : DenseOpticalFlow
[CONST PRESET_ULTRAFAST=0, CONST PRESET_FAST=1, CONST PRESET_MEDIUM=2]
FUNC <Ptr_DISOpticalFlow cv.DISOpticalFlow.create [ARG int preset=DISOpticalFlow::PRESET_FAST]>
java: DISOpticalFlow create(int preset)
java: DISOpticalFlow create()
FUNC <bool cv.DISOpticalFlow.getUseMeanNormalization []>
java: boolean getUseMeanNormalization()
FUNC <bool cv.DISOpticalFlow.getUseSpatialPropagation []>
java: boolean getUseSpatialPropagation()
FUNC <float cv.DISOpticalFlow.getVariationalRefinementAlpha []>
java: float getVariationalRefinementAlpha()
FUNC <float cv.DISOpticalFlow.getVariationalRefinementDelta []>
java: float getVariationalRefinementDelta()
FUNC <float cv.DISOpticalFlow.getVariationalRefinementGamma []>
java: float getVariationalRefinementGamma()
FUNC <int cv.DISOpticalFlow.getFinestScale []>
java: int getFinestScale()
FUNC <int cv.DISOpticalFlow.getGradientDescentIterations []>
java: int getGradientDescentIterations()
FUNC <int cv.DISOpticalFlow.getPatchSize []>
java: int getPatchSize()
FUNC <int cv.DISOpticalFlow.getPatchStride []>
java: int getPatchStride()
FUNC <int cv.DISOpticalFlow.getVariationalRefinementIterations []>
java: int getVariationalRefinementIterations()
FUNC <void cv.DISOpticalFlow.setFinestScale [ARG int val=]>
java: void setFinestScale(int val)
FUNC <void cv.DISOpticalFlow.setGradientDescentIterations [ARG int val=]>
java: void setGradientDescentIterations(int val)
FUNC <void cv.DISOpticalFlow.setPatchSize [ARG int val=]>
java: void setPatchSize(int val)
FUNC <void cv.DISOpticalFlow.setPatchStride [ARG int val=]>
java: void setPatchStride(int val)
FUNC <void cv.DISOpticalFlow.setUseMeanNormalization [ARG bool val=]>
java: void setUseMeanNormalization(boolean val)
FUNC <void cv.DISOpticalFlow.setUseSpatialPropagation [ARG bool val=]>
java: void setUseSpatialPropagation(boolean val)
FUNC <void cv.DISOpticalFlow.setVariationalRefinementAlpha [ARG float val=]>
java: void setVariationalRefinementAlpha(float val)
FUNC <void cv.DISOpticalFlow.setVariationalRefinementDelta [ARG float val=]>
java: void setVariationalRefinementDelta(float val)
FUNC <void cv.DISOpticalFlow.setVariationalRefinementGamma [ARG float val=]>
java: void setVariationalRefinementGamma(float val)
FUNC <void cv.DISOpticalFlow.setVariationalRefinementIterations [ARG int val=]>
java: void setVariationalRefinementIterations(int val)
CLASS cv::.KalmanFilter : 
FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>
java:  KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)
java:  KalmanFilter(int dynamParams, int measureParams, int controlParams)
java:  KalmanFilter(int dynamParams, int measureParams)
FUNC < cv.KalmanFilter.KalmanFilter []>
java:  KalmanFilter()
FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>
java: Mat correct(Mat measurement)
FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>
java: Mat predict(Mat control)
java: Mat predict()
FUNC <Mat cv.KalmanFilter.get_statePre []>
java: Mat get_statePre()
FUNC <void cv.KalmanFilter.set_statePre [ARG Mat statePre=]>
java: void set_statePre(Mat statePre)
FUNC <Mat cv.KalmanFilter.get_statePost []>
java: Mat get_statePost()
FUNC <void cv.KalmanFilter.set_statePost [ARG Mat statePost=]>
java: void set_statePost(Mat statePost)
FUNC <Mat cv.KalmanFilter.get_transitionMatrix []>
java: Mat get_transitionMatrix()
FUNC <void cv.KalmanFilter.set_transitionMatrix [ARG Mat transitionMatrix=]>
java: void set_transitionMatrix(Mat transitionMatrix)
FUNC <Mat cv.KalmanFilter.get_controlMatrix []>
java: Mat get_controlMatrix()
FUNC <void cv.KalmanFilter.set_controlMatrix [ARG Mat controlMatrix=]>
java: void set_controlMatrix(Mat controlMatrix)
FUNC <Mat cv.KalmanFilter.get_measurementMatrix []>
java: Mat get_measurementMatrix()
FUNC <void cv.KalmanFilter.set_measurementMatrix [ARG Mat measurementMatrix=]>
java: void set_measurementMatrix(Mat measurementMatrix)
FUNC <Mat cv.KalmanFilter.get_processNoiseCov []>
java: Mat get_processNoiseCov()
FUNC <void cv.KalmanFilter.set_processNoiseCov [ARG Mat processNoiseCov=]>
java: void set_processNoiseCov(Mat processNoiseCov)
FUNC <Mat cv.KalmanFilter.get_measurementNoiseCov []>
java: Mat get_measurementNoiseCov()
FUNC <void cv.KalmanFilter.set_measurementNoiseCov [ARG Mat measurementNoiseCov=]>
java: void set_measurementNoiseCov(Mat measurementNoiseCov)
FUNC <Mat cv.KalmanFilter.get_errorCovPre []>
java: Mat get_errorCovPre()
FUNC <void cv.KalmanFilter.set_errorCovPre [ARG Mat errorCovPre=]>
java: void set_errorCovPre(Mat errorCovPre)
FUNC <Mat cv.KalmanFilter.get_gain []>
java: Mat get_gain()
FUNC <void cv.KalmanFilter.set_gain [ARG Mat gain=]>
java: void set_gain(Mat gain)
FUNC <Mat cv.KalmanFilter.get_errorCovPost []>
java: Mat get_errorCovPost()
FUNC <void cv.KalmanFilter.set_errorCovPost [ARG Mat errorCovPost=]>
java: void set_errorCovPost(Mat errorCovPost)
CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor
FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>
java: double getBackgroundRatio()
FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>
java: double getComplexityReductionThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>
java: double getVarInit()
FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>
java: double getVarMax()
FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>
java: double getVarMin()
FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>
java: double getVarThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>
java: double getVarThresholdGen()
FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>
java: int getHistory()
FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>
java: int getNMixtures()
FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>
java: int getShadowValue()
FUNC <void cv.BackgroundSubtractorMOG2.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>
java: void setBackgroundRatio(double ratio)
FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>
java: void setComplexityReductionThreshold(double ct)
FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>
java: void setNMixtures(int nmixtures)
FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>
java: void setVarInit(double varInit)
FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>
java: void setVarMax(double varMax)
FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>
java: void setVarMin(double varMin)
FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>
java: void setVarThreshold(double varThreshold)
FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>
java: void setVarThresholdGen(double varThresholdGen)
CLASS cv::.VariationalRefinement : DenseOpticalFlow
FUNC <Ptr_VariationalRefinement cv.VariationalRefinement.create []>
java: VariationalRefinement create()
FUNC <float cv.VariationalRefinement.getAlpha []>
java: float getAlpha()
FUNC <float cv.VariationalRefinement.getDelta []>
java: float getDelta()
FUNC <float cv.VariationalRefinement.getGamma []>
java: float getGamma()
FUNC <float cv.VariationalRefinement.getOmega []>
java: float getOmega()
FUNC <int cv.VariationalRefinement.getFixedPointIterations []>
java: int getFixedPointIterations()
FUNC <int cv.VariationalRefinement.getSorIterations []>
java: int getSorIterations()
FUNC <void cv.VariationalRefinement.calcUV [ARG Mat I0=, ARG Mat I1=, ARG Mat flow_u=, ARG Mat flow_v=]>
java: void calcUV(Mat I0, Mat I1, Mat flow_u, Mat flow_v)
FUNC <void cv.VariationalRefinement.setAlpha [ARG float val=]>
java: void setAlpha(float val)
FUNC <void cv.VariationalRefinement.setDelta [ARG float val=]>
java: void setDelta(float val)
FUNC <void cv.VariationalRefinement.setFixedPointIterations [ARG int val=]>
java: void setFixedPointIterations(int val)
FUNC <void cv.VariationalRefinement.setGamma [ARG float val=]>
java: void setGamma(float val)
FUNC <void cv.VariationalRefinement.setOmega [ARG float val=]>
java: void setOmega(float val)
FUNC <void cv.VariationalRefinement.setSorIterations [ARG int val=]>
java: void setSorIterations(int val)
CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor
FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>
java: double getDist2Threshold()
FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <int cv.BackgroundSubtractorKNN.getHistory []>
java: int getHistory()
FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>
java: int getNSamples()
FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>
java: int getShadowValue()
FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>
java: int getkNNSamples()
FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>
java: void setDist2Threshold(double _dist2Threshold)
FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>
java: void setNSamples(int _nN)
FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>
java: void setkNNSamples(int _nkNN)

=== MODULE: xfeatures2d (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xfeatures2d) ===


Files (3):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d/cuda.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d/nonfree.hpp']

Common headers (0):
[]
ok: class CLASS ::.Xfeatures2d : , name: Xfeatures2d, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d.hpp =====
Namespaces: set([u'cv.xfeatures2d', u'cv'])

--- Incoming ---
[u'class cv.xfeatures2d.FREAK', u': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.FREAK : Feature2D, name: FREAK, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.FREAK.create',
    u'Ptr_FREAK',
    ['/S'],
    [   [u'bool', u'orientationNormalized', u'true', []],
        [u'bool', u'scaleNormalized', u'true', []],
        [u'float', u'patternScale', u'22.0f', []],
        [u'int', u'nOctaves', u'4', []],
        [   u'vector_int',
            u'selectedPairs',
            u'std::vector<int>()',
            ['/C', '/Ref']]],
    u'Ptr<FREAK>']
ok: FUNC <Ptr_FREAK cv.xfeatures2d.FREAK.create [ARG bool orientationNormalized=true, ARG bool scaleNormalized=true, ARG float patternScale=22.0f, ARG int nOctaves=4, ARG vector_int selectedPairs=std::vector<int>()]>

--- Incoming ---
[   u'class cv.xfeatures2d.StarDetector',
    u': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.StarDetector : Feature2D, name: StarDetector, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.StarDetector.create',
    u'Ptr_StarDetector',
    ['/S'],
    [   [u'int', u'maxSize', u'45', []],
        [u'int', u'responseThreshold', u'30', []],
        [u'int', u'lineThresholdProjected', u'10', []],
        [u'int', u'lineThresholdBinarized', u'8', []],
        [u'int', u'suppressNonmaxSize', u'5', []]],
    u'Ptr<StarDetector>']
ok: FUNC <Ptr_StarDetector cv.xfeatures2d.StarDetector.create [ARG int maxSize=45, ARG int responseThreshold=30, ARG int lineThresholdProjected=10, ARG int lineThresholdBinarized=8, ARG int suppressNonmaxSize=5]>

--- Incoming ---
[   u'class cv.xfeatures2d.BriefDescriptorExtractor',
    u': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.BriefDescriptorExtractor : Feature2D, name: BriefDescriptorExtractor, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.BriefDescriptorExtractor.create',
    u'Ptr_BriefDescriptorExtractor',
    ['/S'],
    [   [u'int', u'bytes', u'32', []],
        [u'bool', u'use_orientation', u'false', []]],
    u'Ptr<BriefDescriptorExtractor>']
ok: FUNC <Ptr_BriefDescriptorExtractor cv.xfeatures2d.BriefDescriptorExtractor.create [ARG int bytes=32, ARG bool use_orientation=false]>

--- Incoming ---
[u'class cv.xfeatures2d.LUCID', u': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.LUCID : Feature2D, name: LUCID, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.LUCID.create',
    u'Ptr_LUCID',
    ['/S'],
    [   [u'int', u'lucid_kernel', u'1', ['/C']],
        [u'int', u'blur_kernel', u'2', ['/C']]],
    u'Ptr<LUCID>']
ok: FUNC <Ptr_LUCID cv.xfeatures2d.LUCID.create [ARG int lucid_kernel=1, ARG int blur_kernel=2]>

--- Incoming ---
[u'class cv.xfeatures2d.LATCH', u': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.LATCH : Feature2D, name: LATCH, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.LATCH.create',
    u'Ptr_LATCH',
    ['/S'],
    [   [u'int', u'bytes', u'32', []],
        [u'bool', u'rotationInvariance', u'true', []],
        [u'int', u'half_ssd_size', u'3', []],
        [u'double', u'sigma', u'2.0', []]],
    u'Ptr<LATCH>']
ok: FUNC <Ptr_LATCH cv.xfeatures2d.LATCH.create [ARG int bytes=32, ARG bool rotationInvariance=true, ARG int half_ssd_size=3, ARG double sigma=2.0]>

--- Incoming ---
[u'class cv.xfeatures2d.DAISY', u': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.DAISY : Feature2D, name: DAISY, base: Feature2D

--- Incoming ---
[   u'enum cv.xfeatures2d.DAISY.NormalizationType',
    '',
    [],
    [   [u'const cv.xfeatures2d.DAISY.NRM_NONE', u'100', [], [], None, ''],
        [u'const cv.xfeatures2d.DAISY.NRM_PARTIAL', u'101', [], [], None, ''],
        [u'const cv.xfeatures2d.DAISY.NRM_FULL', u'102', [], [], None, ''],
        [u'const cv.xfeatures2d.DAISY.NRM_SIFT', u'103', [], [], None, '']],
    None]
ok: CONST NRM_NONE=100
ok: CONST NRM_PARTIAL=101
ok: CONST NRM_FULL=102
ok: CONST NRM_SIFT=103

--- Incoming ---
[   u'cv.xfeatures2d.DAISY.create',
    u'Ptr_DAISY',
    ['/S'],
    [   [u'float', u'radius', u'15', []],
        [u'int', u'q_radius', u'3', []],
        [u'int', u'q_theta', u'8', []],
        [u'int', u'q_hist', u'8', []],
        [u'DAISY_NormalizationType', u'norm', u'DAISY::NRM_NONE', []],
        ['Mat', u'H', u'Mat()', []],
        [u'bool', u'interpolation', u'true', []],
        [u'bool', u'use_orientation', u'false', []]],
    u'Ptr<DAISY>']
ok: FUNC <Ptr_DAISY cv.xfeatures2d.DAISY.create [ARG float radius=15, ARG int q_radius=3, ARG int q_theta=8, ARG int q_hist=8, ARG DAISY_NormalizationType norm=DAISY::NRM_NONE, ARG Mat H=Mat(), ARG bool interpolation=true, ARG bool use_orientation=false]>

--- Incoming ---
[   u'class cv.xfeatures2d.MSDDetector',
    u': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.MSDDetector : Feature2D, name: MSDDetector, base: Feature2D

--- Incoming ---
[u'class cv.xfeatures2d.VGG', u': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.VGG : Feature2D, name: VGG, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.VGG.create',
    u'Ptr_VGG',
    ['/S'],
    [   [u'int', u'desc', u'VGG::VGG_120', []],
        [u'float', u'isigma', u'1.4f', []],
        [u'bool', u'img_normalize', u'true', []],
        [u'bool', u'use_scale_orientation', u'true', []],
        [u'float', u'scale_factor', u'6.25f', []],
        [u'bool', u'dsc_normalize', u'false', []]],
    u'Ptr<VGG>']
ok: FUNC <Ptr_VGG cv.xfeatures2d.VGG.create [ARG int desc=VGG::VGG_120, ARG float isigma=1.4f, ARG bool img_normalize=true, ARG bool use_scale_orientation=true, ARG float scale_factor=6.25f, ARG bool dsc_normalize=false]>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.setSigma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'isigma', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.VGG.setSigma [ARG float isigma=]>

--- Incoming ---
[u'cv.xfeatures2d.VGG.getSigma', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.xfeatures2d.VGG.getSigma []>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.setUseNormalizeImage',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'img_normalize', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.VGG.setUseNormalizeImage [ARG bool img_normalize=]>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.getUseNormalizeImage',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.xfeatures2d.VGG.getUseNormalizeImage []>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.setUseScaleOrientation',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'use_scale_orientation', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.VGG.setUseScaleOrientation [ARG bool use_scale_orientation=]>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.getUseScaleOrientation',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.xfeatures2d.VGG.getUseScaleOrientation []>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.setScaleFactor',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'scale_factor', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.VGG.setScaleFactor [ARG float scale_factor=]>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.getScaleFactor',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.VGG.getScaleFactor []>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.setUseNormalizeDescriptor',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'dsc_normalize', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.VGG.setUseNormalizeDescriptor [ARG bool dsc_normalize=]>

--- Incoming ---
[   u'cv.xfeatures2d.VGG.getUseNormalizeDescriptor',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.xfeatures2d.VGG.getUseNormalizeDescriptor []>

--- Incoming ---
[   u'class cv.xfeatures2d.BoostDesc',
    u': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.BoostDesc : Feature2D, name: BoostDesc, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.BoostDesc.create',
    u'Ptr_BoostDesc',
    ['/S'],
    [   [u'int', u'desc', u'BoostDesc::BINBOOST_256', []],
        [u'bool', u'use_scale_orientation', u'true', []],
        [u'float', u'scale_factor', u'6.25f', []]],
    u'Ptr<BoostDesc>']
ok: FUNC <Ptr_BoostDesc cv.xfeatures2d.BoostDesc.create [ARG int desc=BoostDesc::BINBOOST_256, ARG bool use_scale_orientation=true, ARG float scale_factor=6.25f]>

--- Incoming ---
[   u'cv.xfeatures2d.BoostDesc.setUseScaleOrientation',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'use_scale_orientation', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.BoostDesc.setUseScaleOrientation [ARG bool use_scale_orientation=]>

--- Incoming ---
[   u'cv.xfeatures2d.BoostDesc.getUseScaleOrientation',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.xfeatures2d.BoostDesc.getUseScaleOrientation []>

--- Incoming ---
[   u'cv.xfeatures2d.BoostDesc.setScaleFactor',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'scale_factor', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.BoostDesc.setScaleFactor [ARG float scale_factor=]>

--- Incoming ---
[   u'cv.xfeatures2d.BoostDesc.getScaleFactor',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.BoostDesc.getScaleFactor []>

--- Incoming ---
[u'class cv.xfeatures2d.PCTSignatures', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.xfeatures2d::.PCTSignatures : Algorithm, name: PCTSignatures, base: Algorithm

--- Incoming ---
[   u'enum cv.xfeatures2d.PCTSignatures.DistanceFunction',
    '',
    [],
    [   [u'const cv.xfeatures2d.PCTSignatures.L0_25', '0', [], [], None, ''],
        [u'const cv.xfeatures2d.PCTSignatures.L0_5', '1', [], [], None, ''],
        [u'const cv.xfeatures2d.PCTSignatures.L1', '2', [], [], None, ''],
        [u'const cv.xfeatures2d.PCTSignatures.L2', '3', [], [], None, ''],
        [   u'const cv.xfeatures2d.PCTSignatures.L2SQUARED',
            '4',
            [],
            [],
            None,
            ''],
        [u'const cv.xfeatures2d.PCTSignatures.L5', '5', [], [], None, ''],
        [   u'const cv.xfeatures2d.PCTSignatures.L_INFINITY',
            '6',
            [],
            [],
            None,
            '']],
    None]
ok: CONST L0_25=0
ok: CONST L0_5=1
ok: CONST L1=2
ok: CONST L2=3
ok: CONST L2SQUARED=4
ok: CONST L5=5
ok: CONST L_INFINITY=6

--- Incoming ---
[   u'enum cv.xfeatures2d.PCTSignatures.PointDistribution',
    '',
    [],
    [   [   u'const cv.xfeatures2d.PCTSignatures.UNIFORM',
            '0',
            [],
            [],
            None,
            ''],
        [   u'const cv.xfeatures2d.PCTSignatures.REGULAR',
            '1',
            [],
            [],
            None,
            ''],
        [u'const cv.xfeatures2d.PCTSignatures.NORMAL', '2', [], [], None, '']],
    None]
ok: CONST UNIFORM=0
ok: CONST REGULAR=1
ok: CONST NORMAL=2

--- Incoming ---
[   u'enum cv.xfeatures2d.PCTSignatures.SimilarityFunction',
    '',
    [],
    [   [u'const cv.xfeatures2d.PCTSignatures.MINUS', '0', [], [], None, ''],
        [   u'const cv.xfeatures2d.PCTSignatures.GAUSSIAN',
            '1',
            [],
            [],
            None,
            ''],
        [   u'const cv.xfeatures2d.PCTSignatures.HEURISTIC',
            '2',
            [],
            [],
            None,
            '']],
    None]
ok: CONST MINUS=0
ok: CONST GAUSSIAN=1
ok: CONST HEURISTIC=2

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.create',
    u'Ptr_PCTSignatures',
    ['/S'],
    [   [u'int', u'initSampleCount', u'2000', ['/C']],
        [u'int', u'initSeedCount', u'400', ['/C']],
        [u'int', u'pointDistribution', u'0', ['/C']]],
    u'Ptr<PCTSignatures>']
ok: FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG int initSampleCount=2000, ARG int initSeedCount=400, ARG int pointDistribution=0]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.create',
    u'Ptr_PCTSignatures',
    ['/S'],
    [   [u'vector_Point2f', u'initSamplingPoints', u'', ['/C', '/Ref']],
        [u'int', u'initSeedCount', u'', ['/C']]],
    u'Ptr<PCTSignatures>']
ok: FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG vector_Point2f initSamplingPoints=, ARG int initSeedCount=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.create',
    u'Ptr_PCTSignatures',
    ['/S'],
    [   [u'vector_Point2f', u'initSamplingPoints', u'', ['/C', '/Ref']],
        [u'vector_int', u'initClusterSeedIndexes', u'', ['/C', '/Ref']]],
    u'Ptr<PCTSignatures>']
ok: FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG vector_Point2f initSamplingPoints=, ARG vector_int initClusterSeedIndexes=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.computeSignature',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'image', '', []], ['Mat', u'signature', '', ['/O']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.computeSignature [ARG Mat image=, ARG Mat signature=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.computeSignatures',
    u'void',
    ['/C', '/V', '/PV'],
    [   [u'vector_Mat', u'images', u'', ['/C', '/Ref']],
        [u'vector_Mat', u'signatures', u'', ['/Ref']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.computeSignatures [ARG vector_Mat images=, ARG vector_Mat signatures=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.drawSignature',
    u'void',
    ['/S'],
    [   ['Mat', u'source', '', []],
        ['Mat', u'signature', '', []],
        ['Mat', u'result', '', ['/O']],
        [u'float', u'radiusToShorterSideRatio', u'1.0 / 8', []],
        [u'int', u'borderThickness', u'1', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.drawSignature [ARG Mat source=, ARG Mat signature=, ARG Mat result=, ARG float radiusToShorterSideRatio=1.0 / 8, ARG int borderThickness=1]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.generateInitPoints',
    u'void',
    ['/S'],
    [   [u'vector_Point2f', u'initPoints', u'', ['/Ref']],
        [u'int', u'count', u'', ['/C']],
        [u'int', u'pointDistribution', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.generateInitPoints [ARG vector_Point2f initPoints=, ARG int count=, ARG int pointDistribution=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getSampleCount',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getSampleCount []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getGrayscaleBits',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getGrayscaleBits []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setGrayscaleBits',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'grayscaleBits', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setGrayscaleBits [ARG int grayscaleBits=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getWindowRadius',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getWindowRadius []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWindowRadius',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'radius', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWindowRadius [ARG int radius=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getWeightX',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightX []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeightX',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'weight', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightX [ARG float weight=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getWeightY',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightY []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeightY',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'weight', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightY [ARG float weight=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getWeightL',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightL []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeightL',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'weight', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightL [ARG float weight=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getWeightA',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightA []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeightA',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'weight', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightA [ARG float weight=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getWeightB',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightB []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeightB',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'weight', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightB [ARG float weight=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getWeightContrast',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightContrast []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeightContrast',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'weight', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightContrast [ARG float weight=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getWeightEntropy',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightEntropy []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeightEntropy',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'weight', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightEntropy [ARG float weight=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getSamplingPoints',
    u'vector_Point2f',
    ['/C', '/V', '/PV'],
    [],
    u'std::vector<Point2f>']
ok: FUNC <vector_Point2f cv.xfeatures2d.PCTSignatures.getSamplingPoints []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeight',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'idx', u'', []], [u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeight [ARG int idx=, ARG float value=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setWeights',
    u'void',
    ['/V', '/PV'],
    [[u'vector_float', u'weights', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeights [ARG vector_float weights=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setTranslation',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'idx', u'', []], [u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setTranslation [ARG int idx=, ARG float value=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setTranslations',
    u'void',
    ['/V', '/PV'],
    [[u'vector_float', u'translations', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setTranslations [ARG vector_float translations=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setSamplingPoints',
    u'void',
    ['/V', '/PV'],
    [[u'vector_Point2f', u'samplingPoints', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setSamplingPoints [ARG vector_Point2f samplingPoints=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getInitSeedIndexes',
    u'vector_int',
    ['/C', '/V', '/PV'],
    [],
    u'std::vector<int>']
ok: FUNC <vector_int cv.xfeatures2d.PCTSignatures.getInitSeedIndexes []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setInitSeedIndexes',
    u'void',
    ['/V', '/PV'],
    [[u'vector_int', u'initSeedIndexes', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setInitSeedIndexes [ARG vector_int initSeedIndexes=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getInitSeedCount',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getInitSeedCount []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getIterationCount',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getIterationCount []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setIterationCount',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'iterationCount', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setIterationCount [ARG int iterationCount=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getMaxClustersCount',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getMaxClustersCount []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setMaxClustersCount',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxClustersCount', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setMaxClustersCount [ARG int maxClustersCount=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getClusterMinSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getClusterMinSize []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setClusterMinSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'clusterMinSize', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setClusterMinSize [ARG int clusterMinSize=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getJoiningDistance',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getJoiningDistance []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setJoiningDistance',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'joiningDistance', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setJoiningDistance [ARG float joiningDistance=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getDropThreshold',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getDropThreshold []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setDropThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'dropThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setDropThreshold [ARG float dropThreshold=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.getDistanceFunction',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getDistanceFunction []>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignatures.setDistanceFunction',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'distanceFunction', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setDistanceFunction [ARG int distanceFunction=]>

--- Incoming ---
[u'class cv.xfeatures2d.PCTSignaturesSQFD', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.xfeatures2d::.PCTSignaturesSQFD : Algorithm, name: PCTSignaturesSQFD, base: Algorithm

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignaturesSQFD.create',
    u'Ptr_PCTSignaturesSQFD',
    ['/S'],
    [   [u'int', u'distanceFunction', u'3', ['/C']],
        [u'int', u'similarityFunction', u'2', ['/C']],
        [u'float', u'similarityParameter', u'1.0f', ['/C']]],
    u'Ptr<PCTSignaturesSQFD>']
ok: FUNC <Ptr_PCTSignaturesSQFD cv.xfeatures2d.PCTSignaturesSQFD.create [ARG int distanceFunction=3, ARG int similarityFunction=2, ARG float similarityParameter=1.0f]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistance',
    u'float',
    ['/C', '/V', '/PV'],
    [['Mat', u'_signature0', '', []], ['Mat', u'_signature1', '', []]],
    u'float']
ok: FUNC <float cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistance [ARG Mat _signature0=, ARG Mat _signature1=]>

--- Incoming ---
[   u'cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistances',
    u'void',
    ['/C', '/V', '/PV'],
    [   [u'Mat', u'sourceSignature', u'', ['/C', '/Ref']],
        [u'vector_Mat', u'imageSignatures', u'', ['/C', '/Ref']],
        [u'vector_float', u'distances', u'', ['/Ref']]],
    u'void']
ok: FUNC <void cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistances [ARG Mat sourceSignature=, ARG vector_Mat imageSignatures=, ARG vector_float distances=]>

--- Incoming ---
[   u'class cv.xfeatures2d.HarrisLaplaceFeatureDetector',
    u': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.HarrisLaplaceFeatureDetector : Feature2D, name: HarrisLaplaceFeatureDetector, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.HarrisLaplaceFeatureDetector.create',
    u'Ptr_HarrisLaplaceFeatureDetector',
    ['/S'],
    [   [u'int', u'numOctaves', u'6', []],
        [u'float', u'corn_thresh', u'0.01f', []],
        [u'float', u'DOG_thresh', u'0.01f', []],
        [u'int', u'maxCorners', u'5000', []],
        [u'int', u'num_layers', u'4', []]],
    u'Ptr<HarrisLaplaceFeatureDetector>']
ok: FUNC <Ptr_HarrisLaplaceFeatureDetector cv.xfeatures2d.HarrisLaplaceFeatureDetector.create [ARG int numOctaves=6, ARG float corn_thresh=0.01f, ARG float DOG_thresh=0.01f, ARG int maxCorners=5000, ARG int num_layers=4]>

--- Incoming ---
[   u'cv.xfeatures2d.matchGMS',
    u'void',
    [],
    [   [u'Size', u'size1', u'', ['/C', '/Ref']],
        [u'Size', u'size2', u'', ['/C', '/Ref']],
        [u'vector_KeyPoint', u'keypoints1', u'', ['/C', '/Ref']],
        [u'vector_KeyPoint', u'keypoints2', u'', ['/C', '/Ref']],
        [u'vector_DMatch', u'matches1to2', u'', ['/C', '/Ref']],
        [u'vector_DMatch', u'matchesGMS', u'', ['/O', '/Ref']],
        [u'bool', u'withRotation', u'false', ['/C']],
        [u'bool', u'withScale', u'false', ['/C']],
        [u'double', u'thresholdFactor', u'6.0', ['/C']]],
    u'void']
ok: FUNC <void cv.xfeatures2d..matchGMS [ARG Size size1=, ARG Size size2=, ARG vector_KeyPoint keypoints1=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG vector_DMatch matchesGMS=, ARG bool withRotation=false, ARG bool withScale=false, ARG double thresholdFactor=6.0]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d/cuda.hpp =====
Namespaces: set([u'cv.xfeatures2d', u'cv.cuda', u'cv'])

--- Incoming ---
[   u'enum cv.cuda.SURF_CUDA.KeypointLayout',
    '',
    [],
    [   [u'const cv.cuda.SURF_CUDA.X_ROW', u'0', [], [], None, ''],
        [u'const cv.cuda.SURF_CUDA.Y_ROW', u'0+1', [], [], None, ''],
        [u'const cv.cuda.SURF_CUDA.LAPLACIAN_ROW', u'0+2', [], [], None, ''],
        [u'const cv.cuda.SURF_CUDA.OCTAVE_ROW', u'0+3', [], [], None, ''],
        [u'const cv.cuda.SURF_CUDA.SIZE_ROW', u'0+4', [], [], None, ''],
        [u'const cv.cuda.SURF_CUDA.ANGLE_ROW', u'0+5', [], [], None, ''],
        [u'const cv.cuda.SURF_CUDA.HESSIAN_ROW', u'0+6', [], [], None, ''],
        [u'const cv.cuda.SURF_CUDA.ROWS_COUNT', u'0+7', [], [], None, '']],
    None]
class not found: CONST X_ROW=0
ok: CONST SURF_CUDA_X_ROW=0
class not found: CONST Y_ROW=0+1
ok: CONST SURF_CUDA_Y_ROW=0+1
class not found: CONST LAPLACIAN_ROW=0+2
ok: CONST SURF_CUDA_LAPLACIAN_ROW=0+2
class not found: CONST OCTAVE_ROW=0+3
ok: CONST SURF_CUDA_OCTAVE_ROW=0+3
class not found: CONST SIZE_ROW=0+4
ok: CONST SURF_CUDA_SIZE_ROW=0+4
class not found: CONST ANGLE_ROW=0+5
ok: CONST SURF_CUDA_ANGLE_ROW=0+5
class not found: CONST HESSIAN_ROW=0+6
ok: CONST SURF_CUDA_HESSIAN_ROW=0+6
class not found: CONST ROWS_COUNT=0+7
ok: CONST SURF_CUDA_ROWS_COUNT=0+7


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d/nonfree.hpp =====
Namespaces: set([u'cv.xfeatures2d', u'cv.cuda', u'cv'])

--- Incoming ---
[u'class cv.xfeatures2d.SIFT', u': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.SIFT : Feature2D, name: SIFT, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.SIFT.create',
    u'Ptr_SIFT',
    ['/S'],
    [   [u'int', u'nfeatures', u'0', []],
        [u'int', u'nOctaveLayers', u'3', []],
        [u'double', u'contrastThreshold', u'0.04', []],
        [u'double', u'edgeThreshold', u'10', []],
        [u'double', u'sigma', u'1.6', []]],
    u'Ptr<SIFT>']
ok: FUNC <Ptr_SIFT cv.xfeatures2d.SIFT.create [ARG int nfeatures=0, ARG int nOctaveLayers=3, ARG double contrastThreshold=0.04, ARG double edgeThreshold=10, ARG double sigma=1.6]>

--- Incoming ---
[u'class cv.xfeatures2d.SURF', u': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.SURF : Feature2D, name: SURF, base: Feature2D

--- Incoming ---
[   u'cv.xfeatures2d.SURF.create',
    u'Ptr_SURF',
    ['/S'],
    [   [u'double', u'hessianThreshold', u'100', []],
        [u'int', u'nOctaves', u'4', []],
        [u'int', u'nOctaveLayers', u'3', []],
        [u'bool', u'extended', u'false', []],
        [u'bool', u'upright', u'false', []]],
    u'Ptr<SURF>']
ok: FUNC <Ptr_SURF cv.xfeatures2d.SURF.create [ARG double hessianThreshold=100, ARG int nOctaves=4, ARG int nOctaveLayers=3, ARG bool extended=false, ARG bool upright=false]>

--- Incoming ---
[   u'cv.xfeatures2d.SURF.setHessianThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'hessianThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.SURF.setHessianThreshold [ARG double hessianThreshold=]>

--- Incoming ---
[   u'cv.xfeatures2d.SURF.getHessianThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.xfeatures2d.SURF.getHessianThreshold []>

--- Incoming ---
[   u'cv.xfeatures2d.SURF.setNOctaves',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nOctaves', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.SURF.setNOctaves [ARG int nOctaves=]>

--- Incoming ---
[u'cv.xfeatures2d.SURF.getNOctaves', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.xfeatures2d.SURF.getNOctaves []>

--- Incoming ---
[   u'cv.xfeatures2d.SURF.setNOctaveLayers',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nOctaveLayers', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.SURF.setNOctaveLayers [ARG int nOctaveLayers=]>

--- Incoming ---
[   u'cv.xfeatures2d.SURF.getNOctaveLayers',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.xfeatures2d.SURF.getNOctaveLayers []>

--- Incoming ---
[   u'cv.xfeatures2d.SURF.setExtended',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'extended', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.SURF.setExtended [ARG bool extended=]>

--- Incoming ---
[u'cv.xfeatures2d.SURF.getExtended', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.xfeatures2d.SURF.getExtended []>

--- Incoming ---
[   u'cv.xfeatures2d.SURF.setUpright',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'upright', u'', []]],
    u'void']
ok: FUNC <void cv.xfeatures2d.SURF.setUpright [ARG bool upright=]>

--- Incoming ---
[u'cv.xfeatures2d.SURF.getUpright', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.xfeatures2d.SURF.getUpright []>


===== Generating... =====
CLASS cv.xfeatures2d::.SURF : Feature2D
FUNC <Ptr_SURF cv.xfeatures2d.SURF.create [ARG double hessianThreshold=100, ARG int nOctaves=4, ARG int nOctaveLayers=3, ARG bool extended=false, ARG bool upright=false]>
java: SURF create(double hessianThreshold, int nOctaves, int nOctaveLayers, boolean extended, boolean upright)
java: SURF create(double hessianThreshold, int nOctaves, int nOctaveLayers, boolean extended)
java: SURF create(double hessianThreshold, int nOctaves, int nOctaveLayers)
java: SURF create(double hessianThreshold, int nOctaves)
java: SURF create(double hessianThreshold)
java: SURF create()
FUNC <bool cv.xfeatures2d.SURF.getExtended []>
java: boolean getExtended()
FUNC <bool cv.xfeatures2d.SURF.getUpright []>
java: boolean getUpright()
FUNC <double cv.xfeatures2d.SURF.getHessianThreshold []>
java: double getHessianThreshold()
FUNC <int cv.xfeatures2d.SURF.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <int cv.xfeatures2d.SURF.getNOctaves []>
java: int getNOctaves()
FUNC <void cv.xfeatures2d.SURF.setExtended [ARG bool extended=]>
java: void setExtended(boolean extended)
FUNC <void cv.xfeatures2d.SURF.setHessianThreshold [ARG double hessianThreshold=]>
java: void setHessianThreshold(double hessianThreshold)
FUNC <void cv.xfeatures2d.SURF.setNOctaveLayers [ARG int nOctaveLayers=]>
java: void setNOctaveLayers(int nOctaveLayers)
FUNC <void cv.xfeatures2d.SURF.setNOctaves [ARG int nOctaves=]>
java: void setNOctaves(int nOctaves)
FUNC <void cv.xfeatures2d.SURF.setUpright [ARG bool upright=]>
java: void setUpright(boolean upright)
CLASS cv.xfeatures2d::.BoostDesc : Feature2D
FUNC <Ptr_BoostDesc cv.xfeatures2d.BoostDesc.create [ARG int desc=BoostDesc::BINBOOST_256, ARG bool use_scale_orientation=true, ARG float scale_factor=6.25f]>
java: BoostDesc create(int desc, boolean use_scale_orientation, float scale_factor)
java: BoostDesc create(int desc, boolean use_scale_orientation)
java: BoostDesc create(int desc)
java: BoostDesc create()
FUNC <bool cv.xfeatures2d.BoostDesc.getUseScaleOrientation []>
java: boolean getUseScaleOrientation()
FUNC <float cv.xfeatures2d.BoostDesc.getScaleFactor []>
java: float getScaleFactor()
FUNC <void cv.xfeatures2d.BoostDesc.setScaleFactor [ARG float scale_factor=]>
java: void setScaleFactor(float scale_factor)
FUNC <void cv.xfeatures2d.BoostDesc.setUseScaleOrientation [ARG bool use_scale_orientation=]>
java: void setUseScaleOrientation(boolean use_scale_orientation)
CLASS cv.xfeatures2d::.FREAK : Feature2D
FUNC <Ptr_FREAK cv.xfeatures2d.FREAK.create [ARG bool orientationNormalized=true, ARG bool scaleNormalized=true, ARG float patternScale=22.0f, ARG int nOctaves=4, ARG vector_int selectedPairs=std::vector<int>()]>
java: FREAK create(boolean orientationNormalized, boolean scaleNormalized, float patternScale, int nOctaves, MatOfInt selectedPairs)
java: FREAK create(boolean orientationNormalized, boolean scaleNormalized, float patternScale, int nOctaves)
java: FREAK create(boolean orientationNormalized, boolean scaleNormalized, float patternScale)
java: FREAK create(boolean orientationNormalized, boolean scaleNormalized)
java: FREAK create(boolean orientationNormalized)
java: FREAK create()
CLASS cv.xfeatures2d::.HarrisLaplaceFeatureDetector : Feature2D
FUNC <Ptr_HarrisLaplaceFeatureDetector cv.xfeatures2d.HarrisLaplaceFeatureDetector.create [ARG int numOctaves=6, ARG float corn_thresh=0.01f, ARG float DOG_thresh=0.01f, ARG int maxCorners=5000, ARG int num_layers=4]>
java: HarrisLaplaceFeatureDetector create(int numOctaves, float corn_thresh, float DOG_thresh, int maxCorners, int num_layers)
java: HarrisLaplaceFeatureDetector create(int numOctaves, float corn_thresh, float DOG_thresh, int maxCorners)
java: HarrisLaplaceFeatureDetector create(int numOctaves, float corn_thresh, float DOG_thresh)
java: HarrisLaplaceFeatureDetector create(int numOctaves, float corn_thresh)
java: HarrisLaplaceFeatureDetector create(int numOctaves)
java: HarrisLaplaceFeatureDetector create()
CLASS cv.xfeatures2d::.LUCID : Feature2D
FUNC <Ptr_LUCID cv.xfeatures2d.LUCID.create [ARG int lucid_kernel=1, ARG int blur_kernel=2]>
java: LUCID create(int lucid_kernel, int blur_kernel)
java: LUCID create(int lucid_kernel)
java: LUCID create()
CLASS cv.xfeatures2d::.VGG : Feature2D
FUNC <Ptr_VGG cv.xfeatures2d.VGG.create [ARG int desc=VGG::VGG_120, ARG float isigma=1.4f, ARG bool img_normalize=true, ARG bool use_scale_orientation=true, ARG float scale_factor=6.25f, ARG bool dsc_normalize=false]>
java: VGG create(int desc, float isigma, boolean img_normalize, boolean use_scale_orientation, float scale_factor, boolean dsc_normalize)
java: VGG create(int desc, float isigma, boolean img_normalize, boolean use_scale_orientation, float scale_factor)
java: VGG create(int desc, float isigma, boolean img_normalize, boolean use_scale_orientation)
java: VGG create(int desc, float isigma, boolean img_normalize)
java: VGG create(int desc, float isigma)
java: VGG create(int desc)
java: VGG create()
FUNC <bool cv.xfeatures2d.VGG.getUseNormalizeDescriptor []>
java: boolean getUseNormalizeDescriptor()
FUNC <bool cv.xfeatures2d.VGG.getUseNormalizeImage []>
java: boolean getUseNormalizeImage()
FUNC <bool cv.xfeatures2d.VGG.getUseScaleOrientation []>
java: boolean getUseScaleOrientation()
FUNC <float cv.xfeatures2d.VGG.getScaleFactor []>
java: float getScaleFactor()
FUNC <float cv.xfeatures2d.VGG.getSigma []>
java: float getSigma()
FUNC <void cv.xfeatures2d.VGG.setScaleFactor [ARG float scale_factor=]>
java: void setScaleFactor(float scale_factor)
FUNC <void cv.xfeatures2d.VGG.setSigma [ARG float isigma=]>
java: void setSigma(float isigma)
FUNC <void cv.xfeatures2d.VGG.setUseNormalizeDescriptor [ARG bool dsc_normalize=]>
java: void setUseNormalizeDescriptor(boolean dsc_normalize)
FUNC <void cv.xfeatures2d.VGG.setUseNormalizeImage [ARG bool img_normalize=]>
java: void setUseNormalizeImage(boolean img_normalize)
FUNC <void cv.xfeatures2d.VGG.setUseScaleOrientation [ARG bool use_scale_orientation=]>
java: void setUseScaleOrientation(boolean use_scale_orientation)
CLASS cv.xfeatures2d::.MSDDetector : Feature2D
CLASS cv.xfeatures2d::.SIFT : Feature2D
FUNC <Ptr_SIFT cv.xfeatures2d.SIFT.create [ARG int nfeatures=0, ARG int nOctaveLayers=3, ARG double contrastThreshold=0.04, ARG double edgeThreshold=10, ARG double sigma=1.6]>
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold, double sigma)
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold)
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold)
java: SIFT create(int nfeatures, int nOctaveLayers)
java: SIFT create(int nfeatures)
java: SIFT create()
CLASS cv.xfeatures2d::.PCTSignaturesSQFD : Algorithm
FUNC <Ptr_PCTSignaturesSQFD cv.xfeatures2d.PCTSignaturesSQFD.create [ARG int distanceFunction=3, ARG int similarityFunction=2, ARG float similarityParameter=1.0f]>
java: PCTSignaturesSQFD create(int distanceFunction, int similarityFunction, float similarityParameter)
java: PCTSignaturesSQFD create(int distanceFunction, int similarityFunction)
java: PCTSignaturesSQFD create(int distanceFunction)
java: PCTSignaturesSQFD create()
FUNC <float cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistance [ARG Mat _signature0=, ARG Mat _signature1=]>
java: float computeQuadraticFormDistance(Mat _signature0, Mat _signature1)
FUNC <void cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistances [ARG Mat sourceSignature=, ARG vector_Mat imageSignatures=, ARG vector_float distances=]>
java: void computeQuadraticFormDistances(Mat sourceSignature, List<Mat> imageSignatures, MatOfFloat distances)
CLASS cv.xfeatures2d::.DAISY : Feature2D
[CONST NRM_NONE=100, CONST NRM_PARTIAL=101, CONST NRM_FULL=102, CONST NRM_SIFT=103]
FUNC <Ptr_DAISY cv.xfeatures2d.DAISY.create [ARG float radius=15, ARG int q_radius=3, ARG int q_theta=8, ARG int q_hist=8, ARG DAISY_NormalizationType norm=DAISY::NRM_NONE, ARG Mat H=Mat(), ARG bool interpolation=true, ARG bool use_orientation=false]>
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist, Mat H, boolean interpolation, boolean use_orientation)
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist, Mat H, boolean interpolation)
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist, Mat H)
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist)
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist)
java: DAISY create(float radius, int q_radius, int q_theta)
java: DAISY create(float radius, int q_radius)
java: DAISY create(float radius)
java: DAISY create()
CLASS ::.Xfeatures2d : 
[CONST SURF_CUDA_X_ROW=0, CONST SURF_CUDA_Y_ROW=0+1, CONST SURF_CUDA_LAPLACIAN_ROW=0+2, CONST SURF_CUDA_OCTAVE_ROW=0+3, CONST SURF_CUDA_SIZE_ROW=0+4, CONST SURF_CUDA_ANGLE_ROW=0+5, CONST SURF_CUDA_HESSIAN_ROW=0+6, CONST SURF_CUDA_ROWS_COUNT=0+7]
FUNC <void cv.xfeatures2d..matchGMS [ARG Size size1=, ARG Size size2=, ARG vector_KeyPoint keypoints1=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG vector_DMatch matchesGMS=, ARG bool withRotation=false, ARG bool withScale=false, ARG double thresholdFactor=6.0]>
java: void matchGMS(Size size1, Size size2, MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, MatOfDMatch matchesGMS, boolean withRotation, boolean withScale, double thresholdFactor)
java: void matchGMS(Size size1, Size size2, MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, MatOfDMatch matchesGMS, boolean withRotation, boolean withScale)
java: void matchGMS(Size size1, Size size2, MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, MatOfDMatch matchesGMS, boolean withRotation)
java: void matchGMS(Size size1, Size size2, MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, MatOfDMatch matchesGMS)
CLASS cv.xfeatures2d::.LATCH : Feature2D
FUNC <Ptr_LATCH cv.xfeatures2d.LATCH.create [ARG int bytes=32, ARG bool rotationInvariance=true, ARG int half_ssd_size=3, ARG double sigma=2.0]>
java: LATCH create(int bytes, boolean rotationInvariance, int half_ssd_size, double sigma)
java: LATCH create(int bytes, boolean rotationInvariance, int half_ssd_size)
java: LATCH create(int bytes, boolean rotationInvariance)
java: LATCH create(int bytes)
java: LATCH create()
CLASS cv.xfeatures2d::.BriefDescriptorExtractor : Feature2D
FUNC <Ptr_BriefDescriptorExtractor cv.xfeatures2d.BriefDescriptorExtractor.create [ARG int bytes=32, ARG bool use_orientation=false]>
java: BriefDescriptorExtractor create(int bytes, boolean use_orientation)
java: BriefDescriptorExtractor create(int bytes)
java: BriefDescriptorExtractor create()
CLASS cv.xfeatures2d::.StarDetector : Feature2D
FUNC <Ptr_StarDetector cv.xfeatures2d.StarDetector.create [ARG int maxSize=45, ARG int responseThreshold=30, ARG int lineThresholdProjected=10, ARG int lineThresholdBinarized=8, ARG int suppressNonmaxSize=5]>
java: StarDetector create(int maxSize, int responseThreshold, int lineThresholdProjected, int lineThresholdBinarized, int suppressNonmaxSize)
java: StarDetector create(int maxSize, int responseThreshold, int lineThresholdProjected, int lineThresholdBinarized)
java: StarDetector create(int maxSize, int responseThreshold, int lineThresholdProjected)
java: StarDetector create(int maxSize, int responseThreshold)
java: StarDetector create(int maxSize)
java: StarDetector create()
CLASS cv.xfeatures2d::.PCTSignatures : Algorithm
[CONST UNIFORM=0, CONST REGULAR=1, CONST NORMAL=2]
[CONST MINUS=0, CONST GAUSSIAN=1, CONST HEURISTIC=2]
[CONST L0_25=0, CONST L0_5=1, CONST L1=2, CONST L2=3, CONST L2SQUARED=4, CONST L5=5, CONST L_INFINITY=6]
FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG int initSampleCount=2000, ARG int initSeedCount=400, ARG int pointDistribution=0]>
java: PCTSignatures create(int initSampleCount, int initSeedCount, int pointDistribution)
java: PCTSignatures create(int initSampleCount, int initSeedCount)
java: PCTSignatures create(int initSampleCount)
java: PCTSignatures create()
FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG vector_Point2f initSamplingPoints=, ARG int initSeedCount=]>
java: PCTSignatures create(MatOfPoint2f initSamplingPoints, int initSeedCount)
FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG vector_Point2f initSamplingPoints=, ARG vector_int initClusterSeedIndexes=]>
java: PCTSignatures create(MatOfPoint2f initSamplingPoints, MatOfInt initClusterSeedIndexes)
FUNC <float cv.xfeatures2d.PCTSignatures.getDropThreshold []>
java: float getDropThreshold()
FUNC <float cv.xfeatures2d.PCTSignatures.getJoiningDistance []>
java: float getJoiningDistance()
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightA []>
java: float getWeightA()
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightB []>
java: float getWeightB()
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightContrast []>
java: float getWeightContrast()
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightEntropy []>
java: float getWeightEntropy()
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightL []>
java: float getWeightL()
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightX []>
java: float getWeightX()
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightY []>
java: float getWeightY()
FUNC <int cv.xfeatures2d.PCTSignatures.getClusterMinSize []>
java: int getClusterMinSize()
FUNC <int cv.xfeatures2d.PCTSignatures.getDistanceFunction []>
java: int getDistanceFunction()
FUNC <int cv.xfeatures2d.PCTSignatures.getGrayscaleBits []>
java: int getGrayscaleBits()
FUNC <int cv.xfeatures2d.PCTSignatures.getInitSeedCount []>
java: int getInitSeedCount()
FUNC <int cv.xfeatures2d.PCTSignatures.getIterationCount []>
java: int getIterationCount()
FUNC <int cv.xfeatures2d.PCTSignatures.getMaxClustersCount []>
java: int getMaxClustersCount()
FUNC <int cv.xfeatures2d.PCTSignatures.getSampleCount []>
java: int getSampleCount()
FUNC <int cv.xfeatures2d.PCTSignatures.getWindowRadius []>
java: int getWindowRadius()
FUNC <vector_Point2f cv.xfeatures2d.PCTSignatures.getSamplingPoints []>
java: MatOfPoint2f getSamplingPoints()
FUNC <vector_int cv.xfeatures2d.PCTSignatures.getInitSeedIndexes []>
java: MatOfInt getInitSeedIndexes()
FUNC <void cv.xfeatures2d.PCTSignatures.computeSignature [ARG Mat image=, ARG Mat signature=]>
java: void computeSignature(Mat image, Mat signature)
FUNC <void cv.xfeatures2d.PCTSignatures.computeSignatures [ARG vector_Mat images=, ARG vector_Mat signatures=]>
java: void computeSignatures(List<Mat> images, List<Mat> signatures)
FUNC <void cv.xfeatures2d.PCTSignatures.drawSignature [ARG Mat source=, ARG Mat signature=, ARG Mat result=, ARG float radiusToShorterSideRatio=1.0 / 8, ARG int borderThickness=1]>
java: void drawSignature(Mat source, Mat signature, Mat result, float radiusToShorterSideRatio, int borderThickness)
java: void drawSignature(Mat source, Mat signature, Mat result, float radiusToShorterSideRatio)
java: void drawSignature(Mat source, Mat signature, Mat result)
FUNC <void cv.xfeatures2d.PCTSignatures.generateInitPoints [ARG vector_Point2f initPoints=, ARG int count=, ARG int pointDistribution=]>
java: void generateInitPoints(MatOfPoint2f initPoints, int count, int pointDistribution)
FUNC <void cv.xfeatures2d.PCTSignatures.setClusterMinSize [ARG int clusterMinSize=]>
java: void setClusterMinSize(int clusterMinSize)
FUNC <void cv.xfeatures2d.PCTSignatures.setDistanceFunction [ARG int distanceFunction=]>
java: void setDistanceFunction(int distanceFunction)
FUNC <void cv.xfeatures2d.PCTSignatures.setDropThreshold [ARG float dropThreshold=]>
java: void setDropThreshold(float dropThreshold)
FUNC <void cv.xfeatures2d.PCTSignatures.setGrayscaleBits [ARG int grayscaleBits=]>
java: void setGrayscaleBits(int grayscaleBits)
FUNC <void cv.xfeatures2d.PCTSignatures.setInitSeedIndexes [ARG vector_int initSeedIndexes=]>
java: void setInitSeedIndexes(MatOfInt initSeedIndexes)
FUNC <void cv.xfeatures2d.PCTSignatures.setIterationCount [ARG int iterationCount=]>
java: void setIterationCount(int iterationCount)
FUNC <void cv.xfeatures2d.PCTSignatures.setJoiningDistance [ARG float joiningDistance=]>
java: void setJoiningDistance(float joiningDistance)
FUNC <void cv.xfeatures2d.PCTSignatures.setMaxClustersCount [ARG int maxClustersCount=]>
java: void setMaxClustersCount(int maxClustersCount)
FUNC <void cv.xfeatures2d.PCTSignatures.setSamplingPoints [ARG vector_Point2f samplingPoints=]>
java: void setSamplingPoints(MatOfPoint2f samplingPoints)
FUNC <void cv.xfeatures2d.PCTSignatures.setTranslation [ARG int idx=, ARG float value=]>
java: void setTranslation(int idx, float value)
FUNC <void cv.xfeatures2d.PCTSignatures.setTranslations [ARG vector_float translations=]>
java: void setTranslations(MatOfFloat translations)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeight [ARG int idx=, ARG float value=]>
java: void setWeight(int idx, float value)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightA [ARG float weight=]>
java: void setWeightA(float weight)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightB [ARG float weight=]>
java: void setWeightB(float weight)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightContrast [ARG float weight=]>
java: void setWeightContrast(float weight)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightEntropy [ARG float weight=]>
java: void setWeightEntropy(float weight)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightL [ARG float weight=]>
java: void setWeightL(float weight)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightX [ARG float weight=]>
java: void setWeightX(float weight)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightY [ARG float weight=]>
java: void setWeightY(float weight)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeights [ARG vector_float weights=]>
java: void setWeights(MatOfFloat weights)
FUNC <void cv.xfeatures2d.PCTSignatures.setWindowRadius [ARG int radius=]>
java: void setWindowRadius(int radius)

=== MODULE: ximgproc (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc) ===


Files (23):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fast_hough_transform.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/slic.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/peilin.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fourier_descriptors.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fast_line_detector.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/paillou_filter.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/color_match.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/estimated_covariance.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/brightedges.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edge_filter.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/seeds.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/lsc.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/ridgefilter.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/structured_edge_detection.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/segmentation.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/deriche_filter.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edgepreserving_filter.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edgeboxes.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/run_length_morphology.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/weighted_median_filter.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/disparity_filter.hpp']

Common headers (0):
[]
ok: class CLASS ::.Ximgproc : , name: Ximgproc, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[   u'enum cv.ximgproc.ThinningTypes',
    '',
    [],
    [   [u'const cv.ximgproc.THINNING_ZHANGSUEN', u'0', [], [], None, ''],
        [u'const cv.ximgproc.THINNING_GUOHALL', u'1', [], [], None, '']],
    None]
ok: CONST THINNING_ZHANGSUEN=0
ok: CONST THINNING_GUOHALL=1

--- Incoming ---
[   u'enum cv.ximgproc.LocalBinarizationMethods',
    '',
    [],
    [   [u'const cv.ximgproc.BINARIZATION_NIBLACK', u'0', [], [], None, ''],
        [u'const cv.ximgproc.BINARIZATION_SAUVOLA', u'1', [], [], None, ''],
        [u'const cv.ximgproc.BINARIZATION_WOLF', u'2', [], [], None, ''],
        [u'const cv.ximgproc.BINARIZATION_NICK', u'3', [], [], None, '']],
    None]
ok: CONST BINARIZATION_NIBLACK=0
ok: CONST BINARIZATION_SAUVOLA=1
ok: CONST BINARIZATION_WOLF=2
ok: CONST BINARIZATION_NICK=3

--- Incoming ---
[   u'cv.ximgproc.niBlackThreshold',
    u'void',
    [],
    [   ['Mat', u'_src', '', []],
        ['Mat', u'_dst', '', ['/O']],
        [u'double', u'maxValue', u'', []],
        [u'int', u'type', u'', []],
        [u'int', u'blockSize', u'', []],
        [u'double', u'k', u'', []],
        [u'int', u'binarizationMethod', u'BINARIZATION_NIBLACK', []]],
    u'void']
ok: FUNC <void cv.ximgproc..niBlackThreshold [ARG Mat _src=, ARG Mat _dst=, ARG double maxValue=, ARG int type=, ARG int blockSize=, ARG double k=, ARG int binarizationMethod=BINARIZATION_NIBLACK]>

--- Incoming ---
[   u'cv.ximgproc.thinning',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'thinningType', u'THINNING_ZHANGSUEN', []]],
    u'void']
ok: FUNC <void cv.ximgproc..thinning [ARG Mat src=, ARG Mat dst=, ARG int thinningType=THINNING_ZHANGSUEN]>

--- Incoming ---
[   u'cv.ximgproc.anisotropicDiffusion',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'alpha', u'', []],
        [u'float', u'K', u'', []],
        [u'int', u'niters', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc..anisotropicDiffusion [ARG Mat src=, ARG Mat dst=, ARG float alpha=, ARG float K=, ARG int niters=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fast_hough_transform.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[   u'enum cv.ximgproc.AngleRangeOption',
    '',
    [],
    [   [u'const cv.ximgproc.ARO_0_45', u'0', [], [], None, ''],
        [u'const cv.ximgproc.ARO_45_90', u'1', [], [], None, ''],
        [u'const cv.ximgproc.ARO_90_135', u'2', [], [], None, ''],
        [u'const cv.ximgproc.ARO_315_0', u'3', [], [], None, ''],
        [u'const cv.ximgproc.ARO_315_45', u'4', [], [], None, ''],
        [u'const cv.ximgproc.ARO_45_135', u'5', [], [], None, ''],
        [u'const cv.ximgproc.ARO_315_135', u'6', [], [], None, ''],
        [u'const cv.ximgproc.ARO_CTR_HOR', u'7', [], [], None, ''],
        [u'const cv.ximgproc.ARO_CTR_VER', u'8', [], [], None, '']],
    None]
ok: CONST ARO_0_45=0
ok: CONST ARO_45_90=1
ok: CONST ARO_90_135=2
ok: CONST ARO_315_0=3
ok: CONST ARO_315_45=4
ok: CONST ARO_45_135=5
ok: CONST ARO_315_135=6
ok: CONST ARO_CTR_HOR=7
ok: CONST ARO_CTR_VER=8

--- Incoming ---
[   u'enum cv.ximgproc.HoughOp',
    '',
    [],
    [   [u'const cv.ximgproc.FHT_MIN', u'0', [], [], None, ''],
        [u'const cv.ximgproc.FHT_MAX', u'1', [], [], None, ''],
        [u'const cv.ximgproc.FHT_ADD', u'2', [], [], None, ''],
        [u'const cv.ximgproc.FHT_AVE', u'3', [], [], None, '']],
    None]
ok: CONST FHT_MIN=0
ok: CONST FHT_MAX=1
ok: CONST FHT_ADD=2
ok: CONST FHT_AVE=3

--- Incoming ---
[   u'enum cv.ximgproc.HoughDeskewOption',
    '',
    [],
    [   [u'const cv.ximgproc.HDO_RAW', u'0', [], [], None, ''],
        [u'const cv.ximgproc.HDO_DESKEW', u'1', [], [], None, '']],
    None]
ok: CONST HDO_RAW=0
ok: CONST HDO_DESKEW=1

--- Incoming ---
[   u'cv.ximgproc.FastHoughTransform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dstMatDepth', u'', []],
        [u'int', u'angleRange', u'ARO_315_135', []],
        [u'int', u'op', u'FHT_ADD', []],
        [u'int', u'makeSkew', u'HDO_DESKEW', []]],
    u'void']
ok: FUNC <void cv.ximgproc..FastHoughTransform [ARG Mat src=, ARG Mat dst=, ARG int dstMatDepth=, ARG int angleRange=ARO_315_135, ARG int op=FHT_ADD, ARG int makeSkew=HDO_DESKEW]>

--- Incoming ---
[   u'cv.ximgproc.HoughPoint2Line',
    u'Vec4i',
    [],
    [   [u'Point', u'houghPoint', u'', ['/C', '/Ref']],
        ['Mat', u'srcImgInfo', '', []],
        [u'int', u'angleRange', u'ARO_315_135', []],
        [u'int', u'makeSkew', u'HDO_DESKEW', []],
        [u'int', u'rules', u'RO_IGNORE_BORDERS', []]],
    u'Vec4i']
ok: FUNC <Vec4i cv.ximgproc..HoughPoint2Line [ARG Point houghPoint=, ARG Mat srcImgInfo=, ARG int angleRange=ARO_315_135, ARG int makeSkew=HDO_DESKEW, ARG int rules=RO_IGNORE_BORDERS]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/slic.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[   u'enum cv.ximgproc.SLICType',
    '',
    [],
    [   [u'const cv.ximgproc.SLIC', u'100', [], [], None, ''],
        [u'const cv.ximgproc.SLICO', u'101', [], [], None, ''],
        [u'const cv.ximgproc.MSLIC', u'102', [], [], None, '']],
    None]
ok: CONST SLIC=100
ok: CONST SLICO=101
ok: CONST MSLIC=102

--- Incoming ---
[u'class cv.ximgproc.SuperpixelSLIC', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.SuperpixelSLIC : Algorithm, name: SuperpixelSLIC, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSLIC.getNumberOfSuperpixels',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ximgproc.SuperpixelSLIC.getNumberOfSuperpixels []>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSLIC.iterate',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'num_iterations', u'10', []]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelSLIC.iterate [ARG int num_iterations=10]>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSLIC.getLabels',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'labels_out', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelSLIC.getLabels [ARG Mat labels_out=]>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSLIC.getLabelContourMask',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'image', '', ['/O']], [u'bool', u'thick_line', u'true', []]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelSLIC.getLabelContourMask [ARG Mat image=, ARG bool thick_line=true]>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSLIC.enforceLabelConnectivity',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'min_element_size', u'25', []]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelSLIC.enforceLabelConnectivity [ARG int min_element_size=25]>

--- Incoming ---
[   u'cv.ximgproc.createSuperpixelSLIC',
    u'Ptr_SuperpixelSLIC',
    [],
    [   ['Mat', u'image', '', []],
        [u'int', u'algorithm', u'SLICO', []],
        [u'int', u'region_size', u'10', []],
        [u'float', u'ruler', u'10.0f', []]],
    u'Ptr<SuperpixelSLIC>']
ok: FUNC <Ptr_SuperpixelSLIC cv.ximgproc..createSuperpixelSLIC [ARG Mat image=, ARG int algorithm=SLICO, ARG int region_size=10, ARG float ruler=10.0f]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/peilin.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[   u'cv.ximgproc.PeiLinNormalization',
    u'void',
    [],
    [['Mat', u'I', '', []], ['Mat', u'T', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc..PeiLinNormalization [ARG Mat I=, ARG Mat T=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fourier_descriptors.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[u'class cv.ximgproc.ContourFitting', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.ContourFitting : Algorithm, name: ContourFitting, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.ContourFitting.estimateTransformation',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        ['Mat', u'alphaPhiST', '', ['/O']],
        [u'double', u'dist', u'', ['/O', '/Ref']],
        [u'bool', u'fdContour', u'false', []]],
    u'void']
ok: FUNC <void cv.ximgproc.ContourFitting.estimateTransformation [ARG Mat src=, ARG Mat dst=, ARG Mat alphaPhiST=, ARG double dist=, ARG bool fdContour=false]>

--- Incoming ---
[   u'cv.ximgproc.ContourFitting.setCtrSize',
    u'void',
    [],
    [[u'int', u'n', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.ContourFitting.setCtrSize [ARG int n=]>

--- Incoming ---
[   u'cv.ximgproc.ContourFitting.setFDSize',
    u'void',
    [],
    [[u'int', u'n', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.ContourFitting.setFDSize [ARG int n=]>

--- Incoming ---
[u'cv.ximgproc.ContourFitting.getCtrSize', u'int', [], [], u'int']
ok: FUNC <int cv.ximgproc.ContourFitting.getCtrSize []>

--- Incoming ---
[u'cv.ximgproc.ContourFitting.getFDSize', u'int', [], [], u'int']
ok: FUNC <int cv.ximgproc.ContourFitting.getFDSize []>

--- Incoming ---
[   u'cv.ximgproc.fourierDescriptor',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'nbElt', u'-1', []],
        [u'int', u'nbFD', u'-1', []]],
    u'void']
ok: FUNC <void cv.ximgproc..fourierDescriptor [ARG Mat src=, ARG Mat dst=, ARG int nbElt=-1, ARG int nbFD=-1]>

--- Incoming ---
[   u'cv.ximgproc.transformFD',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u't', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'bool', u'fdContour', u'true', []]],
    u'void']
ok: FUNC <void cv.ximgproc..transformFD [ARG Mat src=, ARG Mat t=, ARG Mat dst=, ARG bool fdContour=true]>

--- Incoming ---
[   u'cv.ximgproc.contourSampling',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'out', '', ['/O']],
        [u'int', u'nbElt', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc..contourSampling [ARG Mat src=, ARG Mat out=, ARG int nbElt=]>

--- Incoming ---
[   u'cv.ximgproc.createContourFitting',
    u'Ptr_ContourFitting',
    [],
    [[u'int', u'ctr', u'1024', []], [u'int', u'fd', u'16', []]],
    u'Ptr<ContourFitting>']
ok: FUNC <Ptr_ContourFitting cv.ximgproc..createContourFitting [ARG int ctr=1024, ARG int fd=16]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fast_line_detector.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[u'class cv.ximgproc.FastLineDetector', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.FastLineDetector : Algorithm, name: FastLineDetector, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.FastLineDetector.detect',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'_image', '', []], ['Mat', u'_lines', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.FastLineDetector.detect [ARG Mat _image=, ARG Mat _lines=]>

--- Incoming ---
[   u'cv.ximgproc.FastLineDetector.drawSegments',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'_image', '', ['/IO']],
        ['Mat', u'lines', '', []],
        [u'bool', u'draw_arrow', u'false', []]],
    u'void']
ok: FUNC <void cv.ximgproc.FastLineDetector.drawSegments [ARG Mat _image=, ARG Mat lines=, ARG bool draw_arrow=false]>

--- Incoming ---
[   u'cv.ximgproc.createFastLineDetector',
    u'Ptr_FastLineDetector',
    [],
    [   [u'int', u'_length_threshold', u'10', []],
        [u'float', u'_distance_threshold', u'1.414213562f', []],
        [u'double', u'_canny_th1', u'50.0', []],
        [u'double', u'_canny_th2', u'50.0', []],
        [u'int', u'_canny_aperture_size', u'3', []],
        [u'bool', u'_do_merge', u'false', []]],
    u'Ptr<FastLineDetector>']
ok: FUNC <Ptr_FastLineDetector cv.ximgproc..createFastLineDetector [ARG int _length_threshold=10, ARG float _distance_threshold=1.414213562f, ARG double _canny_th1=50.0, ARG double _canny_th2=50.0, ARG int _canny_aperture_size=3, ARG bool _do_merge=false]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/paillou_filter.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/paillou_filter.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/color_match.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[   u'cv.ximgproc.createQuaternionImage',
    u'void',
    [],
    [['Mat', u'img', '', []], ['Mat', u'qimg', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc..createQuaternionImage [ARG Mat img=, ARG Mat qimg=]>

--- Incoming ---
[   u'cv.ximgproc.qconj',
    u'void',
    [],
    [['Mat', u'qimg', '', []], ['Mat', u'qcimg', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc..qconj [ARG Mat qimg=, ARG Mat qcimg=]>

--- Incoming ---
[   u'cv.ximgproc.qunitary',
    u'void',
    [],
    [['Mat', u'qimg', '', []], ['Mat', u'qnimg', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc..qunitary [ARG Mat qimg=, ARG Mat qnimg=]>

--- Incoming ---
[   u'cv.ximgproc.qmultiply',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc..qmultiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.ximgproc.qdft',
    u'void',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'qimg', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'bool', u'sideLeft', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc..qdft [ARG Mat img=, ARG Mat qimg=, ARG int flags=, ARG bool sideLeft=]>

--- Incoming ---
[   u'cv.ximgproc.colorMatchTemplate',
    u'void',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'templ', '', []],
        ['Mat', u'result', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc..colorMatchTemplate [ARG Mat img=, ARG Mat templ=, ARG Mat result=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/estimated_covariance.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[   u'cv.ximgproc.covarianceEstimation',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'windowRows', u'', []],
        [u'int', u'windowCols', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc..covarianceEstimation [ARG Mat src=, ARG Mat dst=, ARG int windowRows=, ARG int windowCols=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/brightedges.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/brightedges.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edge_filter.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[   u'enum cv.ximgproc.EdgeAwareFiltersList',
    '',
    [],
    [   [u'const cv.ximgproc.DTF_NC', '0', [], [], None, ''],
        [u'const cv.ximgproc.DTF_IC', '1', [], [], None, ''],
        [u'const cv.ximgproc.DTF_RF', '2', [], [], None, ''],
        [u'const cv.ximgproc.GUIDED_FILTER', '3', [], [], None, ''],
        [u'const cv.ximgproc.AM_FILTER', '4', [], [], None, '']],
    None]
ok: CONST DTF_NC=0
ok: CONST DTF_IC=1
ok: CONST DTF_RF=2
ok: CONST GUIDED_FILTER=3
ok: CONST AM_FILTER=4

--- Incoming ---
[u'class cv.ximgproc.DTFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.DTFilter : Algorithm, name: DTFilter, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.DTFilter.filter',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dDepth', u'-1', []]],
    u'void']
ok: FUNC <void cv.ximgproc.DTFilter.filter [ARG Mat src=, ARG Mat dst=, ARG int dDepth=-1]>

--- Incoming ---
[   u'cv.ximgproc.createDTFilter',
    u'Ptr_DTFilter',
    [],
    [   ['Mat', u'guide', '', []],
        [u'double', u'sigmaSpatial', u'', []],
        [u'double', u'sigmaColor', u'', []],
        [u'int', u'mode', u'DTF_NC', []],
        [u'int', u'numIters', u'3', []]],
    u'Ptr<DTFilter>']
ok: FUNC <Ptr_DTFilter cv.ximgproc..createDTFilter [ARG Mat guide=, ARG double sigmaSpatial=, ARG double sigmaColor=, ARG int mode=DTF_NC, ARG int numIters=3]>

--- Incoming ---
[   u'cv.ximgproc.dtFilter',
    u'void',
    [],
    [   ['Mat', u'guide', '', []],
        ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'sigmaSpatial', u'', []],
        [u'double', u'sigmaColor', u'', []],
        [u'int', u'mode', u'DTF_NC', []],
        [u'int', u'numIters', u'3', []]],
    u'void']
ok: FUNC <void cv.ximgproc..dtFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG double sigmaSpatial=, ARG double sigmaColor=, ARG int mode=DTF_NC, ARG int numIters=3]>

--- Incoming ---
[u'class cv.ximgproc.GuidedFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.GuidedFilter : Algorithm, name: GuidedFilter, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.GuidedFilter.filter',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dDepth', u'-1', []]],
    u'void']
ok: FUNC <void cv.ximgproc.GuidedFilter.filter [ARG Mat src=, ARG Mat dst=, ARG int dDepth=-1]>

--- Incoming ---
[   u'cv.ximgproc.createGuidedFilter',
    u'Ptr_GuidedFilter',
    [],
    [   ['Mat', u'guide', '', []],
        [u'int', u'radius', u'', []],
        [u'double', u'eps', u'', []]],
    u'Ptr<GuidedFilter>']
ok: FUNC <Ptr_GuidedFilter cv.ximgproc..createGuidedFilter [ARG Mat guide=, ARG int radius=, ARG double eps=]>

--- Incoming ---
[   u'cv.ximgproc.guidedFilter',
    u'void',
    [],
    [   ['Mat', u'guide', '', []],
        ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'radius', u'', []],
        [u'double', u'eps', u'', []],
        [u'int', u'dDepth', u'-1', []]],
    u'void']
ok: FUNC <void cv.ximgproc..guidedFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG int radius=, ARG double eps=, ARG int dDepth=-1]>

--- Incoming ---
[u'class cv.ximgproc.AdaptiveManifoldFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.AdaptiveManifoldFilter : Algorithm, name: AdaptiveManifoldFilter, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.AdaptiveManifoldFilter.filter',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'joint', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.ximgproc.AdaptiveManifoldFilter.filter [ARG Mat src=, ARG Mat dst=, ARG Mat joint=Mat()]>

--- Incoming ---
[   u'cv.ximgproc.AdaptiveManifoldFilter.collectGarbage',
    u'void',
    ['/V', '/PV'],
    [],
    u'void']
ok: FUNC <void cv.ximgproc.AdaptiveManifoldFilter.collectGarbage []>

--- Incoming ---
[   u'cv.ximgproc.AdaptiveManifoldFilter.create',
    u'Ptr_AdaptiveManifoldFilter',
    ['/S'],
    [],
    u'Ptr<AdaptiveManifoldFilter>']
ok: FUNC <Ptr_AdaptiveManifoldFilter cv.ximgproc.AdaptiveManifoldFilter.create []>

--- Incoming ---
[   u'cv.ximgproc.createAMFilter',
    u'Ptr_AdaptiveManifoldFilter',
    [],
    [   [u'double', u'sigma_s', u'', []],
        [u'double', u'sigma_r', u'', []],
        [u'bool', u'adjust_outliers', u'false', []]],
    u'Ptr<AdaptiveManifoldFilter>']
ok: FUNC <Ptr_AdaptiveManifoldFilter cv.ximgproc..createAMFilter [ARG double sigma_s=, ARG double sigma_r=, ARG bool adjust_outliers=false]>

--- Incoming ---
[   u'cv.ximgproc.amFilter',
    u'void',
    [],
    [   ['Mat', u'joint', '', []],
        ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'sigma_s', u'', []],
        [u'double', u'sigma_r', u'', []],
        [u'bool', u'adjust_outliers', u'false', []]],
    u'void']
ok: FUNC <void cv.ximgproc..amFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG double sigma_s=, ARG double sigma_r=, ARG bool adjust_outliers=false]>

--- Incoming ---
[   u'cv.ximgproc.jointBilateralFilter',
    u'void',
    [],
    [   ['Mat', u'joint', '', []],
        ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'd', u'', []],
        [u'double', u'sigmaColor', u'', []],
        [u'double', u'sigmaSpace', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv.ximgproc..jointBilateralFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.ximgproc.bilateralTextureFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'fr', u'3', []],
        [u'int', u'numIter', u'1', []],
        [u'double', u'sigmaAlpha', u'-1.', []],
        [u'double', u'sigmaAvg', u'-1.', []]],
    u'void']
ok: FUNC <void cv.ximgproc..bilateralTextureFilter [ARG Mat src=, ARG Mat dst=, ARG int fr=3, ARG int numIter=1, ARG double sigmaAlpha=-1., ARG double sigmaAvg=-1.]>

--- Incoming ---
[   u'cv.ximgproc.rollingGuidanceFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'd', u'-1', []],
        [u'double', u'sigmaColor', u'25', []],
        [u'double', u'sigmaSpace', u'3', []],
        [u'int', u'numOfIter', u'4', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv.ximgproc..rollingGuidanceFilter [ARG Mat src=, ARG Mat dst=, ARG int d=-1, ARG double sigmaColor=25, ARG double sigmaSpace=3, ARG int numOfIter=4, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'class cv.ximgproc.FastBilateralSolverFilter',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc::.FastBilateralSolverFilter : Algorithm, name: FastBilateralSolverFilter, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.FastBilateralSolverFilter.filter',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'confidence', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.FastBilateralSolverFilter.filter [ARG Mat src=, ARG Mat confidence=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.ximgproc.createFastBilateralSolverFilter',
    u'Ptr_FastBilateralSolverFilter',
    [],
    [   ['Mat', u'guide', '', []],
        [u'double', u'sigma_spatial', u'', []],
        [u'double', u'sigma_luma', u'', []],
        [u'double', u'sigma_chroma', u'', []],
        [u'double', u'lambda', u'128.0', []],
        [u'int', u'num_iter', u'25', []],
        [u'double', u'max_tol', u'1e-5', []]],
    u'Ptr<FastBilateralSolverFilter>']
ok: FUNC <Ptr_FastBilateralSolverFilter cv.ximgproc..createFastBilateralSolverFilter [ARG Mat guide=, ARG double sigma_spatial=, ARG double sigma_luma=, ARG double sigma_chroma=, ARG double lambda=128.0, ARG int num_iter=25, ARG double max_tol=1e-5]>

--- Incoming ---
[   u'cv.ximgproc.fastBilateralSolverFilter',
    u'void',
    [],
    [   ['Mat', u'guide', '', []],
        ['Mat', u'src', '', []],
        ['Mat', u'confidence', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'sigma_spatial', u'8', []],
        [u'double', u'sigma_luma', u'8', []],
        [u'double', u'sigma_chroma', u'8', []],
        [u'double', u'lambda', u'128.0', []],
        [u'int', u'num_iter', u'25', []],
        [u'double', u'max_tol', u'1e-5', []]],
    u'void']
ok: FUNC <void cv.ximgproc..fastBilateralSolverFilter [ARG Mat guide=, ARG Mat src=, ARG Mat confidence=, ARG Mat dst=, ARG double sigma_spatial=8, ARG double sigma_luma=8, ARG double sigma_chroma=8, ARG double lambda=128.0, ARG int num_iter=25, ARG double max_tol=1e-5]>

--- Incoming ---
[   u'class cv.ximgproc.FastGlobalSmootherFilter',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc::.FastGlobalSmootherFilter : Algorithm, name: FastGlobalSmootherFilter, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.FastGlobalSmootherFilter.filter',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.FastGlobalSmootherFilter.filter [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.ximgproc.createFastGlobalSmootherFilter',
    u'Ptr_FastGlobalSmootherFilter',
    [],
    [   ['Mat', u'guide', '', []],
        [u'double', u'lambda', u'', []],
        [u'double', u'sigma_color', u'', []],
        [u'double', u'lambda_attenuation', u'0.25', []],
        [u'int', u'num_iter', u'3', []]],
    u'Ptr<FastGlobalSmootherFilter>']
ok: FUNC <Ptr_FastGlobalSmootherFilter cv.ximgproc..createFastGlobalSmootherFilter [ARG Mat guide=, ARG double lambda=, ARG double sigma_color=, ARG double lambda_attenuation=0.25, ARG int num_iter=3]>

--- Incoming ---
[   u'cv.ximgproc.fastGlobalSmootherFilter',
    u'void',
    [],
    [   ['Mat', u'guide', '', []],
        ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'lambda', u'', []],
        [u'double', u'sigma_color', u'', []],
        [u'double', u'lambda_attenuation', u'0.25', []],
        [u'int', u'num_iter', u'3', []]],
    u'void']
ok: FUNC <void cv.ximgproc..fastGlobalSmootherFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG double lambda=, ARG double sigma_color=, ARG double lambda_attenuation=0.25, ARG int num_iter=3]>

--- Incoming ---
[   u'cv.ximgproc.l0Smooth',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'lambda', u'0.02', []],
        [u'double', u'kappa', u'2.0', []]],
    u'void']
ok: FUNC <void cv.ximgproc..l0Smooth [ARG Mat src=, ARG Mat dst=, ARG double lambda=0.02, ARG double kappa=2.0]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/seeds.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[u'class cv.ximgproc.SuperpixelSEEDS', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.SuperpixelSEEDS : Algorithm, name: SuperpixelSEEDS, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSEEDS.getNumberOfSuperpixels',
    u'int',
    ['/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ximgproc.SuperpixelSEEDS.getNumberOfSuperpixels []>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSEEDS.iterate',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'img', '', []], [u'int', u'num_iterations', u'4', []]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelSEEDS.iterate [ARG Mat img=, ARG int num_iterations=4]>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSEEDS.getLabels',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'labels_out', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelSEEDS.getLabels [ARG Mat labels_out=]>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelSEEDS.getLabelContourMask',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'image', '', ['/O']], [u'bool', u'thick_line', u'false', []]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelSEEDS.getLabelContourMask [ARG Mat image=, ARG bool thick_line=false]>

--- Incoming ---
[   u'cv.ximgproc.createSuperpixelSEEDS',
    u'Ptr_SuperpixelSEEDS',
    [],
    [   [u'int', u'image_width', u'', []],
        [u'int', u'image_height', u'', []],
        [u'int', u'image_channels', u'', []],
        [u'int', u'num_superpixels', u'', []],
        [u'int', u'num_levels', u'', []],
        [u'int', u'prior', u'2', []],
        [u'int', u'histogram_bins', u'5', []],
        [u'bool', u'double_step', u'false', []]],
    u'Ptr<SuperpixelSEEDS>']
ok: FUNC <Ptr_SuperpixelSEEDS cv.ximgproc..createSuperpixelSEEDS [ARG int image_width=, ARG int image_height=, ARG int image_channels=, ARG int num_superpixels=, ARG int num_levels=, ARG int prior=2, ARG int histogram_bins=5, ARG bool double_step=false]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/lsc.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[u'class cv.ximgproc.SuperpixelLSC', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.SuperpixelLSC : Algorithm, name: SuperpixelLSC, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.SuperpixelLSC.getNumberOfSuperpixels',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ximgproc.SuperpixelLSC.getNumberOfSuperpixels []>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelLSC.iterate',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'num_iterations', u'10', []]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelLSC.iterate [ARG int num_iterations=10]>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelLSC.getLabels',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'labels_out', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelLSC.getLabels [ARG Mat labels_out=]>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelLSC.getLabelContourMask',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'image', '', ['/O']], [u'bool', u'thick_line', u'true', []]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelLSC.getLabelContourMask [ARG Mat image=, ARG bool thick_line=true]>

--- Incoming ---
[   u'cv.ximgproc.SuperpixelLSC.enforceLabelConnectivity',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'min_element_size', u'20', []]],
    u'void']
ok: FUNC <void cv.ximgproc.SuperpixelLSC.enforceLabelConnectivity [ARG int min_element_size=20]>

--- Incoming ---
[   u'cv.ximgproc.createSuperpixelLSC',
    u'Ptr_SuperpixelLSC',
    [],
    [   ['Mat', u'image', '', []],
        [u'int', u'region_size', u'10', []],
        [u'float', u'ratio', u'0.075f', []]],
    u'Ptr<SuperpixelLSC>']
ok: FUNC <Ptr_SuperpixelLSC cv.ximgproc..createSuperpixelLSC [ARG Mat image=, ARG int region_size=10, ARG float ratio=0.075f]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/ridgefilter.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[u'class cv.ximgproc.RidgeDetectionFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.RidgeDetectionFilter : Algorithm, name: RidgeDetectionFilter, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.RidgeDetectionFilter.create',
    u'Ptr_RidgeDetectionFilter',
    ['/S'],
    [   [u'int', u'ddepth', u'CV_32FC1', []],
        [u'int', u'dx', u'1', []],
        [u'int', u'dy', u'1', []],
        [u'int', u'ksize', u'3', []],
        [u'int', u'out_dtype', u'CV_8UC1', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'Ptr<RidgeDetectionFilter>']
ok: FUNC <Ptr_RidgeDetectionFilter cv.ximgproc.RidgeDetectionFilter.create [ARG int ddepth=CV_32FC1, ARG int dx=1, ARG int dy=1, ARG int ksize=3, ARG int out_dtype=CV_8UC1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.ximgproc.RidgeDetectionFilter.getRidgeFilteredImage',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'_img', '', []], ['Mat', u'out', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.RidgeDetectionFilter.getRidgeFilteredImage [ARG Mat _img=, ARG Mat out=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/structured_edge_detection.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv'])

--- Incoming ---
[u'class cv.ximgproc.RFFeatureGetter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.RFFeatureGetter : Algorithm, name: RFFeatureGetter, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.RFFeatureGetter.getFeatures',
    u'void',
    ['/C', '/V', '/PV'],
    [   [u'Mat', u'src', u'', ['/C', '/Ref']],
        [u'Mat', u'features', u'', ['/Ref']],
        [u'int', u'gnrmRad', u'', ['/C']],
        [u'int', u'gsmthRad', u'', ['/C']],
        [u'int', u'shrink', u'', ['/C']],
        [u'int', u'outNum', u'', ['/C']],
        [u'int', u'gradNum', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.ximgproc.RFFeatureGetter.getFeatures [ARG Mat src=, ARG Mat features=, ARG int gnrmRad=, ARG int gsmthRad=, ARG int shrink=, ARG int outNum=, ARG int gradNum=]>

--- Incoming ---
[   u'cv.ximgproc.createRFFeatureGetter',
    u'Ptr_RFFeatureGetter',
    [],
    [],
    u'Ptr<RFFeatureGetter>']
ok: FUNC <Ptr_RFFeatureGetter cv.ximgproc..createRFFeatureGetter []>

--- Incoming ---
[u'class cv.ximgproc.StructuredEdgeDetection', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.StructuredEdgeDetection : Algorithm, name: StructuredEdgeDetection, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.StructuredEdgeDetection.detectEdges',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'_src', '', []], ['Mat', u'_dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.StructuredEdgeDetection.detectEdges [ARG Mat _src=, ARG Mat _dst=]>

--- Incoming ---
[   u'cv.ximgproc.StructuredEdgeDetection.computeOrientation',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'_src', '', []], ['Mat', u'_dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.StructuredEdgeDetection.computeOrientation [ARG Mat _src=, ARG Mat _dst=]>

--- Incoming ---
[   u'cv.ximgproc.StructuredEdgeDetection.edgesNms',
    u'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'edge_image', '', []],
        ['Mat', u'orientation_image', '', []],
        ['Mat', u'_dst', '', ['/O']],
        [u'int', u'r', u'2', []],
        [u'int', u's', u'0', []],
        [u'float', u'm', u'1', []],
        [u'bool', u'isParallel', u'true', []]],
    u'void']
ok: FUNC <void cv.ximgproc.StructuredEdgeDetection.edgesNms [ARG Mat edge_image=, ARG Mat orientation_image=, ARG Mat _dst=, ARG int r=2, ARG int s=0, ARG float m=1, ARG bool isParallel=true]>

--- Incoming ---
[   u'cv.ximgproc.createStructuredEdgeDetection',
    u'Ptr_StructuredEdgeDetection',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [   u'Ptr_RFFeatureGetter',
            u'howToGetFeatures',
            u'Ptr<RFFeatureGetter>()',
            ['/C']]],
    u'Ptr<StructuredEdgeDetection>']
ok: FUNC <Ptr_StructuredEdgeDetection cv.ximgproc..createStructuredEdgeDetection [ARG String model=, ARG Ptr_RFFeatureGetter howToGetFeatures=Ptr<RFFeatureGetter>()]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/segmentation.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv', u'cv.ximgproc.segmentation'])

--- Incoming ---
[   u'class cv.ximgproc.segmentation.GraphSegmentation',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.GraphSegmentation : Algorithm, name: GraphSegmentation, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.segmentation.GraphSegmentation.processImage',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.GraphSegmentation.processImage [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.GraphSegmentation.setSigma',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'sigma', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setSigma [ARG double sigma=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.GraphSegmentation.getSigma',
    u'double',
    ['/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ximgproc.segmentation.GraphSegmentation.getSigma []>

--- Incoming ---
[   u'cv.ximgproc.segmentation.GraphSegmentation.setK',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'k', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setK [ARG float k=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.GraphSegmentation.getK',
    u'float',
    ['/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.segmentation.GraphSegmentation.getK []>

--- Incoming ---
[   u'cv.ximgproc.segmentation.GraphSegmentation.setMinSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'min_size', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setMinSize [ARG int min_size=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.GraphSegmentation.getMinSize',
    u'int',
    ['/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ximgproc.segmentation.GraphSegmentation.getMinSize []>

--- Incoming ---
[   u'cv.ximgproc.segmentation.createGraphSegmentation',
    u'Ptr_GraphSegmentation',
    [],
    [   [u'double', u'sigma', u'0.5', []],
        [u'float', u'k', u'300', []],
        [u'int', u'min_size', u'100', []]],
    u'Ptr<GraphSegmentation>']
ok: FUNC <Ptr_GraphSegmentation cv.ximgproc.segmentation..createGraphSegmentation [ARG double sigma=0.5, ARG float k=300, ARG int min_size=100]>

--- Incoming ---
[   u'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategy : Algorithm, name: SelectiveSearchSegmentationStrategy, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.setImage',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'img', '', []],
        ['Mat', u'regions', '', []],
        ['Mat', u'sizes', '', []],
        [u'int', u'image_id', u'-1', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.setImage [ARG Mat img=, ARG Mat regions=, ARG Mat sizes=, ARG int image_id=-1]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.get',
    u'float',
    ['/V', '/PV'],
    [[u'int', u'r1', u'', []], [u'int', u'r2', u'', []]],
    u'float']
ok: FUNC <float cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.get [ARG int r1=, ARG int r2=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.merge',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'r1', u'', []], [u'int', u'r2', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.merge [ARG int r1=, ARG int r2=]>

--- Incoming ---
[   u'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyColor',
    u': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyColor : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategyColor, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyColor',
    u'Ptr_SelectiveSearchSegmentationStrategyColor',
    [],
    [],
    u'Ptr<SelectiveSearchSegmentationStrategyColor>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyColor cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyColor []>

--- Incoming ---
[   u'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategySize',
    u': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategySize : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategySize, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategySize',
    u'Ptr_SelectiveSearchSegmentationStrategySize',
    [],
    [],
    u'Ptr<SelectiveSearchSegmentationStrategySize>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategySize cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategySize []>

--- Incoming ---
[   u'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyTexture',
    u': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyTexture : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategyTexture, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyTexture',
    u'Ptr_SelectiveSearchSegmentationStrategyTexture',
    [],
    [],
    u'Ptr<SelectiveSearchSegmentationStrategyTexture>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyTexture cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyTexture []>

--- Incoming ---
[   u'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyFill',
    u': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyFill : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategyFill, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyFill',
    u'Ptr_SelectiveSearchSegmentationStrategyFill',
    [],
    [],
    u'Ptr<SelectiveSearchSegmentationStrategyFill>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyFill cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyFill []>

--- Incoming ---
[   u'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple',
    u': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyMultiple : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategyMultiple, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.addStrategy',
    u'void',
    ['/V', '/PV'],
    [   [u'Ptr_SelectiveSearchSegmentationStrategy', u'g', u'', []],
        [u'float', u'weight', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.addStrategy [ARG Ptr_SelectiveSearchSegmentationStrategy g=, ARG float weight=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.clearStrategies',
    u'void',
    ['/V', '/PV'],
    [],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.clearStrategies []>

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    u'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [],
    u'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple []>

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    u'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [[u'Ptr_SelectiveSearchSegmentationStrategy', u's1', u'', []]],
    u'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    u'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [   [u'Ptr_SelectiveSearchSegmentationStrategy', u's1', u'', []],
        [u'Ptr_SelectiveSearchSegmentationStrategy', u's2', u'', []]],
    u'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    u'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [   [u'Ptr_SelectiveSearchSegmentationStrategy', u's1', u'', []],
        [u'Ptr_SelectiveSearchSegmentationStrategy', u's2', u'', []],
        [u'Ptr_SelectiveSearchSegmentationStrategy', u's3', u'', []]],
    u'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=, ARG Ptr_SelectiveSearchSegmentationStrategy s3=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    u'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [   [u'Ptr_SelectiveSearchSegmentationStrategy', u's1', u'', []],
        [u'Ptr_SelectiveSearchSegmentationStrategy', u's2', u'', []],
        [u'Ptr_SelectiveSearchSegmentationStrategy', u's3', u'', []],
        [u'Ptr_SelectiveSearchSegmentationStrategy', u's4', u'', []]],
    u'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=, ARG Ptr_SelectiveSearchSegmentationStrategy s3=, ARG Ptr_SelectiveSearchSegmentationStrategy s4=]>

--- Incoming ---
[   u'class cv.ximgproc.segmentation.SelectiveSearchSegmentation',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentation : Algorithm, name: SelectiveSearchSegmentation, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.setBaseImage',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'img', '', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.setBaseImage [ARG Mat img=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSingleStrategy',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'k', u'200', []], [u'float', u'sigma', u'0.8f', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSingleStrategy [ARG int k=200, ARG float sigma=0.8f]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchFast',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'base_k', u'150', []],
        [u'int', u'inc_k', u'150', []],
        [u'float', u'sigma', u'0.8f', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchFast [ARG int base_k=150, ARG int inc_k=150, ARG float sigma=0.8f]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchQuality',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'base_k', u'150', []],
        [u'int', u'inc_k', u'150', []],
        [u'float', u'sigma', u'0.8f', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchQuality [ARG int base_k=150, ARG int inc_k=150, ARG float sigma=0.8f]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.addImage',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'img', '', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addImage [ARG Mat img=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearImages',
    u'void',
    ['/V', '/PV'],
    [],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearImages []>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.addGraphSegmentation',
    u'void',
    ['/V', '/PV'],
    [[u'Ptr_GraphSegmentation', u'g', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addGraphSegmentation [ARG Ptr_GraphSegmentation g=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearGraphSegmentations',
    u'void',
    ['/V', '/PV'],
    [],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearGraphSegmentations []>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.addStrategy',
    u'void',
    ['/V', '/PV'],
    [[u'Ptr_SelectiveSearchSegmentationStrategy', u's', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addStrategy [ARG Ptr_SelectiveSearchSegmentationStrategy s=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearStrategies',
    u'void',
    ['/V', '/PV'],
    [],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearStrategies []>

--- Incoming ---
[   u'cv.ximgproc.segmentation.SelectiveSearchSegmentation.process',
    u'void',
    ['/V', '/PV'],
    [[u'vector_Rect', u'rects', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.process [ARG vector_Rect rects=]>

--- Incoming ---
[   u'cv.ximgproc.segmentation.createSelectiveSearchSegmentation',
    u'Ptr_SelectiveSearchSegmentation',
    [],
    [],
    u'Ptr<SelectiveSearchSegmentation>']
ok: FUNC <Ptr_SelectiveSearchSegmentation cv.ximgproc.segmentation..createSelectiveSearchSegmentation []>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/deriche_filter.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv', u'cv.ximgproc.segmentation'])

--- Incoming ---
[   u'cv.ximgproc.GradientDericheY',
    u'void',
    [],
    [   ['Mat', u'op', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'alpha', u'', []],
        [u'double', u'omega', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc..GradientDericheY [ARG Mat op=, ARG Mat dst=, ARG double alpha=, ARG double omega=]>

--- Incoming ---
[   u'cv.ximgproc.GradientDericheX',
    u'void',
    [],
    [   ['Mat', u'op', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'alpha', u'', []],
        [u'double', u'omega', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc..GradientDericheX [ARG Mat op=, ARG Mat dst=, ARG double alpha=, ARG double omega=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edgepreserving_filter.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv', u'cv.ximgproc.segmentation'])

--- Incoming ---
[   u'cv.ximgproc.edgePreservingFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'd', u'', []],
        [u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double threshold=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edgeboxes.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv', u'cv.ximgproc.segmentation'])

--- Incoming ---
[u'class cv.ximgproc.EdgeBoxes', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.EdgeBoxes : Algorithm, name: EdgeBoxes, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getBoundingBoxes',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'edge_map', '', []],
        ['Mat', u'orientation_map', '', []],
        [u'vector_Rect', u'boxes', u'', ['/O', '/Ref']],
        ['Mat', u'scores', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.getBoundingBoxes [ARG Mat edge_map=, ARG Mat orientation_map=, ARG vector_Rect boxes=, ARG Mat scores=Mat()]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getAlpha',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getAlpha []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setAlpha',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setAlpha [ARG float value=]>

--- Incoming ---
[u'cv.ximgproc.EdgeBoxes.getBeta', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getBeta []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setBeta',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setBeta [ARG float value=]>

--- Incoming ---
[u'cv.ximgproc.EdgeBoxes.getEta', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getEta []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setEta',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setEta [ARG float value=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getMinScore',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getMinScore []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setMinScore',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setMinScore [ARG float value=]>

--- Incoming ---
[u'cv.ximgproc.EdgeBoxes.getMaxBoxes', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ximgproc.EdgeBoxes.getMaxBoxes []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setMaxBoxes',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setMaxBoxes [ARG int value=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getEdgeMinMag',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getEdgeMinMag []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setEdgeMinMag',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setEdgeMinMag [ARG float value=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getEdgeMergeThr',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getEdgeMergeThr []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setEdgeMergeThr',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setEdgeMergeThr [ARG float value=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getClusterMinMag',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getClusterMinMag []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setClusterMinMag',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setClusterMinMag [ARG float value=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getMaxAspectRatio',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getMaxAspectRatio []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setMaxAspectRatio',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setMaxAspectRatio [ARG float value=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getMinBoxArea',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getMinBoxArea []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setMinBoxArea',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setMinBoxArea [ARG float value=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getGamma',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getGamma []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setGamma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setGamma [ARG float value=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.getKappa',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getKappa []>

--- Incoming ---
[   u'cv.ximgproc.EdgeBoxes.setKappa',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setKappa [ARG float value=]>

--- Incoming ---
[   u'cv.ximgproc.createEdgeBoxes',
    u'Ptr_EdgeBoxes',
    [],
    [   [u'float', u'alpha', u'0.65f', []],
        [u'float', u'beta', u'0.75f', []],
        [u'float', u'eta', u'1', []],
        [u'float', u'minScore', u'0.01f', []],
        [u'int', u'maxBoxes', u'10000', []],
        [u'float', u'edgeMinMag', u'0.1f', []],
        [u'float', u'edgeMergeThr', u'0.5f', []],
        [u'float', u'clusterMinMag', u'0.5f', []],
        [u'float', u'maxAspectRatio', u'3', []],
        [u'float', u'minBoxArea', u'1000', []],
        [u'float', u'gamma', u'2', []],
        [u'float', u'kappa', u'1.5f', []]],
    u'Ptr<EdgeBoxes>']
ok: FUNC <Ptr_EdgeBoxes cv.ximgproc..createEdgeBoxes [ARG float alpha=0.65f, ARG float beta=0.75f, ARG float eta=1, ARG float minScore=0.01f, ARG int maxBoxes=10000, ARG float edgeMinMag=0.1f, ARG float edgeMergeThr=0.5f, ARG float clusterMinMag=0.5f, ARG float maxAspectRatio=3, ARG float minBoxArea=1000, ARG float gamma=2, ARG float kappa=1.5f]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/run_length_morphology.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv.ximgproc.rl', u'cv', u'cv.ximgproc.segmentation'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/run_length_morphology.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv.ximgproc.rl', u'cv', u'cv.ximgproc.segmentation'])

--- Incoming ---
[u'class cv.ximgproc.SparseMatchInterpolator', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.SparseMatchInterpolator : Algorithm, name: SparseMatchInterpolator, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.SparseMatchInterpolator.interpolate',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'from_image', '', []],
        ['Mat', u'from_points', '', []],
        ['Mat', u'to_image', '', []],
        ['Mat', u'to_points', '', []],
        ['Mat', u'dense_flow', '', ['/O']]],
    u'void']
ok: FUNC <void cv.ximgproc.SparseMatchInterpolator.interpolate [ARG Mat from_image=, ARG Mat from_points=, ARG Mat to_image=, ARG Mat to_points=, ARG Mat dense_flow=]>

--- Incoming ---
[   u'class cv.ximgproc.EdgeAwareInterpolator',
    u': cv::ximgproc::SparseMatchInterpolator',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc::.EdgeAwareInterpolator : SparseMatchInterpolator, name: EdgeAwareInterpolator, base: SparseMatchInterpolator

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.setK',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_k', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setK [ARG int _k=]>

--- Incoming ---
[u'cv.ximgproc.EdgeAwareInterpolator.getK', u'int', ['/V', '/PV'], [], u'int']
ok: FUNC <int cv.ximgproc.EdgeAwareInterpolator.getK []>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.setSigma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'_sigma', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setSigma [ARG float _sigma=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.getSigma',
    u'float',
    ['/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeAwareInterpolator.getSigma []>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.setLambda',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'_lambda', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setLambda [ARG float _lambda=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.getLambda',
    u'float',
    ['/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeAwareInterpolator.getLambda []>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.setUsePostProcessing',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'_use_post_proc', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setUsePostProcessing [ARG bool _use_post_proc=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.getUsePostProcessing',
    u'bool',
    ['/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.ximgproc.EdgeAwareInterpolator.getUsePostProcessing []>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.setFGSLambda',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'_lambda', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setFGSLambda [ARG float _lambda=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.getFGSLambda',
    u'float',
    ['/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeAwareInterpolator.getFGSLambda []>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.setFGSSigma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'_sigma', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setFGSSigma [ARG float _sigma=]>

--- Incoming ---
[   u'cv.ximgproc.EdgeAwareInterpolator.getFGSSigma',
    u'float',
    ['/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ximgproc.EdgeAwareInterpolator.getFGSSigma []>

--- Incoming ---
[   u'cv.ximgproc.createEdgeAwareInterpolator',
    u'Ptr_EdgeAwareInterpolator',
    [],
    [],
    u'Ptr<EdgeAwareInterpolator>']
ok: FUNC <Ptr_EdgeAwareInterpolator cv.ximgproc..createEdgeAwareInterpolator []>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/weighted_median_filter.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv.ximgproc.rl', u'cv', u'cv.ximgproc.segmentation'])

--- Incoming ---
[   u'enum cv.ximgproc.WMFWeightType',
    '',
    [],
    [   [u'const cv.ximgproc.WMF_EXP', u'1', [], [], None, ''],
        [u'const cv.ximgproc.WMF_IV1', u'1 << 1', [], [], None, ''],
        [u'const cv.ximgproc.WMF_IV2', u'1 << 2', [], [], None, ''],
        [u'const cv.ximgproc.WMF_COS', u'1 << 3', [], [], None, ''],
        [u'const cv.ximgproc.WMF_JAC', u'1 << 4', [], [], None, ''],
        [u'const cv.ximgproc.WMF_OFF', u'1 << 5', [], [], None, '']],
    None]
ok: CONST WMF_EXP=1
ok: CONST WMF_IV1=1 << 1
ok: CONST WMF_IV2=1 << 2
ok: CONST WMF_COS=1 << 3
ok: CONST WMF_JAC=1 << 4
ok: CONST WMF_OFF=1 << 5

--- Incoming ---
[   u'cv.ximgproc.weightedMedianFilter',
    u'void',
    [],
    [   ['Mat', u'joint', '', []],
        ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'r', u'', []],
        [u'double', u'sigma', u'25.5', []],
        [u'int', u'weightType', u'WMF_EXP', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.ximgproc..weightedMedianFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG int r=, ARG double sigma=25.5, ARG int weightType=WMF_EXP, ARG Mat mask=Mat()]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/disparity_filter.hpp =====
Namespaces: set([u'cv.ximgproc', u'cv.ximgproc.rl', u'cv', u'cv.ximgproc.segmentation'])

--- Incoming ---
[u'class cv.ximgproc.DisparityFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.DisparityFilter : Algorithm, name: DisparityFilter, base: Algorithm

--- Incoming ---
[   u'cv.ximgproc.DisparityFilter.filter',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'disparity_map_left', '', []],
        ['Mat', u'left_view', '', []],
        ['Mat', u'filtered_disparity_map', '', ['/O']],
        ['Mat', u'disparity_map_right', u'Mat()', []],
        [u'Rect', u'ROI', u'Rect()', []],
        ['Mat', u'right_view', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.ximgproc.DisparityFilter.filter [ARG Mat disparity_map_left=, ARG Mat left_view=, ARG Mat filtered_disparity_map=, ARG Mat disparity_map_right=Mat(), ARG Rect ROI=Rect(), ARG Mat right_view=Mat()]>

--- Incoming ---
[   u'class cv.ximgproc.DisparityWLSFilter',
    u': cv::ximgproc::DisparityFilter',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc::.DisparityWLSFilter : DisparityFilter, name: DisparityWLSFilter, base: DisparityFilter

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.getLambda',
    u'double',
    ['/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ximgproc.DisparityWLSFilter.getLambda []>

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.setLambda',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_lambda', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.DisparityWLSFilter.setLambda [ARG double _lambda=]>

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.getSigmaColor',
    u'double',
    ['/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ximgproc.DisparityWLSFilter.getSigmaColor []>

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.setSigmaColor',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_sigma_color', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.DisparityWLSFilter.setSigmaColor [ARG double _sigma_color=]>

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.getLRCthresh',
    u'int',
    ['/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ximgproc.DisparityWLSFilter.getLRCthresh []>

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.setLRCthresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_LRC_thresh', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.DisparityWLSFilter.setLRCthresh [ARG int _LRC_thresh=]>

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.getDepthDiscontinuityRadius',
    u'int',
    ['/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ximgproc.DisparityWLSFilter.getDepthDiscontinuityRadius []>

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.setDepthDiscontinuityRadius',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_disc_radius', u'', []]],
    u'void']
ok: FUNC <void cv.ximgproc.DisparityWLSFilter.setDepthDiscontinuityRadius [ARG int _disc_radius=]>

--- Incoming ---
[   u'cv.ximgproc.DisparityWLSFilter.getConfidenceMap',
    u'Mat',
    ['/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ximgproc.DisparityWLSFilter.getConfidenceMap []>

--- Incoming ---
[u'cv.ximgproc.DisparityWLSFilter.getROI', u'Rect', ['/V', '/PV'], [], u'Rect']
ok: FUNC <Rect cv.ximgproc.DisparityWLSFilter.getROI []>

--- Incoming ---
[   u'cv.ximgproc.createDisparityWLSFilter',
    u'Ptr_DisparityWLSFilter',
    [],
    [[u'Ptr_StereoMatcher', u'matcher_left', u'', []]],
    u'Ptr<DisparityWLSFilter>']
ok: FUNC <Ptr_DisparityWLSFilter cv.ximgproc..createDisparityWLSFilter [ARG Ptr_StereoMatcher matcher_left=]>

--- Incoming ---
[   u'cv.ximgproc.createRightMatcher',
    u'Ptr_StereoMatcher',
    [],
    [[u'Ptr_StereoMatcher', u'matcher_left', u'', []]],
    u'Ptr<StereoMatcher>']
ok: FUNC <Ptr_StereoMatcher cv.ximgproc..createRightMatcher [ARG Ptr_StereoMatcher matcher_left=]>

--- Incoming ---
[   u'cv.ximgproc.createDisparityWLSFilterGeneric',
    u'Ptr_DisparityWLSFilter',
    [],
    [[u'bool', u'use_confidence', u'', []]],
    u'Ptr<DisparityWLSFilter>']
ok: FUNC <Ptr_DisparityWLSFilter cv.ximgproc..createDisparityWLSFilterGeneric [ARG bool use_confidence=]>


===== Generating... =====
CLASS cv.ximgproc::.StructuredEdgeDetection : Algorithm
FUNC <void cv.ximgproc.StructuredEdgeDetection.computeOrientation [ARG Mat _src=, ARG Mat _dst=]>
java: void computeOrientation(Mat _src, Mat _dst)
FUNC <void cv.ximgproc.StructuredEdgeDetection.detectEdges [ARG Mat _src=, ARG Mat _dst=]>
java: void detectEdges(Mat _src, Mat _dst)
FUNC <void cv.ximgproc.StructuredEdgeDetection.edgesNms [ARG Mat edge_image=, ARG Mat orientation_image=, ARG Mat _dst=, ARG int r=2, ARG int s=0, ARG float m=1, ARG bool isParallel=true]>
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat _dst, int r, int s, float m, boolean isParallel)
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat _dst, int r, int s, float m)
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat _dst, int r, int s)
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat _dst, int r)
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat _dst)
CLASS cv.ximgproc::.FastLineDetector : Algorithm
FUNC <void cv.ximgproc.FastLineDetector.detect [ARG Mat _image=, ARG Mat _lines=]>
java: void detect(Mat _image, Mat _lines)
FUNC <void cv.ximgproc.FastLineDetector.drawSegments [ARG Mat _image=, ARG Mat lines=, ARG bool draw_arrow=false]>
java: void drawSegments(Mat _image, Mat lines, boolean draw_arrow)
java: void drawSegments(Mat _image, Mat lines)
CLASS cv.ximgproc::.EdgeBoxes : Algorithm
FUNC <float cv.ximgproc.EdgeBoxes.getAlpha []>
java: float getAlpha()
FUNC <float cv.ximgproc.EdgeBoxes.getBeta []>
java: float getBeta()
FUNC <float cv.ximgproc.EdgeBoxes.getClusterMinMag []>
java: float getClusterMinMag()
FUNC <float cv.ximgproc.EdgeBoxes.getEdgeMergeThr []>
java: float getEdgeMergeThr()
FUNC <float cv.ximgproc.EdgeBoxes.getEdgeMinMag []>
java: float getEdgeMinMag()
FUNC <float cv.ximgproc.EdgeBoxes.getEta []>
java: float getEta()
FUNC <float cv.ximgproc.EdgeBoxes.getGamma []>
java: float getGamma()
FUNC <float cv.ximgproc.EdgeBoxes.getKappa []>
java: float getKappa()
FUNC <float cv.ximgproc.EdgeBoxes.getMaxAspectRatio []>
java: float getMaxAspectRatio()
FUNC <float cv.ximgproc.EdgeBoxes.getMinBoxArea []>
java: float getMinBoxArea()
FUNC <float cv.ximgproc.EdgeBoxes.getMinScore []>
java: float getMinScore()
FUNC <int cv.ximgproc.EdgeBoxes.getMaxBoxes []>
java: int getMaxBoxes()
FUNC <void cv.ximgproc.EdgeBoxes.getBoundingBoxes [ARG Mat edge_map=, ARG Mat orientation_map=, ARG vector_Rect boxes=, ARG Mat scores=Mat()]>
java: void getBoundingBoxes(Mat edge_map, Mat orientation_map, MatOfRect boxes, Mat scores)
java: void getBoundingBoxes(Mat edge_map, Mat orientation_map, MatOfRect boxes)
FUNC <void cv.ximgproc.EdgeBoxes.setAlpha [ARG float value=]>
java: void setAlpha(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setBeta [ARG float value=]>
java: void setBeta(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setClusterMinMag [ARG float value=]>
java: void setClusterMinMag(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setEdgeMergeThr [ARG float value=]>
java: void setEdgeMergeThr(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setEdgeMinMag [ARG float value=]>
java: void setEdgeMinMag(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setEta [ARG float value=]>
java: void setEta(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setGamma [ARG float value=]>
java: void setGamma(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setKappa [ARG float value=]>
java: void setKappa(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setMaxAspectRatio [ARG float value=]>
java: void setMaxAspectRatio(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setMaxBoxes [ARG int value=]>
java: void setMaxBoxes(int value)
FUNC <void cv.ximgproc.EdgeBoxes.setMinBoxArea [ARG float value=]>
java: void setMinBoxArea(float value)
FUNC <void cv.ximgproc.EdgeBoxes.setMinScore [ARG float value=]>
java: void setMinScore(float value)
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyFill : SelectiveSearchSegmentationStrategy
CLASS cv.ximgproc::.SuperpixelSEEDS : Algorithm
FUNC <int cv.ximgproc.SuperpixelSEEDS.getNumberOfSuperpixels []>
java: int getNumberOfSuperpixels()
FUNC <void cv.ximgproc.SuperpixelSEEDS.getLabelContourMask [ARG Mat image=, ARG bool thick_line=false]>
java: void getLabelContourMask(Mat image, boolean thick_line)
java: void getLabelContourMask(Mat image)
FUNC <void cv.ximgproc.SuperpixelSEEDS.getLabels [ARG Mat labels_out=]>
java: void getLabels(Mat labels_out)
FUNC <void cv.ximgproc.SuperpixelSEEDS.iterate [ARG Mat img=, ARG int num_iterations=4]>
java: void iterate(Mat img, int num_iterations)
java: void iterate(Mat img)
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategy : Algorithm
FUNC <float cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.get [ARG int r1=, ARG int r2=]>
java: float get(int r1, int r2)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.merge [ARG int r1=, ARG int r2=]>
java: void merge(int r1, int r2)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.setImage [ARG Mat img=, ARG Mat regions=, ARG Mat sizes=, ARG int image_id=-1]>
java: void setImage(Mat img, Mat regions, Mat sizes, int image_id)
java: void setImage(Mat img, Mat regions, Mat sizes)
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyTexture : SelectiveSearchSegmentationStrategy
CLASS cv.ximgproc::.SparseMatchInterpolator : Algorithm
FUNC <void cv.ximgproc.SparseMatchInterpolator.interpolate [ARG Mat from_image=, ARG Mat from_points=, ARG Mat to_image=, ARG Mat to_points=, ARG Mat dense_flow=]>
java: void interpolate(Mat from_image, Mat from_points, Mat to_image, Mat to_points, Mat dense_flow)
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyMultiple : SelectiveSearchSegmentationStrategy
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.addStrategy [ARG Ptr_SelectiveSearchSegmentationStrategy g=, ARG float weight=]>
java: void addStrategy(SelectiveSearchSegmentationStrategy g, float weight)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.clearStrategies []>
java: void clearStrategies()
CLASS cv.ximgproc::.DTFilter : Algorithm
FUNC <void cv.ximgproc.DTFilter.filter [ARG Mat src=, ARG Mat dst=, ARG int dDepth=-1]>
java: void filter(Mat src, Mat dst, int dDepth)
java: void filter(Mat src, Mat dst)
CLASS cv.ximgproc::.FastBilateralSolverFilter : Algorithm
FUNC <void cv.ximgproc.FastBilateralSolverFilter.filter [ARG Mat src=, ARG Mat confidence=, ARG Mat dst=]>
java: void filter(Mat src, Mat confidence, Mat dst)
CLASS cv.ximgproc::.SuperpixelLSC : Algorithm
FUNC <int cv.ximgproc.SuperpixelLSC.getNumberOfSuperpixels []>
java: int getNumberOfSuperpixels()
FUNC <void cv.ximgproc.SuperpixelLSC.enforceLabelConnectivity [ARG int min_element_size=20]>
java: void enforceLabelConnectivity(int min_element_size)
java: void enforceLabelConnectivity()
FUNC <void cv.ximgproc.SuperpixelLSC.getLabelContourMask [ARG Mat image=, ARG bool thick_line=true]>
java: void getLabelContourMask(Mat image, boolean thick_line)
java: void getLabelContourMask(Mat image)
FUNC <void cv.ximgproc.SuperpixelLSC.getLabels [ARG Mat labels_out=]>
java: void getLabels(Mat labels_out)
FUNC <void cv.ximgproc.SuperpixelLSC.iterate [ARG int num_iterations=10]>
java: void iterate(int num_iterations)
java: void iterate()
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyColor : SelectiveSearchSegmentationStrategy
CLASS cv.ximgproc::.DisparityFilter : Algorithm
FUNC <void cv.ximgproc.DisparityFilter.filter [ARG Mat disparity_map_left=, ARG Mat left_view=, ARG Mat filtered_disparity_map=, ARG Mat disparity_map_right=Mat(), ARG Rect ROI=Rect(), ARG Mat right_view=Mat()]>
java: void filter(Mat disparity_map_left, Mat left_view, Mat filtered_disparity_map, Mat disparity_map_right, Rect ROI, Mat right_view)
java: void filter(Mat disparity_map_left, Mat left_view, Mat filtered_disparity_map, Mat disparity_map_right, Rect ROI)
java: void filter(Mat disparity_map_left, Mat left_view, Mat filtered_disparity_map, Mat disparity_map_right)
java: void filter(Mat disparity_map_left, Mat left_view, Mat filtered_disparity_map)
CLASS cv.ximgproc::.DisparityWLSFilter : DisparityFilter
FUNC <Mat cv.ximgproc.DisparityWLSFilter.getConfidenceMap []>
java: Mat getConfidenceMap()
FUNC <Rect cv.ximgproc.DisparityWLSFilter.getROI []>
java: Rect getROI()
FUNC <double cv.ximgproc.DisparityWLSFilter.getLambda []>
java: double getLambda()
FUNC <double cv.ximgproc.DisparityWLSFilter.getSigmaColor []>
java: double getSigmaColor()
FUNC <int cv.ximgproc.DisparityWLSFilter.getDepthDiscontinuityRadius []>
java: int getDepthDiscontinuityRadius()
FUNC <int cv.ximgproc.DisparityWLSFilter.getLRCthresh []>
java: int getLRCthresh()
FUNC <void cv.ximgproc.DisparityWLSFilter.setDepthDiscontinuityRadius [ARG int _disc_radius=]>
java: void setDepthDiscontinuityRadius(int _disc_radius)
FUNC <void cv.ximgproc.DisparityWLSFilter.setLRCthresh [ARG int _LRC_thresh=]>
java: void setLRCthresh(int _LRC_thresh)
FUNC <void cv.ximgproc.DisparityWLSFilter.setLambda [ARG double _lambda=]>
java: void setLambda(double _lambda)
FUNC <void cv.ximgproc.DisparityWLSFilter.setSigmaColor [ARG double _sigma_color=]>
java: void setSigmaColor(double _sigma_color)
CLASS cv.ximgproc::.RidgeDetectionFilter : Algorithm
FUNC <Ptr_RidgeDetectionFilter cv.ximgproc.RidgeDetectionFilter.create [ARG int ddepth=CV_32FC1, ARG int dx=1, ARG int dy=1, ARG int ksize=3, ARG int out_dtype=CV_8UC1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize, int out_dtype, double scale, double delta, int borderType)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize, int out_dtype, double scale, double delta)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize, int out_dtype, double scale)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize, int out_dtype)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy)
java: RidgeDetectionFilter create(int ddepth, int dx)
java: RidgeDetectionFilter create(int ddepth)
java: RidgeDetectionFilter create()
FUNC <void cv.ximgproc.RidgeDetectionFilter.getRidgeFilteredImage [ARG Mat _img=, ARG Mat out=]>
java: void getRidgeFilteredImage(Mat _img, Mat out)
CLASS cv.ximgproc::.EdgeAwareInterpolator : SparseMatchInterpolator
FUNC <bool cv.ximgproc.EdgeAwareInterpolator.getUsePostProcessing []>
java: boolean getUsePostProcessing()
FUNC <float cv.ximgproc.EdgeAwareInterpolator.getFGSLambda []>
java: float getFGSLambda()
FUNC <float cv.ximgproc.EdgeAwareInterpolator.getFGSSigma []>
java: float getFGSSigma()
FUNC <float cv.ximgproc.EdgeAwareInterpolator.getLambda []>
java: float getLambda()
FUNC <float cv.ximgproc.EdgeAwareInterpolator.getSigma []>
java: float getSigma()
FUNC <int cv.ximgproc.EdgeAwareInterpolator.getK []>
java: int getK()
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setFGSLambda [ARG float _lambda=]>
java: void setFGSLambda(float _lambda)
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setFGSSigma [ARG float _sigma=]>
java: void setFGSSigma(float _sigma)
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setK [ARG int _k=]>
java: void setK(int _k)
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setLambda [ARG float _lambda=]>
java: void setLambda(float _lambda)
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setSigma [ARG float _sigma=]>
java: void setSigma(float _sigma)
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setUsePostProcessing [ARG bool _use_post_proc=]>
java: void setUsePostProcessing(boolean _use_post_proc)
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategySize : SelectiveSearchSegmentationStrategy
CLASS cv.ximgproc::.AdaptiveManifoldFilter : Algorithm
FUNC <Ptr_AdaptiveManifoldFilter cv.ximgproc.AdaptiveManifoldFilter.create []>
java: AdaptiveManifoldFilter create()
FUNC <void cv.ximgproc.AdaptiveManifoldFilter.collectGarbage []>
java: void collectGarbage()
FUNC <void cv.ximgproc.AdaptiveManifoldFilter.filter [ARG Mat src=, ARG Mat dst=, ARG Mat joint=Mat()]>
java: void filter(Mat src, Mat dst, Mat joint)
java: void filter(Mat src, Mat dst)
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentation : Algorithm
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addGraphSegmentation [ARG Ptr_GraphSegmentation g=]>
java: void addGraphSegmentation(GraphSegmentation g)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addImage [ARG Mat img=]>
java: void addImage(Mat img)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addStrategy [ARG Ptr_SelectiveSearchSegmentationStrategy s=]>
java: void addStrategy(SelectiveSearchSegmentationStrategy s)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearGraphSegmentations []>
java: void clearGraphSegmentations()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearImages []>
java: void clearImages()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearStrategies []>
java: void clearStrategies()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.process [ARG vector_Rect rects=]>
java: void process(MatOfRect rects)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.setBaseImage [ARG Mat img=]>
java: void setBaseImage(Mat img)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchFast [ARG int base_k=150, ARG int inc_k=150, ARG float sigma=0.8f]>
java: void switchToSelectiveSearchFast(int base_k, int inc_k, float sigma)
java: void switchToSelectiveSearchFast(int base_k, int inc_k)
java: void switchToSelectiveSearchFast(int base_k)
java: void switchToSelectiveSearchFast()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchQuality [ARG int base_k=150, ARG int inc_k=150, ARG float sigma=0.8f]>
java: void switchToSelectiveSearchQuality(int base_k, int inc_k, float sigma)
java: void switchToSelectiveSearchQuality(int base_k, int inc_k)
java: void switchToSelectiveSearchQuality(int base_k)
java: void switchToSelectiveSearchQuality()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSingleStrategy [ARG int k=200, ARG float sigma=0.8f]>
java: void switchToSingleStrategy(int k, float sigma)
java: void switchToSingleStrategy(int k)
java: void switchToSingleStrategy()
CLASS cv.ximgproc::.SuperpixelSLIC : Algorithm
FUNC <int cv.ximgproc.SuperpixelSLIC.getNumberOfSuperpixels []>
java: int getNumberOfSuperpixels()
FUNC <void cv.ximgproc.SuperpixelSLIC.enforceLabelConnectivity [ARG int min_element_size=25]>
java: void enforceLabelConnectivity(int min_element_size)
java: void enforceLabelConnectivity()
FUNC <void cv.ximgproc.SuperpixelSLIC.getLabelContourMask [ARG Mat image=, ARG bool thick_line=true]>
java: void getLabelContourMask(Mat image, boolean thick_line)
java: void getLabelContourMask(Mat image)
FUNC <void cv.ximgproc.SuperpixelSLIC.getLabels [ARG Mat labels_out=]>
java: void getLabels(Mat labels_out)
FUNC <void cv.ximgproc.SuperpixelSLIC.iterate [ARG int num_iterations=10]>
java: void iterate(int num_iterations)
java: void iterate()
CLASS cv.ximgproc.segmentation::.GraphSegmentation : Algorithm
FUNC <double cv.ximgproc.segmentation.GraphSegmentation.getSigma []>
java: double getSigma()
FUNC <float cv.ximgproc.segmentation.GraphSegmentation.getK []>
java: float getK()
FUNC <int cv.ximgproc.segmentation.GraphSegmentation.getMinSize []>
java: int getMinSize()
FUNC <void cv.ximgproc.segmentation.GraphSegmentation.processImage [ARG Mat src=, ARG Mat dst=]>
java: void processImage(Mat src, Mat dst)
FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setK [ARG float k=]>
java: void setK(float k)
FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setMinSize [ARG int min_size=]>
java: void setMinSize(int min_size)
FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setSigma [ARG double sigma=]>
java: void setSigma(double sigma)
CLASS cv.ximgproc::.GuidedFilter : Algorithm
FUNC <void cv.ximgproc.GuidedFilter.filter [ARG Mat src=, ARG Mat dst=, ARG int dDepth=-1]>
java: void filter(Mat src, Mat dst, int dDepth)
java: void filter(Mat src, Mat dst)
CLASS cv.ximgproc::.RFFeatureGetter : Algorithm
FUNC <void cv.ximgproc.RFFeatureGetter.getFeatures [ARG Mat src=, ARG Mat features=, ARG int gnrmRad=, ARG int gsmthRad=, ARG int shrink=, ARG int outNum=, ARG int gradNum=]>
java: void getFeatures(Mat src, Mat features, int gnrmRad, int gsmthRad, int shrink, int outNum, int gradNum)
CLASS cv.ximgproc::.FastGlobalSmootherFilter : Algorithm
FUNC <void cv.ximgproc.FastGlobalSmootherFilter.filter [ARG Mat src=, ARG Mat dst=]>
java: void filter(Mat src, Mat dst)
CLASS ::.Ximgproc : 
[CONST BINARIZATION_NIBLACK=0, CONST BINARIZATION_SAUVOLA=1, CONST BINARIZATION_WOLF=2, CONST BINARIZATION_NICK=3]
[CONST HDO_RAW=0, CONST HDO_DESKEW=1]
[CONST WMF_EXP=1, CONST WMF_IV1=1 << 1, CONST WMF_IV2=1 << 2, CONST WMF_COS=1 << 3, CONST WMF_JAC=1 << 4, CONST WMF_OFF=1 << 5]
[CONST DTF_NC=0, CONST DTF_IC=1, CONST DTF_RF=2, CONST GUIDED_FILTER=3, CONST AM_FILTER=4]
[CONST THINNING_ZHANGSUEN=0, CONST THINNING_GUOHALL=1]
[CONST FHT_MIN=0, CONST FHT_MAX=1, CONST FHT_ADD=2, CONST FHT_AVE=3]
[CONST SLIC=100, CONST SLICO=101, CONST MSLIC=102]
[CONST ARO_0_45=0, CONST ARO_45_90=1, CONST ARO_90_135=2, CONST ARO_315_0=3, CONST ARO_315_45=4, CONST ARO_45_135=5, CONST ARO_315_135=6, CONST ARO_CTR_HOR=7, CONST ARO_CTR_VER=8]
FUNC <Ptr_AdaptiveManifoldFilter cv.ximgproc..createAMFilter [ARG double sigma_s=, ARG double sigma_r=, ARG bool adjust_outliers=false]>
java: AdaptiveManifoldFilter createAMFilter(double sigma_s, double sigma_r, boolean adjust_outliers)
java: AdaptiveManifoldFilter createAMFilter(double sigma_s, double sigma_r)
FUNC <Ptr_ContourFitting cv.ximgproc..createContourFitting [ARG int ctr=1024, ARG int fd=16]>
java: ContourFitting createContourFitting(int ctr, int fd)
java: ContourFitting createContourFitting(int ctr)
java: ContourFitting createContourFitting()
FUNC <Ptr_DTFilter cv.ximgproc..createDTFilter [ARG Mat guide=, ARG double sigmaSpatial=, ARG double sigmaColor=, ARG int mode=DTF_NC, ARG int numIters=3]>
java: DTFilter createDTFilter(Mat guide, double sigmaSpatial, double sigmaColor, int mode, int numIters)
java: DTFilter createDTFilter(Mat guide, double sigmaSpatial, double sigmaColor, int mode)
java: DTFilter createDTFilter(Mat guide, double sigmaSpatial, double sigmaColor)
FUNC <Ptr_DisparityWLSFilter cv.ximgproc..createDisparityWLSFilter [ARG Ptr_StereoMatcher matcher_left=]>
java: DisparityWLSFilter createDisparityWLSFilter(StereoMatcher matcher_left)
FUNC <Ptr_DisparityWLSFilter cv.ximgproc..createDisparityWLSFilterGeneric [ARG bool use_confidence=]>
java: DisparityWLSFilter createDisparityWLSFilterGeneric(boolean use_confidence)
FUNC <Ptr_EdgeAwareInterpolator cv.ximgproc..createEdgeAwareInterpolator []>
java: EdgeAwareInterpolator createEdgeAwareInterpolator()
FUNC <Ptr_EdgeBoxes cv.ximgproc..createEdgeBoxes [ARG float alpha=0.65f, ARG float beta=0.75f, ARG float eta=1, ARG float minScore=0.01f, ARG int maxBoxes=10000, ARG float edgeMinMag=0.1f, ARG float edgeMergeThr=0.5f, ARG float clusterMinMag=0.5f, ARG float maxAspectRatio=3, ARG float minBoxArea=1000, ARG float gamma=2, ARG float kappa=1.5f]>
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag, float maxAspectRatio, float minBoxArea, float gamma, float kappa)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag, float maxAspectRatio, float minBoxArea, float gamma)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag, float maxAspectRatio, float minBoxArea)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag, float maxAspectRatio)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta)
java: EdgeBoxes createEdgeBoxes(float alpha)
java: EdgeBoxes createEdgeBoxes()
FUNC <Ptr_FastBilateralSolverFilter cv.ximgproc..createFastBilateralSolverFilter [ARG Mat guide=, ARG double sigma_spatial=, ARG double sigma_luma=, ARG double sigma_chroma=, ARG double lambda=128.0, ARG int num_iter=25, ARG double max_tol=1e-5]>
java: FastBilateralSolverFilter createFastBilateralSolverFilter(Mat guide, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter, double max_tol)
java: FastBilateralSolverFilter createFastBilateralSolverFilter(Mat guide, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter)
java: FastBilateralSolverFilter createFastBilateralSolverFilter(Mat guide, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda)
java: FastBilateralSolverFilter createFastBilateralSolverFilter(Mat guide, double sigma_spatial, double sigma_luma, double sigma_chroma)
FUNC <Ptr_FastGlobalSmootherFilter cv.ximgproc..createFastGlobalSmootherFilter [ARG Mat guide=, ARG double lambda=, ARG double sigma_color=, ARG double lambda_attenuation=0.25, ARG int num_iter=3]>
java: FastGlobalSmootherFilter createFastGlobalSmootherFilter(Mat guide, double lambda, double sigma_color, double lambda_attenuation, int num_iter)
java: FastGlobalSmootherFilter createFastGlobalSmootherFilter(Mat guide, double lambda, double sigma_color, double lambda_attenuation)
java: FastGlobalSmootherFilter createFastGlobalSmootherFilter(Mat guide, double lambda, double sigma_color)
FUNC <Ptr_FastLineDetector cv.ximgproc..createFastLineDetector [ARG int _length_threshold=10, ARG float _distance_threshold=1.414213562f, ARG double _canny_th1=50.0, ARG double _canny_th2=50.0, ARG int _canny_aperture_size=3, ARG bool _do_merge=false]>
java: FastLineDetector createFastLineDetector(int _length_threshold, float _distance_threshold, double _canny_th1, double _canny_th2, int _canny_aperture_size, boolean _do_merge)
java: FastLineDetector createFastLineDetector(int _length_threshold, float _distance_threshold, double _canny_th1, double _canny_th2, int _canny_aperture_size)
java: FastLineDetector createFastLineDetector(int _length_threshold, float _distance_threshold, double _canny_th1, double _canny_th2)
java: FastLineDetector createFastLineDetector(int _length_threshold, float _distance_threshold, double _canny_th1)
java: FastLineDetector createFastLineDetector(int _length_threshold, float _distance_threshold)
java: FastLineDetector createFastLineDetector(int _length_threshold)
java: FastLineDetector createFastLineDetector()
FUNC <Ptr_GraphSegmentation cv.ximgproc.segmentation..createGraphSegmentation [ARG double sigma=0.5, ARG float k=300, ARG int min_size=100]>
java: GraphSegmentation createGraphSegmentation(double sigma, float k, int min_size)
java: GraphSegmentation createGraphSegmentation(double sigma, float k)
java: GraphSegmentation createGraphSegmentation(double sigma)
java: GraphSegmentation createGraphSegmentation()
FUNC <Ptr_GuidedFilter cv.ximgproc..createGuidedFilter [ARG Mat guide=, ARG int radius=, ARG double eps=]>
java: GuidedFilter createGuidedFilter(Mat guide, int radius, double eps)
FUNC <Ptr_RFFeatureGetter cv.ximgproc..createRFFeatureGetter []>
java: RFFeatureGetter createRFFeatureGetter()
FUNC <Ptr_SelectiveSearchSegmentation cv.ximgproc.segmentation..createSelectiveSearchSegmentation []>
java: SelectiveSearchSegmentation createSelectiveSearchSegmentation()
FUNC <Ptr_SelectiveSearchSegmentationStrategyColor cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyColor []>
java: SelectiveSearchSegmentationStrategyColor createSelectiveSearchSegmentationStrategyColor()
FUNC <Ptr_SelectiveSearchSegmentationStrategyFill cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyFill []>
java: SelectiveSearchSegmentationStrategyFill createSelectiveSearchSegmentationStrategyFill()
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=, ARG Ptr_SelectiveSearchSegmentationStrategy s3=, ARG Ptr_SelectiveSearchSegmentationStrategy s4=]>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple(SelectiveSearchSegmentationStrategy s1, SelectiveSearchSegmentationStrategy s2, SelectiveSearchSegmentationStrategy s3, SelectiveSearchSegmentationStrategy s4)
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=, ARG Ptr_SelectiveSearchSegmentationStrategy s3=]>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple(SelectiveSearchSegmentationStrategy s1, SelectiveSearchSegmentationStrategy s2, SelectiveSearchSegmentationStrategy s3)
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=]>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple(SelectiveSearchSegmentationStrategy s1, SelectiveSearchSegmentationStrategy s2)
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=]>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple(SelectiveSearchSegmentationStrategy s1)
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple []>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple()
FUNC <Ptr_SelectiveSearchSegmentationStrategySize cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategySize []>
java: SelectiveSearchSegmentationStrategySize createSelectiveSearchSegmentationStrategySize()
FUNC <Ptr_SelectiveSearchSegmentationStrategyTexture cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyTexture []>
java: SelectiveSearchSegmentationStrategyTexture createSelectiveSearchSegmentationStrategyTexture()
FUNC <Ptr_StereoMatcher cv.ximgproc..createRightMatcher [ARG Ptr_StereoMatcher matcher_left=]>
java: StereoMatcher createRightMatcher(StereoMatcher matcher_left)
FUNC <Ptr_StructuredEdgeDetection cv.ximgproc..createStructuredEdgeDetection [ARG String model=, ARG Ptr_RFFeatureGetter howToGetFeatures=Ptr<RFFeatureGetter>()]>
java: StructuredEdgeDetection createStructuredEdgeDetection(String model, RFFeatureGetter howToGetFeatures)
java: StructuredEdgeDetection createStructuredEdgeDetection(String model)
FUNC <Ptr_SuperpixelLSC cv.ximgproc..createSuperpixelLSC [ARG Mat image=, ARG int region_size=10, ARG float ratio=0.075f]>
java: SuperpixelLSC createSuperpixelLSC(Mat image, int region_size, float ratio)
java: SuperpixelLSC createSuperpixelLSC(Mat image, int region_size)
java: SuperpixelLSC createSuperpixelLSC(Mat image)
FUNC <Ptr_SuperpixelSEEDS cv.ximgproc..createSuperpixelSEEDS [ARG int image_width=, ARG int image_height=, ARG int image_channels=, ARG int num_superpixels=, ARG int num_levels=, ARG int prior=2, ARG int histogram_bins=5, ARG bool double_step=false]>
java: SuperpixelSEEDS createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels, int prior, int histogram_bins, boolean double_step)
java: SuperpixelSEEDS createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels, int prior, int histogram_bins)
java: SuperpixelSEEDS createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels, int prior)
java: SuperpixelSEEDS createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels)
FUNC <Ptr_SuperpixelSLIC cv.ximgproc..createSuperpixelSLIC [ARG Mat image=, ARG int algorithm=SLICO, ARG int region_size=10, ARG float ruler=10.0f]>
java: SuperpixelSLIC createSuperpixelSLIC(Mat image, int algorithm, int region_size, float ruler)
java: SuperpixelSLIC createSuperpixelSLIC(Mat image, int algorithm, int region_size)
java: SuperpixelSLIC createSuperpixelSLIC(Mat image, int algorithm)
java: SuperpixelSLIC createSuperpixelSLIC(Mat image)
FUNC <Vec4i cv.ximgproc..HoughPoint2Line [ARG Point houghPoint=, ARG Mat srcImgInfo=, ARG int angleRange=ARO_315_135, ARG int makeSkew=HDO_DESKEW, ARG int rules=RO_IGNORE_BORDERS]>
SKIP:Vec4i cv::ximgproc::HoughPoint2Line(Point houghPoint, Mat srcImgInfo, int angleRange = ARO_315_135, int makeSkew = HDO_DESKEW, int rules = RO_IGNORE_BORDERS)	 due to RET type Vec4i
FUNC <void cv.ximgproc..FastHoughTransform [ARG Mat src=, ARG Mat dst=, ARG int dstMatDepth=, ARG int angleRange=ARO_315_135, ARG int op=FHT_ADD, ARG int makeSkew=HDO_DESKEW]>
java: void FastHoughTransform(Mat src, Mat dst, int dstMatDepth, int angleRange, int op, int makeSkew)
java: void FastHoughTransform(Mat src, Mat dst, int dstMatDepth, int angleRange, int op)
java: void FastHoughTransform(Mat src, Mat dst, int dstMatDepth, int angleRange)
java: void FastHoughTransform(Mat src, Mat dst, int dstMatDepth)
FUNC <void cv.ximgproc..GradientDericheX [ARG Mat op=, ARG Mat dst=, ARG double alpha=, ARG double omega=]>
java: void GradientDericheX(Mat op, Mat dst, double alpha, double omega)
FUNC <void cv.ximgproc..GradientDericheY [ARG Mat op=, ARG Mat dst=, ARG double alpha=, ARG double omega=]>
java: void GradientDericheY(Mat op, Mat dst, double alpha, double omega)
FUNC <void cv.ximgproc..PeiLinNormalization [ARG Mat I=, ARG Mat T=]>
java: void PeiLinNormalization(Mat I, Mat T)
FUNC <void cv.ximgproc..amFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG double sigma_s=, ARG double sigma_r=, ARG bool adjust_outliers=false]>
java: void amFilter(Mat joint, Mat src, Mat dst, double sigma_s, double sigma_r, boolean adjust_outliers)
java: void amFilter(Mat joint, Mat src, Mat dst, double sigma_s, double sigma_r)
FUNC <void cv.ximgproc..anisotropicDiffusion [ARG Mat src=, ARG Mat dst=, ARG float alpha=, ARG float K=, ARG int niters=]>
java: void anisotropicDiffusion(Mat src, Mat dst, float alpha, float K, int niters)
FUNC <void cv.ximgproc..bilateralTextureFilter [ARG Mat src=, ARG Mat dst=, ARG int fr=3, ARG int numIter=1, ARG double sigmaAlpha=-1., ARG double sigmaAvg=-1.]>
java: void bilateralTextureFilter(Mat src, Mat dst, int fr, int numIter, double sigmaAlpha, double sigmaAvg)
java: void bilateralTextureFilter(Mat src, Mat dst, int fr, int numIter, double sigmaAlpha)
java: void bilateralTextureFilter(Mat src, Mat dst, int fr, int numIter)
java: void bilateralTextureFilter(Mat src, Mat dst, int fr)
java: void bilateralTextureFilter(Mat src, Mat dst)
FUNC <void cv.ximgproc..colorMatchTemplate [ARG Mat img=, ARG Mat templ=, ARG Mat result=]>
java: void colorMatchTemplate(Mat img, Mat templ, Mat result)
FUNC <void cv.ximgproc..contourSampling [ARG Mat src=, ARG Mat out=, ARG int nbElt=]>
java: void contourSampling(Mat src, Mat out, int nbElt)
FUNC <void cv.ximgproc..covarianceEstimation [ARG Mat src=, ARG Mat dst=, ARG int windowRows=, ARG int windowCols=]>
java: void covarianceEstimation(Mat src, Mat dst, int windowRows, int windowCols)
FUNC <void cv.ximgproc..createQuaternionImage [ARG Mat img=, ARG Mat qimg=]>
java: void createQuaternionImage(Mat img, Mat qimg)
FUNC <void cv.ximgproc..dtFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG double sigmaSpatial=, ARG double sigmaColor=, ARG int mode=DTF_NC, ARG int numIters=3]>
java: void dtFilter(Mat guide, Mat src, Mat dst, double sigmaSpatial, double sigmaColor, int mode, int numIters)
java: void dtFilter(Mat guide, Mat src, Mat dst, double sigmaSpatial, double sigmaColor, int mode)
java: void dtFilter(Mat guide, Mat src, Mat dst, double sigmaSpatial, double sigmaColor)
FUNC <void cv.ximgproc..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double threshold=]>
java: void edgePreservingFilter(Mat src, Mat dst, int d, double threshold)
FUNC <void cv.ximgproc..fastBilateralSolverFilter [ARG Mat guide=, ARG Mat src=, ARG Mat confidence=, ARG Mat dst=, ARG double sigma_spatial=8, ARG double sigma_luma=8, ARG double sigma_chroma=8, ARG double lambda=128.0, ARG int num_iter=25, ARG double max_tol=1e-5]>
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter, double max_tol)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma, double sigma_chroma)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst)
FUNC <void cv.ximgproc..fastGlobalSmootherFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG double lambda=, ARG double sigma_color=, ARG double lambda_attenuation=0.25, ARG int num_iter=3]>
java: void fastGlobalSmootherFilter(Mat guide, Mat src, Mat dst, double lambda, double sigma_color, double lambda_attenuation, int num_iter)
java: void fastGlobalSmootherFilter(Mat guide, Mat src, Mat dst, double lambda, double sigma_color, double lambda_attenuation)
java: void fastGlobalSmootherFilter(Mat guide, Mat src, Mat dst, double lambda, double sigma_color)
FUNC <void cv.ximgproc..fourierDescriptor [ARG Mat src=, ARG Mat dst=, ARG int nbElt=-1, ARG int nbFD=-1]>
java: void fourierDescriptor(Mat src, Mat dst, int nbElt, int nbFD)
java: void fourierDescriptor(Mat src, Mat dst, int nbElt)
java: void fourierDescriptor(Mat src, Mat dst)
FUNC <void cv.ximgproc..guidedFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG int radius=, ARG double eps=, ARG int dDepth=-1]>
java: void guidedFilter(Mat guide, Mat src, Mat dst, int radius, double eps, int dDepth)
java: void guidedFilter(Mat guide, Mat src, Mat dst, int radius, double eps)
FUNC <void cv.ximgproc..jointBilateralFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>
java: void jointBilateralFilter(Mat joint, Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int borderType)
java: void jointBilateralFilter(Mat joint, Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace)
FUNC <void cv.ximgproc..l0Smooth [ARG Mat src=, ARG Mat dst=, ARG double lambda=0.02, ARG double kappa=2.0]>
java: void l0Smooth(Mat src, Mat dst, double lambda, double kappa)
java: void l0Smooth(Mat src, Mat dst, double lambda)
java: void l0Smooth(Mat src, Mat dst)
FUNC <void cv.ximgproc..niBlackThreshold [ARG Mat _src=, ARG Mat _dst=, ARG double maxValue=, ARG int type=, ARG int blockSize=, ARG double k=, ARG int binarizationMethod=BINARIZATION_NIBLACK]>
java: void niBlackThreshold(Mat _src, Mat _dst, double maxValue, int type, int blockSize, double k, int binarizationMethod)
java: void niBlackThreshold(Mat _src, Mat _dst, double maxValue, int type, int blockSize, double k)
FUNC <void cv.ximgproc..qconj [ARG Mat qimg=, ARG Mat qcimg=]>
java: void qconj(Mat qimg, Mat qcimg)
FUNC <void cv.ximgproc..qdft [ARG Mat img=, ARG Mat qimg=, ARG int flags=, ARG bool sideLeft=]>
java: void qdft(Mat img, Mat qimg, int flags, boolean sideLeft)
FUNC <void cv.ximgproc..qmultiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void qmultiply(Mat src1, Mat src2, Mat dst)
FUNC <void cv.ximgproc..qunitary [ARG Mat qimg=, ARG Mat qnimg=]>
java: void qunitary(Mat qimg, Mat qnimg)
FUNC <void cv.ximgproc..rollingGuidanceFilter [ARG Mat src=, ARG Mat dst=, ARG int d=-1, ARG double sigmaColor=25, ARG double sigmaSpace=3, ARG int numOfIter=4, ARG int borderType=BORDER_DEFAULT]>
java: void rollingGuidanceFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int numOfIter, int borderType)
java: void rollingGuidanceFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int numOfIter)
java: void rollingGuidanceFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace)
java: void rollingGuidanceFilter(Mat src, Mat dst, int d, double sigmaColor)
java: void rollingGuidanceFilter(Mat src, Mat dst, int d)
java: void rollingGuidanceFilter(Mat src, Mat dst)
FUNC <void cv.ximgproc..thinning [ARG Mat src=, ARG Mat dst=, ARG int thinningType=THINNING_ZHANGSUEN]>
java: void thinning(Mat src, Mat dst, int thinningType)
java: void thinning(Mat src, Mat dst)
FUNC <void cv.ximgproc..transformFD [ARG Mat src=, ARG Mat t=, ARG Mat dst=, ARG bool fdContour=true]>
java: void transformFD(Mat src, Mat t, Mat dst, boolean fdContour)
java: void transformFD(Mat src, Mat t, Mat dst)
FUNC <void cv.ximgproc..weightedMedianFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG int r=, ARG double sigma=25.5, ARG int weightType=WMF_EXP, ARG Mat mask=Mat()]>
java: void weightedMedianFilter(Mat joint, Mat src, Mat dst, int r, double sigma, int weightType, Mat mask)
java: void weightedMedianFilter(Mat joint, Mat src, Mat dst, int r, double sigma, int weightType)
java: void weightedMedianFilter(Mat joint, Mat src, Mat dst, int r, double sigma)
java: void weightedMedianFilter(Mat joint, Mat src, Mat dst, int r)
CLASS cv.ximgproc::.ContourFitting : Algorithm
FUNC <int cv.ximgproc.ContourFitting.getCtrSize []>
java: int getCtrSize()
FUNC <int cv.ximgproc.ContourFitting.getFDSize []>
java: int getFDSize()
FUNC <void cv.ximgproc.ContourFitting.estimateTransformation [ARG Mat src=, ARG Mat dst=, ARG Mat alphaPhiST=, ARG double dist=, ARG bool fdContour=false]>
java: void estimateTransformation(Mat src, Mat dst, Mat alphaPhiST, double[] dist, boolean fdContour)
java: void estimateTransformation(Mat src, Mat dst, Mat alphaPhiST, double[] dist)
FUNC <void cv.ximgproc.ContourFitting.setCtrSize [ARG int n=]>
java: void setCtrSize(int n)
FUNC <void cv.ximgproc.ContourFitting.setFDSize [ARG int n=]>
java: void setFDSize(int n)

=== MODULE: aruco (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/aruco) ===


Files (3):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/aruco/include/opencv2/aruco/dictionary.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp']

Common headers (0):
[]
ok: class CLASS ::.Aruco : , name: Aruco, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp =====
Namespaces: set([u'cv.aruco', u'cv'])

--- Incoming ---
[   u'enum cv.aruco.CornerRefineMethod',
    '',
    [],
    [   [u'const cv.aruco.CORNER_REFINE_NONE', '0', [], [], None, ''],
        [u'const cv.aruco.CORNER_REFINE_SUBPIX', '1', [], [], None, ''],
        [u'const cv.aruco.CORNER_REFINE_CONTOUR', '2', [], [], None, ''],
        [u'const cv.aruco.CORNER_REFINE_APRILTAG', '3', [], [], None, '']],
    None]
ok: CONST CORNER_REFINE_NONE=0
ok: CONST CORNER_REFINE_SUBPIX=1
ok: CONST CORNER_REFINE_CONTOUR=2
ok: CONST CORNER_REFINE_APRILTAG=3

--- Incoming ---
[   u'struct cv.aruco.DetectorParameters',
    '',
    [],
    [   [u'int', u'adaptiveThreshWinSizeMin', '', ['/RW']],
        [u'int', u'adaptiveThreshWinSizeMax', '', ['/RW']],
        [u'int', u'adaptiveThreshWinSizeStep', '', ['/RW']],
        [u'double', u'adaptiveThreshConstant', '', ['/RW']],
        [u'double', u'minMarkerPerimeterRate', '', ['/RW']],
        [u'double', u'maxMarkerPerimeterRate', '', ['/RW']],
        [u'double', u'polygonalApproxAccuracyRate', '', ['/RW']],
        [u'double', u'minCornerDistanceRate', '', ['/RW']],
        [u'int', u'minDistanceToBorder', '', ['/RW']],
        [u'double', u'minMarkerDistanceRate', '', ['/RW']],
        [u'int', u'cornerRefinementMethod', '', ['/RW']],
        [u'int', u'cornerRefinementWinSize', '', ['/RW']],
        [u'int', u'cornerRefinementMaxIterations', '', ['/RW']],
        [u'double', u'cornerRefinementMinAccuracy', '', ['/RW']],
        [u'int', u'markerBorderBits', '', ['/RW']],
        [u'int', u'perspectiveRemovePixelPerCell', '', ['/RW']],
        [u'double', u'perspectiveRemoveIgnoredMarginPerCell', '', ['/RW']],
        [u'double', u'maxErroneousBitsInBorderRate', '', ['/RW']],
        [u'double', u'minOtsuStdDev', '', ['/RW']],
        [u'double', u'errorCorrectionRate', '', ['/RW']],
        [u'float', u'aprilTagQuadDecimate', '', ['/RW']],
        [u'float', u'aprilTagQuadSigma', '', ['/RW']],
        [u'int', u'aprilTagMinClusterPixels', '', ['/RW']],
        [u'int', u'aprilTagMaxNmaxima', '', ['/RW']],
        [u'float', u'aprilTagCriticalRad', '', ['/RW']],
        [u'float', u'aprilTagMaxLineFitMse', '', ['/RW']],
        [u'int', u'aprilTagMinWhiteBlackDiff', '', ['/RW']],
        [u'int', u'aprilTagDeglitch', '', ['/RW']],
        [u'bool', u'detectInvertedMarker', '', ['/RW']]],
    None]
ok: class CLASS cv.aruco::.DetectorParameters : , name: DetectorParameters, base: 

--- Incoming ---
[   u'cv.aruco.DetectorParameters.create',
    u'Ptr_DetectorParameters',
    ['/S'],
    [],
    u'Ptr<DetectorParameters>']
ok: FUNC <Ptr_DetectorParameters cv.aruco.DetectorParameters.create []>

--- Incoming ---
[   u'cv.aruco.detectMarkers',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']],
        ['vector_Mat', u'corners', '', ['/O']],
        ['Mat', u'ids', '', ['/O']],
        [   u'Ptr_DetectorParameters',
            u'parameters',
            u'DetectorParameters::create()',
            ['/C', '/Ref']],
        ['vector_Mat', u'rejectedImgPoints', u'vector_Mat()', ['/O']],
        ['Mat', u'cameraMatrix', u'Mat()', []],
        ['Mat', u'distCoeff', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.aruco..detectMarkers [ARG Mat image=, ARG Ptr_Dictionary dictionary=, ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_DetectorParameters parameters=DetectorParameters::create(), ARG vector_Mat rejectedImgPoints=vector_Mat(), ARG Mat cameraMatrix=Mat(), ARG Mat distCoeff=Mat()]>

--- Incoming ---
[   u'cv.aruco.estimatePoseSingleMarkers',
    u'void',
    [],
    [   ['vector_Mat', u'corners', '', []],
        [u'float', u'markerLength', u'', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvecs', '', ['/O']],
        ['Mat', u'tvecs', '', ['/O']],
        ['Mat', u'_objPoints', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.aruco..estimatePoseSingleMarkers [ARG vector_Mat corners=, ARG float markerLength=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvecs=, ARG Mat tvecs=, ARG Mat _objPoints=Mat()]>

--- Incoming ---
[   u'class cv.aruco.Board',
    '',
    [],
    [   [u'vector_vector_Point3f', u'objPoints', '', []],
        [u'Ptr_Dictionary', u'dictionary', '', []],
        [u'vector_int', u'ids', '', []]],
    None]
ok: class CLASS cv.aruco::.Board : , name: Board, base: 

--- Incoming ---
[   u'cv.aruco.Board.create',
    u'Ptr_Board',
    ['/S'],
    [   ['vector_Mat', u'objPoints', '', []],
        [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']],
        ['Mat', u'ids', '', []]],
    u'Ptr<Board>']
ok: FUNC <Ptr_Board cv.aruco.Board.create [ARG vector_Mat objPoints=, ARG Ptr_Dictionary dictionary=, ARG Mat ids=]>

--- Incoming ---
[u'class cv.aruco.GridBoard', u': cv::aruco::Board', [], [], None]
ok: class CLASS cv.aruco::.GridBoard : Board, name: GridBoard, base: Board

--- Incoming ---
[   u'cv.aruco.GridBoard.draw',
    u'void',
    [],
    [   [u'Size', u'outSize', u'', []],
        ['Mat', u'img', '', ['/O']],
        [u'int', u'marginSize', u'0', []],
        [u'int', u'borderBits', u'1', []]],
    u'void']
ok: FUNC <void cv.aruco.GridBoard.draw [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.GridBoard.create',
    u'Ptr_GridBoard',
    ['/S'],
    [   [u'int', u'markersX', u'', []],
        [u'int', u'markersY', u'', []],
        [u'float', u'markerLength', u'', []],
        [u'float', u'markerSeparation', u'', []],
        [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']],
        [u'int', u'firstMarker', u'0', []]],
    u'Ptr<GridBoard>']
ok: FUNC <Ptr_GridBoard cv.aruco.GridBoard.create [ARG int markersX=, ARG int markersY=, ARG float markerLength=, ARG float markerSeparation=, ARG Ptr_Dictionary dictionary=, ARG int firstMarker=0]>

--- Incoming ---
[u'cv.aruco.GridBoard.getGridSize', u'Size', ['/C'], [], u'Size']
ok: FUNC <Size cv.aruco.GridBoard.getGridSize []>

--- Incoming ---
[u'cv.aruco.GridBoard.getMarkerLength', u'float', ['/C'], [], u'float']
ok: FUNC <float cv.aruco.GridBoard.getMarkerLength []>

--- Incoming ---
[u'cv.aruco.GridBoard.getMarkerSeparation', u'float', ['/C'], [], u'float']
ok: FUNC <float cv.aruco.GridBoard.getMarkerSeparation []>

--- Incoming ---
[   u'cv.aruco.estimatePoseBoard',
    u'int',
    [],
    [   ['vector_Mat', u'corners', '', []],
        ['Mat', u'ids', '', []],
        [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/IO']],
        ['Mat', u'tvec', '', ['/IO']],
        [u'bool', u'useExtrinsicGuess', u'false', []]],
    u'int']
ok: FUNC <int cv.aruco..estimatePoseBoard [ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_Board board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>

--- Incoming ---
[   u'cv.aruco.refineDetectedMarkers',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        ['vector_Mat', u'detectedCorners', '', ['/IO']],
        ['Mat', u'detectedIds', '', ['/IO']],
        ['vector_Mat', u'rejectedCorners', '', ['/IO']],
        ['Mat', u'cameraMatrix', u'Mat()', []],
        ['Mat', u'distCoeffs', u'Mat()', []],
        [u'float', u'minRepDistance', u'10.f', []],
        [u'float', u'errorCorrectionRate', u'3.f', []],
        [u'bool', u'checkAllOrders', u'true', []],
        ['Mat', u'recoveredIdxs', u'Mat()', ['/O']],
        [   u'Ptr_DetectorParameters',
            u'parameters',
            u'DetectorParameters::create()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.aruco..refineDetectedMarkers [ARG Mat image=, ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG vector_Mat rejectedCorners=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG float minRepDistance=10.f, ARG float errorCorrectionRate=3.f, ARG bool checkAllOrders=true, ARG Mat recoveredIdxs=Mat(), ARG Ptr_DetectorParameters parameters=DetectorParameters::create()]>

--- Incoming ---
[   u'cv.aruco.drawDetectedMarkers',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['vector_Mat', u'corners', '', []],
        ['Mat', u'ids', u'Mat()', []],
        [u'Scalar', u'borderColor', u'Scalar(0, 255, 0)', []]],
    u'void']
ok: FUNC <void cv.aruco..drawDetectedMarkers [ARG Mat image=, ARG vector_Mat corners=, ARG Mat ids=Mat(), ARG Scalar borderColor=Scalar(0, 255, 0)]>

--- Incoming ---
[   u'cv.aruco.drawAxis',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        [u'float', u'length', u'', []]],
    u'void']
ok: FUNC <void cv.aruco..drawAxis [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=]>

--- Incoming ---
[   u'cv.aruco.drawMarker',
    u'void',
    [],
    [   [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']],
        [u'int', u'id', u'', []],
        [u'int', u'sidePixels', u'', []],
        ['Mat', u'img', '', ['/O']],
        [u'int', u'borderBits', u'1', []]],
    u'void']
ok: FUNC <void cv.aruco..drawMarker [ARG Ptr_Dictionary dictionary=, ARG int id=, ARG int sidePixels=, ARG Mat img=, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.drawPlanarBoard',
    u'void',
    [],
    [   [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'outSize', u'', []],
        ['Mat', u'img', '', ['/O']],
        [u'int', u'marginSize', u'0', []],
        [u'int', u'borderBits', u'1', []]],
    u'void']
ok: FUNC <void cv.aruco..drawPlanarBoard [ARG Ptr_Board board=, ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.calibrateCameraAruco',
    u'double',
    [u'=calibrateCameraArucoExtended'],
    [   ['vector_Mat', u'corners', '', []],
        ['Mat', u'ids', '', []],
        ['Mat', u'counter', '', []],
        [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.aruco.calibrateCameraAruco',
    u'double',
    [],
    [   ['vector_Mat', u'corners', '', []],
        ['Mat', u'ids', '', []],
        ['Mat', u'counter', '', []],
        [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', u'vector_Mat()', ['/O']],
        ['vector_Mat', u'tvecs', u'vector_Mat()', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.aruco.getBoardObjectAndImagePoints',
    u'void',
    [],
    [   [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        ['vector_Mat', u'detectedCorners', '', []],
        ['Mat', u'detectedIds', '', []],
        ['Mat', u'objPoints', '', ['/O']],
        ['Mat', u'imgPoints', '', ['/O']]],
    u'void']
ok: FUNC <void cv.aruco..getBoardObjectAndImagePoints [ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG Mat objPoints=, ARG Mat imgPoints=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/aruco/include/opencv2/aruco/dictionary.hpp =====
Namespaces: set([u'cv.aruco', u'cv'])

--- Incoming ---
[   u'class cv.aruco.Dictionary',
    '',
    [],
    [   [u'Mat', u'bytesList', '', ['/RW']],
        [u'int', u'markerSize', '', ['/RW']],
        [u'int', u'maxCorrectionBits', '', ['/RW']]],
    None]
ok: class CLASS cv.aruco::.Dictionary : , name: Dictionary, base: 

--- Incoming ---
[   u'cv.aruco.Dictionary.create',
    u'Ptr_Dictionary',
    [u'=create', '/S'],
    [   [u'int', u'nMarkers', u'', []],
        [u'int', u'markerSize', u'', []],
        [u'int', u'randomSeed', u'0', []]],
    u'Ptr<Dictionary>']
ok: FUNC <Ptr_Dictionary cv.aruco.Dictionary.create [ARG int nMarkers=, ARG int markerSize=, ARG int randomSeed=0]>

--- Incoming ---
[   u'cv.aruco.Dictionary.create',
    u'Ptr_Dictionary',
    [u'=create_from', '/S'],
    [   [u'int', u'nMarkers', u'', []],
        [u'int', u'markerSize', u'', []],
        [u'Ptr_Dictionary', u'baseDictionary', u'', ['/C', '/Ref']],
        [u'int', u'randomSeed', u'0', []]],
    u'Ptr<Dictionary>']
ok: FUNC <Ptr_Dictionary cv.aruco.Dictionary.create [ARG int nMarkers=, ARG int markerSize=, ARG Ptr_Dictionary baseDictionary=, ARG int randomSeed=0]>

--- Incoming ---
[   u'cv.aruco.Dictionary.get',
    u'Ptr_Dictionary',
    ['/S'],
    [[u'int', u'dict', u'', []]],
    u'Ptr<Dictionary>']
ok: FUNC <Ptr_Dictionary cv.aruco.Dictionary.get [ARG int dict=]>

--- Incoming ---
[   u'cv.aruco.Dictionary.drawMarker',
    u'void',
    ['/C'],
    [   [u'int', u'id', u'', []],
        [u'int', u'sidePixels', u'', []],
        ['Mat', u'_img', '', ['/O']],
        [u'int', u'borderBits', u'1', []]],
    u'void']
ok: FUNC <void cv.aruco.Dictionary.drawMarker [ARG int id=, ARG int sidePixels=, ARG Mat _img=, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.Dictionary.getByteListFromBits',
    u'Mat',
    ['/S'],
    [[u'Mat', u'bits', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.aruco.Dictionary.getByteListFromBits [ARG Mat bits=]>

--- Incoming ---
[   u'cv.aruco.Dictionary.getBitsFromByteList',
    u'Mat',
    ['/S'],
    [   [u'Mat', u'byteList', u'', ['/C', '/Ref']],
        [u'int', u'markerSize', u'', []]],
    u'Mat']
ok: FUNC <Mat cv.aruco.Dictionary.getBitsFromByteList [ARG Mat byteList=, ARG int markerSize=]>

--- Incoming ---
[   u'enum cv.aruco.PREDEFINED_DICTIONARY_NAME',
    '',
    [],
    [   [u'const cv.aruco.DICT_4X4_50', u'0', [], [], None, ''],
        [u'const cv.aruco.DICT_4X4_100', u'0+1', [], [], None, ''],
        [u'const cv.aruco.DICT_4X4_250', u'0+2', [], [], None, ''],
        [u'const cv.aruco.DICT_4X4_1000', u'0+3', [], [], None, ''],
        [u'const cv.aruco.DICT_5X5_50', u'0+4', [], [], None, ''],
        [u'const cv.aruco.DICT_5X5_100', u'0+5', [], [], None, ''],
        [u'const cv.aruco.DICT_5X5_250', u'0+6', [], [], None, ''],
        [u'const cv.aruco.DICT_5X5_1000', u'0+7', [], [], None, ''],
        [u'const cv.aruco.DICT_6X6_50', u'0+8', [], [], None, ''],
        [u'const cv.aruco.DICT_6X6_100', u'0+9', [], [], None, ''],
        [u'const cv.aruco.DICT_6X6_250', u'0+10', [], [], None, ''],
        [u'const cv.aruco.DICT_6X6_1000', u'0+11', [], [], None, ''],
        [u'const cv.aruco.DICT_7X7_50', u'0+12', [], [], None, ''],
        [u'const cv.aruco.DICT_7X7_100', u'0+13', [], [], None, ''],
        [u'const cv.aruco.DICT_7X7_250', u'0+14', [], [], None, ''],
        [u'const cv.aruco.DICT_7X7_1000', u'0+15', [], [], None, ''],
        [u'const cv.aruco.DICT_ARUCO_ORIGINAL', u'0+16', [], [], None, ''],
        [u'const cv.aruco.DICT_APRILTAG_16h5', u'0+17', [], [], None, ''],
        [u'const cv.aruco.DICT_APRILTAG_25h9', u'0+18', [], [], None, ''],
        [u'const cv.aruco.DICT_APRILTAG_36h10', u'0+19', [], [], None, ''],
        [u'const cv.aruco.DICT_APRILTAG_36h11', u'0+20', [], [], None, '']],
    None]
ok: CONST DICT_4X4_50=0
ok: CONST DICT_4X4_100=0+1
ok: CONST DICT_4X4_250=0+2
ok: CONST DICT_4X4_1000=0+3
ok: CONST DICT_5X5_50=0+4
ok: CONST DICT_5X5_100=0+5
ok: CONST DICT_5X5_250=0+6
ok: CONST DICT_5X5_1000=0+7
ok: CONST DICT_6X6_50=0+8
ok: CONST DICT_6X6_100=0+9
ok: CONST DICT_6X6_250=0+10
ok: CONST DICT_6X6_1000=0+11
ok: CONST DICT_7X7_50=0+12
ok: CONST DICT_7X7_100=0+13
ok: CONST DICT_7X7_250=0+14
ok: CONST DICT_7X7_1000=0+15
ok: CONST DICT_ARUCO_ORIGINAL=0+16
ok: CONST DICT_APRILTAG_16h5=0+17
ok: CONST DICT_APRILTAG_25h9=0+18
ok: CONST DICT_APRILTAG_36h10=0+19
ok: CONST DICT_APRILTAG_36h11=0+20

--- Incoming ---
[   u'cv.aruco.getPredefinedDictionary',
    u'Ptr_Dictionary',
    [],
    [[u'int', u'dict', u'', []]],
    u'Ptr<Dictionary>']
ok: FUNC <Ptr_Dictionary cv.aruco..getPredefinedDictionary [ARG int dict=]>

--- Incoming ---
[   u'cv.aruco.generateCustomDictionary',
    u'Ptr_Dictionary',
    [u'=custom_dictionary'],
    [   [u'int', u'nMarkers', u'', []],
        [u'int', u'markerSize', u'', []],
        [u'int', u'randomSeed', u'0', []]],
    u'Ptr<Dictionary>']
ok: FUNC <Ptr_Dictionary cv.aruco..generateCustomDictionary [ARG int nMarkers=, ARG int markerSize=, ARG int randomSeed=0]>

--- Incoming ---
[   u'cv.aruco.generateCustomDictionary',
    u'Ptr_Dictionary',
    [u'=custom_dictionary_from'],
    [   [u'int', u'nMarkers', u'', []],
        [u'int', u'markerSize', u'', []],
        [u'Ptr_Dictionary', u'baseDictionary', u'', ['/C', '/Ref']],
        [u'int', u'randomSeed', u'0', []]],
    u'Ptr<Dictionary>']
ok: FUNC <Ptr_Dictionary cv.aruco..generateCustomDictionary [ARG int nMarkers=, ARG int markerSize=, ARG Ptr_Dictionary baseDictionary=, ARG int randomSeed=0]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp =====
Namespaces: set([u'cv.aruco', u'cv'])

--- Incoming ---
[   u'class cv.aruco.CharucoBoard',
    u': cv::aruco::Board',
    [],
    [   [u'vector_Point3f', u'chessboardCorners', '', []],
        [u'vector_vector_int', u'nearestMarkerIdx', '', []],
        [u'vector_vector_int', u'nearestMarkerCorners', '', []]],
    None]
ok: class CLASS cv.aruco::.CharucoBoard : Board, name: CharucoBoard, base: Board

--- Incoming ---
[   u'cv.aruco.CharucoBoard.draw',
    u'void',
    [],
    [   [u'Size', u'outSize', u'', []],
        ['Mat', u'img', '', ['/O']],
        [u'int', u'marginSize', u'0', []],
        [u'int', u'borderBits', u'1', []]],
    u'void']
ok: FUNC <void cv.aruco.CharucoBoard.draw [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.CharucoBoard.create',
    u'Ptr_CharucoBoard',
    ['/S'],
    [   [u'int', u'squaresX', u'', []],
        [u'int', u'squaresY', u'', []],
        [u'float', u'squareLength', u'', []],
        [u'float', u'markerLength', u'', []],
        [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']]],
    u'Ptr<CharucoBoard>']
ok: FUNC <Ptr_CharucoBoard cv.aruco.CharucoBoard.create [ARG int squaresX=, ARG int squaresY=, ARG float squareLength=, ARG float markerLength=, ARG Ptr_Dictionary dictionary=]>

--- Incoming ---
[u'cv.aruco.CharucoBoard.getChessboardSize', u'Size', ['/C'], [], u'Size']
ok: FUNC <Size cv.aruco.CharucoBoard.getChessboardSize []>

--- Incoming ---
[u'cv.aruco.CharucoBoard.getSquareLength', u'float', ['/C'], [], u'float']
ok: FUNC <float cv.aruco.CharucoBoard.getSquareLength []>

--- Incoming ---
[u'cv.aruco.CharucoBoard.getMarkerLength', u'float', ['/C'], [], u'float']
ok: FUNC <float cv.aruco.CharucoBoard.getMarkerLength []>

--- Incoming ---
[   u'cv.aruco.interpolateCornersCharuco',
    u'int',
    [],
    [   ['vector_Mat', u'markerCorners', '', []],
        ['Mat', u'markerIds', '', []],
        ['Mat', u'image', '', []],
        [u'Ptr_CharucoBoard', u'board', u'', ['/C', '/Ref']],
        ['Mat', u'charucoCorners', '', ['/O']],
        ['Mat', u'charucoIds', '', ['/O']],
        ['Mat', u'cameraMatrix', u'Mat()', []],
        ['Mat', u'distCoeffs', u'Mat()', []],
        [u'int', u'minMarkers', u'2', []]],
    u'int']
ok: FUNC <int cv.aruco..interpolateCornersCharuco [ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG Mat image=, ARG Ptr_CharucoBoard board=, ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG int minMarkers=2]>

--- Incoming ---
[   u'cv.aruco.estimatePoseCharucoBoard',
    u'bool',
    [],
    [   ['Mat', u'charucoCorners', '', []],
        ['Mat', u'charucoIds', '', []],
        [u'Ptr_CharucoBoard', u'board', u'', ['/C', '/Ref']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/IO']],
        ['Mat', u'tvec', '', ['/IO']],
        [u'bool', u'useExtrinsicGuess', u'false', []]],
    u'bool']
ok: FUNC <bool cv.aruco..estimatePoseCharucoBoard [ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>

--- Incoming ---
[   u'cv.aruco.drawDetectedCornersCharuco',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'charucoCorners', '', []],
        ['Mat', u'charucoIds', u'Mat()', []],
        [u'Scalar', u'cornerColor', u'Scalar(255, 0, 0)', []]],
    u'void']
ok: FUNC <void cv.aruco..drawDetectedCornersCharuco [ARG Mat image=, ARG Mat charucoCorners=, ARG Mat charucoIds=Mat(), ARG Scalar cornerColor=Scalar(255, 0, 0)]>

--- Incoming ---
[   u'cv.aruco.calibrateCameraCharuco',
    u'double',
    [u'=calibrateCameraCharucoExtended'],
    [   ['vector_Mat', u'charucoCorners', '', []],
        ['vector_Mat', u'charucoIds', '', []],
        [u'Ptr_CharucoBoard', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.aruco.calibrateCameraCharuco',
    u'double',
    [],
    [   ['vector_Mat', u'charucoCorners', '', []],
        ['vector_Mat', u'charucoIds', '', []],
        [u'Ptr_CharucoBoard', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', u'vector_Mat()', ['/O']],
        ['vector_Mat', u'tvecs', u'vector_Mat()', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.aruco.detectCharucoDiamond',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['vector_Mat', u'markerCorners', '', []],
        ['Mat', u'markerIds', '', []],
        [u'float', u'squareMarkerLengthRate', u'', []],
        ['vector_Mat', u'diamondCorners', '', ['/O']],
        ['Mat', u'diamondIds', '', ['/O']],
        ['Mat', u'cameraMatrix', u'Mat()', []],
        ['Mat', u'distCoeffs', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.aruco..detectCharucoDiamond [ARG Mat image=, ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG float squareMarkerLengthRate=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat()]>

--- Incoming ---
[   u'cv.aruco.drawDetectedDiamonds',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['vector_Mat', u'diamondCorners', '', []],
        ['Mat', u'diamondIds', u'Mat()', []],
        [u'Scalar', u'borderColor', u'Scalar(0, 0, 255)', []]],
    u'void']
ok: FUNC <void cv.aruco..drawDetectedDiamonds [ARG Mat image=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=Mat(), ARG Scalar borderColor=Scalar(0, 0, 255)]>


===== Generating... =====
CLASS cv.aruco::.DetectorParameters : 
FUNC <Ptr_DetectorParameters cv.aruco.DetectorParameters.create []>
java: DetectorParameters create()
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeMin []>
java: int get_adaptiveThreshWinSizeMin()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeMin [ARG int adaptiveThreshWinSizeMin=]>
java: void set_adaptiveThreshWinSizeMin(int adaptiveThreshWinSizeMin)
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeMax []>
java: int get_adaptiveThreshWinSizeMax()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeMax [ARG int adaptiveThreshWinSizeMax=]>
java: void set_adaptiveThreshWinSizeMax(int adaptiveThreshWinSizeMax)
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeStep []>
java: int get_adaptiveThreshWinSizeStep()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeStep [ARG int adaptiveThreshWinSizeStep=]>
java: void set_adaptiveThreshWinSizeStep(int adaptiveThreshWinSizeStep)
FUNC <double cv.aruco.DetectorParameters.get_adaptiveThreshConstant []>
java: double get_adaptiveThreshConstant()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshConstant [ARG double adaptiveThreshConstant=]>
java: void set_adaptiveThreshConstant(double adaptiveThreshConstant)
FUNC <double cv.aruco.DetectorParameters.get_minMarkerPerimeterRate []>
java: double get_minMarkerPerimeterRate()
FUNC <void cv.aruco.DetectorParameters.set_minMarkerPerimeterRate [ARG double minMarkerPerimeterRate=]>
java: void set_minMarkerPerimeterRate(double minMarkerPerimeterRate)
FUNC <double cv.aruco.DetectorParameters.get_maxMarkerPerimeterRate []>
java: double get_maxMarkerPerimeterRate()
FUNC <void cv.aruco.DetectorParameters.set_maxMarkerPerimeterRate [ARG double maxMarkerPerimeterRate=]>
java: void set_maxMarkerPerimeterRate(double maxMarkerPerimeterRate)
FUNC <double cv.aruco.DetectorParameters.get_polygonalApproxAccuracyRate []>
java: double get_polygonalApproxAccuracyRate()
FUNC <void cv.aruco.DetectorParameters.set_polygonalApproxAccuracyRate [ARG double polygonalApproxAccuracyRate=]>
java: void set_polygonalApproxAccuracyRate(double polygonalApproxAccuracyRate)
FUNC <double cv.aruco.DetectorParameters.get_minCornerDistanceRate []>
java: double get_minCornerDistanceRate()
FUNC <void cv.aruco.DetectorParameters.set_minCornerDistanceRate [ARG double minCornerDistanceRate=]>
java: void set_minCornerDistanceRate(double minCornerDistanceRate)
FUNC <int cv.aruco.DetectorParameters.get_minDistanceToBorder []>
java: int get_minDistanceToBorder()
FUNC <void cv.aruco.DetectorParameters.set_minDistanceToBorder [ARG int minDistanceToBorder=]>
java: void set_minDistanceToBorder(int minDistanceToBorder)
FUNC <double cv.aruco.DetectorParameters.get_minMarkerDistanceRate []>
java: double get_minMarkerDistanceRate()
FUNC <void cv.aruco.DetectorParameters.set_minMarkerDistanceRate [ARG double minMarkerDistanceRate=]>
java: void set_minMarkerDistanceRate(double minMarkerDistanceRate)
FUNC <int cv.aruco.DetectorParameters.get_cornerRefinementMethod []>
java: int get_cornerRefinementMethod()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMethod [ARG int cornerRefinementMethod=]>
java: void set_cornerRefinementMethod(int cornerRefinementMethod)
FUNC <int cv.aruco.DetectorParameters.get_cornerRefinementWinSize []>
java: int get_cornerRefinementWinSize()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementWinSize [ARG int cornerRefinementWinSize=]>
java: void set_cornerRefinementWinSize(int cornerRefinementWinSize)
FUNC <int cv.aruco.DetectorParameters.get_cornerRefinementMaxIterations []>
java: int get_cornerRefinementMaxIterations()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMaxIterations [ARG int cornerRefinementMaxIterations=]>
java: void set_cornerRefinementMaxIterations(int cornerRefinementMaxIterations)
FUNC <double cv.aruco.DetectorParameters.get_cornerRefinementMinAccuracy []>
java: double get_cornerRefinementMinAccuracy()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMinAccuracy [ARG double cornerRefinementMinAccuracy=]>
java: void set_cornerRefinementMinAccuracy(double cornerRefinementMinAccuracy)
FUNC <int cv.aruco.DetectorParameters.get_markerBorderBits []>
java: int get_markerBorderBits()
FUNC <void cv.aruco.DetectorParameters.set_markerBorderBits [ARG int markerBorderBits=]>
java: void set_markerBorderBits(int markerBorderBits)
FUNC <int cv.aruco.DetectorParameters.get_perspectiveRemovePixelPerCell []>
java: int get_perspectiveRemovePixelPerCell()
FUNC <void cv.aruco.DetectorParameters.set_perspectiveRemovePixelPerCell [ARG int perspectiveRemovePixelPerCell=]>
java: void set_perspectiveRemovePixelPerCell(int perspectiveRemovePixelPerCell)
FUNC <double cv.aruco.DetectorParameters.get_perspectiveRemoveIgnoredMarginPerCell []>
java: double get_perspectiveRemoveIgnoredMarginPerCell()
FUNC <void cv.aruco.DetectorParameters.set_perspectiveRemoveIgnoredMarginPerCell [ARG double perspectiveRemoveIgnoredMarginPerCell=]>
java: void set_perspectiveRemoveIgnoredMarginPerCell(double perspectiveRemoveIgnoredMarginPerCell)
FUNC <double cv.aruco.DetectorParameters.get_maxErroneousBitsInBorderRate []>
java: double get_maxErroneousBitsInBorderRate()
FUNC <void cv.aruco.DetectorParameters.set_maxErroneousBitsInBorderRate [ARG double maxErroneousBitsInBorderRate=]>
java: void set_maxErroneousBitsInBorderRate(double maxErroneousBitsInBorderRate)
FUNC <double cv.aruco.DetectorParameters.get_minOtsuStdDev []>
java: double get_minOtsuStdDev()
FUNC <void cv.aruco.DetectorParameters.set_minOtsuStdDev [ARG double minOtsuStdDev=]>
java: void set_minOtsuStdDev(double minOtsuStdDev)
FUNC <double cv.aruco.DetectorParameters.get_errorCorrectionRate []>
java: double get_errorCorrectionRate()
FUNC <void cv.aruco.DetectorParameters.set_errorCorrectionRate [ARG double errorCorrectionRate=]>
java: void set_errorCorrectionRate(double errorCorrectionRate)
FUNC <float cv.aruco.DetectorParameters.get_aprilTagQuadDecimate []>
java: float get_aprilTagQuadDecimate()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagQuadDecimate [ARG float aprilTagQuadDecimate=]>
java: void set_aprilTagQuadDecimate(float aprilTagQuadDecimate)
FUNC <float cv.aruco.DetectorParameters.get_aprilTagQuadSigma []>
java: float get_aprilTagQuadSigma()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagQuadSigma [ARG float aprilTagQuadSigma=]>
java: void set_aprilTagQuadSigma(float aprilTagQuadSigma)
FUNC <int cv.aruco.DetectorParameters.get_aprilTagMinClusterPixels []>
java: int get_aprilTagMinClusterPixels()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagMinClusterPixels [ARG int aprilTagMinClusterPixels=]>
java: void set_aprilTagMinClusterPixels(int aprilTagMinClusterPixels)
FUNC <int cv.aruco.DetectorParameters.get_aprilTagMaxNmaxima []>
java: int get_aprilTagMaxNmaxima()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagMaxNmaxima [ARG int aprilTagMaxNmaxima=]>
java: void set_aprilTagMaxNmaxima(int aprilTagMaxNmaxima)
FUNC <float cv.aruco.DetectorParameters.get_aprilTagCriticalRad []>
java: float get_aprilTagCriticalRad()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagCriticalRad [ARG float aprilTagCriticalRad=]>
java: void set_aprilTagCriticalRad(float aprilTagCriticalRad)
FUNC <float cv.aruco.DetectorParameters.get_aprilTagMaxLineFitMse []>
java: float get_aprilTagMaxLineFitMse()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagMaxLineFitMse [ARG float aprilTagMaxLineFitMse=]>
java: void set_aprilTagMaxLineFitMse(float aprilTagMaxLineFitMse)
FUNC <int cv.aruco.DetectorParameters.get_aprilTagMinWhiteBlackDiff []>
java: int get_aprilTagMinWhiteBlackDiff()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagMinWhiteBlackDiff [ARG int aprilTagMinWhiteBlackDiff=]>
java: void set_aprilTagMinWhiteBlackDiff(int aprilTagMinWhiteBlackDiff)
FUNC <int cv.aruco.DetectorParameters.get_aprilTagDeglitch []>
java: int get_aprilTagDeglitch()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagDeglitch [ARG int aprilTagDeglitch=]>
java: void set_aprilTagDeglitch(int aprilTagDeglitch)
FUNC <bool cv.aruco.DetectorParameters.get_detectInvertedMarker []>
java: boolean get_detectInvertedMarker()
FUNC <void cv.aruco.DetectorParameters.set_detectInvertedMarker [ARG bool detectInvertedMarker=]>
java: void set_detectInvertedMarker(boolean detectInvertedMarker)
CLASS cv.aruco::.Dictionary : 
FUNC <Mat cv.aruco.Dictionary.getBitsFromByteList [ARG Mat byteList=, ARG int markerSize=]>
java: Mat getBitsFromByteList(Mat byteList, int markerSize)
FUNC <Mat cv.aruco.Dictionary.getByteListFromBits [ARG Mat bits=]>
java: Mat getByteListFromBits(Mat bits)
FUNC <Ptr_Dictionary cv.aruco.Dictionary.create [ARG int nMarkers=, ARG int markerSize=, ARG Ptr_Dictionary baseDictionary=, ARG int randomSeed=0]>
java: Dictionary create_from(int nMarkers, int markerSize, Dictionary baseDictionary, int randomSeed)
java: Dictionary create_from(int nMarkers, int markerSize, Dictionary baseDictionary)
FUNC <Ptr_Dictionary cv.aruco.Dictionary.create [ARG int nMarkers=, ARG int markerSize=, ARG int randomSeed=0]>
java: Dictionary create(int nMarkers, int markerSize, int randomSeed)
java: Dictionary create(int nMarkers, int markerSize)
FUNC <Ptr_Dictionary cv.aruco.Dictionary.get [ARG int dict=]>
java: Dictionary get(int dict)
FUNC <void cv.aruco.Dictionary.drawMarker [ARG int id=, ARG int sidePixels=, ARG Mat _img=, ARG int borderBits=1]>
java: void drawMarker(int id, int sidePixels, Mat _img, int borderBits)
java: void drawMarker(int id, int sidePixels, Mat _img)
FUNC <Mat cv.aruco.Dictionary.get_bytesList []>
java: Mat get_bytesList()
FUNC <void cv.aruco.Dictionary.set_bytesList [ARG Mat bytesList=]>
java: void set_bytesList(Mat bytesList)
FUNC <int cv.aruco.Dictionary.get_markerSize []>
java: int get_markerSize()
FUNC <void cv.aruco.Dictionary.set_markerSize [ARG int markerSize=]>
java: void set_markerSize(int markerSize)
FUNC <int cv.aruco.Dictionary.get_maxCorrectionBits []>
java: int get_maxCorrectionBits()
FUNC <void cv.aruco.Dictionary.set_maxCorrectionBits [ARG int maxCorrectionBits=]>
java: void set_maxCorrectionBits(int maxCorrectionBits)
CLASS cv.aruco::.GridBoard : Board
FUNC <Ptr_GridBoard cv.aruco.GridBoard.create [ARG int markersX=, ARG int markersY=, ARG float markerLength=, ARG float markerSeparation=, ARG Ptr_Dictionary dictionary=, ARG int firstMarker=0]>
java: GridBoard create(int markersX, int markersY, float markerLength, float markerSeparation, Dictionary dictionary, int firstMarker)
java: GridBoard create(int markersX, int markersY, float markerLength, float markerSeparation, Dictionary dictionary)
FUNC <Size cv.aruco.GridBoard.getGridSize []>
java: Size getGridSize()
FUNC <float cv.aruco.GridBoard.getMarkerLength []>
java: float getMarkerLength()
FUNC <float cv.aruco.GridBoard.getMarkerSeparation []>
java: float getMarkerSeparation()
FUNC <void cv.aruco.GridBoard.draw [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>
java: void draw(Size outSize, Mat img, int marginSize, int borderBits)
java: void draw(Size outSize, Mat img, int marginSize)
java: void draw(Size outSize, Mat img)
CLASS cv.aruco::.Board : 
FUNC <Ptr_Board cv.aruco.Board.create [ARG vector_Mat objPoints=, ARG Ptr_Dictionary dictionary=, ARG Mat ids=]>
java: Board create(List<Mat> objPoints, Dictionary dictionary, Mat ids)
FUNC <vector_vector_Point3f cv.aruco.Board.get_objPoints []>
java: List<MatOfPoint3f> get_objPoints()
FUNC <Ptr_Dictionary cv.aruco.Board.get_dictionary []>
java: Dictionary get_dictionary()
FUNC <vector_int cv.aruco.Board.get_ids []>
java: MatOfInt get_ids()
CLASS ::.Aruco : 
[CONST CORNER_REFINE_NONE=0, CONST CORNER_REFINE_SUBPIX=1, CONST CORNER_REFINE_CONTOUR=2, CONST CORNER_REFINE_APRILTAG=3]
[CONST DICT_4X4_50=0, CONST DICT_4X4_100=0+1, CONST DICT_4X4_250=0+2, CONST DICT_4X4_1000=0+3, CONST DICT_5X5_50=0+4, CONST DICT_5X5_100=0+5, CONST DICT_5X5_250=0+6, CONST DICT_5X5_1000=0+7, CONST DICT_6X6_50=0+8, CONST DICT_6X6_100=0+9, CONST DICT_6X6_250=0+10, CONST DICT_6X6_1000=0+11, CONST DICT_7X7_50=0+12, CONST DICT_7X7_100=0+13, CONST DICT_7X7_250=0+14, CONST DICT_7X7_1000=0+15, CONST DICT_ARUCO_ORIGINAL=0+16, CONST DICT_APRILTAG_16h5=0+17, CONST DICT_APRILTAG_25h9=0+18, CONST DICT_APRILTAG_36h10=0+19, CONST DICT_APRILTAG_36h11=0+20]
FUNC <Ptr_Dictionary cv.aruco..generateCustomDictionary [ARG int nMarkers=, ARG int markerSize=, ARG Ptr_Dictionary baseDictionary=, ARG int randomSeed=0]>
java: Dictionary custom_dictionary_from(int nMarkers, int markerSize, Dictionary baseDictionary, int randomSeed)
java: Dictionary custom_dictionary_from(int nMarkers, int markerSize, Dictionary baseDictionary)
FUNC <Ptr_Dictionary cv.aruco..generateCustomDictionary [ARG int nMarkers=, ARG int markerSize=, ARG int randomSeed=0]>
java: Dictionary custom_dictionary(int nMarkers, int markerSize, int randomSeed)
java: Dictionary custom_dictionary(int nMarkers, int markerSize)
FUNC <Ptr_Dictionary cv.aruco..getPredefinedDictionary [ARG int dict=]>
java: Dictionary getPredefinedDictionary(int dict)
FUNC <bool cv.aruco..estimatePoseCharucoBoard [ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>
java: boolean estimatePoseCharucoBoard(Mat charucoCorners, Mat charucoIds, CharucoBoard board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean estimatePoseCharucoBoard(Mat charucoCorners, Mat charucoIds, CharucoBoard board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs)
FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs)
FUNC <int cv.aruco..estimatePoseBoard [ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_Board board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>
java: int estimatePoseBoard(List<Mat> corners, Mat ids, Board board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: int estimatePoseBoard(List<Mat> corners, Mat ids, Board board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <int cv.aruco..interpolateCornersCharuco [ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG Mat image=, ARG Ptr_CharucoBoard board=, ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG int minMarkers=2]>
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds, Mat cameraMatrix, Mat distCoeffs, int minMarkers)
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds, Mat cameraMatrix, Mat distCoeffs)
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds, Mat cameraMatrix)
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds)
FUNC <void cv.aruco..detectCharucoDiamond [ARG Mat image=, ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG float squareMarkerLengthRate=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat()]>
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds, Mat cameraMatrix, Mat distCoeffs)
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds, Mat cameraMatrix)
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds)
FUNC <void cv.aruco..detectMarkers [ARG Mat image=, ARG Ptr_Dictionary dictionary=, ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_DetectorParameters parameters=DetectorParameters::create(), ARG vector_Mat rejectedImgPoints=vector_Mat(), ARG Mat cameraMatrix=Mat(), ARG Mat distCoeff=Mat()]>
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids, DetectorParameters parameters, List<Mat> rejectedImgPoints, Mat cameraMatrix, Mat distCoeff)
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids, DetectorParameters parameters, List<Mat> rejectedImgPoints, Mat cameraMatrix)
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids, DetectorParameters parameters, List<Mat> rejectedImgPoints)
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids, DetectorParameters parameters)
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids)
FUNC <void cv.aruco..drawAxis [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=]>
java: void drawAxis(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length)
FUNC <void cv.aruco..drawDetectedCornersCharuco [ARG Mat image=, ARG Mat charucoCorners=, ARG Mat charucoIds=Mat(), ARG Scalar cornerColor=Scalar(255, 0, 0)]>
java: void drawDetectedCornersCharuco(Mat image, Mat charucoCorners, Mat charucoIds, Scalar cornerColor)
java: void drawDetectedCornersCharuco(Mat image, Mat charucoCorners, Mat charucoIds)
java: void drawDetectedCornersCharuco(Mat image, Mat charucoCorners)
FUNC <void cv.aruco..drawDetectedDiamonds [ARG Mat image=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=Mat(), ARG Scalar borderColor=Scalar(0, 0, 255)]>
java: void drawDetectedDiamonds(Mat image, List<Mat> diamondCorners, Mat diamondIds, Scalar borderColor)
java: void drawDetectedDiamonds(Mat image, List<Mat> diamondCorners, Mat diamondIds)
java: void drawDetectedDiamonds(Mat image, List<Mat> diamondCorners)
FUNC <void cv.aruco..drawDetectedMarkers [ARG Mat image=, ARG vector_Mat corners=, ARG Mat ids=Mat(), ARG Scalar borderColor=Scalar(0, 255, 0)]>
java: void drawDetectedMarkers(Mat image, List<Mat> corners, Mat ids, Scalar borderColor)
java: void drawDetectedMarkers(Mat image, List<Mat> corners, Mat ids)
java: void drawDetectedMarkers(Mat image, List<Mat> corners)
FUNC <void cv.aruco..drawMarker [ARG Ptr_Dictionary dictionary=, ARG int id=, ARG int sidePixels=, ARG Mat img=, ARG int borderBits=1]>
java: void drawMarker(Dictionary dictionary, int id, int sidePixels, Mat img, int borderBits)
java: void drawMarker(Dictionary dictionary, int id, int sidePixels, Mat img)
FUNC <void cv.aruco..drawPlanarBoard [ARG Ptr_Board board=, ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>
java: void drawPlanarBoard(Board board, Size outSize, Mat img, int marginSize, int borderBits)
java: void drawPlanarBoard(Board board, Size outSize, Mat img, int marginSize)
java: void drawPlanarBoard(Board board, Size outSize, Mat img)
FUNC <void cv.aruco..estimatePoseSingleMarkers [ARG vector_Mat corners=, ARG float markerLength=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvecs=, ARG Mat tvecs=, ARG Mat _objPoints=Mat()]>
java: void estimatePoseSingleMarkers(List<Mat> corners, float markerLength, Mat cameraMatrix, Mat distCoeffs, Mat rvecs, Mat tvecs, Mat _objPoints)
java: void estimatePoseSingleMarkers(List<Mat> corners, float markerLength, Mat cameraMatrix, Mat distCoeffs, Mat rvecs, Mat tvecs)
FUNC <void cv.aruco..getBoardObjectAndImagePoints [ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG Mat objPoints=, ARG Mat imgPoints=]>
java: void getBoardObjectAndImagePoints(Board board, List<Mat> detectedCorners, Mat detectedIds, Mat objPoints, Mat imgPoints)
FUNC <void cv.aruco..refineDetectedMarkers [ARG Mat image=, ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG vector_Mat rejectedCorners=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG float minRepDistance=10.f, ARG float errorCorrectionRate=3.f, ARG bool checkAllOrders=true, ARG Mat recoveredIdxs=Mat(), ARG Ptr_DetectorParameters parameters=DetectorParameters::create()]>
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate, boolean checkAllOrders, Mat recoveredIdxs, DetectorParameters parameters)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate, boolean checkAllOrders, Mat recoveredIdxs)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate, boolean checkAllOrders)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners)
CLASS cv.aruco::.CharucoBoard : Board
FUNC <Ptr_CharucoBoard cv.aruco.CharucoBoard.create [ARG int squaresX=, ARG int squaresY=, ARG float squareLength=, ARG float markerLength=, ARG Ptr_Dictionary dictionary=]>
java: CharucoBoard create(int squaresX, int squaresY, float squareLength, float markerLength, Dictionary dictionary)
FUNC <Size cv.aruco.CharucoBoard.getChessboardSize []>
java: Size getChessboardSize()
FUNC <float cv.aruco.CharucoBoard.getMarkerLength []>
java: float getMarkerLength()
FUNC <float cv.aruco.CharucoBoard.getSquareLength []>
java: float getSquareLength()
FUNC <void cv.aruco.CharucoBoard.draw [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>
java: void draw(Size outSize, Mat img, int marginSize, int borderBits)
java: void draw(Size outSize, Mat img, int marginSize)
java: void draw(Size outSize, Mat img)
FUNC <vector_Point3f cv.aruco.CharucoBoard.get_chessboardCorners []>
java: MatOfPoint3f get_chessboardCorners()
FUNC <vector_vector_int cv.aruco.CharucoBoard.get_nearestMarkerIdx []>
SKIP:vector_vector_int CharucoBoard::nearestMarkerIdx	 due to RET type vector_vector_int
FUNC <vector_vector_int cv.aruco.CharucoBoard.get_nearestMarkerCorners []>
SKIP:vector_vector_int CharucoBoard::nearestMarkerCorners	 due to RET type vector_vector_int

=== MODULE: bgsegm (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bgsegm) ===


Files (1):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bgsegm/include/opencv2/bgsegm.hpp']

Common headers (0):
[]
ok: class CLASS ::.Bgsegm : , name: Bgsegm, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bgsegm/include/opencv2/bgsegm.hpp =====
Namespaces: set([u'cv.bgsegm', u'cv'])

--- Incoming ---
[   u'class cv.bgsegm.BackgroundSubtractorMOG',
    u': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorMOG : BackgroundSubtractor, name: BackgroundSubtractorMOG, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorMOG.getHistory',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorMOG.getHistory []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorMOG.setHistory',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nframes', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setHistory [ARG int nframes=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorMOG.getNMixtures',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorMOG.getNMixtures []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorMOG.setNMixtures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nmix', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setNMixtures [ARG int nmix=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorMOG.getBackgroundRatio',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorMOG.getBackgroundRatio []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorMOG.setBackgroundRatio',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'backgroundRatio', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setBackgroundRatio [ARG double backgroundRatio=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorMOG.getNoiseSigma',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorMOG.getNoiseSigma []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorMOG.setNoiseSigma',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'noiseSigma', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setNoiseSigma [ARG double noiseSigma=]>

--- Incoming ---
[   u'cv.bgsegm.createBackgroundSubtractorMOG',
    u'Ptr_BackgroundSubtractorMOG',
    [],
    [   [u'int', u'history', u'200', []],
        [u'int', u'nmixtures', u'5', []],
        [u'double', u'backgroundRatio', u'0.7', []],
        [u'double', u'noiseSigma', u'0', []]],
    u'Ptr<BackgroundSubtractorMOG>']
ok: FUNC <Ptr_BackgroundSubtractorMOG cv.bgsegm..createBackgroundSubtractorMOG [ARG int history=200, ARG int nmixtures=5, ARG double backgroundRatio=0.7, ARG double noiseSigma=0]>

--- Incoming ---
[   u'class cv.bgsegm.BackgroundSubtractorGMG',
    u': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorGMG : BackgroundSubtractor, name: BackgroundSubtractorGMG, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getMaxFeatures',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getMaxFeatures []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setMaxFeatures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxFeatures', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMaxFeatures [ARG int maxFeatures=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getDefaultLearningRate',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getDefaultLearningRate []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setDefaultLearningRate',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'lr', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setDefaultLearningRate [ARG double lr=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getNumFrames',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getNumFrames []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setNumFrames',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nframes', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setNumFrames [ARG int nframes=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getQuantizationLevels',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getQuantizationLevels []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setQuantizationLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nlevels', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setQuantizationLevels [ARG int nlevels=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getBackgroundPrior',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getBackgroundPrior []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setBackgroundPrior',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'bgprior', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setBackgroundPrior [ARG double bgprior=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getSmoothingRadius',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getSmoothingRadius []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setSmoothingRadius',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'radius', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setSmoothingRadius [ARG int radius=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getDecisionThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getDecisionThreshold []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setDecisionThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'thresh', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setDecisionThreshold [ARG double thresh=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getUpdateBackgroundModel',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.bgsegm.BackgroundSubtractorGMG.getUpdateBackgroundModel []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setUpdateBackgroundModel',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'update', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setUpdateBackgroundModel [ARG bool update=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getMinVal',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getMinVal []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setMinVal',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMinVal [ARG double val=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.getMaxVal',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getMaxVal []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGMG.setMaxVal',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMaxVal [ARG double val=]>

--- Incoming ---
[   u'cv.bgsegm.createBackgroundSubtractorGMG',
    u'Ptr_BackgroundSubtractorGMG',
    [],
    [   [u'int', u'initializationFrames', u'120', []],
        [u'double', u'decisionThreshold', u'0.8', []]],
    u'Ptr<BackgroundSubtractorGMG>']
ok: FUNC <Ptr_BackgroundSubtractorGMG cv.bgsegm..createBackgroundSubtractorGMG [ARG int initializationFrames=120, ARG double decisionThreshold=0.8]>

--- Incoming ---
[   u'class cv.bgsegm.BackgroundSubtractorCNT',
    u': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorCNT : BackgroundSubtractor, name: BackgroundSubtractorCNT, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.getBackgroundImage',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'backgroundImage', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.getMinPixelStability',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorCNT.getMinPixelStability []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.setMinPixelStability',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setMinPixelStability [ARG int value=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.getMaxPixelStability',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorCNT.getMaxPixelStability []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.setMaxPixelStability',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setMaxPixelStability [ARG int value=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.getUseHistory',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.bgsegm.BackgroundSubtractorCNT.getUseHistory []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.setUseHistory',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setUseHistory [ARG bool value=]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.getIsParallel',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.bgsegm.BackgroundSubtractorCNT.getIsParallel []>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorCNT.setIsParallel',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setIsParallel [ARG bool value=]>

--- Incoming ---
[   u'cv.bgsegm.createBackgroundSubtractorCNT',
    u'Ptr_BackgroundSubtractorCNT',
    [],
    [   [u'int', u'minPixelStability', u'15', []],
        [u'bool', u'useHistory', u'true', []],
        [u'int', u'maxPixelStability', u'15*60', []],
        [u'bool', u'isParallel', u'true', []]],
    u'Ptr<BackgroundSubtractorCNT>']
ok: FUNC <Ptr_BackgroundSubtractorCNT cv.bgsegm..createBackgroundSubtractorCNT [ARG int minPixelStability=15, ARG bool useHistory=true, ARG int maxPixelStability=15*60, ARG bool isParallel=true]>

--- Incoming ---
[   u'enum cv.bgsegm.LSBPCameraMotionCompensation',
    '',
    [],
    [   [   u'const cv.bgsegm.LSBP_CAMERA_MOTION_COMPENSATION_NONE',
            u'0',
            [],
            [],
            None,
            ''],
        [   u'const cv.bgsegm.LSBP_CAMERA_MOTION_COMPENSATION_LK',
            u'0+1',
            [],
            [],
            None,
            '']],
    None]
ok: CONST LSBP_CAMERA_MOTION_COMPENSATION_NONE=0
ok: CONST LSBP_CAMERA_MOTION_COMPENSATION_LK=0+1

--- Incoming ---
[   u'class cv.bgsegm.BackgroundSubtractorGSOC',
    u': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorGSOC : BackgroundSubtractor, name: BackgroundSubtractorGSOC, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGSOC.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGSOC.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorGSOC.getBackgroundImage',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'backgroundImage', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGSOC.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[   u'class cv.bgsegm.BackgroundSubtractorLSBP',
    u': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorLSBP : BackgroundSubtractor, name: BackgroundSubtractorLSBP, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorLSBP.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorLSBP.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.bgsegm.BackgroundSubtractorLSBP.getBackgroundImage',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'backgroundImage', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorLSBP.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[u'class cv.bgsegm.BackgroundSubtractorLSBPDesc', '', [], [], None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorLSBPDesc : , name: BackgroundSubtractorLSBPDesc, base: 

--- Incoming ---
[   u'cv.bgsegm.createBackgroundSubtractorGSOC',
    u'Ptr_BackgroundSubtractorGSOC',
    [],
    [   [u'int', u'mc', u'LSBP_CAMERA_MOTION_COMPENSATION_NONE', []],
        [u'int', u'nSamples', u'20', []],
        [u'float', u'replaceRate', u'0.003f', []],
        [u'float', u'propagationRate', u'0.01f', []],
        [u'int', u'hitsThreshold', u'32', []],
        [u'float', u'alpha', u'0.01f', []],
        [u'float', u'beta', u'0.0022f', []],
        [u'float', u'blinkingSupressionDecay', u'0.1f', []],
        [u'float', u'blinkingSupressionMultiplier', u'0.1f', []],
        [u'float', u'noiseRemovalThresholdFacBG', u'0.0004f', []],
        [u'float', u'noiseRemovalThresholdFacFG', u'0.0008f', []]],
    u'Ptr<BackgroundSubtractorGSOC>']
ok: FUNC <Ptr_BackgroundSubtractorGSOC cv.bgsegm..createBackgroundSubtractorGSOC [ARG int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE, ARG int nSamples=20, ARG float replaceRate=0.003f, ARG float propagationRate=0.01f, ARG int hitsThreshold=32, ARG float alpha=0.01f, ARG float beta=0.0022f, ARG float blinkingSupressionDecay=0.1f, ARG float blinkingSupressionMultiplier=0.1f, ARG float noiseRemovalThresholdFacBG=0.0004f, ARG float noiseRemovalThresholdFacFG=0.0008f]>

--- Incoming ---
[   u'cv.bgsegm.createBackgroundSubtractorLSBP',
    u'Ptr_BackgroundSubtractorLSBP',
    [],
    [   [u'int', u'mc', u'LSBP_CAMERA_MOTION_COMPENSATION_NONE', []],
        [u'int', u'nSamples', u'20', []],
        [u'int', u'LSBPRadius', u'16', []],
        [u'float', u'Tlower', u'2.0f', []],
        [u'float', u'Tupper', u'32.0f', []],
        [u'float', u'Tinc', u'1.0f', []],
        [u'float', u'Tdec', u'0.05f', []],
        [u'float', u'Rscale', u'10.0f', []],
        [u'float', u'Rincdec', u'0.005f', []],
        [u'float', u'noiseRemovalThresholdFacBG', u'0.0004f', []],
        [u'float', u'noiseRemovalThresholdFacFG', u'0.0008f', []],
        [u'int', u'LSBPthreshold', u'8', []],
        [u'int', u'minCount', u'2', []]],
    u'Ptr<BackgroundSubtractorLSBP>']
ok: FUNC <Ptr_BackgroundSubtractorLSBP cv.bgsegm..createBackgroundSubtractorLSBP [ARG int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE, ARG int nSamples=20, ARG int LSBPRadius=16, ARG float Tlower=2.0f, ARG float Tupper=32.0f, ARG float Tinc=1.0f, ARG float Tdec=0.05f, ARG float Rscale=10.0f, ARG float Rincdec=0.005f, ARG float noiseRemovalThresholdFacBG=0.0004f, ARG float noiseRemovalThresholdFacFG=0.0008f, ARG int LSBPthreshold=8, ARG int minCount=2]>

--- Incoming ---
[   u'class cv.bgsegm.SyntheticSequenceGenerator',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.SyntheticSequenceGenerator : Algorithm, name: SyntheticSequenceGenerator, base: Algorithm

--- Incoming ---
[   u'cv.bgsegm.SyntheticSequenceGenerator.SyntheticSequenceGenerator',
    '',
    [],
    [   ['Mat', u'background', '', []],
        ['Mat', u'object', '', []],
        [u'double', u'amplitude', u'', []],
        [u'double', u'wavelength', u'', []],
        [u'double', u'wavespeed', u'', []],
        [u'double', u'objspeed', u'', []]],
    None]
ok: FUNC < cv.bgsegm.SyntheticSequenceGenerator.SyntheticSequenceGenerator [ARG Mat background=, ARG Mat object=, ARG double amplitude=, ARG double wavelength=, ARG double wavespeed=, ARG double objspeed=]>

--- Incoming ---
[   u'cv.bgsegm.SyntheticSequenceGenerator.getNextFrame',
    u'void',
    [],
    [['Mat', u'frame', '', ['/O']], ['Mat', u'gtMask', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bgsegm.SyntheticSequenceGenerator.getNextFrame [ARG Mat frame=, ARG Mat gtMask=]>

--- Incoming ---
[   u'cv.bgsegm.createSyntheticSequenceGenerator',
    u'Ptr_SyntheticSequenceGenerator',
    [],
    [   ['Mat', u'background', '', []],
        ['Mat', u'object', '', []],
        [u'double', u'amplitude', u'2.0', []],
        [u'double', u'wavelength', u'20.0', []],
        [u'double', u'wavespeed', u'0.2', []],
        [u'double', u'objspeed', u'6.0', []]],
    u'Ptr<SyntheticSequenceGenerator>']
ok: FUNC <Ptr_SyntheticSequenceGenerator cv.bgsegm..createSyntheticSequenceGenerator [ARG Mat background=, ARG Mat object=, ARG double amplitude=2.0, ARG double wavelength=20.0, ARG double wavespeed=0.2, ARG double objspeed=6.0]>


===== Generating... =====
CLASS cv.bgsegm::.BackgroundSubtractorGMG : BackgroundSubtractor
FUNC <bool cv.bgsegm.BackgroundSubtractorGMG.getUpdateBackgroundModel []>
java: boolean getUpdateBackgroundModel()
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getBackgroundPrior []>
java: double getBackgroundPrior()
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getDecisionThreshold []>
java: double getDecisionThreshold()
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getDefaultLearningRate []>
java: double getDefaultLearningRate()
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getMaxVal []>
java: double getMaxVal()
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getMinVal []>
java: double getMinVal()
FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getMaxFeatures []>
java: int getMaxFeatures()
FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getNumFrames []>
java: int getNumFrames()
FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getQuantizationLevels []>
java: int getQuantizationLevels()
FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getSmoothingRadius []>
java: int getSmoothingRadius()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setBackgroundPrior [ARG double bgprior=]>
java: void setBackgroundPrior(double bgprior)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setDecisionThreshold [ARG double thresh=]>
java: void setDecisionThreshold(double thresh)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setDefaultLearningRate [ARG double lr=]>
java: void setDefaultLearningRate(double lr)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMaxFeatures [ARG int maxFeatures=]>
java: void setMaxFeatures(int maxFeatures)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMaxVal [ARG double val=]>
java: void setMaxVal(double val)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMinVal [ARG double val=]>
java: void setMinVal(double val)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setNumFrames [ARG int nframes=]>
java: void setNumFrames(int nframes)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setQuantizationLevels [ARG int nlevels=]>
java: void setQuantizationLevels(int nlevels)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setSmoothingRadius [ARG int radius=]>
java: void setSmoothingRadius(int radius)
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setUpdateBackgroundModel [ARG bool update=]>
java: void setUpdateBackgroundModel(boolean update)
CLASS ::.Bgsegm : 
[CONST LSBP_CAMERA_MOTION_COMPENSATION_NONE=0, CONST LSBP_CAMERA_MOTION_COMPENSATION_LK=0+1]
FUNC <Ptr_BackgroundSubtractorCNT cv.bgsegm..createBackgroundSubtractorCNT [ARG int minPixelStability=15, ARG bool useHistory=true, ARG int maxPixelStability=15*60, ARG bool isParallel=true]>
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT(int minPixelStability, boolean useHistory, int maxPixelStability, boolean isParallel)
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT(int minPixelStability, boolean useHistory, int maxPixelStability)
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT(int minPixelStability, boolean useHistory)
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT(int minPixelStability)
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT()
FUNC <Ptr_BackgroundSubtractorGMG cv.bgsegm..createBackgroundSubtractorGMG [ARG int initializationFrames=120, ARG double decisionThreshold=0.8]>
java: BackgroundSubtractorGMG createBackgroundSubtractorGMG(int initializationFrames, double decisionThreshold)
java: BackgroundSubtractorGMG createBackgroundSubtractorGMG(int initializationFrames)
java: BackgroundSubtractorGMG createBackgroundSubtractorGMG()
FUNC <Ptr_BackgroundSubtractorGSOC cv.bgsegm..createBackgroundSubtractorGSOC [ARG int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE, ARG int nSamples=20, ARG float replaceRate=0.003f, ARG float propagationRate=0.01f, ARG int hitsThreshold=32, ARG float alpha=0.01f, ARG float beta=0.0022f, ARG float blinkingSupressionDecay=0.1f, ARG float blinkingSupressionMultiplier=0.1f, ARG float noiseRemovalThresholdFacBG=0.0004f, ARG float noiseRemovalThresholdFacFG=0.0008f]>
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta, float blinkingSupressionDecay, float blinkingSupressionMultiplier, float noiseRemovalThresholdFacBG, float noiseRemovalThresholdFacFG)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta, float blinkingSupressionDecay, float blinkingSupressionMultiplier, float noiseRemovalThresholdFacBG)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta, float blinkingSupressionDecay, float blinkingSupressionMultiplier)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta, float blinkingSupressionDecay)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC()
FUNC <Ptr_BackgroundSubtractorLSBP cv.bgsegm..createBackgroundSubtractorLSBP [ARG int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE, ARG int nSamples=20, ARG int LSBPRadius=16, ARG float Tlower=2.0f, ARG float Tupper=32.0f, ARG float Tinc=1.0f, ARG float Tdec=0.05f, ARG float Rscale=10.0f, ARG float Rincdec=0.005f, ARG float noiseRemovalThresholdFacBG=0.0004f, ARG float noiseRemovalThresholdFacFG=0.0008f, ARG int LSBPthreshold=8, ARG int minCount=2]>
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec, float noiseRemovalThresholdFacBG, float noiseRemovalThresholdFacFG, int LSBPthreshold, int minCount)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec, float noiseRemovalThresholdFacBG, float noiseRemovalThresholdFacFG, int LSBPthreshold)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec, float noiseRemovalThresholdFacBG, float noiseRemovalThresholdFacFG)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec, float noiseRemovalThresholdFacBG)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP()
FUNC <Ptr_BackgroundSubtractorMOG cv.bgsegm..createBackgroundSubtractorMOG [ARG int history=200, ARG int nmixtures=5, ARG double backgroundRatio=0.7, ARG double noiseSigma=0]>
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma)
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio)
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG(int history, int nmixtures)
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG(int history)
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG()
FUNC <Ptr_SyntheticSequenceGenerator cv.bgsegm..createSyntheticSequenceGenerator [ARG Mat background=, ARG Mat object=, ARG double amplitude=2.0, ARG double wavelength=20.0, ARG double wavespeed=0.2, ARG double objspeed=6.0]>
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object, double amplitude, double wavelength, double wavespeed, double objspeed)
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object, double amplitude, double wavelength, double wavespeed)
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object, double amplitude, double wavelength)
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object, double amplitude)
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object)
CLASS cv.bgsegm::.BackgroundSubtractorCNT : BackgroundSubtractor
FUNC <bool cv.bgsegm.BackgroundSubtractorCNT.getIsParallel []>
java: boolean getIsParallel()
FUNC <bool cv.bgsegm.BackgroundSubtractorCNT.getUseHistory []>
java: boolean getUseHistory()
FUNC <int cv.bgsegm.BackgroundSubtractorCNT.getMaxPixelStability []>
java: int getMaxPixelStability()
FUNC <int cv.bgsegm.BackgroundSubtractorCNT.getMinPixelStability []>
java: int getMinPixelStability()
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setIsParallel [ARG bool value=]>
java: void setIsParallel(boolean value)
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setMaxPixelStability [ARG int value=]>
java: void setMaxPixelStability(int value)
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setMinPixelStability [ARG int value=]>
java: void setMinPixelStability(int value)
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setUseHistory [ARG bool value=]>
java: void setUseHistory(boolean value)
CLASS cv.bgsegm::.BackgroundSubtractorLSBPDesc : 
CLASS cv.bgsegm::.BackgroundSubtractorLSBP : BackgroundSubtractor
FUNC <void cv.bgsegm.BackgroundSubtractorLSBP.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.bgsegm.BackgroundSubtractorLSBP.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS cv.bgsegm::.SyntheticSequenceGenerator : Algorithm
FUNC < cv.bgsegm.SyntheticSequenceGenerator.SyntheticSequenceGenerator [ARG Mat background=, ARG Mat object=, ARG double amplitude=, ARG double wavelength=, ARG double wavespeed=, ARG double objspeed=]>
java:  SyntheticSequenceGenerator(Mat background, Mat object, double amplitude, double wavelength, double wavespeed, double objspeed)
FUNC <void cv.bgsegm.SyntheticSequenceGenerator.getNextFrame [ARG Mat frame=, ARG Mat gtMask=]>
java: void getNextFrame(Mat frame, Mat gtMask)
CLASS cv.bgsegm::.BackgroundSubtractorGSOC : BackgroundSubtractor
FUNC <void cv.bgsegm.BackgroundSubtractorGSOC.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.bgsegm.BackgroundSubtractorGSOC.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS cv.bgsegm::.BackgroundSubtractorMOG : BackgroundSubtractor
FUNC <double cv.bgsegm.BackgroundSubtractorMOG.getBackgroundRatio []>
java: double getBackgroundRatio()
FUNC <double cv.bgsegm.BackgroundSubtractorMOG.getNoiseSigma []>
java: double getNoiseSigma()
FUNC <int cv.bgsegm.BackgroundSubtractorMOG.getHistory []>
java: int getHistory()
FUNC <int cv.bgsegm.BackgroundSubtractorMOG.getNMixtures []>
java: int getNMixtures()
FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setBackgroundRatio [ARG double backgroundRatio=]>
java: void setBackgroundRatio(double backgroundRatio)
FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setHistory [ARG int nframes=]>
java: void setHistory(int nframes)
FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setNMixtures [ARG int nmix=]>
java: void setNMixtures(int nmix)
FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setNoiseSigma [ARG double noiseSigma=]>
java: void setNoiseSigma(double noiseSigma)

=== MODULE: bioinspired (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired) ===


Files (5):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/retinafasttonemapping.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/transientareassegmentationmodule.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/bioinspired.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/retina.hpp']

Common headers (0):
[]
ok: class CLASS ::.Bioinspired : , name: Bioinspired, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/retinafasttonemapping.hpp =====
Namespaces: set([u'cv', u'cv.bioinspired'])

--- Incoming ---
[   u'class cv.bioinspired.RetinaFastToneMapping',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.bioinspired::.RetinaFastToneMapping : Algorithm, name: RetinaFastToneMapping, base: Algorithm

--- Incoming ---
[   u'cv.bioinspired.RetinaFastToneMapping.applyFastToneMapping',
    u'void',
    ['/V'],
    [   ['Mat', u'inputImage', '', []],
        ['Mat', u'outputToneMappedImage', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bioinspired.RetinaFastToneMapping.applyFastToneMapping [ARG Mat inputImage=, ARG Mat outputToneMappedImage=]>

--- Incoming ---
[   u'cv.bioinspired.RetinaFastToneMapping.setup',
    u'void',
    ['/V'],
    [   [u'float', u'photoreceptorsNeighborhoodRadius', u'3.f', ['/C']],
        [u'float', u'ganglioncellsNeighborhoodRadius', u'1.f', ['/C']],
        [u'float', u'meanLuminanceModulatorK', u'1.f', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.RetinaFastToneMapping.setup [ARG float photoreceptorsNeighborhoodRadius=3.f, ARG float ganglioncellsNeighborhoodRadius=1.f, ARG float meanLuminanceModulatorK=1.f]>

--- Incoming ---
[   u'cv.bioinspired.RetinaFastToneMapping.create',
    u'Ptr_RetinaFastToneMapping',
    ['/S'],
    [[u'Size', u'inputSize', u'', []]],
    u'Ptr<RetinaFastToneMapping>']
ok: FUNC <Ptr_RetinaFastToneMapping cv.bioinspired.RetinaFastToneMapping.create [ARG Size inputSize=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/transientareassegmentationmodule.hpp =====
Namespaces: set([u'cv', u'cv.bioinspired'])

--- Incoming ---
[   u'class cv.bioinspired.TransientAreasSegmentationModule',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.bioinspired::.TransientAreasSegmentationModule : Algorithm, name: TransientAreasSegmentationModule, base: Algorithm

--- Incoming ---
[   u'cv.bioinspired.TransientAreasSegmentationModule.getSize',
    u'Size',
    ['/V'],
    [],
    u'Size']
ok: FUNC <Size cv.bioinspired.TransientAreasSegmentationModule.getSize []>

--- Incoming ---
[   u'cv.bioinspired.TransientAreasSegmentationModule.setup',
    u'void',
    ['/V'],
    [   [u'String', u'segmentationParameterFile', u'""', []],
        [u'bool', u'applyDefaultSetupOnFailure', u'true', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.setup [ARG String segmentationParameterFile="", ARG bool applyDefaultSetupOnFailure=true]>

--- Incoming ---
[   u'cv.bioinspired.TransientAreasSegmentationModule.printSetup',
    u'String',
    ['/V'],
    [],
    u'String']
ok: FUNC <String cv.bioinspired.TransientAreasSegmentationModule.printSetup []>

--- Incoming ---
[   u'cv.bioinspired.TransientAreasSegmentationModule.write',
    u'void',
    ['/V'],
    [[u'String', u'fs', u'', []]],
    u'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.write [ARG String fs=]>

--- Incoming ---
[   u'cv.bioinspired.TransientAreasSegmentationModule.run',
    u'void',
    ['/V'],
    [   ['Mat', u'inputToSegment', '', []],
        [u'int', u'channelIndex', u'0', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.run [ARG Mat inputToSegment=, ARG int channelIndex=0]>

--- Incoming ---
[   u'cv.bioinspired.TransientAreasSegmentationModule.getSegmentationPicture',
    u'void',
    ['/V'],
    [['Mat', u'transientAreas', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.getSegmentationPicture [ARG Mat transientAreas=]>

--- Incoming ---
[   u'cv.bioinspired.TransientAreasSegmentationModule.clearAllBuffers',
    u'void',
    ['/V'],
    [],
    u'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.clearAllBuffers []>

--- Incoming ---
[   u'cv.bioinspired.TransientAreasSegmentationModule.create',
    u'Ptr_TransientAreasSegmentationModule',
    ['/S'],
    [[u'Size', u'inputSize', u'', []]],
    u'Ptr<TransientAreasSegmentationModule>']
ok: FUNC <Ptr_TransientAreasSegmentationModule cv.bioinspired.TransientAreasSegmentationModule.create [ARG Size inputSize=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/bioinspired.hpp =====
Namespaces: set([u'cv', u'cv.bioinspired'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/bioinspired.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/retina.hpp =====
Namespaces: set([u'cv', u'cv.bioinspired'])

--- Incoming ---
[   u'enum cv.bioinspired.<unnamed>',
    '',
    [],
    [   [u'const cv.bioinspired.RETINA_COLOR_RANDOM', '0', [], [], None, ''],
        [   u'const cv.bioinspired.RETINA_COLOR_DIAGONAL',
            '1',
            [],
            [],
            None,
            ''],
        [u'const cv.bioinspired.RETINA_COLOR_BAYER', '2', [], [], None, '']],
    None]
ok: CONST RETINA_COLOR_RANDOM=0
ok: CONST RETINA_COLOR_DIAGONAL=1
ok: CONST RETINA_COLOR_BAYER=2

--- Incoming ---
[u'class cv.bioinspired.Retina', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.bioinspired::.Retina : Algorithm, name: Retina, base: Algorithm

--- Incoming ---
[u'cv.bioinspired.Retina.getInputSize', u'Size', ['/V'], [], u'Size']
ok: FUNC <Size cv.bioinspired.Retina.getInputSize []>

--- Incoming ---
[u'cv.bioinspired.Retina.getOutputSize', u'Size', ['/V'], [], u'Size']
ok: FUNC <Size cv.bioinspired.Retina.getOutputSize []>

--- Incoming ---
[   u'cv.bioinspired.Retina.setup',
    u'void',
    ['/V'],
    [   [u'String', u'retinaParameterFile', u'""', []],
        [u'bool', u'applyDefaultSetupOnFailure', u'true', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.setup [ARG String retinaParameterFile="", ARG bool applyDefaultSetupOnFailure=true]>

--- Incoming ---
[u'cv.bioinspired.Retina.printSetup', u'String', ['/V'], [], u'String']
ok: FUNC <String cv.bioinspired.Retina.printSetup []>

--- Incoming ---
[   u'cv.bioinspired.Retina.write',
    u'void',
    ['/V'],
    [[u'String', u'fs', u'', []]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.write [ARG String fs=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.setupOPLandIPLParvoChannel',
    u'void',
    ['/V'],
    [   [u'bool', u'colorMode', u'true', ['/C']],
        [u'bool', u'normaliseOutput', u'true', ['/C']],
        [   u'float',
            u'photoreceptorsLocalAdaptationSensitivity',
            u'0.7f',
            ['/C']],
        [u'float', u'photoreceptorsTemporalConstant', u'0.5f', ['/C']],
        [u'float', u'photoreceptorsSpatialConstant', u'0.53f', ['/C']],
        [u'float', u'horizontalCellsGain', u'0.f', ['/C']],
        [u'float', u'HcellsTemporalConstant', u'1.f', ['/C']],
        [u'float', u'HcellsSpatialConstant', u'7.f', ['/C']],
        [u'float', u'ganglionCellsSensitivity', u'0.7f', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.setupOPLandIPLParvoChannel [ARG bool colorMode=true, ARG bool normaliseOutput=true, ARG float photoreceptorsLocalAdaptationSensitivity=0.7f, ARG float photoreceptorsTemporalConstant=0.5f, ARG float photoreceptorsSpatialConstant=0.53f, ARG float horizontalCellsGain=0.f, ARG float HcellsTemporalConstant=1.f, ARG float HcellsSpatialConstant=7.f, ARG float ganglionCellsSensitivity=0.7f]>

--- Incoming ---
[   u'cv.bioinspired.Retina.setupIPLMagnoChannel',
    u'void',
    ['/V'],
    [   [u'bool', u'normaliseOutput', u'true', ['/C']],
        [u'float', u'parasolCells_beta', u'0.f', ['/C']],
        [u'float', u'parasolCells_tau', u'0.f', ['/C']],
        [u'float', u'parasolCells_k', u'7.f', ['/C']],
        [u'float', u'amacrinCellsTemporalCutFrequency', u'1.2f', ['/C']],
        [u'float', u'V0CompressionParameter', u'0.95f', ['/C']],
        [u'float', u'localAdaptintegration_tau', u'0.f', ['/C']],
        [u'float', u'localAdaptintegration_k', u'7.f', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.setupIPLMagnoChannel [ARG bool normaliseOutput=true, ARG float parasolCells_beta=0.f, ARG float parasolCells_tau=0.f, ARG float parasolCells_k=7.f, ARG float amacrinCellsTemporalCutFrequency=1.2f, ARG float V0CompressionParameter=0.95f, ARG float localAdaptintegration_tau=0.f, ARG float localAdaptintegration_k=7.f]>

--- Incoming ---
[   u'cv.bioinspired.Retina.run',
    u'void',
    ['/V'],
    [['Mat', u'inputImage', '', []]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.run [ARG Mat inputImage=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.applyFastToneMapping',
    u'void',
    ['/V'],
    [   ['Mat', u'inputImage', '', []],
        ['Mat', u'outputToneMappedImage', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.applyFastToneMapping [ARG Mat inputImage=, ARG Mat outputToneMappedImage=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.getParvo',
    u'void',
    ['/V'],
    [['Mat', u'retinaOutput_parvo', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.getParvo [ARG Mat retinaOutput_parvo=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.getParvoRAW',
    u'void',
    ['/V'],
    [['Mat', u'retinaOutput_parvo', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.getParvoRAW [ARG Mat retinaOutput_parvo=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.getMagno',
    u'void',
    ['/V'],
    [['Mat', u'retinaOutput_magno', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.getMagno [ARG Mat retinaOutput_magno=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.getMagnoRAW',
    u'void',
    ['/V'],
    [['Mat', u'retinaOutput_magno', '', ['/O']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.getMagnoRAW [ARG Mat retinaOutput_magno=]>

--- Incoming ---
[u'cv.bioinspired.Retina.getMagnoRAW', u'Mat', ['/V'], [], u'Mat']
ok: FUNC <Mat cv.bioinspired.Retina.getMagnoRAW []>

--- Incoming ---
[u'cv.bioinspired.Retina.getParvoRAW', u'Mat', ['/V'], [], u'Mat']
ok: FUNC <Mat cv.bioinspired.Retina.getParvoRAW []>

--- Incoming ---
[   u'cv.bioinspired.Retina.setColorSaturation',
    u'void',
    ['/V'],
    [   [u'bool', u'saturateColors', u'true', ['/C']],
        [u'float', u'colorSaturationValue', u'4.0f', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.setColorSaturation [ARG bool saturateColors=true, ARG float colorSaturationValue=4.0f]>

--- Incoming ---
[u'cv.bioinspired.Retina.clearBuffers', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.bioinspired.Retina.clearBuffers []>

--- Incoming ---
[   u'cv.bioinspired.Retina.activateMovingContoursProcessing',
    u'void',
    ['/V'],
    [[u'bool', u'activate', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.activateMovingContoursProcessing [ARG bool activate=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.activateContoursProcessing',
    u'void',
    ['/V'],
    [[u'bool', u'activate', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.bioinspired.Retina.activateContoursProcessing [ARG bool activate=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.create',
    u'Ptr_Retina',
    ['/S'],
    [[u'Size', u'inputSize', u'', []]],
    u'Ptr<Retina>']
ok: FUNC <Ptr_Retina cv.bioinspired.Retina.create [ARG Size inputSize=]>

--- Incoming ---
[   u'cv.bioinspired.Retina.create',
    u'Ptr_Retina',
    ['/S'],
    [   [u'Size', u'inputSize', u'', []],
        [u'bool', u'colorMode', u'', ['/C']],
        [u'int', u'colorSamplingMethod', u'RETINA_COLOR_BAYER', []],
        [u'bool', u'useRetinaLogSampling', u'false', ['/C']],
        [u'float', u'reductionFactor', u'1.0f', ['/C']],
        [u'float', u'samplingStrenght', u'10.0f', ['/C']]],
    u'Ptr<Retina>']
ok: FUNC <Ptr_Retina cv.bioinspired.Retina.create [ARG Size inputSize=, ARG bool colorMode=, ARG int colorSamplingMethod=RETINA_COLOR_BAYER, ARG bool useRetinaLogSampling=false, ARG float reductionFactor=1.0f, ARG float samplingStrenght=10.0f]>


===== Generating... =====
CLASS cv.bioinspired::.TransientAreasSegmentationModule : Algorithm
FUNC <Ptr_TransientAreasSegmentationModule cv.bioinspired.TransientAreasSegmentationModule.create [ARG Size inputSize=]>
java: TransientAreasSegmentationModule create(Size inputSize)
FUNC <Size cv.bioinspired.TransientAreasSegmentationModule.getSize []>
java: Size getSize()
FUNC <String cv.bioinspired.TransientAreasSegmentationModule.printSetup []>
java: String printSetup()
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.clearAllBuffers []>
java: void clearAllBuffers()
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.getSegmentationPicture [ARG Mat transientAreas=]>
java: void getSegmentationPicture(Mat transientAreas)
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.run [ARG Mat inputToSegment=, ARG int channelIndex=0]>
java: void run(Mat inputToSegment, int channelIndex)
java: void run(Mat inputToSegment)
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.setup [ARG String segmentationParameterFile="", ARG bool applyDefaultSetupOnFailure=true]>
java: void setup(String segmentationParameterFile, boolean applyDefaultSetupOnFailure)
java: void setup(String segmentationParameterFile)
java: void setup()
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.write [ARG String fs=]>
java: void write(String fs)
CLASS cv.bioinspired::.Retina : Algorithm
FUNC <Mat cv.bioinspired.Retina.getMagnoRAW []>
java: Mat getMagnoRAW()
FUNC <Mat cv.bioinspired.Retina.getParvoRAW []>
java: Mat getParvoRAW()
FUNC <Ptr_Retina cv.bioinspired.Retina.create [ARG Size inputSize=, ARG bool colorMode=, ARG int colorSamplingMethod=RETINA_COLOR_BAYER, ARG bool useRetinaLogSampling=false, ARG float reductionFactor=1.0f, ARG float samplingStrenght=10.0f]>
java: Retina create(Size inputSize, boolean colorMode, int colorSamplingMethod, boolean useRetinaLogSampling, float reductionFactor, float samplingStrenght)
java: Retina create(Size inputSize, boolean colorMode, int colorSamplingMethod, boolean useRetinaLogSampling, float reductionFactor)
java: Retina create(Size inputSize, boolean colorMode, int colorSamplingMethod, boolean useRetinaLogSampling)
java: Retina create(Size inputSize, boolean colorMode, int colorSamplingMethod)
java: Retina create(Size inputSize, boolean colorMode)
FUNC <Ptr_Retina cv.bioinspired.Retina.create [ARG Size inputSize=]>
java: Retina create(Size inputSize)
FUNC <Size cv.bioinspired.Retina.getInputSize []>
java: Size getInputSize()
FUNC <Size cv.bioinspired.Retina.getOutputSize []>
java: Size getOutputSize()
FUNC <String cv.bioinspired.Retina.printSetup []>
java: String printSetup()
FUNC <void cv.bioinspired.Retina.activateContoursProcessing [ARG bool activate=]>
java: void activateContoursProcessing(boolean activate)
FUNC <void cv.bioinspired.Retina.activateMovingContoursProcessing [ARG bool activate=]>
java: void activateMovingContoursProcessing(boolean activate)
FUNC <void cv.bioinspired.Retina.applyFastToneMapping [ARG Mat inputImage=, ARG Mat outputToneMappedImage=]>
java: void applyFastToneMapping(Mat inputImage, Mat outputToneMappedImage)
FUNC <void cv.bioinspired.Retina.clearBuffers []>
java: void clearBuffers()
FUNC <void cv.bioinspired.Retina.getMagno [ARG Mat retinaOutput_magno=]>
java: void getMagno(Mat retinaOutput_magno)
FUNC <void cv.bioinspired.Retina.getMagnoRAW [ARG Mat retinaOutput_magno=]>
java: void getMagnoRAW(Mat retinaOutput_magno)
FUNC <void cv.bioinspired.Retina.getParvo [ARG Mat retinaOutput_parvo=]>
java: void getParvo(Mat retinaOutput_parvo)
FUNC <void cv.bioinspired.Retina.getParvoRAW [ARG Mat retinaOutput_parvo=]>
java: void getParvoRAW(Mat retinaOutput_parvo)
FUNC <void cv.bioinspired.Retina.run [ARG Mat inputImage=]>
java: void run(Mat inputImage)
FUNC <void cv.bioinspired.Retina.setColorSaturation [ARG bool saturateColors=true, ARG float colorSaturationValue=4.0f]>
java: void setColorSaturation(boolean saturateColors, float colorSaturationValue)
java: void setColorSaturation(boolean saturateColors)
java: void setColorSaturation()
FUNC <void cv.bioinspired.Retina.setup [ARG String retinaParameterFile="", ARG bool applyDefaultSetupOnFailure=true]>
java: void setup(String retinaParameterFile, boolean applyDefaultSetupOnFailure)
java: void setup(String retinaParameterFile)
java: void setup()
FUNC <void cv.bioinspired.Retina.setupIPLMagnoChannel [ARG bool normaliseOutput=true, ARG float parasolCells_beta=0.f, ARG float parasolCells_tau=0.f, ARG float parasolCells_k=7.f, ARG float amacrinCellsTemporalCutFrequency=1.2f, ARG float V0CompressionParameter=0.95f, ARG float localAdaptintegration_tau=0.f, ARG float localAdaptintegration_k=7.f]>
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k, float amacrinCellsTemporalCutFrequency, float V0CompressionParameter, float localAdaptintegration_tau, float localAdaptintegration_k)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k, float amacrinCellsTemporalCutFrequency, float V0CompressionParameter, float localAdaptintegration_tau)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k, float amacrinCellsTemporalCutFrequency, float V0CompressionParameter)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k, float amacrinCellsTemporalCutFrequency)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta)
java: void setupIPLMagnoChannel(boolean normaliseOutput)
java: void setupIPLMagnoChannel()
FUNC <void cv.bioinspired.Retina.setupOPLandIPLParvoChannel [ARG bool colorMode=true, ARG bool normaliseOutput=true, ARG float photoreceptorsLocalAdaptationSensitivity=0.7f, ARG float photoreceptorsTemporalConstant=0.5f, ARG float photoreceptorsSpatialConstant=0.53f, ARG float horizontalCellsGain=0.f, ARG float HcellsTemporalConstant=1.f, ARG float HcellsSpatialConstant=7.f, ARG float ganglionCellsSensitivity=0.7f]>
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant, float horizontalCellsGain, float HcellsTemporalConstant, float HcellsSpatialConstant, float ganglionCellsSensitivity)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant, float horizontalCellsGain, float HcellsTemporalConstant, float HcellsSpatialConstant)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant, float horizontalCellsGain, float HcellsTemporalConstant)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant, float horizontalCellsGain)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput)
java: void setupOPLandIPLParvoChannel(boolean colorMode)
java: void setupOPLandIPLParvoChannel()
FUNC <void cv.bioinspired.Retina.write [ARG String fs=]>
java: void write(String fs)
CLASS cv.bioinspired::.RetinaFastToneMapping : Algorithm
FUNC <Ptr_RetinaFastToneMapping cv.bioinspired.RetinaFastToneMapping.create [ARG Size inputSize=]>
java: RetinaFastToneMapping create(Size inputSize)
FUNC <void cv.bioinspired.RetinaFastToneMapping.applyFastToneMapping [ARG Mat inputImage=, ARG Mat outputToneMappedImage=]>
java: void applyFastToneMapping(Mat inputImage, Mat outputToneMappedImage)
FUNC <void cv.bioinspired.RetinaFastToneMapping.setup [ARG float photoreceptorsNeighborhoodRadius=3.f, ARG float ganglioncellsNeighborhoodRadius=1.f, ARG float meanLuminanceModulatorK=1.f]>
java: void setup(float photoreceptorsNeighborhoodRadius, float ganglioncellsNeighborhoodRadius, float meanLuminanceModulatorK)
java: void setup(float photoreceptorsNeighborhoodRadius, float ganglioncellsNeighborhoodRadius)
java: void setup(float photoreceptorsNeighborhoodRadius)
java: void setup()
CLASS ::.Bioinspired : 
[CONST RETINA_COLOR_RANDOM=0, CONST RETINA_COLOR_DIAGONAL=1, CONST RETINA_COLOR_BAYER=2]

=== MODULE: face (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face) ===


Files (10):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facerec.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/predict_collector.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/mace.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facemark.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facemark_train.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/bif.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/face_alignment.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facemarkLBF.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facemarkAAM.hpp']

Common headers (0):
[]
ok: class CLASS ::.Face : , name: Face, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[u'class cv.face.FaceRecognizer', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.face::.FaceRecognizer : Algorithm, name: FaceRecognizer, base: Algorithm

--- Incoming ---
[   u'cv.face.FaceRecognizer.train',
    u'void',
    ['/V', '/PV'],
    [['vector_Mat', u'src', '', []], ['Mat', u'labels', '', []]],
    u'void']
ok: FUNC <void cv.face.FaceRecognizer.train [ARG vector_Mat src=, ARG Mat labels=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.update',
    u'void',
    ['/V'],
    [['vector_Mat', u'src', '', []], ['Mat', u'labels', '', []]],
    u'void']
ok: FUNC <void cv.face.FaceRecognizer.update [ARG vector_Mat src=, ARG Mat labels=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.predict',
    u'int',
    [u'=predict_label', '/C'],
    [['Mat', u'src', '', []]],
    u'int']
ok: FUNC <int cv.face.FaceRecognizer.predict [ARG Mat src=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.predict',
    u'void',
    ['/C'],
    [   ['Mat', u'src', '', []],
        [u'int', u'label', u'', ['/O', '/Ref']],
        [u'double', u'confidence', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.face.FaceRecognizer.predict [ARG Mat src=, ARG int label=, ARG double confidence=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.predict',
    u'void',
    [u'=predict_collect', '/C', '/V', '/PV'],
    [   ['Mat', u'src', '', []],
        [u'Ptr_PredictCollector', u'collector', u'', []]],
    u'void']
ok: FUNC <void cv.face.FaceRecognizer.predict [ARG Mat src=, ARG Ptr_PredictCollector collector=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.write',
    u'void',
    ['/C', '/V'],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.face.FaceRecognizer.write [ARG String filename=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.read',
    u'void',
    ['/V'],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.face.FaceRecognizer.read [ARG String filename=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.setLabelInfo',
    u'void',
    ['/V'],
    [   [u'int', u'label', u'', []],
        [u'String', u'strInfo', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.face.FaceRecognizer.setLabelInfo [ARG int label=, ARG String strInfo=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.getLabelInfo',
    u'String',
    ['/C', '/V'],
    [[u'int', u'label', u'', []]],
    u'String']
ok: FUNC <String cv.face.FaceRecognizer.getLabelInfo [ARG int label=]>

--- Incoming ---
[   u'cv.face.FaceRecognizer.getLabelsByString',
    u'vector_int',
    ['/C', '/V'],
    [[u'String', u'str', u'', ['/C', '/Ref']]],
    u'std::vector<int>']
ok: FUNC <vector_int cv.face.FaceRecognizer.getLabelsByString [ARG String str=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facerec.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[   u'class cv.face.BasicFaceRecognizer',
    u': cv::face::FaceRecognizer',
    [],
    [],
    None]
ok: class CLASS cv.face::.BasicFaceRecognizer : FaceRecognizer, name: BasicFaceRecognizer, base: FaceRecognizer

--- Incoming ---
[u'cv.face.BasicFaceRecognizer.getNumComponents', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.face.BasicFaceRecognizer.getNumComponents []>

--- Incoming ---
[   u'cv.face.BasicFaceRecognizer.setNumComponents',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.face.BasicFaceRecognizer.setNumComponents [ARG int val=]>

--- Incoming ---
[u'cv.face.BasicFaceRecognizer.getThreshold', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.face.BasicFaceRecognizer.getThreshold []>

--- Incoming ---
[   u'cv.face.BasicFaceRecognizer.setThreshold',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.face.BasicFaceRecognizer.setThreshold [ARG double val=]>

--- Incoming ---
[   u'cv.face.BasicFaceRecognizer.getProjections',
    u'vector_Mat',
    ['/C'],
    [],
    u'std::vector<cv::Mat>']
ok: FUNC <vector_Mat cv.face.BasicFaceRecognizer.getProjections []>

--- Incoming ---
[u'cv.face.BasicFaceRecognizer.getLabels', u'Mat', ['/C'], [], u'cv::Mat']
ok: FUNC <Mat cv.face.BasicFaceRecognizer.getLabels []>

--- Incoming ---
[u'cv.face.BasicFaceRecognizer.getEigenValues', u'Mat', ['/C'], [], u'cv::Mat']
ok: FUNC <Mat cv.face.BasicFaceRecognizer.getEigenValues []>

--- Incoming ---
[   u'cv.face.BasicFaceRecognizer.getEigenVectors',
    u'Mat',
    ['/C'],
    [],
    u'cv::Mat']
ok: FUNC <Mat cv.face.BasicFaceRecognizer.getEigenVectors []>

--- Incoming ---
[u'cv.face.BasicFaceRecognizer.getMean', u'Mat', ['/C'], [], u'cv::Mat']
ok: FUNC <Mat cv.face.BasicFaceRecognizer.getMean []>

--- Incoming ---
[   u'class cv.face.EigenFaceRecognizer',
    u': cv::face::BasicFaceRecognizer',
    [],
    [],
    None]
ok: class CLASS cv.face::.EigenFaceRecognizer : BasicFaceRecognizer, name: EigenFaceRecognizer, base: BasicFaceRecognizer

--- Incoming ---
[   u'cv.face.EigenFaceRecognizer.create',
    u'Ptr_EigenFaceRecognizer',
    ['/S'],
    [   [u'int', u'num_components', u'0', []],
        [u'double', u'threshold', u'DBL_MAX', []]],
    u'Ptr<EigenFaceRecognizer>']
ok: FUNC <Ptr_EigenFaceRecognizer cv.face.EigenFaceRecognizer.create [ARG int num_components=0, ARG double threshold=DBL_MAX]>

--- Incoming ---
[   u'class cv.face.FisherFaceRecognizer',
    u': cv::face::BasicFaceRecognizer',
    [],
    [],
    None]
ok: class CLASS cv.face::.FisherFaceRecognizer : BasicFaceRecognizer, name: FisherFaceRecognizer, base: BasicFaceRecognizer

--- Incoming ---
[   u'cv.face.FisherFaceRecognizer.create',
    u'Ptr_FisherFaceRecognizer',
    ['/S'],
    [   [u'int', u'num_components', u'0', []],
        [u'double', u'threshold', u'DBL_MAX', []]],
    u'Ptr<FisherFaceRecognizer>']
ok: FUNC <Ptr_FisherFaceRecognizer cv.face.FisherFaceRecognizer.create [ARG int num_components=0, ARG double threshold=DBL_MAX]>

--- Incoming ---
[   u'class cv.face.LBPHFaceRecognizer',
    u': cv::face::FaceRecognizer',
    [],
    [],
    None]
ok: class CLASS cv.face::.LBPHFaceRecognizer : FaceRecognizer, name: LBPHFaceRecognizer, base: FaceRecognizer

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.getGridX',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.face.LBPHFaceRecognizer.getGridX []>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.setGridX',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setGridX [ARG int val=]>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.getGridY',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.face.LBPHFaceRecognizer.getGridY []>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.setGridY',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setGridY [ARG int val=]>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.getRadius',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.face.LBPHFaceRecognizer.getRadius []>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.setRadius',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setRadius [ARG int val=]>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.getNeighbors',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.face.LBPHFaceRecognizer.getNeighbors []>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.setNeighbors',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setNeighbors [ARG int val=]>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.getThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.face.LBPHFaceRecognizer.getThreshold []>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setThreshold [ARG double val=]>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.getHistograms',
    u'vector_Mat',
    ['/C', '/V', '/PV'],
    [],
    u'std::vector<cv::Mat>']
ok: FUNC <vector_Mat cv.face.LBPHFaceRecognizer.getHistograms []>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.getLabels',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'cv::Mat']
ok: FUNC <Mat cv.face.LBPHFaceRecognizer.getLabels []>

--- Incoming ---
[   u'cv.face.LBPHFaceRecognizer.create',
    u'Ptr_LBPHFaceRecognizer',
    ['/S'],
    [   [u'int', u'radius', u'1', []],
        [u'int', u'neighbors', u'8', []],
        [u'int', u'grid_x', u'8', []],
        [u'int', u'grid_y', u'8', []],
        [u'double', u'threshold', u'DBL_MAX', []]],
    u'Ptr<LBPHFaceRecognizer>']
ok: FUNC <Ptr_LBPHFaceRecognizer cv.face.LBPHFaceRecognizer.create [ARG int radius=1, ARG int neighbors=8, ARG int grid_x=8, ARG int grid_y=8, ARG double threshold=DBL_MAX]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/predict_collector.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[u'class cv.face.PredictCollector', '', [], [], None]
ok: class CLASS cv.face::.PredictCollector : , name: PredictCollector, base: 

--- Incoming ---
[   u'class cv.face.StandardCollector',
    u': cv::face::PredictCollector',
    [],
    [],
    None]
ok: class CLASS cv.face::.StandardCollector : PredictCollector, name: StandardCollector, base: PredictCollector

--- Incoming ---
[u'cv.face.StandardCollector.getMinLabel', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.face.StandardCollector.getMinLabel []>

--- Incoming ---
[u'cv.face.StandardCollector.getMinDist', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.face.StandardCollector.getMinDist []>

--- Incoming ---
[   u'cv.face.StandardCollector.getResults',
    u'vector_pair_int_and_double',
    ['/C'],
    [[u'bool', u'sorted', u'false', []]],
    u'std::vector< std::pair<int, double> >']
ok: FUNC <vector_pair_int_and_double cv.face.StandardCollector.getResults [ARG bool sorted=false]>

--- Incoming ---
[   u'cv.face.StandardCollector.create',
    u'Ptr_StandardCollector',
    ['/S'],
    [[u'double', u'threshold', u'DBL_MAX', []]],
    u'Ptr<StandardCollector>']
ok: FUNC <Ptr_StandardCollector cv.face.StandardCollector.create [ARG double threshold=DBL_MAX]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/mace.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[u'class cv.face.MACE', u': cv::Algorithm', [], [], None]
ok: class CLASS cv.face::.MACE : Algorithm, name: MACE, base: Algorithm

--- Incoming ---
[   u'cv.face.MACE.salt',
    u'void',
    ['/V', '/PV'],
    [[u'String', u'passphrase', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.face.MACE.salt [ARG String passphrase=]>

--- Incoming ---
[   u'cv.face.MACE.train',
    u'void',
    ['/V', '/PV'],
    [['vector_Mat', u'images', '', []]],
    u'void']
ok: FUNC <void cv.face.MACE.train [ARG vector_Mat images=]>

--- Incoming ---
[   u'cv.face.MACE.same',
    u'bool',
    ['/C', '/V', '/PV'],
    [['Mat', u'query', '', []]],
    u'bool']
ok: FUNC <bool cv.face.MACE.same [ARG Mat query=]>

--- Incoming ---
[   u'cv.face.MACE.load',
    u'Ptr_MACE',
    ['/S'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'objname', u'String()', ['/C', '/Ref']]],
    u'cv::Ptr<MACE>']
ok: FUNC <Ptr_MACE cv.face.MACE.load [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   u'cv.face.MACE.create',
    u'Ptr_MACE',
    ['/S'],
    [[u'int', u'IMGSIZE', u'64', []]],
    u'cv::Ptr<MACE>']
ok: FUNC <Ptr_MACE cv.face.MACE.create [ARG int IMGSIZE=64]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facemark.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[u'class cv.face.Facemark', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.face::.Facemark : Algorithm, name: Facemark, base: Algorithm

--- Incoming ---
[   u'cv.face.Facemark.loadModel',
    u'void',
    ['/V', '/PV'],
    [[u'String', u'model', u'', []]],
    u'void']
ok: FUNC <void cv.face.Facemark.loadModel [ARG String model=]>

--- Incoming ---
[   u'cv.face.Facemark.fit',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'faces', '', []],
        ['vector_Mat', u'landmarks', '', ['/O']]],
    u'bool']
ok: FUNC <bool cv.face.Facemark.fit [ARG Mat image=, ARG vector_Rect faces=, ARG vector_vector_Point2f landmarks=]>

--- Incoming ---
[u'cv.face.createFacemarkAAM', u'Ptr_Facemark', [], [], u'Ptr<Facemark>']
ok: FUNC <Ptr_Facemark cv.face..createFacemarkAAM []>

--- Incoming ---
[u'cv.face.createFacemarkLBF', u'Ptr_Facemark', [], [], u'Ptr<Facemark>']
ok: FUNC <Ptr_Facemark cv.face..createFacemarkLBF []>

--- Incoming ---
[u'cv.face.createFacemarkKazemi', u'Ptr_Facemark', [], [], u'Ptr<Facemark>']
ok: FUNC <Ptr_Facemark cv.face..createFacemarkKazemi []>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facemark_train.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[   u'cv.face.getFacesHAAR',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'faces', '', ['/O']],
        [u'String', u'face_cascade_name', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.face..getFacesHAAR [ARG Mat image=, ARG Mat faces=, ARG String face_cascade_name=]>

--- Incoming ---
[   u'cv.face.loadDatasetList',
    u'bool',
    [],
    [   [u'String', u'imageList', u'', []],
        [u'String', u'annotationList', u'', []],
        [u'vector_String', u'images', u'', ['/Ref']],
        [u'vector_String', u'annotations', u'', ['/Ref']]],
    u'bool']
ok: FUNC <bool cv.face..loadDatasetList [ARG String imageList=, ARG String annotationList=, ARG vector_String images=, ARG vector_String annotations=]>

--- Incoming ---
[   u'cv.face.loadTrainingData',
    u'bool',
    [],
    [   [u'String', u'filename', u'', []],
        [u'vector_String', u'images', u'', ['/Ref']],
        ['Mat', u'facePoints', '', ['/O']],
        [u'char', u'delim', u"' '", []],
        [u'float', u'offset', u'0.0f', []]],
    u'bool']
ok: FUNC <bool cv.face..loadTrainingData [ARG String filename=, ARG vector_String images=, ARG Mat facePoints=, ARG char delim=' ', ARG float offset=0.0f]>

--- Incoming ---
[   u'cv.face.loadTrainingData',
    u'bool',
    [],
    [   [u'String', u'imageList', u'', []],
        [u'String', u'groundTruth', u'', []],
        [u'vector_String', u'images', u'', ['/Ref']],
        ['Mat', u'facePoints', '', ['/O']],
        [u'float', u'offset', u'0.0f', []]],
    u'bool']
ok: FUNC <bool cv.face..loadTrainingData [ARG String imageList=, ARG String groundTruth=, ARG vector_String images=, ARG Mat facePoints=, ARG float offset=0.0f]>

--- Incoming ---
[   u'cv.face.loadTrainingData',
    u'bool',
    [],
    [   [u'vector_String', u'filename', u'', []],
        [u'vector_vector_Point2f', u'trainlandmarks', u'', ['/Ref']],
        [u'vector_String', u'trainimages', u'', ['/Ref']]],
    u'bool']
ok: FUNC <bool cv.face..loadTrainingData [ARG vector_String filename=, ARG vector_vector_Point2f trainlandmarks=, ARG vector_String trainimages=]>

--- Incoming ---
[   u'cv.face.loadFacePoints',
    u'bool',
    [],
    [   [u'String', u'filename', u'', []],
        ['Mat', u'points', '', ['/O']],
        [u'float', u'offset', u'0.0f', []]],
    u'bool']
ok: FUNC <bool cv.face..loadFacePoints [ARG String filename=, ARG Mat points=, ARG float offset=0.0f]>

--- Incoming ---
[   u'cv.face.drawFacemarks',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'points', '', []],
        [u'Scalar', u'color', u'Scalar(255,0,0)', []]],
    u'void']
ok: FUNC <void cv.face..drawFacemarks [ARG Mat image=, ARG Mat points=, ARG Scalar color=Scalar(255,0,0)]>

--- Incoming ---
[u'class cv.face.FacemarkTrain', u': cv::face::Facemark', [], [], None]
ok: class CLASS cv.face::.FacemarkTrain : Facemark, name: FacemarkTrain, base: Facemark


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/bif.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[u'class cv.face.BIF', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.face::.BIF : Algorithm, name: BIF, base: Algorithm

--- Incoming ---
[u'cv.face.BIF.getNumBands', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.face.BIF.getNumBands []>

--- Incoming ---
[u'cv.face.BIF.getNumRotations', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.face.BIF.getNumRotations []>

--- Incoming ---
[   u'cv.face.BIF.compute',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'image', '', []], ['Mat', u'features', '', ['/O']]],
    u'void']
ok: FUNC <void cv.face.BIF.compute [ARG Mat image=, ARG Mat features=]>

--- Incoming ---
[   u'cv.face.BIF.create',
    u'Ptr_BIF',
    ['/S'],
    [[u'int', u'num_bands', u'8', []], [u'int', u'num_rotations', u'12', []]],
    u'Ptr<BIF>']
ok: FUNC <Ptr_BIF cv.face.BIF.create [ARG int num_bands=8, ARG int num_rotations=12]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/face_alignment.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[u'class cv.face.FacemarkKazemi', u': cv::face::Facemark', [], [], None]
ok: class CLASS cv.face::.FacemarkKazemi : Facemark, name: FacemarkKazemi, base: Facemark


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facemarkLBF.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[u'class cv.face.FacemarkLBF', u': cv::face::FacemarkTrain', [], [], None]
ok: class CLASS cv.face::.FacemarkLBF : FacemarkTrain, name: FacemarkLBF, base: FacemarkTrain


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/face/include/opencv2/face/facemarkAAM.hpp =====
Namespaces: set([u'cv', u'cv.face'])

--- Incoming ---
[u'class cv.face.FacemarkAAM', u': cv::face::FacemarkTrain', [], [], None]
ok: class CLASS cv.face::.FacemarkAAM : FacemarkTrain, name: FacemarkAAM, base: FacemarkTrain


===== Generating... =====
CLASS cv.face::.FisherFaceRecognizer : BasicFaceRecognizer
FUNC <Ptr_FisherFaceRecognizer cv.face.FisherFaceRecognizer.create [ARG int num_components=0, ARG double threshold=DBL_MAX]>
java: FisherFaceRecognizer create(int num_components, double threshold)
java: FisherFaceRecognizer create(int num_components)
java: FisherFaceRecognizer create()
CLASS cv.face::.FacemarkTrain : Facemark
CLASS cv.face::.BIF : Algorithm
FUNC <Ptr_BIF cv.face.BIF.create [ARG int num_bands=8, ARG int num_rotations=12]>
java: BIF create(int num_bands, int num_rotations)
java: BIF create(int num_bands)
java: BIF create()
FUNC <int cv.face.BIF.getNumBands []>
java: int getNumBands()
FUNC <int cv.face.BIF.getNumRotations []>
java: int getNumRotations()
FUNC <void cv.face.BIF.compute [ARG Mat image=, ARG Mat features=]>
java: void compute(Mat image, Mat features)
CLASS cv.face::.FacemarkKazemi : Facemark
CLASS cv.face::.FaceRecognizer : Algorithm
FUNC <String cv.face.FaceRecognizer.getLabelInfo [ARG int label=]>
java: String getLabelInfo(int label)
FUNC <int cv.face.FaceRecognizer.predict [ARG Mat src=]>
java: int predict_label(Mat src)
FUNC <vector_int cv.face.FaceRecognizer.getLabelsByString [ARG String str=]>
java: MatOfInt getLabelsByString(String str)
FUNC <void cv.face.FaceRecognizer.predict [ARG Mat src=, ARG Ptr_PredictCollector collector=]>
java: void predict_collect(Mat src, PredictCollector collector)
FUNC <void cv.face.FaceRecognizer.predict [ARG Mat src=, ARG int label=, ARG double confidence=]>
java: void predict(Mat src, int[] label, double[] confidence)
FUNC <void cv.face.FaceRecognizer.read [ARG String filename=]>
java: void read(String filename)
FUNC <void cv.face.FaceRecognizer.setLabelInfo [ARG int label=, ARG String strInfo=]>
java: void setLabelInfo(int label, String strInfo)
FUNC <void cv.face.FaceRecognizer.train [ARG vector_Mat src=, ARG Mat labels=]>
java: void train(List<Mat> src, Mat labels)
FUNC <void cv.face.FaceRecognizer.update [ARG vector_Mat src=, ARG Mat labels=]>
java: void update(List<Mat> src, Mat labels)
FUNC <void cv.face.FaceRecognizer.write [ARG String filename=]>
java: void write(String filename)
CLASS cv.face::.LBPHFaceRecognizer : FaceRecognizer
FUNC <Mat cv.face.LBPHFaceRecognizer.getLabels []>
java: Mat getLabels()
FUNC <Ptr_LBPHFaceRecognizer cv.face.LBPHFaceRecognizer.create [ARG int radius=1, ARG int neighbors=8, ARG int grid_x=8, ARG int grid_y=8, ARG double threshold=DBL_MAX]>
java: LBPHFaceRecognizer create(int radius, int neighbors, int grid_x, int grid_y, double threshold)
java: LBPHFaceRecognizer create(int radius, int neighbors, int grid_x, int grid_y)
java: LBPHFaceRecognizer create(int radius, int neighbors, int grid_x)
java: LBPHFaceRecognizer create(int radius, int neighbors)
java: LBPHFaceRecognizer create(int radius)
java: LBPHFaceRecognizer create()
FUNC <double cv.face.LBPHFaceRecognizer.getThreshold []>
java: double getThreshold()
FUNC <int cv.face.LBPHFaceRecognizer.getGridX []>
java: int getGridX()
FUNC <int cv.face.LBPHFaceRecognizer.getGridY []>
java: int getGridY()
FUNC <int cv.face.LBPHFaceRecognizer.getNeighbors []>
java: int getNeighbors()
FUNC <int cv.face.LBPHFaceRecognizer.getRadius []>
java: int getRadius()
FUNC <vector_Mat cv.face.LBPHFaceRecognizer.getHistograms []>
java: List<Mat> getHistograms()
FUNC <void cv.face.LBPHFaceRecognizer.setGridX [ARG int val=]>
java: void setGridX(int val)
FUNC <void cv.face.LBPHFaceRecognizer.setGridY [ARG int val=]>
java: void setGridY(int val)
FUNC <void cv.face.LBPHFaceRecognizer.setNeighbors [ARG int val=]>
java: void setNeighbors(int val)
FUNC <void cv.face.LBPHFaceRecognizer.setRadius [ARG int val=]>
java: void setRadius(int val)
FUNC <void cv.face.LBPHFaceRecognizer.setThreshold [ARG double val=]>
java: void setThreshold(double val)
CLASS ::.Face : 
FUNC <Ptr_Facemark cv.face..createFacemarkAAM []>
java: Facemark createFacemarkAAM()
FUNC <Ptr_Facemark cv.face..createFacemarkKazemi []>
java: Facemark createFacemarkKazemi()
FUNC <Ptr_Facemark cv.face..createFacemarkLBF []>
java: Facemark createFacemarkLBF()
FUNC <bool cv.face..getFacesHAAR [ARG Mat image=, ARG Mat faces=, ARG String face_cascade_name=]>
java: boolean getFacesHAAR(Mat image, Mat faces, String face_cascade_name)
FUNC <bool cv.face..loadDatasetList [ARG String imageList=, ARG String annotationList=, ARG vector_String images=, ARG vector_String annotations=]>
java: boolean loadDatasetList(String imageList, String annotationList, List<String> images, List<String> annotations)
FUNC <bool cv.face..loadFacePoints [ARG String filename=, ARG Mat points=, ARG float offset=0.0f]>
java: boolean loadFacePoints(String filename, Mat points, float offset)
java: boolean loadFacePoints(String filename, Mat points)
FUNC <bool cv.face..loadTrainingData [ARG String filename=, ARG vector_String images=, ARG Mat facePoints=, ARG char delim=' ', ARG float offset=0.0f]>
java: boolean loadTrainingData(String filename, List<String> images, Mat facePoints, char delim, float offset)
java: boolean loadTrainingData(String filename, List<String> images, Mat facePoints, char delim)
java: boolean loadTrainingData(String filename, List<String> images, Mat facePoints)
FUNC <bool cv.face..loadTrainingData [ARG String imageList=, ARG String groundTruth=, ARG vector_String images=, ARG Mat facePoints=, ARG float offset=0.0f]>
java: boolean loadTrainingData(String imageList, String groundTruth, List<String> images, Mat facePoints, float offset)
java: boolean loadTrainingData(String imageList, String groundTruth, List<String> images, Mat facePoints)
FUNC <bool cv.face..loadTrainingData [ARG vector_String filename=, ARG vector_vector_Point2f trainlandmarks=, ARG vector_String trainimages=]>
java: boolean loadTrainingData(List<String> filename, List<MatOfPoint2f> trainlandmarks, List<String> trainimages)
FUNC <void cv.face..drawFacemarks [ARG Mat image=, ARG Mat points=, ARG Scalar color=Scalar(255,0,0)]>
java: void drawFacemarks(Mat image, Mat points, Scalar color)
java: void drawFacemarks(Mat image, Mat points)
CLASS cv.face::.PredictCollector : 
CLASS cv.face::.MACE : Algorithm
FUNC <Ptr_MACE cv.face.MACE.create [ARG int IMGSIZE=64]>
java: MACE create(int IMGSIZE)
java: MACE create()
FUNC <Ptr_MACE cv.face.MACE.load [ARG String filename=, ARG String objname=String()]>
java: MACE load(String filename, String objname)
java: MACE load(String filename)
FUNC <bool cv.face.MACE.same [ARG Mat query=]>
java: boolean same(Mat query)
FUNC <void cv.face.MACE.salt [ARG String passphrase=]>
java: void salt(String passphrase)
FUNC <void cv.face.MACE.train [ARG vector_Mat images=]>
java: void train(List<Mat> images)
CLASS cv.face::.FacemarkLBF : FacemarkTrain
CLASS cv.face::.Facemark : Algorithm
FUNC <bool cv.face.Facemark.fit [ARG Mat image=, ARG vector_Rect faces=, ARG vector_vector_Point2f landmarks=]>
java: boolean fit(Mat image, MatOfRect faces, List<MatOfPoint2f> landmarks)
FUNC <void cv.face.Facemark.loadModel [ARG String model=]>
java: void loadModel(String model)
CLASS cv.face::.EigenFaceRecognizer : BasicFaceRecognizer
FUNC <Ptr_EigenFaceRecognizer cv.face.EigenFaceRecognizer.create [ARG int num_components=0, ARG double threshold=DBL_MAX]>
java: EigenFaceRecognizer create(int num_components, double threshold)
java: EigenFaceRecognizer create(int num_components)
java: EigenFaceRecognizer create()
CLASS cv.face::.BasicFaceRecognizer : FaceRecognizer
FUNC <Mat cv.face.BasicFaceRecognizer.getEigenValues []>
java: Mat getEigenValues()
FUNC <Mat cv.face.BasicFaceRecognizer.getEigenVectors []>
java: Mat getEigenVectors()
FUNC <Mat cv.face.BasicFaceRecognizer.getLabels []>
java: Mat getLabels()
FUNC <Mat cv.face.BasicFaceRecognizer.getMean []>
java: Mat getMean()
FUNC <double cv.face.BasicFaceRecognizer.getThreshold []>
java: double getThreshold()
FUNC <int cv.face.BasicFaceRecognizer.getNumComponents []>
java: int getNumComponents()
FUNC <vector_Mat cv.face.BasicFaceRecognizer.getProjections []>
java: List<Mat> getProjections()
FUNC <void cv.face.BasicFaceRecognizer.setNumComponents [ARG int val=]>
java: void setNumComponents(int val)
FUNC <void cv.face.BasicFaceRecognizer.setThreshold [ARG double val=]>
java: void setThreshold(double val)
CLASS cv.face::.StandardCollector : PredictCollector
FUNC <Ptr_StandardCollector cv.face.StandardCollector.create [ARG double threshold=DBL_MAX]>
java: StandardCollector create(double threshold)
java: StandardCollector create()
FUNC <double cv.face.StandardCollector.getMinDist []>
java: double getMinDist()
FUNC <int cv.face.StandardCollector.getMinLabel []>
java: int getMinLabel()
FUNC <vector_pair_int_and_double cv.face.StandardCollector.getResults [ARG bool sorted=false]>
SKIP:vector_pair_int_and_double cv::face::StandardCollector::getResults(bool sorted = false)	 due to RET type vector_pair_int_and_double
CLASS cv.face::.FacemarkAAM : FacemarkTrain

=== MODULE: tracking (/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking) ===


Files (9):
[u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_by_matching.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tracker.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineMIL.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineBoosting.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tldDataset.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tracking.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/feature.hpp',
 u'/home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/kalman_filters.hpp']

Common headers (0):
[]
ok: class CLASS ::.Tracking : , name: Tracking, base: 


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking.hpp =====
Namespaces: set([])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_by_matching.hpp =====
Namespaces: set([u'cv.tbm', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_by_matching.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tracker.hpp =====
Namespaces: set([u'cv.tbm', u'cv'])

--- Incoming ---
[u'class cv.Tracker', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.Tracker : Algorithm, name: Tracker, base: Algorithm

--- Incoming ---
[   u'cv.Tracker.init',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Rect2d', u'boundingBox', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.Tracker.init [ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
[   u'cv.Tracker.update',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Rect2d', u'boundingBox', u'', ['/O', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.Tracker.update [ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
[   u'enum cv.TrackerSamplerCSC.<unnamed>',
    '',
    [],
    [   [u'const cv.TrackerSamplerCSC.MODE_INIT_POS', u'1', [], [], None, ''],
        [u'const cv.TrackerSamplerCSC.MODE_INIT_NEG', u'2', [], [], None, ''],
        [   u'const cv.TrackerSamplerCSC.MODE_TRACK_POS',
            u'3',
            [],
            [],
            None,
            ''],
        [   u'const cv.TrackerSamplerCSC.MODE_TRACK_NEG',
            u'4',
            [],
            [],
            None,
            ''],
        [u'const cv.TrackerSamplerCSC.MODE_DETECT', u'5', [], [], None, '']],
    None]
class not found: CONST MODE_INIT_POS=1
ok: CONST TrackerSamplerCSC_MODE_INIT_POS=1
class not found: CONST MODE_INIT_NEG=2
ok: CONST TrackerSamplerCSC_MODE_INIT_NEG=2
class not found: CONST MODE_TRACK_POS=3
ok: CONST TrackerSamplerCSC_MODE_TRACK_POS=3
class not found: CONST MODE_TRACK_NEG=4
ok: CONST TrackerSamplerCSC_MODE_TRACK_NEG=4
class not found: CONST MODE_DETECT=5
ok: CONST TrackerSamplerCSC_MODE_DETECT=5

--- Incoming ---
[   u'enum cv.TrackerSamplerCS.<unnamed>',
    '',
    [],
    [   [u'const cv.TrackerSamplerCS.MODE_POSITIVE', u'1', [], [], None, ''],
        [u'const cv.TrackerSamplerCS.MODE_NEGATIVE', u'2', [], [], None, ''],
        [u'const cv.TrackerSamplerCS.MODE_CLASSIFY', u'3', [], [], None, '']],
    None]
class not found: CONST MODE_POSITIVE=1
ok: CONST TrackerSamplerCS_MODE_POSITIVE=1
class not found: CONST MODE_NEGATIVE=2
ok: CONST TrackerSamplerCS_MODE_NEGATIVE=2
class not found: CONST MODE_CLASSIFY=3
ok: CONST TrackerSamplerCS_MODE_CLASSIFY=3

--- Incoming ---
[u'class cv.TrackerMIL', u': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerMIL : Tracker, name: TrackerMIL, base: Tracker

--- Incoming ---
[u'cv.TrackerMIL.create', u'Ptr_TrackerMIL', ['/S'], [], u'Ptr<TrackerMIL>']
ok: FUNC <Ptr_TrackerMIL cv.TrackerMIL.create []>

--- Incoming ---
[u'class cv.TrackerBoosting', u': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerBoosting : Tracker, name: TrackerBoosting, base: Tracker

--- Incoming ---
[   u'cv.TrackerBoosting.create',
    u'Ptr_TrackerBoosting',
    ['/S'],
    [],
    u'Ptr<TrackerBoosting>']
ok: FUNC <Ptr_TrackerBoosting cv.TrackerBoosting.create []>

--- Incoming ---
[u'class cv.TrackerMedianFlow', u': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerMedianFlow : Tracker, name: TrackerMedianFlow, base: Tracker

--- Incoming ---
[   u'cv.TrackerMedianFlow.create',
    u'Ptr_TrackerMedianFlow',
    ['/S'],
    [],
    u'Ptr<TrackerMedianFlow>']
ok: FUNC <Ptr_TrackerMedianFlow cv.TrackerMedianFlow.create []>

--- Incoming ---
[u'class cv.TrackerTLD', u': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerTLD : Tracker, name: TrackerTLD, base: Tracker

--- Incoming ---
[u'cv.TrackerTLD.create', u'Ptr_TrackerTLD', ['/S'], [], u'Ptr<TrackerTLD>']
ok: FUNC <Ptr_TrackerTLD cv.TrackerTLD.create []>

--- Incoming ---
[u'class cv.TrackerKCF', u': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerKCF : Tracker, name: TrackerKCF, base: Tracker

--- Incoming ---
[   u'enum cv.TrackerKCF.MODE',
    '',
    [],
    [   [u'const cv.TrackerKCF.GRAY', u'(1 << 0)', [], [], None, ''],
        [u'const cv.TrackerKCF.CN', u'(1 << 1)', [], [], None, ''],
        [u'const cv.TrackerKCF.CUSTOM', u'(1 << 2)', [], [], None, '']],
    None]
ok: CONST GRAY=(1 << 0)
ok: CONST CN=(1 << 1)
ok: CONST CUSTOM=(1 << 2)

--- Incoming ---
[u'cv.TrackerKCF.create', u'Ptr_TrackerKCF', ['/S'], [], u'Ptr<TrackerKCF>']
ok: FUNC <Ptr_TrackerKCF cv.TrackerKCF.create []>

--- Incoming ---
[u'class cv.TrackerGOTURN', u': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerGOTURN : Tracker, name: TrackerGOTURN, base: Tracker

--- Incoming ---
[   u'cv.TrackerGOTURN.create',
    u'Ptr_TrackerGOTURN',
    ['/S'],
    [],
    u'Ptr<TrackerGOTURN>']
ok: FUNC <Ptr_TrackerGOTURN cv.TrackerGOTURN.create []>

--- Incoming ---
[u'class cv.TrackerMOSSE', u': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerMOSSE : Tracker, name: TrackerMOSSE, base: Tracker

--- Incoming ---
[   u'cv.TrackerMOSSE.create',
    u'Ptr_TrackerMOSSE',
    ['/S'],
    [],
    u'Ptr<TrackerMOSSE>']
ok: FUNC <Ptr_TrackerMOSSE cv.TrackerMOSSE.create []>

--- Incoming ---
[u'class cv.MultiTracker', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.MultiTracker : Algorithm, name: MultiTracker, base: Algorithm

--- Incoming ---
[u'cv.MultiTracker.MultiTracker', '', [], [], None]
ok: FUNC < cv.MultiTracker.MultiTracker []>

--- Incoming ---
[   u'cv.MultiTracker.add',
    u'bool',
    [],
    [   [u'Ptr_Tracker', u'newTracker', u'', []],
        ['Mat', u'image', '', []],
        [u'Rect2d', u'boundingBox', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.MultiTracker.add [ARG Ptr_Tracker newTracker=, ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
[   u'cv.MultiTracker.update',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect2d', u'boundingBox', u'', ['/O', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.MultiTracker.update [ARG Mat image=, ARG vector_Rect2d boundingBox=]>

--- Incoming ---
[   u'cv.MultiTracker.getObjects',
    u'vector_Rect2d',
    ['/C'],
    [],
    u'std::vector<Rect2d>']
ok: FUNC <vector_Rect2d cv.MultiTracker.getObjects []>

--- Incoming ---
[   u'cv.MultiTracker.create',
    u'Ptr_MultiTracker',
    ['/S'],
    [],
    u'Ptr<MultiTracker>']
ok: FUNC <Ptr_MultiTracker cv.MultiTracker.create []>

--- Incoming ---
[u'class cv.TrackerCSRT', u': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerCSRT : Tracker, name: TrackerCSRT, base: Tracker

--- Incoming ---
[u'cv.TrackerCSRT.create', u'Ptr_TrackerCSRT', ['/S'], [], u'Ptr<TrackerCSRT>']
ok: FUNC <Ptr_TrackerCSRT cv.TrackerCSRT.create []>

--- Incoming ---
[   u'cv.TrackerCSRT.setInitialMask',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'mask', '', []]],
    u'void']
ok: FUNC <void cv.TrackerCSRT.setInitialMask [ARG Mat mask=]>


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineMIL.hpp =====
Namespaces: set([u'cv.tbm', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineMIL.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineBoosting.hpp =====
Namespaces: set([u'cv.tbm', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineBoosting.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tldDataset.hpp =====
Namespaces: set([u'cv.tld', u'cv.tbm', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tldDataset.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tracking.hpp =====
Namespaces: set([u'cv.tld', u'cv.tbm', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/tracking.hpp


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/feature.hpp =====
Namespaces: set([u'cv.tld', u'cv.tbm', u'cv'])

--- Incoming ---
[   u'enum cv.CvFeatureParams.FeatureType',
    '',
    [],
    [   [u'const cv.CvFeatureParams.HAAR', u'0', [], [], None, ''],
        [u'const cv.CvFeatureParams.LBP', u'1', [], [], None, ''],
        [u'const cv.CvFeatureParams.HOG', u'2', [], [], None, '']],
    None]
class not found: CONST HAAR=0
ok: CONST CvFeatureParams_HAAR=0
class not found: CONST LBP=1
ok: CONST CvFeatureParams_LBP=1
class not found: CONST HOG=2
ok: CONST CvFeatureParams_HOG=2


===== Header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/kalman_filters.hpp =====
Namespaces: set([u'cv.tracking', u'cv.tld', u'cv.tbm', u'cv'])
Ignore header: /home/borg/404/scripts_robotica/OpenCV/opencv_contrib/modules/tracking/include/opencv2/tracking/kalman_filters.hpp


===== Generating... =====
CLASS ::.Tracking : 
[CONST TrackerSamplerCSC_MODE_INIT_POS=1, CONST TrackerSamplerCSC_MODE_INIT_NEG=2, CONST TrackerSamplerCSC_MODE_TRACK_POS=3, CONST TrackerSamplerCSC_MODE_TRACK_NEG=4, CONST TrackerSamplerCSC_MODE_DETECT=5, CONST TrackerSamplerCS_MODE_POSITIVE=1, CONST TrackerSamplerCS_MODE_NEGATIVE=2, CONST TrackerSamplerCS_MODE_CLASSIFY=3]
[CONST CvFeatureParams_HAAR=0, CONST CvFeatureParams_LBP=1, CONST CvFeatureParams_HOG=2]
CLASS cv::.Tracker : Algorithm
FUNC <bool cv.Tracker.init [ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean init(Mat image, Rect2d boundingBox)
FUNC <bool cv.Tracker.update [ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean update(Mat image, Rect2d boundingBox)
CLASS cv::.TrackerMIL : Tracker
FUNC <Ptr_TrackerMIL cv.TrackerMIL.create []>
java: TrackerMIL create()
CLASS cv::.TrackerGOTURN : Tracker
FUNC <Ptr_TrackerGOTURN cv.TrackerGOTURN.create []>
java: TrackerGOTURN create()
CLASS cv::.TrackerTLD : Tracker
FUNC <Ptr_TrackerTLD cv.TrackerTLD.create []>
java: TrackerTLD create()
CLASS cv::.TrackerMedianFlow : Tracker
FUNC <Ptr_TrackerMedianFlow cv.TrackerMedianFlow.create []>
java: TrackerMedianFlow create()
CLASS cv::.TrackerBoosting : Tracker
FUNC <Ptr_TrackerBoosting cv.TrackerBoosting.create []>
java: TrackerBoosting create()
CLASS cv::.MultiTracker : Algorithm
FUNC < cv.MultiTracker.MultiTracker []>
java:  MultiTracker()
FUNC <Ptr_MultiTracker cv.MultiTracker.create []>
java: MultiTracker create()
FUNC <bool cv.MultiTracker.add [ARG Ptr_Tracker newTracker=, ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean add(Tracker newTracker, Mat image, Rect2d boundingBox)
FUNC <bool cv.MultiTracker.update [ARG Mat image=, ARG vector_Rect2d boundingBox=]>
java: boolean update(Mat image, MatOfRect2d boundingBox)
FUNC <vector_Rect2d cv.MultiTracker.getObjects []>
java: MatOfRect2d getObjects()
CLASS cv::.TrackerCSRT : Tracker
FUNC <Ptr_TrackerCSRT cv.TrackerCSRT.create []>
java: TrackerCSRT create()
FUNC <void cv.TrackerCSRT.setInitialMask [ARG Mat mask=]>
java: void setInitialMask(Mat mask)
CLASS cv::.TrackerMOSSE : Tracker
FUNC <Ptr_TrackerMOSSE cv.TrackerMOSSE.create []>
java: TrackerMOSSE create()
CLASS cv::.TrackerKCF : Tracker
[CONST GRAY=(1 << 0), CONST CN=(1 << 1), CONST CUSTOM=(1 << 2)]
FUNC <Ptr_TrackerKCF cv.TrackerKCF.create []>
java: TrackerKCF create()
