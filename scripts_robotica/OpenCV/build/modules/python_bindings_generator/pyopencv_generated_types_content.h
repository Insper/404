//================================================================================
// AKAZE (Generic)
//================================================================================

// GetSet (AKAZE)



// Methods (AKAZE)

static PyObject* pyopencv_cv_AKAZE_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_descriptor_type = NULL;
    AKAZE_DescriptorType descriptor_type=AKAZE::DESCRIPTOR_MLDB;
    int descriptor_size=0;
    int descriptor_channels=3;
    float threshold=0.001f;
    int nOctaves=4;
    int nOctaveLayers=4;
    PyObject* pyobj_diffusivity = NULL;
    KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2;
    Ptr<AKAZE> retval;

    const char* keywords[] = { "descriptor_type", "descriptor_size", "descriptor_channels", "threshold", "nOctaves", "nOctaveLayers", "diffusivity", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OiifiiO:AKAZE.create", (char**)keywords, &pyobj_descriptor_type, &descriptor_size, &descriptor_channels, &threshold, &nOctaves, &nOctaveLayers, &pyobj_diffusivity) &&
        pyopencv_to(pyobj_descriptor_type, descriptor_type, ArgInfo("descriptor_type", 0)) &&
        pyopencv_to(pyobj_diffusivity, diffusivity, ArgInfo("diffusivity", 0)) )
    {
        ERRWRAP2(retval = cv::AKAZE::create(descriptor_type, descriptor_size, descriptor_channels, threshold, nOctaves, nOctaveLayers, diffusivity));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_getDescriptorChannels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDescriptorChannels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_getDescriptorSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDescriptorSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_getDescriptorType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    AKAZE::DescriptorType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDescriptorType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_getDiffusivity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    KAZE::DiffusivityType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDiffusivity());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_getNOctaveLayers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNOctaveLayers());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_getNOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNOctaves());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_setDescriptorChannels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    int dch=0;

    const char* keywords[] = { "dch", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:AKAZE.setDescriptorChannels", (char**)keywords, &dch) )
    {
        ERRWRAP2(_self_->setDescriptorChannels(dch));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_setDescriptorSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    int dsize=0;

    const char* keywords[] = { "dsize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:AKAZE.setDescriptorSize", (char**)keywords, &dsize) )
    {
        ERRWRAP2(_self_->setDescriptorSize(dsize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_setDescriptorType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    PyObject* pyobj_dtype = NULL;
    AKAZE_DescriptorType dtype=static_cast<AKAZE_DescriptorType>(0);

    const char* keywords[] = { "dtype", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:AKAZE.setDescriptorType", (char**)keywords, &pyobj_dtype) &&
        pyopencv_to(pyobj_dtype, dtype, ArgInfo("dtype", 0)) )
    {
        ERRWRAP2(_self_->setDescriptorType(dtype));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_setDiffusivity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    PyObject* pyobj_diff = NULL;
    KAZE_DiffusivityType diff=static_cast<KAZE_DiffusivityType>(0);

    const char* keywords[] = { "diff", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:AKAZE.setDiffusivity", (char**)keywords, &pyobj_diff) &&
        pyopencv_to(pyobj_diff, diff, ArgInfo("diff", 0)) )
    {
        ERRWRAP2(_self_->setDiffusivity(diff));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_setNOctaveLayers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    int octaveLayers=0;

    const char* keywords[] = { "octaveLayers", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:AKAZE.setNOctaveLayers", (char**)keywords, &octaveLayers) )
    {
        ERRWRAP2(_self_->setNOctaveLayers(octaveLayers));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_setNOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    int octaves=0;

    const char* keywords[] = { "octaves", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:AKAZE.setNOctaves", (char**)keywords, &octaves) )
    {
        ERRWRAP2(_self_->setNOctaves(octaves));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AKAZE_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AKAZE> * self1 = 0;
    if (!pyopencv_AKAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AKAZE' or its derivative)");
    Ptr<cv::AKAZE> _self_ = *(self1);
    double threshold=0;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:AKAZE.setThreshold", (char**)keywords, &threshold) )
    {
        ERRWRAP2(_self_->setThreshold(threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (AKAZE)

static PyGetSetDef pyopencv_AKAZE_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_AKAZE_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_create_static, METH_STATIC), "create([, descriptor_type[, descriptor_size[, descriptor_channels[, threshold[, nOctaves[, nOctaveLayers[, diffusivity]]]]]]]) -> retval\n.   @brief The AKAZE constructor\n.   \n.       @param descriptor_type Type of the extracted descriptor: DESCRIPTOR_KAZE,\n.       DESCRIPTOR_KAZE_UPRIGHT, DESCRIPTOR_MLDB or DESCRIPTOR_MLDB_UPRIGHT.\n.       @param descriptor_size Size of the descriptor in bits. 0 -\\> Full size\n.       @param descriptor_channels Number of channels in the descriptor (1, 2, 3)\n.       @param threshold Detector response threshold to accept point\n.       @param nOctaves Maximum octave evolution of the image\n.       @param nOctaveLayers Default number of sublevels per scale level\n.       @param diffusivity Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or\n.       DIFF_CHARBONNIER"},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"getDescriptorChannels", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_getDescriptorChannels, 0), "getDescriptorChannels() -> retval\n."},
    {"getDescriptorSize", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_getDescriptorSize, 0), "getDescriptorSize() -> retval\n."},
    {"getDescriptorType", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_getDescriptorType, 0), "getDescriptorType() -> retval\n."},
    {"getDiffusivity", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_getDiffusivity, 0), "getDiffusivity() -> retval\n."},
    {"getNOctaveLayers", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_getNOctaveLayers, 0), "getNOctaveLayers() -> retval\n."},
    {"getNOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_getNOctaves, 0), "getNOctaves() -> retval\n."},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_getThreshold, 0), "getThreshold() -> retval\n."},
    {"setDescriptorChannels", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_setDescriptorChannels, 0), "setDescriptorChannels(dch) -> None\n."},
    {"setDescriptorSize", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_setDescriptorSize, 0), "setDescriptorSize(dsize) -> None\n."},
    {"setDescriptorType", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_setDescriptorType, 0), "setDescriptorType(dtype) -> None\n."},
    {"setDiffusivity", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_setDiffusivity, 0), "setDiffusivity(diff) -> None\n."},
    {"setNOctaveLayers", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_setNOctaveLayers, 0), "setNOctaveLayers(octaveLayers) -> None\n."},
    {"setNOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_setNOctaves, 0), "setNOctaves(octaves) -> None\n."},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_AKAZE_setThreshold, 0), "setThreshold(threshold) -> None\n."},

    {NULL,          NULL}
};

// Converter (AKAZE)

template<>
struct PyOpenCV_Converter< Ptr<cv::AKAZE> >
{
    static PyObject* from(const Ptr<cv::AKAZE>& r)
    {
        return pyopencv_AKAZE_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::AKAZE>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::AKAZE> * dst_;
        if (pyopencv_AKAZE_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::AKAZE> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// AffineTransformer (Generic)
//================================================================================

// GetSet (AffineTransformer)



// Methods (AffineTransformer)

static PyObject* pyopencv_cv_AffineTransformer_getFullAffine(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AffineTransformer> * self1 = 0;
    if (!pyopencv_AffineTransformer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AffineTransformer' or its derivative)");
    Ptr<cv::AffineTransformer> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFullAffine());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AffineTransformer_setFullAffine(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AffineTransformer> * self1 = 0;
    if (!pyopencv_AffineTransformer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AffineTransformer' or its derivative)");
    Ptr<cv::AffineTransformer> _self_ = *(self1);
    bool fullAffine=0;

    const char* keywords[] = { "fullAffine", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:AffineTransformer.setFullAffine", (char**)keywords, &fullAffine) )
    {
        ERRWRAP2(_self_->setFullAffine(fullAffine));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (AffineTransformer)

static PyGetSetDef pyopencv_AffineTransformer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_AffineTransformer_methods[] =
{
    {"getFullAffine", CV_PY_FN_WITH_KW_(pyopencv_cv_AffineTransformer_getFullAffine, 0), "getFullAffine() -> retval\n."},
    {"setFullAffine", CV_PY_FN_WITH_KW_(pyopencv_cv_AffineTransformer_setFullAffine, 0), "setFullAffine(fullAffine) -> None\n."},

    {NULL,          NULL}
};

// Converter (AffineTransformer)

template<>
struct PyOpenCV_Converter< Ptr<cv::AffineTransformer> >
{
    static PyObject* from(const Ptr<cv::AffineTransformer>& r)
    {
        return pyopencv_AffineTransformer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::AffineTransformer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::AffineTransformer> * dst_;
        if (pyopencv_AffineTransformer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::AffineTransformer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// AgastFeatureDetector (Generic)
//================================================================================

// GetSet (AgastFeatureDetector)



// Methods (AgastFeatureDetector)

static PyObject* pyopencv_cv_AgastFeatureDetector_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int threshold=10;
    bool nonmaxSuppression=true;
    PyObject* pyobj_type = NULL;
    AgastFeatureDetector_DetectorType type=AgastFeatureDetector::OAST_9_16;
    Ptr<AgastFeatureDetector> retval;

    const char* keywords[] = { "threshold", "nonmaxSuppression", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ibO:AgastFeatureDetector.create", (char**)keywords, &threshold, &nonmaxSuppression, &pyobj_type) &&
        pyopencv_to(pyobj_type, type, ArgInfo("type", 0)) )
    {
        ERRWRAP2(retval = cv::AgastFeatureDetector::create(threshold, nonmaxSuppression, type));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AgastFeatureDetector_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!pyopencv_AgastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AgastFeatureDetector' or its derivative)");
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AgastFeatureDetector_getNonmaxSuppression(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!pyopencv_AgastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AgastFeatureDetector' or its derivative)");
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNonmaxSuppression());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AgastFeatureDetector_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!pyopencv_AgastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AgastFeatureDetector' or its derivative)");
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AgastFeatureDetector_getType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!pyopencv_AgastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AgastFeatureDetector' or its derivative)");
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    AgastFeatureDetector::DetectorType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AgastFeatureDetector_setNonmaxSuppression(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!pyopencv_AgastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AgastFeatureDetector' or its derivative)");
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    bool f=0;

    const char* keywords[] = { "f", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:AgastFeatureDetector.setNonmaxSuppression", (char**)keywords, &f) )
    {
        ERRWRAP2(_self_->setNonmaxSuppression(f));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AgastFeatureDetector_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!pyopencv_AgastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AgastFeatureDetector' or its derivative)");
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    int threshold=0;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:AgastFeatureDetector.setThreshold", (char**)keywords, &threshold) )
    {
        ERRWRAP2(_self_->setThreshold(threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AgastFeatureDetector_setType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AgastFeatureDetector> * self1 = 0;
    if (!pyopencv_AgastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AgastFeatureDetector' or its derivative)");
    Ptr<cv::AgastFeatureDetector> _self_ = *(self1);
    PyObject* pyobj_type = NULL;
    AgastFeatureDetector_DetectorType type=static_cast<AgastFeatureDetector_DetectorType>(0);

    const char* keywords[] = { "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:AgastFeatureDetector.setType", (char**)keywords, &pyobj_type) &&
        pyopencv_to(pyobj_type, type, ArgInfo("type", 0)) )
    {
        ERRWRAP2(_self_->setType(type));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (AgastFeatureDetector)

static PyGetSetDef pyopencv_AgastFeatureDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_AgastFeatureDetector_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_AgastFeatureDetector_create_static, METH_STATIC), "create([, threshold[, nonmaxSuppression[, type]]]) -> retval\n."},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_AgastFeatureDetector_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"getNonmaxSuppression", CV_PY_FN_WITH_KW_(pyopencv_cv_AgastFeatureDetector_getNonmaxSuppression, 0), "getNonmaxSuppression() -> retval\n."},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_AgastFeatureDetector_getThreshold, 0), "getThreshold() -> retval\n."},
    {"getType", CV_PY_FN_WITH_KW_(pyopencv_cv_AgastFeatureDetector_getType, 0), "getType() -> retval\n."},
    {"setNonmaxSuppression", CV_PY_FN_WITH_KW_(pyopencv_cv_AgastFeatureDetector_setNonmaxSuppression, 0), "setNonmaxSuppression(f) -> None\n."},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_AgastFeatureDetector_setThreshold, 0), "setThreshold(threshold) -> None\n."},
    {"setType", CV_PY_FN_WITH_KW_(pyopencv_cv_AgastFeatureDetector_setType, 0), "setType(type) -> None\n."},

    {NULL,          NULL}
};

// Converter (AgastFeatureDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::AgastFeatureDetector> >
{
    static PyObject* from(const Ptr<cv::AgastFeatureDetector>& r)
    {
        return pyopencv_AgastFeatureDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::AgastFeatureDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::AgastFeatureDetector> * dst_;
        if (pyopencv_AgastFeatureDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::AgastFeatureDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// Algorithm (Generic)
//================================================================================

// GetSet (Algorithm)



// Methods (Algorithm)

static PyObject* pyopencv_cv_Algorithm_clear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Algorithm> * self1 = 0;
    if (!pyopencv_Algorithm_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Algorithm' or its derivative)");
    Ptr<cv::Algorithm> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clear());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Algorithm_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Algorithm> * self1 = 0;
    if (!pyopencv_Algorithm_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Algorithm' or its derivative)");
    Ptr<cv::Algorithm> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Algorithm_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Algorithm> * self1 = 0;
    if (!pyopencv_Algorithm_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Algorithm' or its derivative)");
    Ptr<cv::Algorithm> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Algorithm_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Algorithm> * self1 = 0;
    if (!pyopencv_Algorithm_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Algorithm' or its derivative)");
    Ptr<cv::Algorithm> _self_ = *(self1);
    PyObject* pyobj_fn = NULL;
    FileNode fn;

    const char* keywords[] = { "fn", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Algorithm.read", (char**)keywords, &pyobj_fn) &&
        pyopencv_to(pyobj_fn, fn, ArgInfo("fn", 0)) )
    {
        ERRWRAP2(_self_->read(fn));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Algorithm_save(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Algorithm> * self1 = 0;
    if (!pyopencv_Algorithm_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Algorithm' or its derivative)");
    Ptr<cv::Algorithm> _self_ = *(self1);
    PyObject* pyobj_filename = NULL;
    String filename;

    const char* keywords[] = { "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Algorithm.save", (char**)keywords, &pyobj_filename) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        ERRWRAP2(_self_->save(filename));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Algorithm_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Algorithm> * self1 = 0;
    if (!pyopencv_Algorithm_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Algorithm' or its derivative)");
    Ptr<cv::Algorithm> _self_ = *(self1);
    PyObject* pyobj_fs = NULL;
    Ptr<FileStorage> fs;
    PyObject* pyobj_name = NULL;
    String name;

    const char* keywords[] = { "fs", "name", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Algorithm.write", (char**)keywords, &pyobj_fs, &pyobj_name) &&
        pyopencv_to(pyobj_fs, fs, ArgInfo("fs", 0)) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) )
    {
        ERRWRAP2(_self_->write(fs, name));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (Algorithm)

static PyGetSetDef pyopencv_Algorithm_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_Algorithm_methods[] =
{
    {"clear", CV_PY_FN_WITH_KW_(pyopencv_cv_Algorithm_clear, 0), "clear() -> None\n.   @brief Clears the algorithm state"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_Algorithm_empty, 0), "empty() -> retval\n.   @brief Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read"},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_Algorithm_getDefaultName, 0), "getDefaultName() -> retval\n.   Returns the algorithm string identifier.\n.   This string is used as top level xml/yml node tag when the object is saved to a file or string."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_Algorithm_read, 0), "read(fn) -> None\n.   @brief Reads algorithm parameters from a file storage"},
    {"save", CV_PY_FN_WITH_KW_(pyopencv_cv_Algorithm_save, 0), "save(filename) -> None\n.   Saves the algorithm to a file.\n.   In order to make this method work, the derived class must implement Algorithm::write(FileStorage& fs)."},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_Algorithm_write, 0), "write(fs[, name]) -> None\n.   @brief simplified API for language bindings\n.       * @overload"},

    {NULL,          NULL}
};

// Converter (Algorithm)

template<>
struct PyOpenCV_Converter< Ptr<cv::Algorithm> >
{
    static PyObject* from(const Ptr<cv::Algorithm>& r)
    {
        return pyopencv_Algorithm_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::Algorithm>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::Algorithm> * dst_;
        if (pyopencv_Algorithm_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::Algorithm> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// AlignExposures (Generic)
//================================================================================

// GetSet (AlignExposures)



// Methods (AlignExposures)

static PyObject* pyopencv_cv_AlignExposures_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignExposures> * self1 = 0;
    if (!pyopencv_AlignExposures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignExposures' or its derivative)");
    Ptr<cv::AlignExposures> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    vector_Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;
    PyObject* pyobj_response = NULL;
    Mat response;

    const char* keywords[] = { "src", "dst", "times", "response", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO:AlignExposures.process", (char**)keywords, &pyobj_src, &pyobj_dst, &pyobj_times, &pyobj_response) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 0)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    vector_Mat dst;
    PyObject* pyobj_times = NULL;
    UMat times;
    PyObject* pyobj_response = NULL;
    UMat response;

    const char* keywords[] = { "src", "dst", "times", "response", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO:AlignExposures.process", (char**)keywords, &pyobj_src, &pyobj_dst, &pyobj_times, &pyobj_response) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 0)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (AlignExposures)

static PyGetSetDef pyopencv_AlignExposures_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_AlignExposures_methods[] =
{
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignExposures_process, 0), "process(src, dst, times, response) -> None\n.   @brief Aligns images\n.   \n.       @param src vector of input images\n.       @param dst vector of aligned images\n.       @param times vector of exposure time values for each image\n.       @param response 256x1 matrix with inverse camera response function for each pixel value, it should\n.       have the same number of channels as images."},

    {NULL,          NULL}
};

// Converter (AlignExposures)

template<>
struct PyOpenCV_Converter< Ptr<cv::AlignExposures> >
{
    static PyObject* from(const Ptr<cv::AlignExposures>& r)
    {
        return pyopencv_AlignExposures_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::AlignExposures>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::AlignExposures> * dst_;
        if (pyopencv_AlignExposures_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::AlignExposures> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// AlignMTB (Generic)
//================================================================================

// GetSet (AlignMTB)



// Methods (AlignMTB)

static PyObject* pyopencv_cv_AlignMTB_calculateShift(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    {
    PyObject* pyobj_img0 = NULL;
    Mat img0;
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    Point retval;

    const char* keywords[] = { "img0", "img1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:AlignMTB.calculateShift", (char**)keywords, &pyobj_img0, &pyobj_img1) &&
        pyopencv_to(pyobj_img0, img0, ArgInfo("img0", 0)) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) )
    {
        ERRWRAP2(retval = _self_->calculateShift(img0, img1));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img0 = NULL;
    UMat img0;
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    Point retval;

    const char* keywords[] = { "img0", "img1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:AlignMTB.calculateShift", (char**)keywords, &pyobj_img0, &pyobj_img1) &&
        pyopencv_to(pyobj_img0, img0, ArgInfo("img0", 0)) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) )
    {
        ERRWRAP2(retval = _self_->calculateShift(img0, img1));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_computeBitmaps(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_tb = NULL;
    Mat tb;
    PyObject* pyobj_eb = NULL;
    Mat eb;

    const char* keywords[] = { "img", "tb", "eb", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:AlignMTB.computeBitmaps", (char**)keywords, &pyobj_img, &pyobj_tb, &pyobj_eb) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_tb, tb, ArgInfo("tb", 1)) &&
        pyopencv_to(pyobj_eb, eb, ArgInfo("eb", 1)) )
    {
        ERRWRAP2(_self_->computeBitmaps(img, tb, eb));
        return Py_BuildValue("(NN)", pyopencv_from(tb), pyopencv_from(eb));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_tb = NULL;
    UMat tb;
    PyObject* pyobj_eb = NULL;
    UMat eb;

    const char* keywords[] = { "img", "tb", "eb", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:AlignMTB.computeBitmaps", (char**)keywords, &pyobj_img, &pyobj_tb, &pyobj_eb) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_tb, tb, ArgInfo("tb", 1)) &&
        pyopencv_to(pyobj_eb, eb, ArgInfo("eb", 1)) )
    {
        ERRWRAP2(_self_->computeBitmaps(img, tb, eb));
        return Py_BuildValue("(NN)", pyopencv_from(tb), pyopencv_from(eb));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_getCut(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCut());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_getExcludeRange(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getExcludeRange());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_getMaxBits(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxBits());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    vector_Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;
    PyObject* pyobj_response = NULL;
    Mat response;

    const char* keywords[] = { "src", "dst", "times", "response", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO:AlignMTB.process", (char**)keywords, &pyobj_src, &pyobj_dst, &pyobj_times, &pyobj_response) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 0)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    vector_Mat dst;
    PyObject* pyobj_times = NULL;
    UMat times;
    PyObject* pyobj_response = NULL;
    UMat response;

    const char* keywords[] = { "src", "dst", "times", "response", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO:AlignMTB.process", (char**)keywords, &pyobj_src, &pyobj_dst, &pyobj_times, &pyobj_response) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 0)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    vector_Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:AlignMTB.process", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    vector_Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:AlignMTB.process", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_setCut(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    bool value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:AlignMTB.setCut", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setCut(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_setExcludeRange(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    int exclude_range=0;

    const char* keywords[] = { "exclude_range", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:AlignMTB.setExcludeRange", (char**)keywords, &exclude_range) )
    {
        ERRWRAP2(_self_->setExcludeRange(exclude_range));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_setMaxBits(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    int max_bits=0;

    const char* keywords[] = { "max_bits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:AlignMTB.setMaxBits", (char**)keywords, &max_bits) )
    {
        ERRWRAP2(_self_->setMaxBits(max_bits));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AlignMTB_shiftMat(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AlignMTB> * self1 = 0;
    if (!pyopencv_AlignMTB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AlignMTB' or its derivative)");
    Ptr<cv::AlignMTB> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_shift = NULL;
    Point shift;

    const char* keywords[] = { "src", "shift", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:AlignMTB.shiftMat", (char**)keywords, &pyobj_src, &pyobj_shift, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 0)) )
    {
        ERRWRAP2(_self_->shiftMat(src, dst, shift));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_shift = NULL;
    Point shift;

    const char* keywords[] = { "src", "shift", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:AlignMTB.shiftMat", (char**)keywords, &pyobj_src, &pyobj_shift, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 0)) )
    {
        ERRWRAP2(_self_->shiftMat(src, dst, shift));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (AlignMTB)

static PyGetSetDef pyopencv_AlignMTB_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_AlignMTB_methods[] =
{
    {"calculateShift", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_calculateShift, 0), "calculateShift(img0, img1) -> retval\n.   @brief Calculates shift between two images, i. e. how to shift the second image to correspond it with the\n.       first.\n.   \n.       @param img0 first image\n.       @param img1 second image"},
    {"computeBitmaps", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_computeBitmaps, 0), "computeBitmaps(img[, tb[, eb]]) -> tb, eb\n.   @brief Computes median threshold and exclude bitmaps of given image.\n.   \n.       @param img input image\n.       @param tb median threshold bitmap\n.       @param eb exclude bitmap"},
    {"getCut", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_getCut, 0), "getCut() -> retval\n."},
    {"getExcludeRange", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_getExcludeRange, 0), "getExcludeRange() -> retval\n."},
    {"getMaxBits", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_getMaxBits, 0), "getMaxBits() -> retval\n."},
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_process, 0), "process(src, dst, times, response) -> None\n.   \n\n\n\nprocess(src, dst) -> None\n.   @brief Short version of process, that doesn't take extra arguments.\n.   \n.       @param src vector of input images\n.       @param dst vector of aligned images"},
    {"setCut", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_setCut, 0), "setCut(value) -> None\n."},
    {"setExcludeRange", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_setExcludeRange, 0), "setExcludeRange(exclude_range) -> None\n."},
    {"setMaxBits", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_setMaxBits, 0), "setMaxBits(max_bits) -> None\n."},
    {"shiftMat", CV_PY_FN_WITH_KW_(pyopencv_cv_AlignMTB_shiftMat, 0), "shiftMat(src, shift[, dst]) -> dst\n.   @brief Helper function, that shift Mat filling new regions with zeros.\n.   \n.       @param src input image\n.       @param dst result image\n.       @param shift shift value"},

    {NULL,          NULL}
};

// Converter (AlignMTB)

template<>
struct PyOpenCV_Converter< Ptr<cv::AlignMTB> >
{
    static PyObject* from(const Ptr<cv::AlignMTB>& r)
    {
        return pyopencv_AlignMTB_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::AlignMTB>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::AlignMTB> * dst_;
        if (pyopencv_AlignMTB_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::AlignMTB> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// AsyncArray (Generic)
//================================================================================

// GetSet (AsyncArray)



// Methods (AsyncArray)

static int pyopencv_cv_AsyncArray_AsyncArray(pyopencv_AsyncArray_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::AsyncArray>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::AsyncArray()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_AsyncArray_get(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AsyncArray> * self1 = 0;
    if (!pyopencv_AsyncArray_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AsyncArray' or its derivative)");
    Ptr<cv::AsyncArray> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:AsyncArray.get", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->get(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:AsyncArray.get", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->get(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    double timeoutNs=0;
    bool retval;

    const char* keywords[] = { "timeoutNs", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d|O:AsyncArray.get", (char**)keywords, &timeoutNs, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(retval = _self_->get(dst, timeoutNs));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(dst));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    double timeoutNs=0;
    bool retval;

    const char* keywords[] = { "timeoutNs", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d|O:AsyncArray.get", (char**)keywords, &timeoutNs, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(retval = _self_->get(dst, timeoutNs));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(dst));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_AsyncArray_release(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AsyncArray> * self1 = 0;
    if (!pyopencv_AsyncArray_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AsyncArray' or its derivative)");
    Ptr<cv::AsyncArray> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->release());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_AsyncArray_valid(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AsyncArray> * self1 = 0;
    if (!pyopencv_AsyncArray_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AsyncArray' or its derivative)");
    Ptr<cv::AsyncArray> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->valid());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_AsyncArray_wait_for(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::AsyncArray> * self1 = 0;
    if (!pyopencv_AsyncArray_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'AsyncArray' or its derivative)");
    Ptr<cv::AsyncArray> _self_ = *(self1);
    double timeoutNs=0;
    bool retval;

    const char* keywords[] = { "timeoutNs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:AsyncArray.wait_for", (char**)keywords, &timeoutNs) )
    {
        ERRWRAP2(retval = _self_->wait_for(timeoutNs));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (AsyncArray)

static PyGetSetDef pyopencv_AsyncArray_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_AsyncArray_methods[] =
{
    {"get", CV_PY_FN_WITH_KW_(pyopencv_cv_AsyncArray_get, 0), "get([, dst]) -> dst\n.   Fetch the result.\n.       @param[out] dst destination array\n.   \n.       Waits for result until container has valid result.\n.       Throws exception if exception was stored as a result.\n.   \n.       Throws exception on invalid container state.\n.   \n.       @note Result or stored exception can be fetched only once.\n\n\n\nget(timeoutNs[, dst]) -> retval, dst\n.   Retrieving the result with timeout\n.       @param[out] dst destination array\n.       @param[in] timeoutNs timeout in nanoseconds, -1 for infinite wait\n.   \n.       @returns true if result is ready, false if the timeout has expired\n.   \n.       @note Result or stored exception can be fetched only once."},
    {"release", CV_PY_FN_WITH_KW_(pyopencv_cv_AsyncArray_release, 0), "release() -> None\n."},
    {"valid", CV_PY_FN_WITH_KW_(pyopencv_cv_AsyncArray_valid, 0), "valid() -> retval\n."},
    {"wait_for", CV_PY_FN_WITH_KW_(pyopencv_cv_AsyncArray_wait_for, 0), "wait_for(timeoutNs) -> retval\n."},

    {NULL,          NULL}
};

// Converter (AsyncArray)

template<>
struct PyOpenCV_Converter< Ptr<cv::AsyncArray> >
{
    static PyObject* from(const Ptr<cv::AsyncArray>& r)
    {
        return pyopencv_AsyncArray_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::AsyncArray>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::AsyncArray> * dst_;
        if (pyopencv_AsyncArray_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::AsyncArray> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BFMatcher (Generic)
//================================================================================

// GetSet (BFMatcher)



// Methods (BFMatcher)

static int pyopencv_cv_BFMatcher_BFMatcher(pyopencv_BFMatcher_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int normType=NORM_L2;
    bool crossCheck=false;

    const char* keywords[] = { "normType", "crossCheck", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ib:BFMatcher", (char**)keywords, &normType, &crossCheck) )
    {
        new (&(self->v)) Ptr<cv::BFMatcher>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::BFMatcher(normType, crossCheck)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_BFMatcher_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int normType=NORM_L2;
    bool crossCheck=false;
    Ptr<BFMatcher> retval;

    const char* keywords[] = { "normType", "crossCheck", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ib:BFMatcher.create", (char**)keywords, &normType, &crossCheck) )
    {
        ERRWRAP2(retval = cv::BFMatcher::create(normType, crossCheck));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (BFMatcher)

static PyGetSetDef pyopencv_BFMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BFMatcher_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_BFMatcher_create_static, METH_STATIC), "create([, normType[, crossCheck]]) -> retval\n.   @brief Brute-force matcher create method.\n.       @param normType One of NORM_L1, NORM_L2, NORM_HAMMING, NORM_HAMMING2. L1 and L2 norms are\n.       preferable choices for SIFT and SURF descriptors, NORM_HAMMING should be used with ORB, BRISK and\n.       BRIEF, NORM_HAMMING2 should be used with ORB when WTA_K==3 or 4 (see ORB::ORB constructor\n.       description).\n.       @param crossCheck If it is false, this is will be default BFMatcher behaviour when it finds the k\n.       nearest neighbors for each query descriptor. If crossCheck==true, then the knnMatch() method with\n.       k=1 will only return pairs (i,j) such that for i-th query descriptor the j-th descriptor in the\n.       matcher's collection is the nearest and vice versa, i.e. the BFMatcher will only return consistent\n.       pairs. Such technique usually produces best results with minimal number of outliers when there are\n.       enough matches. This is alternative to the ratio test, used by D. Lowe in SIFT paper."},

    {NULL,          NULL}
};

// Converter (BFMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::BFMatcher> >
{
    static PyObject* from(const Ptr<cv::BFMatcher>& r)
    {
        return pyopencv_BFMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BFMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BFMatcher> * dst_;
        if (pyopencv_BFMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BFMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BOWImgDescriptorExtractor (Generic)
//================================================================================

// GetSet (BOWImgDescriptorExtractor)



// Methods (BOWImgDescriptorExtractor)

static int pyopencv_cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor(pyopencv_BOWImgDescriptorExtractor_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_dextractor = NULL;
    Ptr<DescriptorExtractor> dextractor;
    PyObject* pyobj_dmatcher = NULL;
    Ptr<DescriptorMatcher> dmatcher;

    const char* keywords[] = { "dextractor", "dmatcher", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:BOWImgDescriptorExtractor", (char**)keywords, &pyobj_dextractor, &pyobj_dmatcher) &&
        pyopencv_to(pyobj_dextractor, dextractor, ArgInfo("dextractor", 0)) &&
        pyopencv_to(pyobj_dmatcher, dmatcher, ArgInfo("dmatcher", 0)) )
    {
        new (&(self->v)) Ptr<cv::BOWImgDescriptorExtractor>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::BOWImgDescriptorExtractor(dextractor, dmatcher)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_BOWImgDescriptorExtractor_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!pyopencv_BOWImgDescriptorExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWImgDescriptorExtractor' or its derivative)");
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_keypoints = NULL;
    vector_KeyPoint keypoints;
    PyObject* pyobj_imgDescriptor = NULL;
    Mat imgDescriptor;

    const char* keywords[] = { "image", "keypoints", "imgDescriptor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:BOWImgDescriptorExtractor.compute", (char**)keywords, &pyobj_image, &pyobj_keypoints, &pyobj_imgDescriptor) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_keypoints, keypoints, ArgInfo("keypoints", 0)) &&
        pyopencv_to(pyobj_imgDescriptor, imgDescriptor, ArgInfo("imgDescriptor", 1)) )
    {
        ERRWRAP2(_self_->compute2(image, keypoints, imgDescriptor));
        return pyopencv_from(imgDescriptor);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_keypoints = NULL;
    vector_KeyPoint keypoints;
    PyObject* pyobj_imgDescriptor = NULL;
    Mat imgDescriptor;

    const char* keywords[] = { "image", "keypoints", "imgDescriptor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:BOWImgDescriptorExtractor.compute", (char**)keywords, &pyobj_image, &pyobj_keypoints, &pyobj_imgDescriptor) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_keypoints, keypoints, ArgInfo("keypoints", 0)) &&
        pyopencv_to(pyobj_imgDescriptor, imgDescriptor, ArgInfo("imgDescriptor", 1)) )
    {
        ERRWRAP2(_self_->compute2(image, keypoints, imgDescriptor));
        return pyopencv_from(imgDescriptor);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_BOWImgDescriptorExtractor_descriptorSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!pyopencv_BOWImgDescriptorExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWImgDescriptorExtractor' or its derivative)");
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->descriptorSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BOWImgDescriptorExtractor_descriptorType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!pyopencv_BOWImgDescriptorExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWImgDescriptorExtractor' or its derivative)");
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->descriptorType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BOWImgDescriptorExtractor_getVocabulary(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!pyopencv_BOWImgDescriptorExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWImgDescriptorExtractor' or its derivative)");
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVocabulary());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BOWImgDescriptorExtractor_setVocabulary(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWImgDescriptorExtractor> * self1 = 0;
    if (!pyopencv_BOWImgDescriptorExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWImgDescriptorExtractor' or its derivative)");
    Ptr<cv::BOWImgDescriptorExtractor> _self_ = *(self1);
    {
    PyObject* pyobj_vocabulary = NULL;
    Mat vocabulary;

    const char* keywords[] = { "vocabulary", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:BOWImgDescriptorExtractor.setVocabulary", (char**)keywords, &pyobj_vocabulary) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) )
    {
        ERRWRAP2(_self_->setVocabulary(vocabulary));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_vocabulary = NULL;
    Mat vocabulary;

    const char* keywords[] = { "vocabulary", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:BOWImgDescriptorExtractor.setVocabulary", (char**)keywords, &pyobj_vocabulary) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) )
    {
        ERRWRAP2(_self_->setVocabulary(vocabulary));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (BOWImgDescriptorExtractor)

static PyGetSetDef pyopencv_BOWImgDescriptorExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BOWImgDescriptorExtractor_methods[] =
{
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWImgDescriptorExtractor_compute, 0), "compute(image, keypoints[, imgDescriptor]) -> imgDescriptor\n.   @overload\n.       @param keypointDescriptors Computed descriptors to match with vocabulary.\n.       @param imgDescriptor Computed output image descriptor.\n.       @param pointIdxsOfClusters Indices of keypoints that belong to the cluster. This means that\n.       pointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster (word of vocabulary)\n.       returned if it is non-zero."},
    {"descriptorSize", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWImgDescriptorExtractor_descriptorSize, 0), "descriptorSize() -> retval\n.   @brief Returns an image descriptor size if the vocabulary is set. Otherwise, it returns 0."},
    {"descriptorType", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWImgDescriptorExtractor_descriptorType, 0), "descriptorType() -> retval\n.   @brief Returns an image descriptor type."},
    {"getVocabulary", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWImgDescriptorExtractor_getVocabulary, 0), "getVocabulary() -> retval\n.   @brief Returns the set vocabulary."},
    {"setVocabulary", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWImgDescriptorExtractor_setVocabulary, 0), "setVocabulary(vocabulary) -> None\n.   @brief Sets a visual vocabulary.\n.   \n.       @param vocabulary Vocabulary (can be trained using the inheritor of BOWTrainer ). Each row of the\n.       vocabulary is a visual word (cluster center)."},

    {NULL,          NULL}
};

// Converter (BOWImgDescriptorExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::BOWImgDescriptorExtractor> >
{
    static PyObject* from(const Ptr<cv::BOWImgDescriptorExtractor>& r)
    {
        return pyopencv_BOWImgDescriptorExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BOWImgDescriptorExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BOWImgDescriptorExtractor> * dst_;
        if (pyopencv_BOWImgDescriptorExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BOWImgDescriptorExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BOWKMeansTrainer (Generic)
//================================================================================

// GetSet (BOWKMeansTrainer)



// Methods (BOWKMeansTrainer)

static int pyopencv_cv_BOWKMeansTrainer_BOWKMeansTrainer(pyopencv_BOWKMeansTrainer_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int clusterCount=0;
    PyObject* pyobj_termcrit = NULL;
    TermCriteria termcrit;
    int attempts=3;
    int flags=KMEANS_PP_CENTERS;

    const char* keywords[] = { "clusterCount", "termcrit", "attempts", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|Oii:BOWKMeansTrainer", (char**)keywords, &clusterCount, &pyobj_termcrit, &attempts, &flags) &&
        pyopencv_to(pyobj_termcrit, termcrit, ArgInfo("termcrit", 0)) )
    {
        new (&(self->v)) Ptr<cv::BOWKMeansTrainer>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::BOWKMeansTrainer(clusterCount, termcrit, attempts, flags)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_BOWKMeansTrainer_cluster(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWKMeansTrainer> * self1 = 0;
    if (!pyopencv_BOWKMeansTrainer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWKMeansTrainer' or its derivative)");
    Ptr<cv::BOWKMeansTrainer> _self_ = *(self1);
    {
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->cluster());
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;
    Mat retval;

    const char* keywords[] = { "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:BOWKMeansTrainer.cluster", (char**)keywords, &pyobj_descriptors) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 0)) )
    {
        ERRWRAP2(retval = _self_->cluster(descriptors));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;
    Mat retval;

    const char* keywords[] = { "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:BOWKMeansTrainer.cluster", (char**)keywords, &pyobj_descriptors) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 0)) )
    {
        ERRWRAP2(retval = _self_->cluster(descriptors));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (BOWKMeansTrainer)

static PyGetSetDef pyopencv_BOWKMeansTrainer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BOWKMeansTrainer_methods[] =
{
    {"cluster", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWKMeansTrainer_cluster, 0), "cluster() -> retval\n.   \n\n\n\ncluster(descriptors) -> retval\n."},

    {NULL,          NULL}
};

// Converter (BOWKMeansTrainer)

template<>
struct PyOpenCV_Converter< Ptr<cv::BOWKMeansTrainer> >
{
    static PyObject* from(const Ptr<cv::BOWKMeansTrainer>& r)
    {
        return pyopencv_BOWKMeansTrainer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BOWKMeansTrainer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BOWKMeansTrainer> * dst_;
        if (pyopencv_BOWKMeansTrainer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BOWKMeansTrainer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BOWTrainer (Generic)
//================================================================================

// GetSet (BOWTrainer)



// Methods (BOWTrainer)

static PyObject* pyopencv_cv_BOWTrainer_add(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!pyopencv_BOWTrainer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWTrainer' or its derivative)");
    Ptr<cv::BOWTrainer> _self_ = *(self1);
    {
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;

    const char* keywords[] = { "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:BOWTrainer.add", (char**)keywords, &pyobj_descriptors) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 0)) )
    {
        ERRWRAP2(_self_->add(descriptors));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;

    const char* keywords[] = { "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:BOWTrainer.add", (char**)keywords, &pyobj_descriptors) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 0)) )
    {
        ERRWRAP2(_self_->add(descriptors));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_BOWTrainer_clear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!pyopencv_BOWTrainer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWTrainer' or its derivative)");
    Ptr<cv::BOWTrainer> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clear());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BOWTrainer_cluster(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!pyopencv_BOWTrainer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWTrainer' or its derivative)");
    Ptr<cv::BOWTrainer> _self_ = *(self1);
    {
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->cluster());
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;
    Mat retval;

    const char* keywords[] = { "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:BOWTrainer.cluster", (char**)keywords, &pyobj_descriptors) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 0)) )
    {
        ERRWRAP2(retval = _self_->cluster(descriptors));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;
    Mat retval;

    const char* keywords[] = { "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:BOWTrainer.cluster", (char**)keywords, &pyobj_descriptors) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 0)) )
    {
        ERRWRAP2(retval = _self_->cluster(descriptors));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_BOWTrainer_descriptorsCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!pyopencv_BOWTrainer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWTrainer' or its derivative)");
    Ptr<cv::BOWTrainer> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->descriptorsCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BOWTrainer_getDescriptors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BOWTrainer> * self1 = 0;
    if (!pyopencv_BOWTrainer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BOWTrainer' or its derivative)");
    Ptr<cv::BOWTrainer> _self_ = *(self1);
    std::vector<Mat> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDescriptors());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (BOWTrainer)

static PyGetSetDef pyopencv_BOWTrainer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BOWTrainer_methods[] =
{
    {"add", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWTrainer_add, 0), "add(descriptors) -> None\n.   @brief Adds descriptors to a training set.\n.   \n.       @param descriptors Descriptors to add to a training set. Each row of the descriptors matrix is a\n.       descriptor.\n.   \n.       The training set is clustered using clustermethod to construct the vocabulary."},
    {"clear", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWTrainer_clear, 0), "clear() -> None\n."},
    {"cluster", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWTrainer_cluster, 0), "cluster() -> retval\n.   @overload\n\n\n\ncluster(descriptors) -> retval\n.   @brief Clusters train descriptors.\n.   \n.       @param descriptors Descriptors to cluster. Each row of the descriptors matrix is a descriptor.\n.       Descriptors are not added to the inner train descriptor set.\n.   \n.       The vocabulary consists of cluster centers. So, this method returns the vocabulary. In the first\n.       variant of the method, train descriptors stored in the object are clustered. In the second variant,\n.       input descriptors are clustered."},
    {"descriptorsCount", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWTrainer_descriptorsCount, 0), "descriptorsCount() -> retval\n.   @brief Returns the count of all descriptors stored in the training set."},
    {"getDescriptors", CV_PY_FN_WITH_KW_(pyopencv_cv_BOWTrainer_getDescriptors, 0), "getDescriptors() -> retval\n.   @brief Returns a training set of descriptors."},

    {NULL,          NULL}
};

// Converter (BOWTrainer)

template<>
struct PyOpenCV_Converter< Ptr<cv::BOWTrainer> >
{
    static PyObject* from(const Ptr<cv::BOWTrainer>& r)
    {
        return pyopencv_BOWTrainer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BOWTrainer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BOWTrainer> * dst_;
        if (pyopencv_BOWTrainer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BOWTrainer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BRISK (Generic)
//================================================================================

// GetSet (BRISK)



// Methods (BRISK)

static PyObject* pyopencv_cv_BRISK_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {
    int thresh=30;
    int octaves=3;
    float patternScale=1.0f;
    Ptr<BRISK> retval;

    const char* keywords[] = { "thresh", "octaves", "patternScale", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iif:BRISK.create", (char**)keywords, &thresh, &octaves, &patternScale) )
    {
        ERRWRAP2(retval = cv::BRISK::create(thresh, octaves, patternScale));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_radiusList = NULL;
    vector_float radiusList;
    PyObject* pyobj_numberList = NULL;
    vector_int numberList;
    float dMax=5.85f;
    float dMin=8.2f;
    PyObject* pyobj_indexChange = NULL;
    vector_int indexChange=std::vector<int>();
    Ptr<BRISK> retval;

    const char* keywords[] = { "radiusList", "numberList", "dMax", "dMin", "indexChange", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|ffO:BRISK.create", (char**)keywords, &pyobj_radiusList, &pyobj_numberList, &dMax, &dMin, &pyobj_indexChange) &&
        pyopencv_to(pyobj_radiusList, radiusList, ArgInfo("radiusList", 0)) &&
        pyopencv_to(pyobj_numberList, numberList, ArgInfo("numberList", 0)) &&
        pyopencv_to(pyobj_indexChange, indexChange, ArgInfo("indexChange", 0)) )
    {
        ERRWRAP2(retval = cv::BRISK::create(radiusList, numberList, dMax, dMin, indexChange));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    int thresh=0;
    int octaves=0;
    PyObject* pyobj_radiusList = NULL;
    vector_float radiusList;
    PyObject* pyobj_numberList = NULL;
    vector_int numberList;
    float dMax=5.85f;
    float dMin=8.2f;
    PyObject* pyobj_indexChange = NULL;
    vector_int indexChange=std::vector<int>();
    Ptr<BRISK> retval;

    const char* keywords[] = { "thresh", "octaves", "radiusList", "numberList", "dMax", "dMin", "indexChange", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiOO|ffO:BRISK.create", (char**)keywords, &thresh, &octaves, &pyobj_radiusList, &pyobj_numberList, &dMax, &dMin, &pyobj_indexChange) &&
        pyopencv_to(pyobj_radiusList, radiusList, ArgInfo("radiusList", 0)) &&
        pyopencv_to(pyobj_numberList, numberList, ArgInfo("numberList", 0)) &&
        pyopencv_to(pyobj_indexChange, indexChange, ArgInfo("indexChange", 0)) )
    {
        ERRWRAP2(retval = cv::BRISK::create(thresh, octaves, radiusList, numberList, dMax, dMin, indexChange));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_BRISK_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BRISK> * self1 = 0;
    if (!pyopencv_BRISK_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BRISK' or its derivative)");
    Ptr<cv::BRISK> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BRISK_getOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BRISK> * self1 = 0;
    if (!pyopencv_BRISK_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BRISK' or its derivative)");
    Ptr<cv::BRISK> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getOctaves());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BRISK_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BRISK> * self1 = 0;
    if (!pyopencv_BRISK_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BRISK' or its derivative)");
    Ptr<cv::BRISK> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BRISK_setOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BRISK> * self1 = 0;
    if (!pyopencv_BRISK_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BRISK' or its derivative)");
    Ptr<cv::BRISK> _self_ = *(self1);
    int octaves=0;

    const char* keywords[] = { "octaves", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BRISK.setOctaves", (char**)keywords, &octaves) )
    {
        ERRWRAP2(_self_->setOctaves(octaves));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BRISK_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BRISK> * self1 = 0;
    if (!pyopencv_BRISK_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BRISK' or its derivative)");
    Ptr<cv::BRISK> _self_ = *(self1);
    int threshold=0;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BRISK.setThreshold", (char**)keywords, &threshold) )
    {
        ERRWRAP2(_self_->setThreshold(threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (BRISK)

static PyGetSetDef pyopencv_BRISK_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BRISK_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_BRISK_create_static, METH_STATIC), "create([, thresh[, octaves[, patternScale]]]) -> retval\n.   @brief The BRISK constructor\n.   \n.       @param thresh AGAST detection threshold score.\n.       @param octaves detection octaves. Use 0 to do single scale.\n.       @param patternScale apply this scale to the pattern used for sampling the neighbourhood of a\n.       keypoint.\n\n\n\ncreate(radiusList, numberList[, dMax[, dMin[, indexChange]]]) -> retval\n.   @brief The BRISK constructor for a custom pattern\n.   \n.       @param radiusList defines the radii (in pixels) where the samples around a keypoint are taken (for\n.       keypoint scale 1).\n.       @param numberList defines the number of sampling points on the sampling circle. Must be the same\n.       size as radiusList..\n.       @param dMax threshold for the short pairings used for descriptor formation (in pixels for keypoint\n.       scale 1).\n.       @param dMin threshold for the long pairings used for orientation determination (in pixels for\n.       keypoint scale 1).\n.   @param indexChange index remapping of the bits.\n\n\n\ncreate(thresh, octaves, radiusList, numberList[, dMax[, dMin[, indexChange]]]) -> retval\n.   @brief The BRISK constructor for a custom pattern, detection threshold and octaves\n.   \n.       @param thresh AGAST detection threshold score.\n.       @param octaves detection octaves. Use 0 to do single scale.\n.       @param radiusList defines the radii (in pixels) where the samples around a keypoint are taken (for\n.       keypoint scale 1).\n.       @param numberList defines the number of sampling points on the sampling circle. Must be the same\n.       size as radiusList..\n.       @param dMax threshold for the short pairings used for descriptor formation (in pixels for keypoint\n.       scale 1).\n.       @param dMin threshold for the long pairings used for orientation determination (in pixels for\n.       keypoint scale 1).\n.   @param indexChange index remapping of the bits."},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_BRISK_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"getOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_BRISK_getOctaves, 0), "getOctaves() -> retval\n."},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BRISK_getThreshold, 0), "getThreshold() -> retval\n."},
    {"setOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_BRISK_setOctaves, 0), "setOctaves(octaves) -> None\n.   @brief Set detection octaves.\n.       @param octaves detection octaves. Use 0 to do single scale."},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BRISK_setThreshold, 0), "setThreshold(threshold) -> None\n.   @brief Set detection threshold.\n.       @param threshold AGAST detection threshold score."},

    {NULL,          NULL}
};

// Converter (BRISK)

template<>
struct PyOpenCV_Converter< Ptr<cv::BRISK> >
{
    static PyObject* from(const Ptr<cv::BRISK>& r)
    {
        return pyopencv_BRISK_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BRISK>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BRISK> * dst_;
        if (pyopencv_BRISK_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BRISK> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BackgroundSubtractor (Generic)
//================================================================================

// GetSet (BackgroundSubtractor)



// Methods (BackgroundSubtractor)

static PyObject* pyopencv_cv_BackgroundSubtractor_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!pyopencv_BackgroundSubtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractor' or its derivative)");
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_fgmask = NULL;
    Mat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:BackgroundSubtractor.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_fgmask = NULL;
    UMat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:BackgroundSubtractor.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractor_getBackgroundImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractor> * self1 = 0;
    if (!pyopencv_BackgroundSubtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractor' or its derivative)");
    Ptr<cv::BackgroundSubtractor> _self_ = *(self1);
    {
    PyObject* pyobj_backgroundImage = NULL;
    Mat backgroundImage;

    const char* keywords[] = { "backgroundImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:BackgroundSubtractor.getBackgroundImage", (char**)keywords, &pyobj_backgroundImage) &&
        pyopencv_to(pyobj_backgroundImage, backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage));
        return pyopencv_from(backgroundImage);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_backgroundImage = NULL;
    UMat backgroundImage;

    const char* keywords[] = { "backgroundImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:BackgroundSubtractor.getBackgroundImage", (char**)keywords, &pyobj_backgroundImage) &&
        pyopencv_to(pyobj_backgroundImage, backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage));
        return pyopencv_from(backgroundImage);
    }
    }

    return NULL;
}



// Tables (BackgroundSubtractor)

static PyGetSetDef pyopencv_BackgroundSubtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BackgroundSubtractor_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractor_apply, 0), "apply(image[, fgmask[, learningRate]]) -> fgmask\n.   @brief Computes a foreground mask.\n.   \n.       @param image Next video frame.\n.       @param fgmask The output foreground mask as an 8-bit binary image.\n.       @param learningRate The value between 0 and 1 that indicates how fast the background model is\n.       learnt. Negative parameter value makes the algorithm to use some automatically chosen learning\n.       rate. 0 means that the background model is not updated at all, 1 means that the background model\n.       is completely reinitialized from the last frame."},
    {"getBackgroundImage", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractor_getBackgroundImage, 0), "getBackgroundImage([, backgroundImage]) -> backgroundImage\n.   @brief Computes a background image.\n.   \n.       @param backgroundImage The output background image.\n.   \n.       @note Sometimes the background image can be very blurry, as it contain the average background\n.       statistics."},

    {NULL,          NULL}
};

// Converter (BackgroundSubtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::BackgroundSubtractor> >
{
    static PyObject* from(const Ptr<cv::BackgroundSubtractor>& r)
    {
        return pyopencv_BackgroundSubtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BackgroundSubtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BackgroundSubtractor> * dst_;
        if (pyopencv_BackgroundSubtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BackgroundSubtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BackgroundSubtractorKNN (Generic)
//================================================================================

// GetSet (BackgroundSubtractorKNN)



// Methods (BackgroundSubtractorKNN)

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_getDetectShadows(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDetectShadows());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_getDist2Threshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDist2Threshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_getHistory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getHistory());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_getNSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNSamples());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_getShadowThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getShadowThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_getShadowValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getShadowValue());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_getkNNSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getkNNSamples());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_setDetectShadows(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    bool detectShadows=0;

    const char* keywords[] = { "detectShadows", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:BackgroundSubtractorKNN.setDetectShadows", (char**)keywords, &detectShadows) )
    {
        ERRWRAP2(_self_->setDetectShadows(detectShadows));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_setDist2Threshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    double _dist2Threshold=0;

    const char* keywords[] = { "_dist2Threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorKNN.setDist2Threshold", (char**)keywords, &_dist2Threshold) )
    {
        ERRWRAP2(_self_->setDist2Threshold(_dist2Threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_setHistory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int history=0;

    const char* keywords[] = { "history", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BackgroundSubtractorKNN.setHistory", (char**)keywords, &history) )
    {
        ERRWRAP2(_self_->setHistory(history));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_setNSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int _nN=0;

    const char* keywords[] = { "_nN", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BackgroundSubtractorKNN.setNSamples", (char**)keywords, &_nN) )
    {
        ERRWRAP2(_self_->setNSamples(_nN));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_setShadowThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    double threshold=0;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorKNN.setShadowThreshold", (char**)keywords, &threshold) )
    {
        ERRWRAP2(_self_->setShadowThreshold(threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_setShadowValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BackgroundSubtractorKNN.setShadowValue", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setShadowValue(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorKNN_setkNNSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorKNN> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorKNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorKNN' or its derivative)");
    Ptr<cv::BackgroundSubtractorKNN> _self_ = *(self1);
    int _nkNN=0;

    const char* keywords[] = { "_nkNN", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BackgroundSubtractorKNN.setkNNSamples", (char**)keywords, &_nkNN) )
    {
        ERRWRAP2(_self_->setkNNSamples(_nkNN));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (BackgroundSubtractorKNN)

static PyGetSetDef pyopencv_BackgroundSubtractorKNN_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BackgroundSubtractorKNN_methods[] =
{
    {"getDetectShadows", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_getDetectShadows, 0), "getDetectShadows() -> retval\n.   @brief Returns the shadow detection flag\n.   \n.       If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorKNN for\n.       details."},
    {"getDist2Threshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_getDist2Threshold, 0), "getDist2Threshold() -> retval\n.   @brief Returns the threshold on the squared distance between the pixel and the sample\n.   \n.       The threshold on the squared distance between the pixel and the sample to decide whether a pixel is\n.       close to a data sample."},
    {"getHistory", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_getHistory, 0), "getHistory() -> retval\n.   @brief Returns the number of last frames that affect the background model"},
    {"getNSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_getNSamples, 0), "getNSamples() -> retval\n.   @brief Returns the number of data samples in the background model"},
    {"getShadowThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_getShadowThreshold, 0), "getShadowThreshold() -> retval\n.   @brief Returns the shadow threshold\n.   \n.       A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in\n.       the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel\n.       is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara,\n.       *Detecting Moving Shadows...*, IEEE PAMI,2003."},
    {"getShadowValue", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_getShadowValue, 0), "getShadowValue() -> retval\n.   @brief Returns the shadow value\n.   \n.       Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0\n.       in the mask always means background, 255 means foreground."},
    {"getkNNSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_getkNNSamples, 0), "getkNNSamples() -> retval\n.   @brief Returns the number of neighbours, the k in the kNN.\n.   \n.       K is the number of samples that need to be within dist2Threshold in order to decide that that\n.       pixel is matching the kNN background model."},
    {"setDetectShadows", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_setDetectShadows, 0), "setDetectShadows(detectShadows) -> None\n.   @brief Enables or disables shadow detection"},
    {"setDist2Threshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_setDist2Threshold, 0), "setDist2Threshold(_dist2Threshold) -> None\n.   @brief Sets the threshold on the squared distance"},
    {"setHistory", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_setHistory, 0), "setHistory(history) -> None\n.   @brief Sets the number of last frames that affect the background model"},
    {"setNSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_setNSamples, 0), "setNSamples(_nN) -> None\n.   @brief Sets the number of data samples in the background model.\n.   \n.       The model needs to be reinitalized to reserve memory."},
    {"setShadowThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_setShadowThreshold, 0), "setShadowThreshold(threshold) -> None\n.   @brief Sets the shadow threshold"},
    {"setShadowValue", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_setShadowValue, 0), "setShadowValue(value) -> None\n.   @brief Sets the shadow value"},
    {"setkNNSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorKNN_setkNNSamples, 0), "setkNNSamples(_nkNN) -> None\n.   @brief Sets the k in the kNN. How many nearest neighbours need to match."},

    {NULL,          NULL}
};

// Converter (BackgroundSubtractorKNN)

template<>
struct PyOpenCV_Converter< Ptr<cv::BackgroundSubtractorKNN> >
{
    static PyObject* from(const Ptr<cv::BackgroundSubtractorKNN>& r)
    {
        return pyopencv_BackgroundSubtractorKNN_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BackgroundSubtractorKNN>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BackgroundSubtractorKNN> * dst_;
        if (pyopencv_BackgroundSubtractorKNN_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BackgroundSubtractorKNN> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BackgroundSubtractorMOG2 (Generic)
//================================================================================

// GetSet (BackgroundSubtractorMOG2)



// Methods (BackgroundSubtractorMOG2)

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_fgmask = NULL;
    Mat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:BackgroundSubtractorMOG2.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_fgmask = NULL;
    UMat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:BackgroundSubtractorMOG2.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getBackgroundRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBackgroundRatio());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getComplexityReductionThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getComplexityReductionThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getDetectShadows(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDetectShadows());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getHistory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getHistory());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getNMixtures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNMixtures());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getShadowThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getShadowThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getShadowValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getShadowValue());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getVarInit(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarInit());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getVarMax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarMax());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getVarMin(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarMin());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getVarThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_getVarThresholdGen(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarThresholdGen());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setBackgroundRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double ratio=0;

    const char* keywords[] = { "ratio", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorMOG2.setBackgroundRatio", (char**)keywords, &ratio) )
    {
        ERRWRAP2(_self_->setBackgroundRatio(ratio));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setComplexityReductionThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double ct=0;

    const char* keywords[] = { "ct", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorMOG2.setComplexityReductionThreshold", (char**)keywords, &ct) )
    {
        ERRWRAP2(_self_->setComplexityReductionThreshold(ct));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setDetectShadows(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    bool detectShadows=0;

    const char* keywords[] = { "detectShadows", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:BackgroundSubtractorMOG2.setDetectShadows", (char**)keywords, &detectShadows) )
    {
        ERRWRAP2(_self_->setDetectShadows(detectShadows));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setHistory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int history=0;

    const char* keywords[] = { "history", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BackgroundSubtractorMOG2.setHistory", (char**)keywords, &history) )
    {
        ERRWRAP2(_self_->setHistory(history));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setNMixtures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int nmixtures=0;

    const char* keywords[] = { "nmixtures", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BackgroundSubtractorMOG2.setNMixtures", (char**)keywords, &nmixtures) )
    {
        ERRWRAP2(_self_->setNMixtures(nmixtures));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setShadowThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double threshold=0;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorMOG2.setShadowThreshold", (char**)keywords, &threshold) )
    {
        ERRWRAP2(_self_->setShadowThreshold(threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setShadowValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    int value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:BackgroundSubtractorMOG2.setShadowValue", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setShadowValue(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setVarInit(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varInit=0;

    const char* keywords[] = { "varInit", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorMOG2.setVarInit", (char**)keywords, &varInit) )
    {
        ERRWRAP2(_self_->setVarInit(varInit));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setVarMax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varMax=0;

    const char* keywords[] = { "varMax", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorMOG2.setVarMax", (char**)keywords, &varMax) )
    {
        ERRWRAP2(_self_->setVarMax(varMax));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setVarMin(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varMin=0;

    const char* keywords[] = { "varMin", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorMOG2.setVarMin", (char**)keywords, &varMin) )
    {
        ERRWRAP2(_self_->setVarMin(varMin));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setVarThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varThreshold=0;

    const char* keywords[] = { "varThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorMOG2.setVarThreshold", (char**)keywords, &varThreshold) )
    {
        ERRWRAP2(_self_->setVarThreshold(varThreshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_BackgroundSubtractorMOG2_setVarThresholdGen(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::BackgroundSubtractorMOG2> * self1 = 0;
    if (!pyopencv_BackgroundSubtractorMOG2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'BackgroundSubtractorMOG2' or its derivative)");
    Ptr<cv::BackgroundSubtractorMOG2> _self_ = *(self1);
    double varThresholdGen=0;

    const char* keywords[] = { "varThresholdGen", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:BackgroundSubtractorMOG2.setVarThresholdGen", (char**)keywords, &varThresholdGen) )
    {
        ERRWRAP2(_self_->setVarThresholdGen(varThresholdGen));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (BackgroundSubtractorMOG2)

static PyGetSetDef pyopencv_BackgroundSubtractorMOG2_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BackgroundSubtractorMOG2_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_apply, 0), "apply(image[, fgmask[, learningRate]]) -> fgmask\n.   @brief Computes a foreground mask.\n.   \n.       @param image Next video frame. Floating point frame will be used without scaling and should be in range \\f$[0,255]\\f$.\n.       @param fgmask The output foreground mask as an 8-bit binary image.\n.       @param learningRate The value between 0 and 1 that indicates how fast the background model is\n.       learnt. Negative parameter value makes the algorithm to use some automatically chosen learning\n.       rate. 0 means that the background model is not updated at all, 1 means that the background model\n.       is completely reinitialized from the last frame."},
    {"getBackgroundRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getBackgroundRatio, 0), "getBackgroundRatio() -> retval\n.   @brief Returns the \"background ratio\" parameter of the algorithm\n.   \n.       If a foreground pixel keeps semi-constant value for about backgroundRatio\\*history frames, it's\n.       considered background and added to the model as a center of a new component. It corresponds to TB\n.       parameter in the paper."},
    {"getComplexityReductionThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getComplexityReductionThreshold, 0), "getComplexityReductionThreshold() -> retval\n.   @brief Returns the complexity reduction threshold\n.   \n.       This parameter defines the number of samples needed to accept to prove the component exists. CT=0.05\n.       is a default value for all the samples. By setting CT=0 you get an algorithm very similar to the\n.       standard Stauffer&Grimson algorithm."},
    {"getDetectShadows", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getDetectShadows, 0), "getDetectShadows() -> retval\n.   @brief Returns the shadow detection flag\n.   \n.       If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorMOG2 for\n.       details."},
    {"getHistory", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getHistory, 0), "getHistory() -> retval\n.   @brief Returns the number of last frames that affect the background model"},
    {"getNMixtures", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getNMixtures, 0), "getNMixtures() -> retval\n.   @brief Returns the number of gaussian components in the background model"},
    {"getShadowThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getShadowThreshold, 0), "getShadowThreshold() -> retval\n.   @brief Returns the shadow threshold\n.   \n.       A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in\n.       the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel\n.       is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiara,\n.       *Detecting Moving Shadows...*, IEEE PAMI,2003."},
    {"getShadowValue", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getShadowValue, 0), "getShadowValue() -> retval\n.   @brief Returns the shadow value\n.   \n.       Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0\n.       in the mask always means background, 255 means foreground."},
    {"getVarInit", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getVarInit, 0), "getVarInit() -> retval\n.   @brief Returns the initial variance of each gaussian component"},
    {"getVarMax", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getVarMax, 0), "getVarMax() -> retval\n."},
    {"getVarMin", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getVarMin, 0), "getVarMin() -> retval\n."},
    {"getVarThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getVarThreshold, 0), "getVarThreshold() -> retval\n.   @brief Returns the variance threshold for the pixel-model match\n.   \n.       The main threshold on the squared Mahalanobis distance to decide if the sample is well described by\n.       the background model or not. Related to Cthr from the paper."},
    {"getVarThresholdGen", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_getVarThresholdGen, 0), "getVarThresholdGen() -> retval\n.   @brief Returns the variance threshold for the pixel-model match used for new mixture component generation\n.   \n.       Threshold for the squared Mahalanobis distance that helps decide when a sample is close to the\n.       existing components (corresponds to Tg in the paper). If a pixel is not close to any component, it\n.       is considered foreground or added as a new component. 3 sigma =\\> Tg=3\\*3=9 is default. A smaller Tg\n.       value generates more components. A higher Tg value may result in a small number of components but\n.       they can grow too large."},
    {"setBackgroundRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setBackgroundRatio, 0), "setBackgroundRatio(ratio) -> None\n.   @brief Sets the \"background ratio\" parameter of the algorithm"},
    {"setComplexityReductionThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setComplexityReductionThreshold, 0), "setComplexityReductionThreshold(ct) -> None\n.   @brief Sets the complexity reduction threshold"},
    {"setDetectShadows", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setDetectShadows, 0), "setDetectShadows(detectShadows) -> None\n.   @brief Enables or disables shadow detection"},
    {"setHistory", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setHistory, 0), "setHistory(history) -> None\n.   @brief Sets the number of last frames that affect the background model"},
    {"setNMixtures", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setNMixtures, 0), "setNMixtures(nmixtures) -> None\n.   @brief Sets the number of gaussian components in the background model.\n.   \n.       The model needs to be reinitalized to reserve memory."},
    {"setShadowThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setShadowThreshold, 0), "setShadowThreshold(threshold) -> None\n.   @brief Sets the shadow threshold"},
    {"setShadowValue", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setShadowValue, 0), "setShadowValue(value) -> None\n.   @brief Sets the shadow value"},
    {"setVarInit", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setVarInit, 0), "setVarInit(varInit) -> None\n.   @brief Sets the initial variance of each gaussian component"},
    {"setVarMax", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setVarMax, 0), "setVarMax(varMax) -> None\n."},
    {"setVarMin", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setVarMin, 0), "setVarMin(varMin) -> None\n."},
    {"setVarThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setVarThreshold, 0), "setVarThreshold(varThreshold) -> None\n.   @brief Sets the variance threshold for the pixel-model match"},
    {"setVarThresholdGen", CV_PY_FN_WITH_KW_(pyopencv_cv_BackgroundSubtractorMOG2_setVarThresholdGen, 0), "setVarThresholdGen(varThresholdGen) -> None\n.   @brief Sets the variance threshold for the pixel-model match used for new mixture component generation"},

    {NULL,          NULL}
};

// Converter (BackgroundSubtractorMOG2)

template<>
struct PyOpenCV_Converter< Ptr<cv::BackgroundSubtractorMOG2> >
{
    static PyObject* from(const Ptr<cv::BackgroundSubtractorMOG2>& r)
    {
        return pyopencv_BackgroundSubtractorMOG2_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BackgroundSubtractorMOG2>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BackgroundSubtractorMOG2> * dst_;
        if (pyopencv_BackgroundSubtractorMOG2_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BackgroundSubtractorMOG2> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// BaseCascadeClassifier (Generic)
//================================================================================

// GetSet (BaseCascadeClassifier)



// Methods (BaseCascadeClassifier)



// Tables (BaseCascadeClassifier)

static PyGetSetDef pyopencv_BaseCascadeClassifier_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_BaseCascadeClassifier_methods[] =
{

    {NULL,          NULL}
};

// Converter (BaseCascadeClassifier)

template<>
struct PyOpenCV_Converter< Ptr<cv::BaseCascadeClassifier> >
{
    static PyObject* from(const Ptr<cv::BaseCascadeClassifier>& r)
    {
        return pyopencv_BaseCascadeClassifier_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::BaseCascadeClassifier>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::BaseCascadeClassifier> * dst_;
        if (pyopencv_BaseCascadeClassifier_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::BaseCascadeClassifier> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// CLAHE (Generic)
//================================================================================

// GetSet (CLAHE)



// Methods (CLAHE)

static PyObject* pyopencv_cv_CLAHE_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CLAHE> * self1 = 0;
    if (!pyopencv_CLAHE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CLAHE' or its derivative)");
    Ptr<cv::CLAHE> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:CLAHE.apply", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->apply(src, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:CLAHE.apply", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->apply(src, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_CLAHE_collectGarbage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CLAHE> * self1 = 0;
    if (!pyopencv_CLAHE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CLAHE' or its derivative)");
    Ptr<cv::CLAHE> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->collectGarbage());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_CLAHE_getClipLimit(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CLAHE> * self1 = 0;
    if (!pyopencv_CLAHE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CLAHE' or its derivative)");
    Ptr<cv::CLAHE> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getClipLimit());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CLAHE_getTilesGridSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CLAHE> * self1 = 0;
    if (!pyopencv_CLAHE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CLAHE' or its derivative)");
    Ptr<cv::CLAHE> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTilesGridSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CLAHE_setClipLimit(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CLAHE> * self1 = 0;
    if (!pyopencv_CLAHE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CLAHE' or its derivative)");
    Ptr<cv::CLAHE> _self_ = *(self1);
    double clipLimit=0;

    const char* keywords[] = { "clipLimit", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:CLAHE.setClipLimit", (char**)keywords, &clipLimit) )
    {
        ERRWRAP2(_self_->setClipLimit(clipLimit));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_CLAHE_setTilesGridSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CLAHE> * self1 = 0;
    if (!pyopencv_CLAHE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CLAHE' or its derivative)");
    Ptr<cv::CLAHE> _self_ = *(self1);
    PyObject* pyobj_tileGridSize = NULL;
    Size tileGridSize;

    const char* keywords[] = { "tileGridSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:CLAHE.setTilesGridSize", (char**)keywords, &pyobj_tileGridSize) &&
        pyopencv_to(pyobj_tileGridSize, tileGridSize, ArgInfo("tileGridSize", 0)) )
    {
        ERRWRAP2(_self_->setTilesGridSize(tileGridSize));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (CLAHE)

static PyGetSetDef pyopencv_CLAHE_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_CLAHE_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_CLAHE_apply, 0), "apply(src[, dst]) -> dst\n.   @brief Equalizes the histogram of a grayscale image using Contrast Limited Adaptive Histogram Equalization.\n.   \n.       @param src Source image of type CV_8UC1 or CV_16UC1.\n.       @param dst Destination image."},
    {"collectGarbage", CV_PY_FN_WITH_KW_(pyopencv_cv_CLAHE_collectGarbage, 0), "collectGarbage() -> None\n."},
    {"getClipLimit", CV_PY_FN_WITH_KW_(pyopencv_cv_CLAHE_getClipLimit, 0), "getClipLimit() -> retval\n."},
    {"getTilesGridSize", CV_PY_FN_WITH_KW_(pyopencv_cv_CLAHE_getTilesGridSize, 0), "getTilesGridSize() -> retval\n."},
    {"setClipLimit", CV_PY_FN_WITH_KW_(pyopencv_cv_CLAHE_setClipLimit, 0), "setClipLimit(clipLimit) -> None\n.   @brief Sets threshold for contrast limiting.\n.   \n.       @param clipLimit threshold value."},
    {"setTilesGridSize", CV_PY_FN_WITH_KW_(pyopencv_cv_CLAHE_setTilesGridSize, 0), "setTilesGridSize(tileGridSize) -> None\n.   @brief Sets size of grid for histogram equalization. Input image will be divided into\n.       equally sized rectangular tiles.\n.   \n.       @param tileGridSize defines the number of tiles in row and column."},

    {NULL,          NULL}
};

// Converter (CLAHE)

template<>
struct PyOpenCV_Converter< Ptr<cv::CLAHE> >
{
    static PyObject* from(const Ptr<cv::CLAHE>& r)
    {
        return pyopencv_CLAHE_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::CLAHE>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::CLAHE> * dst_;
        if (pyopencv_CLAHE_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::CLAHE> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// CalibrateCRF (Generic)
//================================================================================

// GetSet (CalibrateCRF)



// Methods (CalibrateCRF)

static PyObject* pyopencv_cv_CalibrateCRF_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateCRF> * self1 = 0;
    if (!pyopencv_CalibrateCRF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateCRF' or its derivative)");
    Ptr<cv::CalibrateCRF> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;

    const char* keywords[] = { "src", "times", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:CalibrateCRF.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_times = NULL;
    UMat times;

    const char* keywords[] = { "src", "times", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:CalibrateCRF.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (CalibrateCRF)

static PyGetSetDef pyopencv_CalibrateCRF_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_CalibrateCRF_methods[] =
{
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateCRF_process, 0), "process(src, times[, dst]) -> dst\n.   @brief Recovers inverse camera response.\n.   \n.       @param src vector of input images\n.       @param dst 256x1 matrix with inverse camera response function\n.       @param times vector of exposure time values for each image"},

    {NULL,          NULL}
};

// Converter (CalibrateCRF)

template<>
struct PyOpenCV_Converter< Ptr<cv::CalibrateCRF> >
{
    static PyObject* from(const Ptr<cv::CalibrateCRF>& r)
    {
        return pyopencv_CalibrateCRF_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::CalibrateCRF>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::CalibrateCRF> * dst_;
        if (pyopencv_CalibrateCRF_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::CalibrateCRF> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// CalibrateDebevec (Generic)
//================================================================================

// GetSet (CalibrateDebevec)



// Methods (CalibrateDebevec)

static PyObject* pyopencv_cv_CalibrateDebevec_getLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!pyopencv_CalibrateDebevec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateDebevec' or its derivative)");
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLambda());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateDebevec_getRandom(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!pyopencv_CalibrateDebevec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateDebevec' or its derivative)");
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRandom());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateDebevec_getSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!pyopencv_CalibrateDebevec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateDebevec' or its derivative)");
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSamples());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateDebevec_setLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!pyopencv_CalibrateDebevec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateDebevec' or its derivative)");
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    float lambda=0.f;

    const char* keywords[] = { "lambda", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:CalibrateDebevec.setLambda", (char**)keywords, &lambda) )
    {
        ERRWRAP2(_self_->setLambda(lambda));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateDebevec_setRandom(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!pyopencv_CalibrateDebevec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateDebevec' or its derivative)");
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    bool random=0;

    const char* keywords[] = { "random", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:CalibrateDebevec.setRandom", (char**)keywords, &random) )
    {
        ERRWRAP2(_self_->setRandom(random));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateDebevec_setSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateDebevec> * self1 = 0;
    if (!pyopencv_CalibrateDebevec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateDebevec' or its derivative)");
    Ptr<cv::CalibrateDebevec> _self_ = *(self1);
    int samples=0;

    const char* keywords[] = { "samples", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:CalibrateDebevec.setSamples", (char**)keywords, &samples) )
    {
        ERRWRAP2(_self_->setSamples(samples));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (CalibrateDebevec)

static PyGetSetDef pyopencv_CalibrateDebevec_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_CalibrateDebevec_methods[] =
{
    {"getLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateDebevec_getLambda, 0), "getLambda() -> retval\n."},
    {"getRandom", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateDebevec_getRandom, 0), "getRandom() -> retval\n."},
    {"getSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateDebevec_getSamples, 0), "getSamples() -> retval\n."},
    {"setLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateDebevec_setLambda, 0), "setLambda(lambda) -> None\n."},
    {"setRandom", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateDebevec_setRandom, 0), "setRandom(random) -> None\n."},
    {"setSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateDebevec_setSamples, 0), "setSamples(samples) -> None\n."},

    {NULL,          NULL}
};

// Converter (CalibrateDebevec)

template<>
struct PyOpenCV_Converter< Ptr<cv::CalibrateDebevec> >
{
    static PyObject* from(const Ptr<cv::CalibrateDebevec>& r)
    {
        return pyopencv_CalibrateDebevec_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::CalibrateDebevec>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::CalibrateDebevec> * dst_;
        if (pyopencv_CalibrateDebevec_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::CalibrateDebevec> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// CalibrateRobertson (Generic)
//================================================================================

// GetSet (CalibrateRobertson)



// Methods (CalibrateRobertson)

static PyObject* pyopencv_cv_CalibrateRobertson_getMaxIter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!pyopencv_CalibrateRobertson_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateRobertson' or its derivative)");
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxIter());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateRobertson_getRadiance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!pyopencv_CalibrateRobertson_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateRobertson' or its derivative)");
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRadiance());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateRobertson_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!pyopencv_CalibrateRobertson_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateRobertson' or its derivative)");
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateRobertson_setMaxIter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!pyopencv_CalibrateRobertson_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateRobertson' or its derivative)");
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    int max_iter=0;

    const char* keywords[] = { "max_iter", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:CalibrateRobertson.setMaxIter", (char**)keywords, &max_iter) )
    {
        ERRWRAP2(_self_->setMaxIter(max_iter));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_CalibrateRobertson_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CalibrateRobertson> * self1 = 0;
    if (!pyopencv_CalibrateRobertson_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CalibrateRobertson' or its derivative)");
    Ptr<cv::CalibrateRobertson> _self_ = *(self1);
    float threshold=0.f;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:CalibrateRobertson.setThreshold", (char**)keywords, &threshold) )
    {
        ERRWRAP2(_self_->setThreshold(threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (CalibrateRobertson)

static PyGetSetDef pyopencv_CalibrateRobertson_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_CalibrateRobertson_methods[] =
{
    {"getMaxIter", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateRobertson_getMaxIter, 0), "getMaxIter() -> retval\n."},
    {"getRadiance", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateRobertson_getRadiance, 0), "getRadiance() -> retval\n."},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateRobertson_getThreshold, 0), "getThreshold() -> retval\n."},
    {"setMaxIter", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateRobertson_setMaxIter, 0), "setMaxIter(max_iter) -> None\n."},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_CalibrateRobertson_setThreshold, 0), "setThreshold(threshold) -> None\n."},

    {NULL,          NULL}
};

// Converter (CalibrateRobertson)

template<>
struct PyOpenCV_Converter< Ptr<cv::CalibrateRobertson> >
{
    static PyObject* from(const Ptr<cv::CalibrateRobertson>& r)
    {
        return pyopencv_CalibrateRobertson_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::CalibrateRobertson>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::CalibrateRobertson> * dst_;
        if (pyopencv_CalibrateRobertson_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::CalibrateRobertson> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// CascadeClassifier (Generic)
//================================================================================

// GetSet (CascadeClassifier)



// Methods (CascadeClassifier)

static int pyopencv_cv_CascadeClassifier_CascadeClassifier(pyopencv_CascadeClassifier_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::CascadeClassifier>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::CascadeClassifier()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;

    const char* keywords[] = { "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:CascadeClassifier", (char**)keywords, &pyobj_filename) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        new (&(self->v)) Ptr<cv::CascadeClassifier>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::CascadeClassifier(filename)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_CascadeClassifier_convert_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_oldcascade = NULL;
    String oldcascade;
    PyObject* pyobj_newcascade = NULL;
    String newcascade;
    bool retval;

    const char* keywords[] = { "oldcascade", "newcascade", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:CascadeClassifier.convert", (char**)keywords, &pyobj_oldcascade, &pyobj_newcascade) &&
        pyopencv_to(pyobj_oldcascade, oldcascade, ArgInfo("oldcascade", 0)) &&
        pyopencv_to(pyobj_newcascade, newcascade, ArgInfo("newcascade", 0)) )
    {
        ERRWRAP2(retval = cv::CascadeClassifier::convert(oldcascade, newcascade));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_detectMultiScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_Rect objects;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    PyObject* pyobj_minSize = NULL;
    Size minSize;
    PyObject* pyobj_maxSize = NULL;
    Size maxSize;

    const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|diiOO:CascadeClassifier.detectMultiScale", (char**)keywords, &pyobj_image, &scaleFactor, &minNeighbors, &flags, &pyobj_minSize, &pyobj_maxSize) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_minSize, minSize, ArgInfo("minSize", 0)) &&
        pyopencv_to(pyobj_maxSize, maxSize, ArgInfo("maxSize", 0)) )
    {
        ERRWRAP2(_self_->detectMultiScale(image, objects, scaleFactor, minNeighbors, flags, minSize, maxSize));
        return pyopencv_from(objects);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    vector_Rect objects;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    PyObject* pyobj_minSize = NULL;
    Size minSize;
    PyObject* pyobj_maxSize = NULL;
    Size maxSize;

    const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|diiOO:CascadeClassifier.detectMultiScale", (char**)keywords, &pyobj_image, &scaleFactor, &minNeighbors, &flags, &pyobj_minSize, &pyobj_maxSize) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_minSize, minSize, ArgInfo("minSize", 0)) &&
        pyopencv_to(pyobj_maxSize, maxSize, ArgInfo("maxSize", 0)) )
    {
        ERRWRAP2(_self_->detectMultiScale(image, objects, scaleFactor, minNeighbors, flags, minSize, maxSize));
        return pyopencv_from(objects);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_detectMultiScale2(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_Rect objects;
    vector_int numDetections;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    PyObject* pyobj_minSize = NULL;
    Size minSize;
    PyObject* pyobj_maxSize = NULL;
    Size maxSize;

    const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|diiOO:CascadeClassifier.detectMultiScale2", (char**)keywords, &pyobj_image, &scaleFactor, &minNeighbors, &flags, &pyobj_minSize, &pyobj_maxSize) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_minSize, minSize, ArgInfo("minSize", 0)) &&
        pyopencv_to(pyobj_maxSize, maxSize, ArgInfo("maxSize", 0)) )
    {
        ERRWRAP2(_self_->detectMultiScale(image, objects, numDetections, scaleFactor, minNeighbors, flags, minSize, maxSize));
        return Py_BuildValue("(NN)", pyopencv_from(objects), pyopencv_from(numDetections));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    vector_Rect objects;
    vector_int numDetections;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    PyObject* pyobj_minSize = NULL;
    Size minSize;
    PyObject* pyobj_maxSize = NULL;
    Size maxSize;

    const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|diiOO:CascadeClassifier.detectMultiScale2", (char**)keywords, &pyobj_image, &scaleFactor, &minNeighbors, &flags, &pyobj_minSize, &pyobj_maxSize) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_minSize, minSize, ArgInfo("minSize", 0)) &&
        pyopencv_to(pyobj_maxSize, maxSize, ArgInfo("maxSize", 0)) )
    {
        ERRWRAP2(_self_->detectMultiScale(image, objects, numDetections, scaleFactor, minNeighbors, flags, minSize, maxSize));
        return Py_BuildValue("(NN)", pyopencv_from(objects), pyopencv_from(numDetections));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_detectMultiScale3(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_Rect objects;
    vector_int rejectLevels;
    vector_double levelWeights;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    PyObject* pyobj_minSize = NULL;
    Size minSize;
    PyObject* pyobj_maxSize = NULL;
    Size maxSize;
    bool outputRejectLevels=false;

    const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", "outputRejectLevels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|diiOOb:CascadeClassifier.detectMultiScale3", (char**)keywords, &pyobj_image, &scaleFactor, &minNeighbors, &flags, &pyobj_minSize, &pyobj_maxSize, &outputRejectLevels) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_minSize, minSize, ArgInfo("minSize", 0)) &&
        pyopencv_to(pyobj_maxSize, maxSize, ArgInfo("maxSize", 0)) )
    {
        ERRWRAP2(_self_->detectMultiScale(image, objects, rejectLevels, levelWeights, scaleFactor, minNeighbors, flags, minSize, maxSize, outputRejectLevels));
        return Py_BuildValue("(NNN)", pyopencv_from(objects), pyopencv_from(rejectLevels), pyopencv_from(levelWeights));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    vector_Rect objects;
    vector_int rejectLevels;
    vector_double levelWeights;
    double scaleFactor=1.1;
    int minNeighbors=3;
    int flags=0;
    PyObject* pyobj_minSize = NULL;
    Size minSize;
    PyObject* pyobj_maxSize = NULL;
    Size maxSize;
    bool outputRejectLevels=false;

    const char* keywords[] = { "image", "scaleFactor", "minNeighbors", "flags", "minSize", "maxSize", "outputRejectLevels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|diiOOb:CascadeClassifier.detectMultiScale3", (char**)keywords, &pyobj_image, &scaleFactor, &minNeighbors, &flags, &pyobj_minSize, &pyobj_maxSize, &outputRejectLevels) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_minSize, minSize, ArgInfo("minSize", 0)) &&
        pyopencv_to(pyobj_maxSize, maxSize, ArgInfo("maxSize", 0)) )
    {
        ERRWRAP2(_self_->detectMultiScale(image, objects, rejectLevels, levelWeights, scaleFactor, minNeighbors, flags, minSize, maxSize, outputRejectLevels));
        return Py_BuildValue("(NNN)", pyopencv_from(objects), pyopencv_from(rejectLevels), pyopencv_from(levelWeights));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_getFeatureType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFeatureType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_getOriginalWindowSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getOriginalWindowSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_isOldFormatCascade(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isOldFormatCascade());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_load(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    PyObject* pyobj_filename = NULL;
    String filename;
    bool retval;

    const char* keywords[] = { "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:CascadeClassifier.load", (char**)keywords, &pyobj_filename) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        ERRWRAP2(retval = _self_->load(filename));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_CascadeClassifier_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::CascadeClassifier> * self1 = 0;
    if (!pyopencv_CascadeClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'CascadeClassifier' or its derivative)");
    Ptr<cv::CascadeClassifier> _self_ = *(self1);
    PyObject* pyobj_node = NULL;
    FileNode node;
    bool retval;

    const char* keywords[] = { "node", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:CascadeClassifier.read", (char**)keywords, &pyobj_node) &&
        pyopencv_to(pyobj_node, node, ArgInfo("node", 0)) )
    {
        ERRWRAP2(retval = _self_->read(node));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (CascadeClassifier)

static PyGetSetDef pyopencv_CascadeClassifier_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_CascadeClassifier_methods[] =
{
    {"convert", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_convert_static, METH_STATIC), "convert(oldcascade, newcascade) -> retval\n."},
    {"detectMultiScale", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_detectMultiScale, 0), "detectMultiScale(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize]]]]]) -> objects\n.   @brief Detects objects of different sizes in the input image. The detected objects are returned as a list\n.       of rectangles.\n.   \n.       @param image Matrix of the type CV_8U containing an image where objects are detected.\n.       @param objects Vector of rectangles where each rectangle contains the detected object, the\n.       rectangles may be partially outside the original image.\n.       @param scaleFactor Parameter specifying how much the image size is reduced at each image scale.\n.       @param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have\n.       to retain it.\n.       @param flags Parameter with the same meaning for an old cascade as in the function\n.       cvHaarDetectObjects. It is not used for a new cascade.\n.       @param minSize Minimum possible object size. Objects smaller than that are ignored.\n.       @param maxSize Maximum possible object size. Objects larger than that are ignored. If `maxSize == minSize` model is evaluated on single scale.\n.   \n.       The function is parallelized with the TBB library.\n.   \n.       @note\n.          -   (Python) A face detection example using cascade classifiers can be found at\n.               opencv_source_code/samples/python/facedetect.py"},
    {"detectMultiScale2", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_detectMultiScale2, 0), "detectMultiScale2(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize]]]]]) -> objects, numDetections\n.   @overload\n.       @param image Matrix of the type CV_8U containing an image where objects are detected.\n.       @param objects Vector of rectangles where each rectangle contains the detected object, the\n.       rectangles may be partially outside the original image.\n.       @param numDetections Vector of detection numbers for the corresponding objects. An object's number\n.       of detections is the number of neighboring positively classified rectangles that were joined\n.       together to form the object.\n.       @param scaleFactor Parameter specifying how much the image size is reduced at each image scale.\n.       @param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have\n.       to retain it.\n.       @param flags Parameter with the same meaning for an old cascade as in the function\n.       cvHaarDetectObjects. It is not used for a new cascade.\n.       @param minSize Minimum possible object size. Objects smaller than that are ignored.\n.       @param maxSize Maximum possible object size. Objects larger than that are ignored. If `maxSize == minSize` model is evaluated on single scale."},
    {"detectMultiScale3", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_detectMultiScale3, 0), "detectMultiScale3(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize[, outputRejectLevels]]]]]]) -> objects, rejectLevels, levelWeights\n.   @overload\n.       This function allows you to retrieve the final stage decision certainty of classification.\n.       For this, one needs to set `outputRejectLevels` on true and provide the `rejectLevels` and `levelWeights` parameter.\n.       For each resulting detection, `levelWeights` will then contain the certainty of classification at the final stage.\n.       This value can then be used to separate strong from weaker classifications.\n.   \n.       A code sample on how to use it efficiently can be found below:\n.       @code\n.       Mat img;\n.       vector<double> weights;\n.       vector<int> levels;\n.       vector<Rect> detections;\n.       CascadeClassifier model(\"/path/to/your/model.xml\");\n.       model.detectMultiScale(img, detections, levels, weights, 1.1, 3, 0, Size(), Size(), true);\n.       cerr << \"Detection \" << detections[0] << \" with weight \" << weights[0] << endl;\n.       @endcode"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_empty, 0), "empty() -> retval\n.   @brief Checks whether the classifier has been loaded."},
    {"getFeatureType", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_getFeatureType, 0), "getFeatureType() -> retval\n."},
    {"getOriginalWindowSize", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_getOriginalWindowSize, 0), "getOriginalWindowSize() -> retval\n."},
    {"isOldFormatCascade", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_isOldFormatCascade, 0), "isOldFormatCascade() -> retval\n."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_load, 0), "load(filename) -> retval\n.   @brief Loads a classifier from a file.\n.   \n.       @param filename Name of the file from which the classifier is loaded. The file may contain an old\n.       HAAR classifier trained by the haartraining application or a new cascade classifier trained by the\n.       traincascade application."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_CascadeClassifier_read, 0), "read(node) -> retval\n.   @brief Reads a classifier from a FileStorage node.\n.   \n.       @note The file may contain a new cascade classifier (trained traincascade application) only."},

    {NULL,          NULL}
};

// Converter (CascadeClassifier)

template<>
struct PyOpenCV_Converter< Ptr<cv::CascadeClassifier> >
{
    static PyObject* from(const Ptr<cv::CascadeClassifier>& r)
    {
        return pyopencv_CascadeClassifier_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::CascadeClassifier>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::CascadeClassifier> * dst_;
        if (pyopencv_CascadeClassifier_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::CascadeClassifier> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ChiHistogramCostExtractor (Generic)
//================================================================================

// GetSet (ChiHistogramCostExtractor)



// Methods (ChiHistogramCostExtractor)



// Tables (ChiHistogramCostExtractor)

static PyGetSetDef pyopencv_ChiHistogramCostExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ChiHistogramCostExtractor_methods[] =
{

    {NULL,          NULL}
};

// Converter (ChiHistogramCostExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::ChiHistogramCostExtractor> >
{
    static PyObject* from(const Ptr<cv::ChiHistogramCostExtractor>& r)
    {
        return pyopencv_ChiHistogramCostExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ChiHistogramCostExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ChiHistogramCostExtractor> * dst_;
        if (pyopencv_ChiHistogramCostExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ChiHistogramCostExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// CirclesGridFinderParameters (Generic)
//================================================================================

// GetSet (CirclesGridFinderParameters)


static PyObject* pyopencv_CirclesGridFinderParameters_get_convexHullFactor(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.convexHullFactor);
}

static int pyopencv_CirclesGridFinderParameters_set_convexHullFactor(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the convexHullFactor attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.convexHullFactor) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_densityNeighborhoodSize(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.densityNeighborhoodSize);
}

static int pyopencv_CirclesGridFinderParameters_set_densityNeighborhoodSize(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the densityNeighborhoodSize attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.densityNeighborhoodSize) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_edgeGain(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.edgeGain);
}

static int pyopencv_CirclesGridFinderParameters_set_edgeGain(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the edgeGain attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.edgeGain) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_edgePenalty(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.edgePenalty);
}

static int pyopencv_CirclesGridFinderParameters_set_edgePenalty(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the edgePenalty attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.edgePenalty) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_existingVertexGain(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.existingVertexGain);
}

static int pyopencv_CirclesGridFinderParameters_set_existingVertexGain(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the existingVertexGain attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.existingVertexGain) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_keypointScale(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.keypointScale);
}

static int pyopencv_CirclesGridFinderParameters_set_keypointScale(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the keypointScale attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.keypointScale) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_kmeansAttempts(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.kmeansAttempts);
}

static int pyopencv_CirclesGridFinderParameters_set_kmeansAttempts(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the kmeansAttempts attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.kmeansAttempts) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_maxRectifiedDistance(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.maxRectifiedDistance);
}

static int pyopencv_CirclesGridFinderParameters_set_maxRectifiedDistance(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxRectifiedDistance attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.maxRectifiedDistance) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_minDensity(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.minDensity);
}

static int pyopencv_CirclesGridFinderParameters_set_minDensity(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minDensity attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minDensity) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_minDistanceToAddKeypoint(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.minDistanceToAddKeypoint);
}

static int pyopencv_CirclesGridFinderParameters_set_minDistanceToAddKeypoint(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minDistanceToAddKeypoint attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minDistanceToAddKeypoint) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_minGraphConfidence(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.minGraphConfidence);
}

static int pyopencv_CirclesGridFinderParameters_set_minGraphConfidence(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minGraphConfidence attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minGraphConfidence) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_minRNGEdgeSwitchDist(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.minRNGEdgeSwitchDist);
}

static int pyopencv_CirclesGridFinderParameters_set_minRNGEdgeSwitchDist(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minRNGEdgeSwitchDist attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minRNGEdgeSwitchDist) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_squareSize(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.squareSize);
}

static int pyopencv_CirclesGridFinderParameters_set_squareSize(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the squareSize attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.squareSize) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_vertexGain(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.vertexGain);
}

static int pyopencv_CirclesGridFinderParameters_set_vertexGain(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the vertexGain attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.vertexGain) ? 0 : -1;
}

static PyObject* pyopencv_CirclesGridFinderParameters_get_vertexPenalty(pyopencv_CirclesGridFinderParameters_t* p, void *closure)
{
    return pyopencv_from(p->v.vertexPenalty);
}

static int pyopencv_CirclesGridFinderParameters_set_vertexPenalty(pyopencv_CirclesGridFinderParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the vertexPenalty attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.vertexPenalty) ? 0 : -1;
}


// Methods (CirclesGridFinderParameters)

static int pyopencv_cv_CirclesGridFinderParameters_CirclesGridFinderParameters(pyopencv_CirclesGridFinderParameters_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::CirclesGridFinderParameters());
        return 0;
    }

    return -1;
}



// Tables (CirclesGridFinderParameters)

static PyGetSetDef pyopencv_CirclesGridFinderParameters_getseters[] =
{
    {(char*)"convexHullFactor", (getter)pyopencv_CirclesGridFinderParameters_get_convexHullFactor, (setter)pyopencv_CirclesGridFinderParameters_set_convexHullFactor, (char*)"convexHullFactor", NULL},
    {(char*)"densityNeighborhoodSize", (getter)pyopencv_CirclesGridFinderParameters_get_densityNeighborhoodSize, (setter)pyopencv_CirclesGridFinderParameters_set_densityNeighborhoodSize, (char*)"densityNeighborhoodSize", NULL},
    {(char*)"edgeGain", (getter)pyopencv_CirclesGridFinderParameters_get_edgeGain, (setter)pyopencv_CirclesGridFinderParameters_set_edgeGain, (char*)"edgeGain", NULL},
    {(char*)"edgePenalty", (getter)pyopencv_CirclesGridFinderParameters_get_edgePenalty, (setter)pyopencv_CirclesGridFinderParameters_set_edgePenalty, (char*)"edgePenalty", NULL},
    {(char*)"existingVertexGain", (getter)pyopencv_CirclesGridFinderParameters_get_existingVertexGain, (setter)pyopencv_CirclesGridFinderParameters_set_existingVertexGain, (char*)"existingVertexGain", NULL},
    {(char*)"keypointScale", (getter)pyopencv_CirclesGridFinderParameters_get_keypointScale, (setter)pyopencv_CirclesGridFinderParameters_set_keypointScale, (char*)"keypointScale", NULL},
    {(char*)"kmeansAttempts", (getter)pyopencv_CirclesGridFinderParameters_get_kmeansAttempts, (setter)pyopencv_CirclesGridFinderParameters_set_kmeansAttempts, (char*)"kmeansAttempts", NULL},
    {(char*)"maxRectifiedDistance", (getter)pyopencv_CirclesGridFinderParameters_get_maxRectifiedDistance, (setter)pyopencv_CirclesGridFinderParameters_set_maxRectifiedDistance, (char*)"maxRectifiedDistance", NULL},
    {(char*)"minDensity", (getter)pyopencv_CirclesGridFinderParameters_get_minDensity, (setter)pyopencv_CirclesGridFinderParameters_set_minDensity, (char*)"minDensity", NULL},
    {(char*)"minDistanceToAddKeypoint", (getter)pyopencv_CirclesGridFinderParameters_get_minDistanceToAddKeypoint, (setter)pyopencv_CirclesGridFinderParameters_set_minDistanceToAddKeypoint, (char*)"minDistanceToAddKeypoint", NULL},
    {(char*)"minGraphConfidence", (getter)pyopencv_CirclesGridFinderParameters_get_minGraphConfidence, (setter)pyopencv_CirclesGridFinderParameters_set_minGraphConfidence, (char*)"minGraphConfidence", NULL},
    {(char*)"minRNGEdgeSwitchDist", (getter)pyopencv_CirclesGridFinderParameters_get_minRNGEdgeSwitchDist, (setter)pyopencv_CirclesGridFinderParameters_set_minRNGEdgeSwitchDist, (char*)"minRNGEdgeSwitchDist", NULL},
    {(char*)"squareSize", (getter)pyopencv_CirclesGridFinderParameters_get_squareSize, (setter)pyopencv_CirclesGridFinderParameters_set_squareSize, (char*)"squareSize", NULL},
    {(char*)"vertexGain", (getter)pyopencv_CirclesGridFinderParameters_get_vertexGain, (setter)pyopencv_CirclesGridFinderParameters_set_vertexGain, (char*)"vertexGain", NULL},
    {(char*)"vertexPenalty", (getter)pyopencv_CirclesGridFinderParameters_get_vertexPenalty, (setter)pyopencv_CirclesGridFinderParameters_set_vertexPenalty, (char*)"vertexPenalty", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_CirclesGridFinderParameters_methods[] =
{

    {NULL,          NULL}
};

// Converter (CirclesGridFinderParameters)

template<>
struct PyOpenCV_Converter< cv::CirclesGridFinderParameters >
{
    static PyObject* from(const cv::CirclesGridFinderParameters& r)
    {
        return pyopencv_CirclesGridFinderParameters_Instance(r);
    }
    static bool to(PyObject* src, cv::CirclesGridFinderParameters& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::CirclesGridFinderParameters * dst_;
        if (pyopencv_CirclesGridFinderParameters_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::CirclesGridFinderParameters for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// DISOpticalFlow (Generic)
//================================================================================

// GetSet (DISOpticalFlow)



// Methods (DISOpticalFlow)

static PyObject* pyopencv_cv_DISOpticalFlow_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int preset=DISOpticalFlow::PRESET_FAST;
    Ptr<DISOpticalFlow> retval;

    const char* keywords[] = { "preset", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:DISOpticalFlow.create", (char**)keywords, &preset) )
    {
        ERRWRAP2(retval = cv::DISOpticalFlow::create(preset));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getFinestScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFinestScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getGradientDescentIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGradientDescentIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getPatchSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPatchSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getPatchStride(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPatchStride());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getUseMeanNormalization(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseMeanNormalization());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getUseSpatialPropagation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseSpatialPropagation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getVariationalRefinementAlpha(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVariationalRefinementAlpha());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getVariationalRefinementDelta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVariationalRefinementDelta());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getVariationalRefinementGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVariationalRefinementGamma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_getVariationalRefinementIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVariationalRefinementIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setFinestScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:DISOpticalFlow.setFinestScale", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setFinestScale(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setGradientDescentIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:DISOpticalFlow.setGradientDescentIterations", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setGradientDescentIterations(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setPatchSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:DISOpticalFlow.setPatchSize", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setPatchSize(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setPatchStride(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:DISOpticalFlow.setPatchStride", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setPatchStride(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setUseMeanNormalization(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:DISOpticalFlow.setUseMeanNormalization", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUseMeanNormalization(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setUseSpatialPropagation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:DISOpticalFlow.setUseSpatialPropagation", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUseSpatialPropagation(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setVariationalRefinementAlpha(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:DISOpticalFlow.setVariationalRefinementAlpha", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setVariationalRefinementAlpha(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setVariationalRefinementDelta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:DISOpticalFlow.setVariationalRefinementDelta", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setVariationalRefinementDelta(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setVariationalRefinementGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:DISOpticalFlow.setVariationalRefinementGamma", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setVariationalRefinementGamma(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DISOpticalFlow_setVariationalRefinementIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DISOpticalFlow> * self1 = 0;
    if (!pyopencv_DISOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DISOpticalFlow' or its derivative)");
    Ptr<cv::DISOpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:DISOpticalFlow.setVariationalRefinementIterations", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setVariationalRefinementIterations(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (DISOpticalFlow)

static PyGetSetDef pyopencv_DISOpticalFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_DISOpticalFlow_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_create_static, METH_STATIC), "create([, preset]) -> retval\n.   @brief Creates an instance of DISOpticalFlow\n.   \n.       @param preset one of PRESET_ULTRAFAST, PRESET_FAST and PRESET_MEDIUM"},
    {"getFinestScale", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getFinestScale, 0), "getFinestScale() -> retval\n.   @brief Finest level of the Gaussian pyramid on which the flow is computed (zero level\n.           corresponds to the original image resolution). The final flow is obtained by bilinear upscaling.\n.   @see setFinestScale"},
    {"getGradientDescentIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getGradientDescentIterations, 0), "getGradientDescentIterations() -> retval\n.   @brief Maximum number of gradient descent iterations in the patch inverse search stage. Higher values\n.           may improve quality in some cases.\n.   @see setGradientDescentIterations"},
    {"getPatchSize", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getPatchSize, 0), "getPatchSize() -> retval\n.   @brief Size of an image patch for matching (in pixels). Normally, default 8x8 patches work well\n.           enough in most cases.\n.   @see setPatchSize"},
    {"getPatchStride", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getPatchStride, 0), "getPatchStride() -> retval\n.   @brief Stride between neighbor patches. Must be less than patch size. Lower values correspond\n.           to higher flow quality.\n.   @see setPatchStride"},
    {"getUseMeanNormalization", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getUseMeanNormalization, 0), "getUseMeanNormalization() -> retval\n.   @brief Whether to use mean-normalization of patches when computing patch distance. It is turned on\n.           by default as it typically provides a noticeable quality boost because of increased robustness to\n.           illumination variations. Turn it off if you are certain that your sequence doesn't contain any changes\n.           in illumination.\n.   @see setUseMeanNormalization"},
    {"getUseSpatialPropagation", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getUseSpatialPropagation, 0), "getUseSpatialPropagation() -> retval\n.   @brief Whether to use spatial propagation of good optical flow vectors. This option is turned on by\n.           default, as it tends to work better on average and can sometimes help recover from major errors\n.           introduced by the coarse-to-fine scheme employed by the DIS optical flow algorithm. Turning this\n.           option off can make the output flow field a bit smoother, however.\n.   @see setUseSpatialPropagation"},
    {"getVariationalRefinementAlpha", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getVariationalRefinementAlpha, 0), "getVariationalRefinementAlpha() -> retval\n.   @brief Weight of the smoothness term\n.   @see setVariationalRefinementAlpha"},
    {"getVariationalRefinementDelta", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getVariationalRefinementDelta, 0), "getVariationalRefinementDelta() -> retval\n.   @brief Weight of the color constancy term\n.   @see setVariationalRefinementDelta"},
    {"getVariationalRefinementGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getVariationalRefinementGamma, 0), "getVariationalRefinementGamma() -> retval\n.   @brief Weight of the gradient constancy term\n.   @see setVariationalRefinementGamma"},
    {"getVariationalRefinementIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_getVariationalRefinementIterations, 0), "getVariationalRefinementIterations() -> retval\n.   @brief Number of fixed point iterations of variational refinement per scale. Set to zero to\n.           disable variational refinement completely. Higher values will typically result in more smooth and\n.           high-quality flow.\n.   @see setGradientDescentIterations"},
    {"setFinestScale", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setFinestScale, 0), "setFinestScale(val) -> None\n.   @copybrief getFinestScale @see getFinestScale"},
    {"setGradientDescentIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setGradientDescentIterations, 0), "setGradientDescentIterations(val) -> None\n.   @copybrief getGradientDescentIterations @see getGradientDescentIterations"},
    {"setPatchSize", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setPatchSize, 0), "setPatchSize(val) -> None\n.   @copybrief getPatchSize @see getPatchSize"},
    {"setPatchStride", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setPatchStride, 0), "setPatchStride(val) -> None\n.   @copybrief getPatchStride @see getPatchStride"},
    {"setUseMeanNormalization", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setUseMeanNormalization, 0), "setUseMeanNormalization(val) -> None\n.   @copybrief getUseMeanNormalization @see getUseMeanNormalization"},
    {"setUseSpatialPropagation", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setUseSpatialPropagation, 0), "setUseSpatialPropagation(val) -> None\n.   @copybrief getUseSpatialPropagation @see getUseSpatialPropagation"},
    {"setVariationalRefinementAlpha", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setVariationalRefinementAlpha, 0), "setVariationalRefinementAlpha(val) -> None\n.   @copybrief getVariationalRefinementAlpha @see getVariationalRefinementAlpha"},
    {"setVariationalRefinementDelta", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setVariationalRefinementDelta, 0), "setVariationalRefinementDelta(val) -> None\n.   @copybrief getVariationalRefinementDelta @see getVariationalRefinementDelta"},
    {"setVariationalRefinementGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setVariationalRefinementGamma, 0), "setVariationalRefinementGamma(val) -> None\n.   @copybrief getVariationalRefinementGamma @see getVariationalRefinementGamma"},
    {"setVariationalRefinementIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_DISOpticalFlow_setVariationalRefinementIterations, 0), "setVariationalRefinementIterations(val) -> None\n.   @copybrief getGradientDescentIterations @see getGradientDescentIterations"},

    {NULL,          NULL}
};

// Converter (DISOpticalFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::DISOpticalFlow> >
{
    static PyObject* from(const Ptr<cv::DISOpticalFlow>& r)
    {
        return pyopencv_DISOpticalFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::DISOpticalFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::DISOpticalFlow> * dst_;
        if (pyopencv_DISOpticalFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::DISOpticalFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// DMatch (Generic)
//================================================================================

// GetSet (DMatch)


static PyObject* pyopencv_DMatch_get_distance(pyopencv_DMatch_t* p, void *closure)
{
    return pyopencv_from(p->v.distance);
}

static int pyopencv_DMatch_set_distance(pyopencv_DMatch_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the distance attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.distance) ? 0 : -1;
}

static PyObject* pyopencv_DMatch_get_imgIdx(pyopencv_DMatch_t* p, void *closure)
{
    return pyopencv_from(p->v.imgIdx);
}

static int pyopencv_DMatch_set_imgIdx(pyopencv_DMatch_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the imgIdx attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.imgIdx) ? 0 : -1;
}

static PyObject* pyopencv_DMatch_get_queryIdx(pyopencv_DMatch_t* p, void *closure)
{
    return pyopencv_from(p->v.queryIdx);
}

static int pyopencv_DMatch_set_queryIdx(pyopencv_DMatch_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the queryIdx attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.queryIdx) ? 0 : -1;
}

static PyObject* pyopencv_DMatch_get_trainIdx(pyopencv_DMatch_t* p, void *closure)
{
    return pyopencv_from(p->v.trainIdx);
}

static int pyopencv_DMatch_set_trainIdx(pyopencv_DMatch_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the trainIdx attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.trainIdx) ? 0 : -1;
}


// Methods (DMatch)

static int pyopencv_cv_DMatch_DMatch(pyopencv_DMatch_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::DMatch());
        return 0;
    }
    }
    PyErr_Clear();

    {
    int _queryIdx=0;
    int _trainIdx=0;
    float _distance=0.f;

    const char* keywords[] = { "_queryIdx", "_trainIdx", "_distance", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iif:DMatch", (char**)keywords, &_queryIdx, &_trainIdx, &_distance) )
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::DMatch(_queryIdx, _trainIdx, _distance));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int _queryIdx=0;
    int _trainIdx=0;
    int _imgIdx=0;
    float _distance=0.f;

    const char* keywords[] = { "_queryIdx", "_trainIdx", "_imgIdx", "_distance", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiif:DMatch", (char**)keywords, &_queryIdx, &_trainIdx, &_imgIdx, &_distance) )
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::DMatch(_queryIdx, _trainIdx, _imgIdx, _distance));
        return 0;
    }
    }

    return -1;
}



// Tables (DMatch)

static PyGetSetDef pyopencv_DMatch_getseters[] =
{
    {(char*)"distance", (getter)pyopencv_DMatch_get_distance, (setter)pyopencv_DMatch_set_distance, (char*)"distance", NULL},
    {(char*)"imgIdx", (getter)pyopencv_DMatch_get_imgIdx, (setter)pyopencv_DMatch_set_imgIdx, (char*)"imgIdx", NULL},
    {(char*)"queryIdx", (getter)pyopencv_DMatch_get_queryIdx, (setter)pyopencv_DMatch_set_queryIdx, (char*)"queryIdx", NULL},
    {(char*)"trainIdx", (getter)pyopencv_DMatch_get_trainIdx, (setter)pyopencv_DMatch_set_trainIdx, (char*)"trainIdx", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_DMatch_methods[] =
{

    {NULL,          NULL}
};

// Converter (DMatch)

template<>
struct PyOpenCV_Converter< cv::DMatch >
{
    static PyObject* from(const cv::DMatch& r)
    {
        return pyopencv_DMatch_Instance(r);
    }
    static bool to(PyObject* src, cv::DMatch& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::DMatch * dst_;
        if (pyopencv_DMatch_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::DMatch for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// DenseOpticalFlow (Generic)
//================================================================================

// GetSet (DenseOpticalFlow)



// Methods (DenseOpticalFlow)

static PyObject* pyopencv_cv_DenseOpticalFlow_calc(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!pyopencv_DenseOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DenseOpticalFlow' or its derivative)");
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);
    {
    PyObject* pyobj_I0 = NULL;
    Mat I0;
    PyObject* pyobj_I1 = NULL;
    Mat I1;
    PyObject* pyobj_flow = NULL;
    Mat flow;

    const char* keywords[] = { "I0", "I1", "flow", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:DenseOpticalFlow.calc", (char**)keywords, &pyobj_I0, &pyobj_I1, &pyobj_flow) &&
        pyopencv_to(pyobj_I0, I0, ArgInfo("I0", 0)) &&
        pyopencv_to(pyobj_I1, I1, ArgInfo("I1", 0)) &&
        pyopencv_to(pyobj_flow, flow, ArgInfo("flow", 1)) )
    {
        ERRWRAP2(_self_->calc(I0, I1, flow));
        return pyopencv_from(flow);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_I0 = NULL;
    UMat I0;
    PyObject* pyobj_I1 = NULL;
    UMat I1;
    PyObject* pyobj_flow = NULL;
    UMat flow;

    const char* keywords[] = { "I0", "I1", "flow", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:DenseOpticalFlow.calc", (char**)keywords, &pyobj_I0, &pyobj_I1, &pyobj_flow) &&
        pyopencv_to(pyobj_I0, I0, ArgInfo("I0", 0)) &&
        pyopencv_to(pyobj_I1, I1, ArgInfo("I1", 0)) &&
        pyopencv_to(pyobj_flow, flow, ArgInfo("flow", 1)) )
    {
        ERRWRAP2(_self_->calc(I0, I1, flow));
        return pyopencv_from(flow);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_DenseOpticalFlow_collectGarbage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DenseOpticalFlow> * self1 = 0;
    if (!pyopencv_DenseOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DenseOpticalFlow' or its derivative)");
    Ptr<cv::DenseOpticalFlow> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->collectGarbage());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (DenseOpticalFlow)

static PyGetSetDef pyopencv_DenseOpticalFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_DenseOpticalFlow_methods[] =
{
    {"calc", CV_PY_FN_WITH_KW_(pyopencv_cv_DenseOpticalFlow_calc, 0), "calc(I0, I1, flow) -> flow\n.   @brief Calculates an optical flow.\n.   \n.       @param I0 first 8-bit single-channel input image.\n.       @param I1 second input image of the same size and the same type as prev.\n.       @param flow computed flow image that has the same size as prev and type CV_32FC2."},
    {"collectGarbage", CV_PY_FN_WITH_KW_(pyopencv_cv_DenseOpticalFlow_collectGarbage, 0), "collectGarbage() -> None\n.   @brief Releases all inner buffers."},

    {NULL,          NULL}
};

// Converter (DenseOpticalFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::DenseOpticalFlow> >
{
    static PyObject* from(const Ptr<cv::DenseOpticalFlow>& r)
    {
        return pyopencv_DenseOpticalFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::DenseOpticalFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::DenseOpticalFlow> * dst_;
        if (pyopencv_DenseOpticalFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::DenseOpticalFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// DescriptorMatcher (Generic)
//================================================================================

// GetSet (DescriptorMatcher)



// Methods (DescriptorMatcher)

static PyObject* pyopencv_cv_DescriptorMatcher_add(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_descriptors = NULL;
    vector_Mat descriptors;

    const char* keywords[] = { "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DescriptorMatcher.add", (char**)keywords, &pyobj_descriptors) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 0)) )
    {
        ERRWRAP2(_self_->add(descriptors));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_descriptors = NULL;
    vector_Mat descriptors;

    const char* keywords[] = { "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DescriptorMatcher.add", (char**)keywords, &pyobj_descriptors) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 0)) )
    {
        ERRWRAP2(_self_->add(descriptors));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_clear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clear());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_clone(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    bool emptyTrainData=false;
    Ptr<DescriptorMatcher> retval;

    const char* keywords[] = { "emptyTrainData", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|b:DescriptorMatcher.clone", (char**)keywords, &emptyTrainData) )
    {
        ERRWRAP2(retval = _self_->clone(emptyTrainData));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {
    PyObject* pyobj_descriptorMatcherType = NULL;
    String descriptorMatcherType;
    Ptr<DescriptorMatcher> retval;

    const char* keywords[] = { "descriptorMatcherType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DescriptorMatcher.create", (char**)keywords, &pyobj_descriptorMatcherType) &&
        pyopencv_to(pyobj_descriptorMatcherType, descriptorMatcherType, ArgInfo("descriptorMatcherType", 0)) )
    {
        ERRWRAP2(retval = cv::DescriptorMatcher::create(descriptorMatcherType));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_matcherType = NULL;
    DescriptorMatcher_MatcherType matcherType=static_cast<DescriptorMatcher_MatcherType>(0);
    Ptr<DescriptorMatcher> retval;

    const char* keywords[] = { "matcherType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DescriptorMatcher.create", (char**)keywords, &pyobj_matcherType) &&
        pyopencv_to(pyobj_matcherType, matcherType, ArgInfo("matcherType", 0)) )
    {
        ERRWRAP2(retval = cv::DescriptorMatcher::create(matcherType));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_getTrainDescriptors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    std::vector<Mat> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTrainDescriptors());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_isMaskSupported(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isMaskSupported());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_knnMatch(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|Ob:DescriptorMatcher.knnMatch", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &k, &pyobj_mask, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    UMat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    UMat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|Ob:DescriptorMatcher.knnMatch", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &k, &pyobj_mask, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "k", "masks", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|Ob:DescriptorMatcher.knnMatch", (char**)keywords, &pyobj_queryDescriptors, &k, &pyobj_masks, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->knnMatch(queryDescriptors, matches, k, masks, compactResult));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    UMat queryDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "k", "masks", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|Ob:DescriptorMatcher.knnMatch", (char**)keywords, &pyobj_queryDescriptors, &k, &pyobj_masks, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->knnMatch(queryDescriptors, matches, k, masks, compactResult));
        return pyopencv_from(matches);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_match(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    Mat trainDescriptors;
    vector_DMatch matches;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:DescriptorMatcher.match", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &pyobj_mask) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->match(queryDescriptors, trainDescriptors, matches, mask));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    UMat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    UMat trainDescriptors;
    vector_DMatch matches;
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:DescriptorMatcher.match", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &pyobj_mask) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->match(queryDescriptors, trainDescriptors, matches, mask));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    vector_DMatch matches;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;

    const char* keywords[] = { "queryDescriptors", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:DescriptorMatcher.match", (char**)keywords, &pyobj_queryDescriptors, &pyobj_masks) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->match(queryDescriptors, matches, masks));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    UMat queryDescriptors;
    vector_DMatch matches;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;

    const char* keywords[] = { "queryDescriptors", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:DescriptorMatcher.match", (char**)keywords, &pyobj_queryDescriptors, &pyobj_masks) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->match(queryDescriptors, matches, masks));
        return pyopencv_from(matches);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_radiusMatch(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "maxDistance", "mask", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOf|Ob:DescriptorMatcher.radiusMatch", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &maxDistance, &pyobj_mask, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    UMat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    UMat trainDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "maxDistance", "mask", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOf|Ob:DescriptorMatcher.radiusMatch", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &maxDistance, &pyobj_mask, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "maxDistance", "masks", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Of|Ob:DescriptorMatcher.radiusMatch", (char**)keywords, &pyobj_queryDescriptors, &maxDistance, &pyobj_masks, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    UMat queryDescriptors;
    vector_vector_DMatch matches;
    float maxDistance=0.f;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "maxDistance", "masks", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Of|Ob:DescriptorMatcher.radiusMatch", (char**)keywords, &pyobj_queryDescriptors, &maxDistance, &pyobj_masks, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult));
        return pyopencv_from(matches);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_fileName = NULL;
    String fileName;

    const char* keywords[] = { "fileName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DescriptorMatcher.read", (char**)keywords, &pyobj_fileName) &&
        pyopencv_to(pyobj_fileName, fileName, ArgInfo("fileName", 0)) )
    {
        ERRWRAP2(_self_->read(fileName));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arg1 = NULL;
    FileNode arg1;

    const char* keywords[] = { "arg1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DescriptorMatcher.read", (char**)keywords, &pyobj_arg1) &&
        pyopencv_to(pyobj_arg1, arg1, ArgInfo("arg1", 0)) )
    {
        ERRWRAP2(_self_->read(arg1));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_train(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->train());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_DescriptorMatcher_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::DescriptorMatcher> * self1 = 0;
    if (!pyopencv_DescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'DescriptorMatcher' or its derivative)");
    Ptr<cv::DescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_fileName = NULL;
    String fileName;

    const char* keywords[] = { "fileName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DescriptorMatcher.write", (char**)keywords, &pyobj_fileName) &&
        pyopencv_to(pyobj_fileName, fileName, ArgInfo("fileName", 0)) )
    {
        ERRWRAP2(_self_->write(fileName));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_fs = NULL;
    Ptr<FileStorage> fs;
    PyObject* pyobj_name = NULL;
    String name;

    const char* keywords[] = { "fs", "name", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:DescriptorMatcher.write", (char**)keywords, &pyobj_fs, &pyobj_name) &&
        pyopencv_to(pyobj_fs, fs, ArgInfo("fs", 0)) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) )
    {
        ERRWRAP2(_self_->write(fs, name));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (DescriptorMatcher)

static PyGetSetDef pyopencv_DescriptorMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_DescriptorMatcher_methods[] =
{
    {"add", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_add, 0), "add(descriptors) -> None\n.   @brief Adds descriptors to train a CPU(trainDescCollectionis) or GPU(utrainDescCollectionis) descriptor\n.       collection.\n.   \n.       If the collection is not empty, the new descriptors are added to existing train descriptors.\n.   \n.       @param descriptors Descriptors to add. Each descriptors[i] is a set of descriptors from the same\n.       train image."},
    {"clear", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_clear, 0), "clear() -> None\n.   @brief Clears the train descriptor collections."},
    {"clone", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_clone, 0), "clone([, emptyTrainData]) -> retval\n.   @brief Clones the matcher.\n.   \n.       @param emptyTrainData If emptyTrainData is false, the method creates a deep copy of the object,\n.       that is, copies both parameters and train data. If emptyTrainData is true, the method creates an\n.       object copy with the current parameters but with empty train data."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_create_static, METH_STATIC), "create(descriptorMatcherType) -> retval\n.   @brief Creates a descriptor matcher of a given type with the default parameters (using default\n.       constructor).\n.   \n.       @param descriptorMatcherType Descriptor matcher type. Now the following matcher types are\n.       supported:\n.       -   `BruteForce` (it uses L2 )\n.       -   `BruteForce-L1`\n.       -   `BruteForce-Hamming`\n.       -   `BruteForce-Hamming(2)`\n.       -   `FlannBased`\n\n\n\ncreate(matcherType) -> retval\n."},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_empty, 0), "empty() -> retval\n.   @brief Returns true if there are no train descriptors in the both collections."},
    {"getTrainDescriptors", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_getTrainDescriptors, 0), "getTrainDescriptors() -> retval\n.   @brief Returns a constant link to the train descriptor collection trainDescCollection ."},
    {"isMaskSupported", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_isMaskSupported, 0), "isMaskSupported() -> retval\n.   @brief Returns true if the descriptor matcher supports masking permissible matches."},
    {"knnMatch", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_knnMatch, 0), "knnMatch(queryDescriptors, trainDescriptors, k[, mask[, compactResult]]) -> matches\n.   @brief Finds the k best matches for each descriptor from a query set.\n.   \n.       @param queryDescriptors Query set of descriptors.\n.       @param trainDescriptors Train set of descriptors. This set is not added to the train descriptors\n.       collection stored in the class object.\n.       @param mask Mask specifying permissible matches between an input query and train matrices of\n.       descriptors.\n.       @param matches Matches. Each matches[i] is k or less matches for the same query descriptor.\n.       @param k Count of best matches found per each query descriptor or less if a query descriptor has\n.       less than k possible matches in total.\n.       @param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is\n.       false, the matches vector has the same size as queryDescriptors rows. If compactResult is true,\n.       the matches vector does not contain matches for fully masked-out query descriptors.\n.   \n.       These extended variants of DescriptorMatcher::match methods find several best matches for each query\n.       descriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match\n.       for the details about query and train descriptors.\n\n\n\nknnMatch(queryDescriptors, k[, masks[, compactResult]]) -> matches\n.   @overload\n.       @param queryDescriptors Query set of descriptors.\n.       @param matches Matches. Each matches[i] is k or less matches for the same query descriptor.\n.       @param k Count of best matches found per each query descriptor or less if a query descriptor has\n.       less than k possible matches in total.\n.       @param masks Set of masks. Each masks[i] specifies permissible matches between the input query\n.       descriptors and stored train descriptors from the i-th image trainDescCollection[i].\n.       @param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is\n.       false, the matches vector has the same size as queryDescriptors rows. If compactResult is true,\n.       the matches vector does not contain matches for fully masked-out query descriptors."},
    {"match", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_match, 0), "match(queryDescriptors, trainDescriptors[, mask]) -> matches\n.   @brief Finds the best match for each descriptor from a query set.\n.   \n.       @param queryDescriptors Query set of descriptors.\n.       @param trainDescriptors Train set of descriptors. This set is not added to the train descriptors\n.       collection stored in the class object.\n.       @param matches Matches. If a query descriptor is masked out in mask , no match is added for this\n.       descriptor. So, matches size may be smaller than the query descriptors count.\n.       @param mask Mask specifying permissible matches between an input query and train matrices of\n.       descriptors.\n.   \n.       In the first variant of this method, the train descriptors are passed as an input argument. In the\n.       second variant of the method, train descriptors collection that was set by DescriptorMatcher::add is\n.       used. Optional mask (or masks) can be passed to specify which query and training descriptors can be\n.       matched. Namely, queryDescriptors[i] can be matched with trainDescriptors[j] only if\n.       mask.at\\<uchar\\>(i,j) is non-zero.\n\n\n\nmatch(queryDescriptors[, masks]) -> matches\n.   @overload\n.       @param queryDescriptors Query set of descriptors.\n.       @param matches Matches. If a query descriptor is masked out in mask , no match is added for this\n.       descriptor. So, matches size may be smaller than the query descriptors count.\n.       @param masks Set of masks. Each masks[i] specifies permissible matches between the input query\n.       descriptors and stored train descriptors from the i-th image trainDescCollection[i]."},
    {"radiusMatch", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_radiusMatch, 0), "radiusMatch(queryDescriptors, trainDescriptors, maxDistance[, mask[, compactResult]]) -> matches\n.   @brief For each query descriptor, finds the training descriptors not farther than the specified distance.\n.   \n.       @param queryDescriptors Query set of descriptors.\n.       @param trainDescriptors Train set of descriptors. This set is not added to the train descriptors\n.       collection stored in the class object.\n.       @param matches Found matches.\n.       @param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is\n.       false, the matches vector has the same size as queryDescriptors rows. If compactResult is true,\n.       the matches vector does not contain matches for fully masked-out query descriptors.\n.       @param maxDistance Threshold for the distance between matched descriptors. Distance means here\n.       metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured\n.       in Pixels)!\n.       @param mask Mask specifying permissible matches between an input query and train matrices of\n.       descriptors.\n.   \n.       For each query descriptor, the methods find such training descriptors that the distance between the\n.       query descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are\n.       returned in the distance increasing order.\n\n\n\nradiusMatch(queryDescriptors, maxDistance[, masks[, compactResult]]) -> matches\n.   @overload\n.       @param queryDescriptors Query set of descriptors.\n.       @param matches Found matches.\n.       @param maxDistance Threshold for the distance between matched descriptors. Distance means here\n.       metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured\n.       in Pixels)!\n.       @param masks Set of masks. Each masks[i] specifies permissible matches between the input query\n.       descriptors and stored train descriptors from the i-th image trainDescCollection[i].\n.       @param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is\n.       false, the matches vector has the same size as queryDescriptors rows. If compactResult is true,\n.       the matches vector does not contain matches for fully masked-out query descriptors."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_read, 0), "read(fileName) -> None\n.   \n\n\n\nread(arg1) -> None\n."},
    {"train", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_train, 0), "train() -> None\n.   @brief Trains a descriptor matcher\n.   \n.       Trains a descriptor matcher (for example, the flann index). In all methods to match, the method\n.       train() is run every time before matching. Some descriptor matchers (for example, BruteForceMatcher)\n.       have an empty implementation of this method. Other matchers really train their inner structures (for\n.       example, FlannBasedMatcher trains flann::Index )."},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_DescriptorMatcher_write, 0), "write(fileName) -> None\n.   \n\n\n\nwrite(fs[, name]) -> None\n."},

    {NULL,          NULL}
};

// Converter (DescriptorMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::DescriptorMatcher> >
{
    static PyObject* from(const Ptr<cv::DescriptorMatcher>& r)
    {
        return pyopencv_DescriptorMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::DescriptorMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::DescriptorMatcher> * dst_;
        if (pyopencv_DescriptorMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::DescriptorMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// EMDHistogramCostExtractor (Generic)
//================================================================================

// GetSet (EMDHistogramCostExtractor)



// Methods (EMDHistogramCostExtractor)

static PyObject* pyopencv_cv_EMDHistogramCostExtractor_getNormFlag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::EMDHistogramCostExtractor> * self1 = 0;
    if (!pyopencv_EMDHistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'EMDHistogramCostExtractor' or its derivative)");
    Ptr<cv::EMDHistogramCostExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNormFlag());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_EMDHistogramCostExtractor_setNormFlag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::EMDHistogramCostExtractor> * self1 = 0;
    if (!pyopencv_EMDHistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'EMDHistogramCostExtractor' or its derivative)");
    Ptr<cv::EMDHistogramCostExtractor> _self_ = *(self1);
    int flag=0;

    const char* keywords[] = { "flag", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:EMDHistogramCostExtractor.setNormFlag", (char**)keywords, &flag) )
    {
        ERRWRAP2(_self_->setNormFlag(flag));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (EMDHistogramCostExtractor)

static PyGetSetDef pyopencv_EMDHistogramCostExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_EMDHistogramCostExtractor_methods[] =
{
    {"getNormFlag", CV_PY_FN_WITH_KW_(pyopencv_cv_EMDHistogramCostExtractor_getNormFlag, 0), "getNormFlag() -> retval\n."},
    {"setNormFlag", CV_PY_FN_WITH_KW_(pyopencv_cv_EMDHistogramCostExtractor_setNormFlag, 0), "setNormFlag(flag) -> None\n."},

    {NULL,          NULL}
};

// Converter (EMDHistogramCostExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::EMDHistogramCostExtractor> >
{
    static PyObject* from(const Ptr<cv::EMDHistogramCostExtractor>& r)
    {
        return pyopencv_EMDHistogramCostExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::EMDHistogramCostExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::EMDHistogramCostExtractor> * dst_;
        if (pyopencv_EMDHistogramCostExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::EMDHistogramCostExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// EMDL1HistogramCostExtractor (Generic)
//================================================================================

// GetSet (EMDL1HistogramCostExtractor)



// Methods (EMDL1HistogramCostExtractor)



// Tables (EMDL1HistogramCostExtractor)

static PyGetSetDef pyopencv_EMDL1HistogramCostExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_EMDL1HistogramCostExtractor_methods[] =
{

    {NULL,          NULL}
};

// Converter (EMDL1HistogramCostExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::EMDL1HistogramCostExtractor> >
{
    static PyObject* from(const Ptr<cv::EMDL1HistogramCostExtractor>& r)
    {
        return pyopencv_EMDL1HistogramCostExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::EMDL1HistogramCostExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::EMDL1HistogramCostExtractor> * dst_;
        if (pyopencv_EMDL1HistogramCostExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::EMDL1HistogramCostExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// FarnebackOpticalFlow (Generic)
//================================================================================

// GetSet (FarnebackOpticalFlow)



// Methods (FarnebackOpticalFlow)

static PyObject* pyopencv_cv_FarnebackOpticalFlow_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int numLevels=5;
    double pyrScale=0.5;
    bool fastPyramids=false;
    int winSize=13;
    int numIters=10;
    int polyN=5;
    double polySigma=1.1;
    int flags=0;
    Ptr<FarnebackOpticalFlow> retval;

    const char* keywords[] = { "numLevels", "pyrScale", "fastPyramids", "winSize", "numIters", "polyN", "polySigma", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|idbiiidi:FarnebackOpticalFlow.create", (char**)keywords, &numLevels, &pyrScale, &fastPyramids, &winSize, &numIters, &polyN, &polySigma, &flags) )
    {
        ERRWRAP2(retval = cv::FarnebackOpticalFlow::create(numLevels, pyrScale, fastPyramids, winSize, numIters, polyN, polySigma, flags));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_getFastPyramids(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFastPyramids());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_getFlags(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFlags());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_getNumIters(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumIters());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_getNumLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumLevels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_getPolyN(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPolyN());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_getPolySigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPolySigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_getPyrScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPyrScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_getWinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWinSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_setFastPyramids(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    bool fastPyramids=0;

    const char* keywords[] = { "fastPyramids", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:FarnebackOpticalFlow.setFastPyramids", (char**)keywords, &fastPyramids) )
    {
        ERRWRAP2(_self_->setFastPyramids(fastPyramids));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_setFlags(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int flags=0;

    const char* keywords[] = { "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:FarnebackOpticalFlow.setFlags", (char**)keywords, &flags) )
    {
        ERRWRAP2(_self_->setFlags(flags));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_setNumIters(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int numIters=0;

    const char* keywords[] = { "numIters", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:FarnebackOpticalFlow.setNumIters", (char**)keywords, &numIters) )
    {
        ERRWRAP2(_self_->setNumIters(numIters));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_setNumLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int numLevels=0;

    const char* keywords[] = { "numLevels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:FarnebackOpticalFlow.setNumLevels", (char**)keywords, &numLevels) )
    {
        ERRWRAP2(_self_->setNumLevels(numLevels));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_setPolyN(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int polyN=0;

    const char* keywords[] = { "polyN", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:FarnebackOpticalFlow.setPolyN", (char**)keywords, &polyN) )
    {
        ERRWRAP2(_self_->setPolyN(polyN));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_setPolySigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    double polySigma=0;

    const char* keywords[] = { "polySigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:FarnebackOpticalFlow.setPolySigma", (char**)keywords, &polySigma) )
    {
        ERRWRAP2(_self_->setPolySigma(polySigma));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_setPyrScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    double pyrScale=0;

    const char* keywords[] = { "pyrScale", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:FarnebackOpticalFlow.setPyrScale", (char**)keywords, &pyrScale) )
    {
        ERRWRAP2(_self_->setPyrScale(pyrScale));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FarnebackOpticalFlow_setWinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FarnebackOpticalFlow> * self1 = 0;
    if (!pyopencv_FarnebackOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FarnebackOpticalFlow' or its derivative)");
    Ptr<cv::FarnebackOpticalFlow> _self_ = *(self1);
    int winSize=0;

    const char* keywords[] = { "winSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:FarnebackOpticalFlow.setWinSize", (char**)keywords, &winSize) )
    {
        ERRWRAP2(_self_->setWinSize(winSize));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (FarnebackOpticalFlow)

static PyGetSetDef pyopencv_FarnebackOpticalFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_FarnebackOpticalFlow_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_create_static, METH_STATIC), "create([, numLevels[, pyrScale[, fastPyramids[, winSize[, numIters[, polyN[, polySigma[, flags]]]]]]]]) -> retval\n."},
    {"getFastPyramids", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_getFastPyramids, 0), "getFastPyramids() -> retval\n."},
    {"getFlags", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_getFlags, 0), "getFlags() -> retval\n."},
    {"getNumIters", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_getNumIters, 0), "getNumIters() -> retval\n."},
    {"getNumLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_getNumLevels, 0), "getNumLevels() -> retval\n."},
    {"getPolyN", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_getPolyN, 0), "getPolyN() -> retval\n."},
    {"getPolySigma", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_getPolySigma, 0), "getPolySigma() -> retval\n."},
    {"getPyrScale", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_getPyrScale, 0), "getPyrScale() -> retval\n."},
    {"getWinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_getWinSize, 0), "getWinSize() -> retval\n."},
    {"setFastPyramids", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_setFastPyramids, 0), "setFastPyramids(fastPyramids) -> None\n."},
    {"setFlags", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_setFlags, 0), "setFlags(flags) -> None\n."},
    {"setNumIters", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_setNumIters, 0), "setNumIters(numIters) -> None\n."},
    {"setNumLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_setNumLevels, 0), "setNumLevels(numLevels) -> None\n."},
    {"setPolyN", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_setPolyN, 0), "setPolyN(polyN) -> None\n."},
    {"setPolySigma", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_setPolySigma, 0), "setPolySigma(polySigma) -> None\n."},
    {"setPyrScale", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_setPyrScale, 0), "setPyrScale(pyrScale) -> None\n."},
    {"setWinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_FarnebackOpticalFlow_setWinSize, 0), "setWinSize(winSize) -> None\n."},

    {NULL,          NULL}
};

// Converter (FarnebackOpticalFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::FarnebackOpticalFlow> >
{
    static PyObject* from(const Ptr<cv::FarnebackOpticalFlow>& r)
    {
        return pyopencv_FarnebackOpticalFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::FarnebackOpticalFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::FarnebackOpticalFlow> * dst_;
        if (pyopencv_FarnebackOpticalFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::FarnebackOpticalFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// FastFeatureDetector (Generic)
//================================================================================

// GetSet (FastFeatureDetector)



// Methods (FastFeatureDetector)

static PyObject* pyopencv_cv_FastFeatureDetector_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int threshold=10;
    bool nonmaxSuppression=true;
    PyObject* pyobj_type = NULL;
    FastFeatureDetector_DetectorType type=FastFeatureDetector::TYPE_9_16;
    Ptr<FastFeatureDetector> retval;

    const char* keywords[] = { "threshold", "nonmaxSuppression", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ibO:FastFeatureDetector.create", (char**)keywords, &threshold, &nonmaxSuppression, &pyobj_type) &&
        pyopencv_to(pyobj_type, type, ArgInfo("type", 0)) )
    {
        ERRWRAP2(retval = cv::FastFeatureDetector::create(threshold, nonmaxSuppression, type));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FastFeatureDetector_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!pyopencv_FastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FastFeatureDetector' or its derivative)");
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FastFeatureDetector_getNonmaxSuppression(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!pyopencv_FastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FastFeatureDetector' or its derivative)");
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNonmaxSuppression());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FastFeatureDetector_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!pyopencv_FastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FastFeatureDetector' or its derivative)");
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FastFeatureDetector_getType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!pyopencv_FastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FastFeatureDetector' or its derivative)");
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    FastFeatureDetector::DetectorType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FastFeatureDetector_setNonmaxSuppression(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!pyopencv_FastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FastFeatureDetector' or its derivative)");
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    bool f=0;

    const char* keywords[] = { "f", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:FastFeatureDetector.setNonmaxSuppression", (char**)keywords, &f) )
    {
        ERRWRAP2(_self_->setNonmaxSuppression(f));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FastFeatureDetector_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!pyopencv_FastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FastFeatureDetector' or its derivative)");
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    int threshold=0;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:FastFeatureDetector.setThreshold", (char**)keywords, &threshold) )
    {
        ERRWRAP2(_self_->setThreshold(threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FastFeatureDetector_setType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FastFeatureDetector> * self1 = 0;
    if (!pyopencv_FastFeatureDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FastFeatureDetector' or its derivative)");
    Ptr<cv::FastFeatureDetector> _self_ = *(self1);
    PyObject* pyobj_type = NULL;
    FastFeatureDetector_DetectorType type=static_cast<FastFeatureDetector_DetectorType>(0);

    const char* keywords[] = { "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:FastFeatureDetector.setType", (char**)keywords, &pyobj_type) &&
        pyopencv_to(pyobj_type, type, ArgInfo("type", 0)) )
    {
        ERRWRAP2(_self_->setType(type));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (FastFeatureDetector)

static PyGetSetDef pyopencv_FastFeatureDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_FastFeatureDetector_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_FastFeatureDetector_create_static, METH_STATIC), "create([, threshold[, nonmaxSuppression[, type]]]) -> retval\n."},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_FastFeatureDetector_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"getNonmaxSuppression", CV_PY_FN_WITH_KW_(pyopencv_cv_FastFeatureDetector_getNonmaxSuppression, 0), "getNonmaxSuppression() -> retval\n."},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_FastFeatureDetector_getThreshold, 0), "getThreshold() -> retval\n."},
    {"getType", CV_PY_FN_WITH_KW_(pyopencv_cv_FastFeatureDetector_getType, 0), "getType() -> retval\n."},
    {"setNonmaxSuppression", CV_PY_FN_WITH_KW_(pyopencv_cv_FastFeatureDetector_setNonmaxSuppression, 0), "setNonmaxSuppression(f) -> None\n."},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_FastFeatureDetector_setThreshold, 0), "setThreshold(threshold) -> None\n."},
    {"setType", CV_PY_FN_WITH_KW_(pyopencv_cv_FastFeatureDetector_setType, 0), "setType(type) -> None\n."},

    {NULL,          NULL}
};

// Converter (FastFeatureDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::FastFeatureDetector> >
{
    static PyObject* from(const Ptr<cv::FastFeatureDetector>& r)
    {
        return pyopencv_FastFeatureDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::FastFeatureDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::FastFeatureDetector> * dst_;
        if (pyopencv_FastFeatureDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::FastFeatureDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// Feature2D (Generic)
//================================================================================

// GetSet (Feature2D)



// Methods (Feature2D)

static PyObject* pyopencv_cv_Feature2D_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_keypoints = NULL;
    vector_KeyPoint keypoints;
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;

    const char* keywords[] = { "image", "keypoints", "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:Feature2D.compute", (char**)keywords, &pyobj_image, &pyobj_keypoints, &pyobj_descriptors) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_keypoints, keypoints, ArgInfo("keypoints", 1)) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 1)) )
    {
        ERRWRAP2(_self_->compute(image, keypoints, descriptors));
        return Py_BuildValue("(NN)", pyopencv_from(keypoints), pyopencv_from(descriptors));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_keypoints = NULL;
    vector_KeyPoint keypoints;
    PyObject* pyobj_descriptors = NULL;
    UMat descriptors;

    const char* keywords[] = { "image", "keypoints", "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:Feature2D.compute", (char**)keywords, &pyobj_image, &pyobj_keypoints, &pyobj_descriptors) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_keypoints, keypoints, ArgInfo("keypoints", 1)) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 1)) )
    {
        ERRWRAP2(_self_->compute(image, keypoints, descriptors));
        return Py_BuildValue("(NN)", pyopencv_from(keypoints), pyopencv_from(descriptors));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_keypoints = NULL;
    vector_vector_KeyPoint keypoints;
    PyObject* pyobj_descriptors = NULL;
    vector_Mat descriptors;

    const char* keywords[] = { "images", "keypoints", "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:Feature2D.compute", (char**)keywords, &pyobj_images, &pyobj_keypoints, &pyobj_descriptors) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_keypoints, keypoints, ArgInfo("keypoints", 1)) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 1)) )
    {
        ERRWRAP2(_self_->compute(images, keypoints, descriptors));
        return Py_BuildValue("(NN)", pyopencv_from(keypoints), pyopencv_from(descriptors));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_keypoints = NULL;
    vector_vector_KeyPoint keypoints;
    PyObject* pyobj_descriptors = NULL;
    vector_Mat descriptors;

    const char* keywords[] = { "images", "keypoints", "descriptors", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:Feature2D.compute", (char**)keywords, &pyobj_images, &pyobj_keypoints, &pyobj_descriptors) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_keypoints, keypoints, ArgInfo("keypoints", 1)) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 1)) )
    {
        ERRWRAP2(_self_->compute(images, keypoints, descriptors));
        return Py_BuildValue("(NN)", pyopencv_from(keypoints), pyopencv_from(descriptors));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_defaultNorm(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->defaultNorm());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_descriptorSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->descriptorSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_descriptorType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->descriptorType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_KeyPoint keypoints;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Feature2D.detect", (char**)keywords, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->detect(image, keypoints, mask));
        return pyopencv_from(keypoints);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    vector_KeyPoint keypoints;
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Feature2D.detect", (char**)keywords, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->detect(image, keypoints, mask));
        return pyopencv_from(keypoints);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;

    const char* keywords[] = { "images", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Feature2D.detect", (char**)keywords, &pyobj_images, &pyobj_masks) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->detect(images, keypoints, masks));
        return pyopencv_from(keypoints);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    vector_vector_KeyPoint keypoints;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;

    const char* keywords[] = { "images", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Feature2D.detect", (char**)keywords, &pyobj_images, &pyobj_masks) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->detect(images, keypoints, masks));
        return pyopencv_from(keypoints);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_detectAndCompute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    vector_KeyPoint keypoints;
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;
    bool useProvidedKeypoints=false;

    const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Ob:Feature2D.detectAndCompute", (char**)keywords, &pyobj_image, &pyobj_mask, &pyobj_descriptors, &useProvidedKeypoints) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 1)) )
    {
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints));
        return Py_BuildValue("(NN)", pyopencv_from(keypoints), pyopencv_from(descriptors));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    vector_KeyPoint keypoints;
    PyObject* pyobj_descriptors = NULL;
    UMat descriptors;
    bool useProvidedKeypoints=false;

    const char* keywords[] = { "image", "mask", "descriptors", "useProvidedKeypoints", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Ob:Feature2D.detectAndCompute", (char**)keywords, &pyobj_image, &pyobj_mask, &pyobj_descriptors, &useProvidedKeypoints) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 1)) )
    {
        ERRWRAP2(_self_->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints));
        return Py_BuildValue("(NN)", pyopencv_from(keypoints), pyopencv_from(descriptors));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    {
    PyObject* pyobj_fileName = NULL;
    String fileName;

    const char* keywords[] = { "fileName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Feature2D.read", (char**)keywords, &pyobj_fileName) &&
        pyopencv_to(pyobj_fileName, fileName, ArgInfo("fileName", 0)) )
    {
        ERRWRAP2(_self_->read(fileName));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arg1 = NULL;
    FileNode arg1;

    const char* keywords[] = { "arg1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Feature2D.read", (char**)keywords, &pyobj_arg1) &&
        pyopencv_to(pyobj_arg1, arg1, ArgInfo("arg1", 0)) )
    {
        ERRWRAP2(_self_->read(arg1));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Feature2D_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Feature2D> * self1 = 0;
    if (!pyopencv_Feature2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Feature2D' or its derivative)");
    Ptr<cv::Feature2D> _self_ = *(self1);
    {
    PyObject* pyobj_fileName = NULL;
    String fileName;

    const char* keywords[] = { "fileName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Feature2D.write", (char**)keywords, &pyobj_fileName) &&
        pyopencv_to(pyobj_fileName, fileName, ArgInfo("fileName", 0)) )
    {
        ERRWRAP2(_self_->write(fileName));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_fs = NULL;
    Ptr<FileStorage> fs;
    PyObject* pyobj_name = NULL;
    String name;

    const char* keywords[] = { "fs", "name", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Feature2D.write", (char**)keywords, &pyobj_fs, &pyobj_name) &&
        pyopencv_to(pyobj_fs, fs, ArgInfo("fs", 0)) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) )
    {
        ERRWRAP2(_self_->write(fs, name));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (Feature2D)

static PyGetSetDef pyopencv_Feature2D_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_Feature2D_methods[] =
{
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_compute, 0), "compute(image, keypoints[, descriptors]) -> keypoints, descriptors\n.   @brief Computes the descriptors for a set of keypoints detected in an image (first variant) or image set\n.       (second variant).\n.   \n.       @param image Image.\n.       @param keypoints Input collection of keypoints. Keypoints for which a descriptor cannot be\n.       computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint\n.       with several dominant orientations (for each orientation).\n.       @param descriptors Computed descriptors. In the second variant of the method descriptors[i] are\n.       descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the\n.       descriptor for keypoint j-th keypoint.\n\n\n\ncompute(images, keypoints[, descriptors]) -> keypoints, descriptors\n.   @overload\n.   \n.       @param images Image set.\n.       @param keypoints Input collection of keypoints. Keypoints for which a descriptor cannot be\n.       computed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint\n.       with several dominant orientations (for each orientation).\n.       @param descriptors Computed descriptors. In the second variant of the method descriptors[i] are\n.       descriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the\n.       descriptor for keypoint j-th keypoint."},
    {"defaultNorm", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_defaultNorm, 0), "defaultNorm() -> retval\n."},
    {"descriptorSize", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_descriptorSize, 0), "descriptorSize() -> retval\n."},
    {"descriptorType", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_descriptorType, 0), "descriptorType() -> retval\n."},
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_detect, 0), "detect(image[, mask]) -> keypoints\n.   @brief Detects keypoints in an image (first variant) or image set (second variant).\n.   \n.       @param image Image.\n.       @param keypoints The detected keypoints. In the second variant of the method keypoints[i] is a set\n.       of keypoints detected in images[i] .\n.       @param mask Mask specifying where to look for keypoints (optional). It must be a 8-bit integer\n.       matrix with non-zero values in the region of interest.\n\n\n\ndetect(images[, masks]) -> keypoints\n.   @overload\n.       @param images Image set.\n.       @param keypoints The detected keypoints. In the second variant of the method keypoints[i] is a set\n.       of keypoints detected in images[i] .\n.       @param masks Masks for each input image specifying where to look for keypoints (optional).\n.       masks[i] is a mask for images[i]."},
    {"detectAndCompute", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_detectAndCompute, 0), "detectAndCompute(image, mask[, descriptors[, useProvidedKeypoints]]) -> keypoints, descriptors\n.   Detects keypoints and computes the descriptors"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_empty, 0), "empty() -> retval\n."},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_read, 0), "read(fileName) -> None\n.   \n\n\n\nread(arg1) -> None\n."},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_Feature2D_write, 0), "write(fileName) -> None\n.   \n\n\n\nwrite(fs[, name]) -> None\n."},

    {NULL,          NULL}
};

// Converter (Feature2D)

template<>
struct PyOpenCV_Converter< Ptr<cv::Feature2D> >
{
    static PyObject* from(const Ptr<cv::Feature2D>& r)
    {
        return pyopencv_Feature2D_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::Feature2D>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::Feature2D> * dst_;
        if (pyopencv_Feature2D_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::Feature2D> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// FileNode (Generic)
//================================================================================

// GetSet (FileNode)



// Methods (FileNode)

static int pyopencv_cv_FileNode_FileNode(pyopencv_FileNode_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::FileNode());
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_FileNode_at(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    int i=0;
    FileNode retval;

    const char* keywords[] = { "i", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:FileNode.at", (char**)keywords, &i) )
    {
        ERRWRAP2(retval = _self_->operator[](i));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_getNode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    char* nodename=(char*)"";
    FileNode retval;

    const char* keywords[] = { "nodename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "s:FileNode.getNode", (char**)keywords, &nodename) )
    {
        ERRWRAP2(retval = _self_->operator[](nodename));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_isInt(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isInt());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_isMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isMap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_isNamed(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isNamed());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_isNone(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isNone());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_isReal(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isReal());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_isSeq(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isSeq());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_isString(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isString());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_keys(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    std::vector<String> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->keys());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_mat(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->mat());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_name(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    std::string retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->name());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_rawSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->rawSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_real(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->real());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_size(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->size());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_string(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    std::string retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->string());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileNode_type(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    cv::FileNode * self1 = 0;
    if (!pyopencv_FileNode_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileNode' or its derivative)");
    cv::FileNode* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->type());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (FileNode)

static PyGetSetDef pyopencv_FileNode_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_FileNode_methods[] =
{
    {"at", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_at, 0), "at(i) -> retval\n.   @overload\n.        @param i Index of an element in the sequence node."},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_empty, 0), "empty() -> retval\n."},
    {"getNode", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_getNode, 0), "getNode(nodename) -> retval\n.   @overload\n.        @param nodename Name of an element in the mapping node."},
    {"isInt", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_isInt, 0), "isInt() -> retval\n."},
    {"isMap", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_isMap, 0), "isMap() -> retval\n."},
    {"isNamed", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_isNamed, 0), "isNamed() -> retval\n."},
    {"isNone", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_isNone, 0), "isNone() -> retval\n."},
    {"isReal", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_isReal, 0), "isReal() -> retval\n."},
    {"isSeq", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_isSeq, 0), "isSeq() -> retval\n."},
    {"isString", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_isString, 0), "isString() -> retval\n."},
    {"keys", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_keys, 0), "keys() -> retval\n.   @brief Returns keys of a mapping node.\n.        @returns Keys of a mapping node."},
    {"mat", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_mat, 0), "mat() -> retval\n."},
    {"name", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_name, 0), "name() -> retval\n."},
    {"rawSize", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_rawSize, 0), "rawSize() -> retval\n."},
    {"real", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_real, 0), "real() -> retval\n.   Internal method used when reading FileStorage.\n.        Sets the type (int, real or string) and value of the previously created node."},
    {"size", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_size, 0), "size() -> retval\n."},
    {"string", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_string, 0), "string() -> retval\n."},
    {"type", CV_PY_FN_WITH_KW_(pyopencv_cv_FileNode_type, 0), "type() -> retval\n.   @brief Returns type of the node.\n.        @returns Type of the node. See FileNode::Type"},

    {NULL,          NULL}
};

// Converter (FileNode)

template<>
struct PyOpenCV_Converter< cv::FileNode >
{
    static PyObject* from(const cv::FileNode& r)
    {
        return pyopencv_FileNode_Instance(r);
    }
    static bool to(PyObject* src, cv::FileNode& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::FileNode * dst_;
        if (pyopencv_FileNode_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::FileNode for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// FileStorage (Generic)
//================================================================================

// GetSet (FileStorage)



// Methods (FileStorage)

static int pyopencv_cv_FileStorage_FileStorage(pyopencv_FileStorage_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::FileStorage>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::FileStorage()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    int flags=0;
    PyObject* pyobj_encoding = NULL;
    String encoding;

    const char* keywords[] = { "filename", "flags", "encoding", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:FileStorage", (char**)keywords, &pyobj_filename, &flags, &pyobj_encoding) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_encoding, encoding, ArgInfo("encoding", 0)) )
    {
        new (&(self->v)) Ptr<cv::FileStorage>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::FileStorage(filename, flags, encoding)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_FileStorage_getFirstTopLevelNode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    FileNode retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFirstTopLevelNode());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_getFormat(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFormat());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_getNode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    char* nodename=(char*)"";
    FileNode retval;

    const char* keywords[] = { "nodename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "s:FileStorage.getNode", (char**)keywords, &nodename) )
    {
        ERRWRAP2(retval = _self_->operator[](nodename));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_isOpened(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isOpened());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_open(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    PyObject* pyobj_filename = NULL;
    String filename;
    int flags=0;
    PyObject* pyobj_encoding = NULL;
    String encoding;
    bool retval;

    const char* keywords[] = { "filename", "flags", "encoding", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:FileStorage.open", (char**)keywords, &pyobj_filename, &flags, &pyobj_encoding) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_encoding, encoding, ArgInfo("encoding", 0)) )
    {
        ERRWRAP2(retval = _self_->open(filename, flags, encoding));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_release(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->release());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_releaseAndGetString(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->releaseAndGetString());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_root(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    int streamidx=0;
    FileNode retval;

    const char* keywords[] = { "streamidx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:FileStorage.root", (char**)keywords, &streamidx) )
    {
        ERRWRAP2(retval = _self_->root(streamidx));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    {
    PyObject* pyobj_name = NULL;
    String name;
    int val=0;

    const char* keywords[] = { "name", "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:FileStorage.write", (char**)keywords, &pyobj_name, &val) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) )
    {
        ERRWRAP2(_self_->write(name, val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_name = NULL;
    String name;
    double val=0;

    const char* keywords[] = { "name", "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Od:FileStorage.write", (char**)keywords, &pyobj_name, &val) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) )
    {
        ERRWRAP2(_self_->write(name, val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_name = NULL;
    String name;
    PyObject* pyobj_val = NULL;
    String val;

    const char* keywords[] = { "name", "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:FileStorage.write", (char**)keywords, &pyobj_name, &pyobj_val) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->write(name, val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_name = NULL;
    String name;
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "name", "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:FileStorage.write", (char**)keywords, &pyobj_name, &pyobj_val) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->write(name, val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_name = NULL;
    String name;
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "name", "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:FileStorage.write", (char**)keywords, &pyobj_name, &pyobj_val) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->write(name, val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_name = NULL;
    String name;
    PyObject* pyobj_val = NULL;
    vector_String val;

    const char* keywords[] = { "name", "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:FileStorage.write", (char**)keywords, &pyobj_name, &pyobj_val) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->write(name, val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_FileStorage_writeComment(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::FileStorage> * self1 = 0;
    if (!pyopencv_FileStorage_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'FileStorage' or its derivative)");
    Ptr<cv::FileStorage> _self_ = *(self1);
    PyObject* pyobj_comment = NULL;
    String comment;
    bool append=false;

    const char* keywords[] = { "comment", "append", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|b:FileStorage.writeComment", (char**)keywords, &pyobj_comment, &append) &&
        pyopencv_to(pyobj_comment, comment, ArgInfo("comment", 0)) )
    {
        ERRWRAP2(_self_->writeComment(comment, append));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (FileStorage)

static PyGetSetDef pyopencv_FileStorage_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_FileStorage_methods[] =
{
    {"getFirstTopLevelNode", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_getFirstTopLevelNode, 0), "getFirstTopLevelNode() -> retval\n.   @brief Returns the first element of the top-level mapping.\n.        @returns The first element of the top-level mapping."},
    {"getFormat", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_getFormat, 0), "getFormat() -> retval\n.   @brief Returns the current format.\n.        * @returns The current format, see FileStorage::Mode"},
    {"getNode", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_getNode, 0), "getNode(nodename) -> retval\n.   @overload"},
    {"isOpened", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_isOpened, 0), "isOpened() -> retval\n.   @brief Checks whether the file is opened.\n.   \n.        @returns true if the object is associated with the current file and false otherwise. It is a\n.        good practice to call this method after you tried to open a file."},
    {"open", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_open, 0), "open(filename, flags[, encoding]) -> retval\n.   @brief Opens a file.\n.   \n.        See description of parameters in FileStorage::FileStorage. The method calls FileStorage::release\n.        before opening the file.\n.        @param filename Name of the file to open or the text string to read the data from.\n.        Extension of the file (.xml, .yml/.yaml or .json) determines its format (XML, YAML or JSON\n.        respectively). Also you can append .gz to work with compressed files, for example myHugeMatrix.xml.gz. If both\n.        FileStorage::WRITE and FileStorage::MEMORY flags are specified, source is used just to specify\n.        the output file format (e.g. mydata.xml, .yml etc.). A file name can also contain parameters.\n.        You can use this format, \"*?base64\" (e.g. \"file.json?base64\" (case sensitive)), as an alternative to\n.        FileStorage::BASE64 flag.\n.        @param flags Mode of operation. One of FileStorage::Mode\n.        @param encoding Encoding of the file. Note that UTF-16 XML encoding is not supported currently and\n.        you should use 8-bit encoding instead of it."},
    {"release", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_release, 0), "release() -> None\n.   @brief Closes the file and releases all the memory buffers.\n.   \n.        Call this method after all I/O operations with the storage are finished."},
    {"releaseAndGetString", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_releaseAndGetString, 0), "releaseAndGetString() -> retval\n.   @brief Closes the file and releases all the memory buffers.\n.   \n.        Call this method after all I/O operations with the storage are finished. If the storage was\n.        opened for writing data and FileStorage::WRITE was specified"},
    {"root", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_root, 0), "root([, streamidx]) -> retval\n.   @brief Returns the top-level mapping\n.        @param streamidx Zero-based index of the stream. In most cases there is only one stream in the file.\n.        However, YAML supports multiple streams and so there can be several.\n.        @returns The top-level mapping."},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_write, 0), "write(name, val) -> None\n.   * @brief Simplified writing API to use with bindings.\n.        * @param name Name of the written object\n.        * @param val Value of the written object"},
    {"writeComment", CV_PY_FN_WITH_KW_(pyopencv_cv_FileStorage_writeComment, 0), "writeComment(comment[, append]) -> None\n.   @brief Writes a comment.\n.   \n.        The function writes a comment into file storage. The comments are skipped when the storage is read.\n.        @param comment The written comment, single-line or multi-line\n.        @param append If true, the function tries to put the comment at the end of current line.\n.        Else if the comment is multi-line, or if it does not fit at the end of the current\n.        line, the comment starts a new line."},

    {NULL,          NULL}
};

// Converter (FileStorage)

template<>
struct PyOpenCV_Converter< Ptr<cv::FileStorage> >
{
    static PyObject* from(const Ptr<cv::FileStorage>& r)
    {
        return pyopencv_FileStorage_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::FileStorage>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::FileStorage> * dst_;
        if (pyopencv_FileStorage_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::FileStorage> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// FlannBasedMatcher (Generic)
//================================================================================

// GetSet (FlannBasedMatcher)



// Methods (FlannBasedMatcher)

static int pyopencv_cv_FlannBasedMatcher_FlannBasedMatcher(pyopencv_FlannBasedMatcher_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_indexParams = NULL;
    Ptr<flann::IndexParams> indexParams=makePtr<flann::KDTreeIndexParams>();
    PyObject* pyobj_searchParams = NULL;
    Ptr<flann::SearchParams> searchParams=makePtr<flann::SearchParams>();

    const char* keywords[] = { "indexParams", "searchParams", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:FlannBasedMatcher", (char**)keywords, &pyobj_indexParams, &pyobj_searchParams) &&
        pyopencv_to(pyobj_indexParams, indexParams, ArgInfo("indexParams", 0)) &&
        pyopencv_to(pyobj_searchParams, searchParams, ArgInfo("searchParams", 0)) )
    {
        new (&(self->v)) Ptr<cv::FlannBasedMatcher>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::FlannBasedMatcher(indexParams, searchParams)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_FlannBasedMatcher_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<FlannBasedMatcher> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::FlannBasedMatcher::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (FlannBasedMatcher)

static PyGetSetDef pyopencv_FlannBasedMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_FlannBasedMatcher_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_FlannBasedMatcher_create_static, METH_STATIC), "create() -> retval\n."},

    {NULL,          NULL}
};

// Converter (FlannBasedMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::FlannBasedMatcher> >
{
    static PyObject* from(const Ptr<cv::FlannBasedMatcher>& r)
    {
        return pyopencv_FlannBasedMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::FlannBasedMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::FlannBasedMatcher> * dst_;
        if (pyopencv_FlannBasedMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::FlannBasedMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// GFTTDetector (Generic)
//================================================================================

// GetSet (GFTTDetector)



// Methods (GFTTDetector)

static PyObject* pyopencv_cv_GFTTDetector_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {
    int maxCorners=1000;
    double qualityLevel=0.01;
    double minDistance=1;
    int blockSize=3;
    bool useHarrisDetector=false;
    double k=0.04;
    Ptr<GFTTDetector> retval;

    const char* keywords[] = { "maxCorners", "qualityLevel", "minDistance", "blockSize", "useHarrisDetector", "k", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iddibd:GFTTDetector.create", (char**)keywords, &maxCorners, &qualityLevel, &minDistance, &blockSize, &useHarrisDetector, &k) )
    {
        ERRWRAP2(retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, useHarrisDetector, k));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    int maxCorners=0;
    double qualityLevel=0;
    double minDistance=0;
    int blockSize=0;
    int gradiantSize=0;
    bool useHarrisDetector=false;
    double k=0.04;
    Ptr<GFTTDetector> retval;

    const char* keywords[] = { "maxCorners", "qualityLevel", "minDistance", "blockSize", "gradiantSize", "useHarrisDetector", "k", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iddii|bd:GFTTDetector.create", (char**)keywords, &maxCorners, &qualityLevel, &minDistance, &blockSize, &gradiantSize, &useHarrisDetector, &k) )
    {
        ERRWRAP2(retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize, useHarrisDetector, k));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_getBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBlockSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_getHarrisDetector(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getHarrisDetector());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_getK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getK());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_getMaxFeatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxFeatures());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_getMinDistance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinDistance());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_getQualityLevel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getQualityLevel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_setBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int blockSize=0;

    const char* keywords[] = { "blockSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GFTTDetector.setBlockSize", (char**)keywords, &blockSize) )
    {
        ERRWRAP2(_self_->setBlockSize(blockSize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_setHarrisDetector(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:GFTTDetector.setHarrisDetector", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setHarrisDetector(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_setK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double k=0;

    const char* keywords[] = { "k", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GFTTDetector.setK", (char**)keywords, &k) )
    {
        ERRWRAP2(_self_->setK(k));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_setMaxFeatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    int maxFeatures=0;

    const char* keywords[] = { "maxFeatures", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GFTTDetector.setMaxFeatures", (char**)keywords, &maxFeatures) )
    {
        ERRWRAP2(_self_->setMaxFeatures(maxFeatures));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_setMinDistance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double minDistance=0;

    const char* keywords[] = { "minDistance", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GFTTDetector.setMinDistance", (char**)keywords, &minDistance) )
    {
        ERRWRAP2(_self_->setMinDistance(minDistance));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GFTTDetector_setQualityLevel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GFTTDetector> * self1 = 0;
    if (!pyopencv_GFTTDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GFTTDetector' or its derivative)");
    Ptr<cv::GFTTDetector> _self_ = *(self1);
    double qlevel=0;

    const char* keywords[] = { "qlevel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GFTTDetector.setQualityLevel", (char**)keywords, &qlevel) )
    {
        ERRWRAP2(_self_->setQualityLevel(qlevel));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (GFTTDetector)

static PyGetSetDef pyopencv_GFTTDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_GFTTDetector_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_create_static, METH_STATIC), "create([, maxCorners[, qualityLevel[, minDistance[, blockSize[, useHarrisDetector[, k]]]]]]) -> retval\n.   \n\n\n\ncreate(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize[, useHarrisDetector[, k]]) -> retval\n."},
    {"getBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_getBlockSize, 0), "getBlockSize() -> retval\n."},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"getHarrisDetector", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_getHarrisDetector, 0), "getHarrisDetector() -> retval\n."},
    {"getK", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_getK, 0), "getK() -> retval\n."},
    {"getMaxFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_getMaxFeatures, 0), "getMaxFeatures() -> retval\n."},
    {"getMinDistance", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_getMinDistance, 0), "getMinDistance() -> retval\n."},
    {"getQualityLevel", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_getQualityLevel, 0), "getQualityLevel() -> retval\n."},
    {"setBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_setBlockSize, 0), "setBlockSize(blockSize) -> None\n."},
    {"setHarrisDetector", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_setHarrisDetector, 0), "setHarrisDetector(val) -> None\n."},
    {"setK", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_setK, 0), "setK(k) -> None\n."},
    {"setMaxFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_setMaxFeatures, 0), "setMaxFeatures(maxFeatures) -> None\n."},
    {"setMinDistance", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_setMinDistance, 0), "setMinDistance(minDistance) -> None\n."},
    {"setQualityLevel", CV_PY_FN_WITH_KW_(pyopencv_cv_GFTTDetector_setQualityLevel, 0), "setQualityLevel(qlevel) -> None\n."},

    {NULL,          NULL}
};

// Converter (GFTTDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::GFTTDetector> >
{
    static PyObject* from(const Ptr<cv::GFTTDetector>& r)
    {
        return pyopencv_GFTTDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::GFTTDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::GFTTDetector> * dst_;
        if (pyopencv_GFTTDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::GFTTDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// GeneralizedHough (Generic)
//================================================================================

// GetSet (GeneralizedHough)



// Methods (GeneralizedHough)

static PyObject* pyopencv_cv_GeneralizedHough_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_positions = NULL;
    Mat positions;
    PyObject* pyobj_votes = NULL;
    Mat votes;

    const char* keywords[] = { "image", "positions", "votes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:GeneralizedHough.detect", (char**)keywords, &pyobj_image, &pyobj_positions, &pyobj_votes) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_positions, positions, ArgInfo("positions", 1)) &&
        pyopencv_to(pyobj_votes, votes, ArgInfo("votes", 1)) )
    {
        ERRWRAP2(_self_->detect(image, positions, votes));
        return Py_BuildValue("(NN)", pyopencv_from(positions), pyopencv_from(votes));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_positions = NULL;
    UMat positions;
    PyObject* pyobj_votes = NULL;
    UMat votes;

    const char* keywords[] = { "image", "positions", "votes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:GeneralizedHough.detect", (char**)keywords, &pyobj_image, &pyobj_positions, &pyobj_votes) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_positions, positions, ArgInfo("positions", 1)) &&
        pyopencv_to(pyobj_votes, votes, ArgInfo("votes", 1)) )
    {
        ERRWRAP2(_self_->detect(image, positions, votes));
        return Py_BuildValue("(NN)", pyopencv_from(positions), pyopencv_from(votes));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_edges = NULL;
    Mat edges;
    PyObject* pyobj_dx = NULL;
    Mat dx;
    PyObject* pyobj_dy = NULL;
    Mat dy;
    PyObject* pyobj_positions = NULL;
    Mat positions;
    PyObject* pyobj_votes = NULL;
    Mat votes;

    const char* keywords[] = { "edges", "dx", "dy", "positions", "votes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:GeneralizedHough.detect", (char**)keywords, &pyobj_edges, &pyobj_dx, &pyobj_dy, &pyobj_positions, &pyobj_votes) &&
        pyopencv_to(pyobj_edges, edges, ArgInfo("edges", 0)) &&
        pyopencv_to(pyobj_dx, dx, ArgInfo("dx", 0)) &&
        pyopencv_to(pyobj_dy, dy, ArgInfo("dy", 0)) &&
        pyopencv_to(pyobj_positions, positions, ArgInfo("positions", 1)) &&
        pyopencv_to(pyobj_votes, votes, ArgInfo("votes", 1)) )
    {
        ERRWRAP2(_self_->detect(edges, dx, dy, positions, votes));
        return Py_BuildValue("(NN)", pyopencv_from(positions), pyopencv_from(votes));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_edges = NULL;
    UMat edges;
    PyObject* pyobj_dx = NULL;
    UMat dx;
    PyObject* pyobj_dy = NULL;
    UMat dy;
    PyObject* pyobj_positions = NULL;
    UMat positions;
    PyObject* pyobj_votes = NULL;
    UMat votes;

    const char* keywords[] = { "edges", "dx", "dy", "positions", "votes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:GeneralizedHough.detect", (char**)keywords, &pyobj_edges, &pyobj_dx, &pyobj_dy, &pyobj_positions, &pyobj_votes) &&
        pyopencv_to(pyobj_edges, edges, ArgInfo("edges", 0)) &&
        pyopencv_to(pyobj_dx, dx, ArgInfo("dx", 0)) &&
        pyopencv_to(pyobj_dy, dy, ArgInfo("dy", 0)) &&
        pyopencv_to(pyobj_positions, positions, ArgInfo("positions", 1)) &&
        pyopencv_to(pyobj_votes, votes, ArgInfo("votes", 1)) )
    {
        ERRWRAP2(_self_->detect(edges, dx, dy, positions, votes));
        return Py_BuildValue("(NN)", pyopencv_from(positions), pyopencv_from(votes));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_getCannyHighThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCannyHighThresh());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_getCannyLowThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCannyLowThresh());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_getDp(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDp());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_getMaxBufferSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxBufferSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_getMinDist(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinDist());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_setCannyHighThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int cannyHighThresh=0;

    const char* keywords[] = { "cannyHighThresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHough.setCannyHighThresh", (char**)keywords, &cannyHighThresh) )
    {
        ERRWRAP2(_self_->setCannyHighThresh(cannyHighThresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_setCannyLowThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int cannyLowThresh=0;

    const char* keywords[] = { "cannyLowThresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHough.setCannyLowThresh", (char**)keywords, &cannyLowThresh) )
    {
        ERRWRAP2(_self_->setCannyLowThresh(cannyLowThresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_setDp(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    double dp=0;

    const char* keywords[] = { "dp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHough.setDp", (char**)keywords, &dp) )
    {
        ERRWRAP2(_self_->setDp(dp));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_setMaxBufferSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    int maxBufferSize=0;

    const char* keywords[] = { "maxBufferSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHough.setMaxBufferSize", (char**)keywords, &maxBufferSize) )
    {
        ERRWRAP2(_self_->setMaxBufferSize(maxBufferSize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_setMinDist(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    double minDist=0;

    const char* keywords[] = { "minDist", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHough.setMinDist", (char**)keywords, &minDist) )
    {
        ERRWRAP2(_self_->setMinDist(minDist));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHough_setTemplate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHough> * self1 = 0;
    if (!pyopencv_GeneralizedHough_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHough' or its derivative)");
    Ptr<cv::GeneralizedHough> _self_ = *(self1);
    {
    PyObject* pyobj_templ = NULL;
    Mat templ;
    PyObject* pyobj_templCenter = NULL;
    Point templCenter=Point(-1, -1);

    const char* keywords[] = { "templ", "templCenter", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:GeneralizedHough.setTemplate", (char**)keywords, &pyobj_templ, &pyobj_templCenter) &&
        pyopencv_to(pyobj_templ, templ, ArgInfo("templ", 0)) &&
        pyopencv_to(pyobj_templCenter, templCenter, ArgInfo("templCenter", 0)) )
    {
        ERRWRAP2(_self_->setTemplate(templ, templCenter));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_templ = NULL;
    UMat templ;
    PyObject* pyobj_templCenter = NULL;
    Point templCenter=Point(-1, -1);

    const char* keywords[] = { "templ", "templCenter", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:GeneralizedHough.setTemplate", (char**)keywords, &pyobj_templ, &pyobj_templCenter) &&
        pyopencv_to(pyobj_templ, templ, ArgInfo("templ", 0)) &&
        pyopencv_to(pyobj_templCenter, templCenter, ArgInfo("templCenter", 0)) )
    {
        ERRWRAP2(_self_->setTemplate(templ, templCenter));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_edges = NULL;
    Mat edges;
    PyObject* pyobj_dx = NULL;
    Mat dx;
    PyObject* pyobj_dy = NULL;
    Mat dy;
    PyObject* pyobj_templCenter = NULL;
    Point templCenter=Point(-1, -1);

    const char* keywords[] = { "edges", "dx", "dy", "templCenter", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:GeneralizedHough.setTemplate", (char**)keywords, &pyobj_edges, &pyobj_dx, &pyobj_dy, &pyobj_templCenter) &&
        pyopencv_to(pyobj_edges, edges, ArgInfo("edges", 0)) &&
        pyopencv_to(pyobj_dx, dx, ArgInfo("dx", 0)) &&
        pyopencv_to(pyobj_dy, dy, ArgInfo("dy", 0)) &&
        pyopencv_to(pyobj_templCenter, templCenter, ArgInfo("templCenter", 0)) )
    {
        ERRWRAP2(_self_->setTemplate(edges, dx, dy, templCenter));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_edges = NULL;
    UMat edges;
    PyObject* pyobj_dx = NULL;
    UMat dx;
    PyObject* pyobj_dy = NULL;
    UMat dy;
    PyObject* pyobj_templCenter = NULL;
    Point templCenter=Point(-1, -1);

    const char* keywords[] = { "edges", "dx", "dy", "templCenter", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:GeneralizedHough.setTemplate", (char**)keywords, &pyobj_edges, &pyobj_dx, &pyobj_dy, &pyobj_templCenter) &&
        pyopencv_to(pyobj_edges, edges, ArgInfo("edges", 0)) &&
        pyopencv_to(pyobj_dx, dx, ArgInfo("dx", 0)) &&
        pyopencv_to(pyobj_dy, dy, ArgInfo("dy", 0)) &&
        pyopencv_to(pyobj_templCenter, templCenter, ArgInfo("templCenter", 0)) )
    {
        ERRWRAP2(_self_->setTemplate(edges, dx, dy, templCenter));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (GeneralizedHough)

static PyGetSetDef pyopencv_GeneralizedHough_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_GeneralizedHough_methods[] =
{
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_detect, 0), "detect(image[, positions[, votes]]) -> positions, votes\n.   \n\n\n\ndetect(edges, dx, dy[, positions[, votes]]) -> positions, votes\n."},
    {"getCannyHighThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_getCannyHighThresh, 0), "getCannyHighThresh() -> retval\n."},
    {"getCannyLowThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_getCannyLowThresh, 0), "getCannyLowThresh() -> retval\n."},
    {"getDp", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_getDp, 0), "getDp() -> retval\n."},
    {"getMaxBufferSize", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_getMaxBufferSize, 0), "getMaxBufferSize() -> retval\n."},
    {"getMinDist", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_getMinDist, 0), "getMinDist() -> retval\n."},
    {"setCannyHighThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_setCannyHighThresh, 0), "setCannyHighThresh(cannyHighThresh) -> None\n."},
    {"setCannyLowThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_setCannyLowThresh, 0), "setCannyLowThresh(cannyLowThresh) -> None\n."},
    {"setDp", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_setDp, 0), "setDp(dp) -> None\n."},
    {"setMaxBufferSize", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_setMaxBufferSize, 0), "setMaxBufferSize(maxBufferSize) -> None\n."},
    {"setMinDist", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_setMinDist, 0), "setMinDist(minDist) -> None\n."},
    {"setTemplate", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHough_setTemplate, 0), "setTemplate(templ[, templCenter]) -> None\n.   \n\n\n\nsetTemplate(edges, dx, dy[, templCenter]) -> None\n."},

    {NULL,          NULL}
};

// Converter (GeneralizedHough)

template<>
struct PyOpenCV_Converter< Ptr<cv::GeneralizedHough> >
{
    static PyObject* from(const Ptr<cv::GeneralizedHough>& r)
    {
        return pyopencv_GeneralizedHough_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::GeneralizedHough>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::GeneralizedHough> * dst_;
        if (pyopencv_GeneralizedHough_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::GeneralizedHough> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// GeneralizedHoughBallard (Generic)
//================================================================================

// GetSet (GeneralizedHoughBallard)



// Methods (GeneralizedHoughBallard)

static PyObject* pyopencv_cv_GeneralizedHoughBallard_getLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughBallard> * self1 = 0;
    if (!pyopencv_GeneralizedHoughBallard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughBallard' or its derivative)");
    Ptr<cv::GeneralizedHoughBallard> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLevels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughBallard_getVotesThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughBallard> * self1 = 0;
    if (!pyopencv_GeneralizedHoughBallard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughBallard' or its derivative)");
    Ptr<cv::GeneralizedHoughBallard> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVotesThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughBallard_setLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughBallard> * self1 = 0;
    if (!pyopencv_GeneralizedHoughBallard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughBallard' or its derivative)");
    Ptr<cv::GeneralizedHoughBallard> _self_ = *(self1);
    int levels=0;

    const char* keywords[] = { "levels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHoughBallard.setLevels", (char**)keywords, &levels) )
    {
        ERRWRAP2(_self_->setLevels(levels));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughBallard_setVotesThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughBallard> * self1 = 0;
    if (!pyopencv_GeneralizedHoughBallard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughBallard' or its derivative)");
    Ptr<cv::GeneralizedHoughBallard> _self_ = *(self1);
    int votesThreshold=0;

    const char* keywords[] = { "votesThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHoughBallard.setVotesThreshold", (char**)keywords, &votesThreshold) )
    {
        ERRWRAP2(_self_->setVotesThreshold(votesThreshold));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (GeneralizedHoughBallard)

static PyGetSetDef pyopencv_GeneralizedHoughBallard_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_GeneralizedHoughBallard_methods[] =
{
    {"getLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughBallard_getLevels, 0), "getLevels() -> retval\n."},
    {"getVotesThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughBallard_getVotesThreshold, 0), "getVotesThreshold() -> retval\n."},
    {"setLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughBallard_setLevels, 0), "setLevels(levels) -> None\n."},
    {"setVotesThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughBallard_setVotesThreshold, 0), "setVotesThreshold(votesThreshold) -> None\n."},

    {NULL,          NULL}
};

// Converter (GeneralizedHoughBallard)

template<>
struct PyOpenCV_Converter< Ptr<cv::GeneralizedHoughBallard> >
{
    static PyObject* from(const Ptr<cv::GeneralizedHoughBallard>& r)
    {
        return pyopencv_GeneralizedHoughBallard_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::GeneralizedHoughBallard>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::GeneralizedHoughBallard> * dst_;
        if (pyopencv_GeneralizedHoughBallard_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::GeneralizedHoughBallard> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// GeneralizedHoughGuil (Generic)
//================================================================================

// GetSet (GeneralizedHoughGuil)



// Methods (GeneralizedHoughGuil)

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getAngleEpsilon(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAngleEpsilon());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getAngleStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAngleStep());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getAngleThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAngleThresh());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLevels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getMaxAngle(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxAngle());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getMaxScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getMinAngle(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinAngle());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getMinScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getPosThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPosThresh());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getScaleStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScaleStep());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getScaleThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScaleThresh());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_getXi(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getXi());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setAngleEpsilon(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double angleEpsilon=0;

    const char* keywords[] = { "angleEpsilon", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHoughGuil.setAngleEpsilon", (char**)keywords, &angleEpsilon) )
    {
        ERRWRAP2(_self_->setAngleEpsilon(angleEpsilon));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setAngleStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double angleStep=0;

    const char* keywords[] = { "angleStep", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHoughGuil.setAngleStep", (char**)keywords, &angleStep) )
    {
        ERRWRAP2(_self_->setAngleStep(angleStep));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setAngleThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int angleThresh=0;

    const char* keywords[] = { "angleThresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHoughGuil.setAngleThresh", (char**)keywords, &angleThresh) )
    {
        ERRWRAP2(_self_->setAngleThresh(angleThresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int levels=0;

    const char* keywords[] = { "levels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHoughGuil.setLevels", (char**)keywords, &levels) )
    {
        ERRWRAP2(_self_->setLevels(levels));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setMaxAngle(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double maxAngle=0;

    const char* keywords[] = { "maxAngle", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHoughGuil.setMaxAngle", (char**)keywords, &maxAngle) )
    {
        ERRWRAP2(_self_->setMaxAngle(maxAngle));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setMaxScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double maxScale=0;

    const char* keywords[] = { "maxScale", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHoughGuil.setMaxScale", (char**)keywords, &maxScale) )
    {
        ERRWRAP2(_self_->setMaxScale(maxScale));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setMinAngle(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double minAngle=0;

    const char* keywords[] = { "minAngle", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHoughGuil.setMinAngle", (char**)keywords, &minAngle) )
    {
        ERRWRAP2(_self_->setMinAngle(minAngle));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setMinScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double minScale=0;

    const char* keywords[] = { "minScale", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHoughGuil.setMinScale", (char**)keywords, &minScale) )
    {
        ERRWRAP2(_self_->setMinScale(minScale));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setPosThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int posThresh=0;

    const char* keywords[] = { "posThresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHoughGuil.setPosThresh", (char**)keywords, &posThresh) )
    {
        ERRWRAP2(_self_->setPosThresh(posThresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setScaleStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double scaleStep=0;

    const char* keywords[] = { "scaleStep", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHoughGuil.setScaleStep", (char**)keywords, &scaleStep) )
    {
        ERRWRAP2(_self_->setScaleStep(scaleStep));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setScaleThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    int scaleThresh=0;

    const char* keywords[] = { "scaleThresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GeneralizedHoughGuil.setScaleThresh", (char**)keywords, &scaleThresh) )
    {
        ERRWRAP2(_self_->setScaleThresh(scaleThresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_GeneralizedHoughGuil_setXi(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::GeneralizedHoughGuil> * self1 = 0;
    if (!pyopencv_GeneralizedHoughGuil_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'GeneralizedHoughGuil' or its derivative)");
    Ptr<cv::GeneralizedHoughGuil> _self_ = *(self1);
    double xi=0;

    const char* keywords[] = { "xi", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:GeneralizedHoughGuil.setXi", (char**)keywords, &xi) )
    {
        ERRWRAP2(_self_->setXi(xi));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (GeneralizedHoughGuil)

static PyGetSetDef pyopencv_GeneralizedHoughGuil_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_GeneralizedHoughGuil_methods[] =
{
    {"getAngleEpsilon", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getAngleEpsilon, 0), "getAngleEpsilon() -> retval\n."},
    {"getAngleStep", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getAngleStep, 0), "getAngleStep() -> retval\n."},
    {"getAngleThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getAngleThresh, 0), "getAngleThresh() -> retval\n."},
    {"getLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getLevels, 0), "getLevels() -> retval\n."},
    {"getMaxAngle", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getMaxAngle, 0), "getMaxAngle() -> retval\n."},
    {"getMaxScale", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getMaxScale, 0), "getMaxScale() -> retval\n."},
    {"getMinAngle", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getMinAngle, 0), "getMinAngle() -> retval\n."},
    {"getMinScale", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getMinScale, 0), "getMinScale() -> retval\n."},
    {"getPosThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getPosThresh, 0), "getPosThresh() -> retval\n."},
    {"getScaleStep", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getScaleStep, 0), "getScaleStep() -> retval\n."},
    {"getScaleThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getScaleThresh, 0), "getScaleThresh() -> retval\n."},
    {"getXi", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_getXi, 0), "getXi() -> retval\n."},
    {"setAngleEpsilon", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setAngleEpsilon, 0), "setAngleEpsilon(angleEpsilon) -> None\n."},
    {"setAngleStep", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setAngleStep, 0), "setAngleStep(angleStep) -> None\n."},
    {"setAngleThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setAngleThresh, 0), "setAngleThresh(angleThresh) -> None\n."},
    {"setLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setLevels, 0), "setLevels(levels) -> None\n."},
    {"setMaxAngle", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setMaxAngle, 0), "setMaxAngle(maxAngle) -> None\n."},
    {"setMaxScale", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setMaxScale, 0), "setMaxScale(maxScale) -> None\n."},
    {"setMinAngle", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setMinAngle, 0), "setMinAngle(minAngle) -> None\n."},
    {"setMinScale", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setMinScale, 0), "setMinScale(minScale) -> None\n."},
    {"setPosThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setPosThresh, 0), "setPosThresh(posThresh) -> None\n."},
    {"setScaleStep", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setScaleStep, 0), "setScaleStep(scaleStep) -> None\n."},
    {"setScaleThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setScaleThresh, 0), "setScaleThresh(scaleThresh) -> None\n."},
    {"setXi", CV_PY_FN_WITH_KW_(pyopencv_cv_GeneralizedHoughGuil_setXi, 0), "setXi(xi) -> None\n."},

    {NULL,          NULL}
};

// Converter (GeneralizedHoughGuil)

template<>
struct PyOpenCV_Converter< Ptr<cv::GeneralizedHoughGuil> >
{
    static PyObject* from(const Ptr<cv::GeneralizedHoughGuil>& r)
    {
        return pyopencv_GeneralizedHoughGuil_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::GeneralizedHoughGuil>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::GeneralizedHoughGuil> * dst_;
        if (pyopencv_GeneralizedHoughGuil_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::GeneralizedHoughGuil> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// HOGDescriptor (Generic)
//================================================================================

// GetSet (HOGDescriptor)


static PyObject* pyopencv_HOGDescriptor_get_L2HysThreshold(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->L2HysThreshold);
}

static PyObject* pyopencv_HOGDescriptor_get_blockSize(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->blockSize);
}

static PyObject* pyopencv_HOGDescriptor_get_blockStride(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->blockStride);
}

static PyObject* pyopencv_HOGDescriptor_get_cellSize(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->cellSize);
}

static PyObject* pyopencv_HOGDescriptor_get_derivAperture(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->derivAperture);
}

static PyObject* pyopencv_HOGDescriptor_get_gammaCorrection(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->gammaCorrection);
}

static PyObject* pyopencv_HOGDescriptor_get_histogramNormType(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->histogramNormType);
}

static PyObject* pyopencv_HOGDescriptor_get_nbins(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->nbins);
}

static PyObject* pyopencv_HOGDescriptor_get_nlevels(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->nlevels);
}

static PyObject* pyopencv_HOGDescriptor_get_signedGradient(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->signedGradient);
}

static PyObject* pyopencv_HOGDescriptor_get_svmDetector(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->svmDetector);
}

static PyObject* pyopencv_HOGDescriptor_get_winSigma(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->winSigma);
}

static PyObject* pyopencv_HOGDescriptor_get_winSize(pyopencv_HOGDescriptor_t* p, void *closure)
{
    return pyopencv_from(p->v->winSize);
}


// Methods (HOGDescriptor)

static int pyopencv_cv_HOGDescriptor_HOGDescriptor(pyopencv_HOGDescriptor_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::HOGDescriptor>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::HOGDescriptor()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__winSize = NULL;
    Size _winSize;
    PyObject* pyobj__blockSize = NULL;
    Size _blockSize;
    PyObject* pyobj__blockStride = NULL;
    Size _blockStride;
    PyObject* pyobj__cellSize = NULL;
    Size _cellSize;
    int _nbins=0;
    int _derivAperture=1;
    double _winSigma=-1;
    PyObject* pyobj__histogramNormType = NULL;
    HOGDescriptor_HistogramNormType _histogramNormType=HOGDescriptor::L2Hys;
    double _L2HysThreshold=0.2;
    bool _gammaCorrection=false;
    int _nlevels=HOGDescriptor::DEFAULT_NLEVELS;
    bool _signedGradient=false;

    const char* keywords[] = { "_winSize", "_blockSize", "_blockStride", "_cellSize", "_nbins", "_derivAperture", "_winSigma", "_histogramNormType", "_L2HysThreshold", "_gammaCorrection", "_nlevels", "_signedGradient", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOOi|idOdbib:HOGDescriptor", (char**)keywords, &pyobj__winSize, &pyobj__blockSize, &pyobj__blockStride, &pyobj__cellSize, &_nbins, &_derivAperture, &_winSigma, &pyobj__histogramNormType, &_L2HysThreshold, &_gammaCorrection, &_nlevels, &_signedGradient) &&
        pyopencv_to(pyobj__winSize, _winSize, ArgInfo("_winSize", 0)) &&
        pyopencv_to(pyobj__blockSize, _blockSize, ArgInfo("_blockSize", 0)) &&
        pyopencv_to(pyobj__blockStride, _blockStride, ArgInfo("_blockStride", 0)) &&
        pyopencv_to(pyobj__cellSize, _cellSize, ArgInfo("_cellSize", 0)) &&
        pyopencv_to(pyobj__histogramNormType, _histogramNormType, ArgInfo("_histogramNormType", 0)) )
    {
        new (&(self->v)) Ptr<cv::HOGDescriptor>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::HOGDescriptor(_winSize, _blockSize, _blockStride, _cellSize, _nbins, _derivAperture, _winSigma, _histogramNormType, _L2HysThreshold, _gammaCorrection, _nlevels, _signedGradient)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;

    const char* keywords[] = { "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:HOGDescriptor", (char**)keywords, &pyobj_filename) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        new (&(self->v)) Ptr<cv::HOGDescriptor>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::HOGDescriptor(filename)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_HOGDescriptor_checkDetectorSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->checkDetectorSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    vector_float descriptors;
    PyObject* pyobj_winStride = NULL;
    Size winStride;
    PyObject* pyobj_padding = NULL;
    Size padding;
    PyObject* pyobj_locations = NULL;
    vector_Point locations=std::vector<Point>();

    const char* keywords[] = { "img", "winStride", "padding", "locations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:HOGDescriptor.compute", (char**)keywords, &pyobj_img, &pyobj_winStride, &pyobj_padding, &pyobj_locations) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_winStride, winStride, ArgInfo("winStride", 0)) &&
        pyopencv_to(pyobj_padding, padding, ArgInfo("padding", 0)) &&
        pyopencv_to(pyobj_locations, locations, ArgInfo("locations", 0)) )
    {
        ERRWRAP2(_self_->compute(img, descriptors, winStride, padding, locations));
        return pyopencv_from(descriptors);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    vector_float descriptors;
    PyObject* pyobj_winStride = NULL;
    Size winStride;
    PyObject* pyobj_padding = NULL;
    Size padding;
    PyObject* pyobj_locations = NULL;
    vector_Point locations=std::vector<Point>();

    const char* keywords[] = { "img", "winStride", "padding", "locations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:HOGDescriptor.compute", (char**)keywords, &pyobj_img, &pyobj_winStride, &pyobj_padding, &pyobj_locations) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_winStride, winStride, ArgInfo("winStride", 0)) &&
        pyopencv_to(pyobj_padding, padding, ArgInfo("padding", 0)) &&
        pyopencv_to(pyobj_locations, locations, ArgInfo("locations", 0)) )
    {
        ERRWRAP2(_self_->compute(img, descriptors, winStride, padding, locations));
        return pyopencv_from(descriptors);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_computeGradient(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_grad = NULL;
    Mat grad;
    PyObject* pyobj_angleOfs = NULL;
    Mat angleOfs;
    PyObject* pyobj_paddingTL = NULL;
    Size paddingTL;
    PyObject* pyobj_paddingBR = NULL;
    Size paddingBR;

    const char* keywords[] = { "img", "grad", "angleOfs", "paddingTL", "paddingBR", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:HOGDescriptor.computeGradient", (char**)keywords, &pyobj_img, &pyobj_grad, &pyobj_angleOfs, &pyobj_paddingTL, &pyobj_paddingBR) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_grad, grad, ArgInfo("grad", 1)) &&
        pyopencv_to(pyobj_angleOfs, angleOfs, ArgInfo("angleOfs", 1)) &&
        pyopencv_to(pyobj_paddingTL, paddingTL, ArgInfo("paddingTL", 0)) &&
        pyopencv_to(pyobj_paddingBR, paddingBR, ArgInfo("paddingBR", 0)) )
    {
        ERRWRAP2(_self_->computeGradient(img, grad, angleOfs, paddingTL, paddingBR));
        return Py_BuildValue("(NN)", pyopencv_from(grad), pyopencv_from(angleOfs));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_grad = NULL;
    UMat grad;
    PyObject* pyobj_angleOfs = NULL;
    UMat angleOfs;
    PyObject* pyobj_paddingTL = NULL;
    Size paddingTL;
    PyObject* pyobj_paddingBR = NULL;
    Size paddingBR;

    const char* keywords[] = { "img", "grad", "angleOfs", "paddingTL", "paddingBR", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:HOGDescriptor.computeGradient", (char**)keywords, &pyobj_img, &pyobj_grad, &pyobj_angleOfs, &pyobj_paddingTL, &pyobj_paddingBR) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_grad, grad, ArgInfo("grad", 1)) &&
        pyopencv_to(pyobj_angleOfs, angleOfs, ArgInfo("angleOfs", 1)) &&
        pyopencv_to(pyobj_paddingTL, paddingTL, ArgInfo("paddingTL", 0)) &&
        pyopencv_to(pyobj_paddingBR, paddingBR, ArgInfo("paddingBR", 0)) )
    {
        ERRWRAP2(_self_->computeGradient(img, grad, angleOfs, paddingTL, paddingBR));
        return Py_BuildValue("(NN)", pyopencv_from(grad), pyopencv_from(angleOfs));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    vector_Point foundLocations;
    vector_double weights;
    double hitThreshold=0;
    PyObject* pyobj_winStride = NULL;
    Size winStride;
    PyObject* pyobj_padding = NULL;
    Size padding;
    PyObject* pyobj_searchLocations = NULL;
    vector_Point searchLocations=std::vector<Point>();

    const char* keywords[] = { "img", "hitThreshold", "winStride", "padding", "searchLocations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|dOOO:HOGDescriptor.detect", (char**)keywords, &pyobj_img, &hitThreshold, &pyobj_winStride, &pyobj_padding, &pyobj_searchLocations) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_winStride, winStride, ArgInfo("winStride", 0)) &&
        pyopencv_to(pyobj_padding, padding, ArgInfo("padding", 0)) &&
        pyopencv_to(pyobj_searchLocations, searchLocations, ArgInfo("searchLocations", 0)) )
    {
        ERRWRAP2(_self_->detect(img, foundLocations, weights, hitThreshold, winStride, padding, searchLocations));
        return Py_BuildValue("(NN)", pyopencv_from(foundLocations), pyopencv_from(weights));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    vector_Point foundLocations;
    vector_double weights;
    double hitThreshold=0;
    PyObject* pyobj_winStride = NULL;
    Size winStride;
    PyObject* pyobj_padding = NULL;
    Size padding;
    PyObject* pyobj_searchLocations = NULL;
    vector_Point searchLocations=std::vector<Point>();

    const char* keywords[] = { "img", "hitThreshold", "winStride", "padding", "searchLocations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|dOOO:HOGDescriptor.detect", (char**)keywords, &pyobj_img, &hitThreshold, &pyobj_winStride, &pyobj_padding, &pyobj_searchLocations) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_winStride, winStride, ArgInfo("winStride", 0)) &&
        pyopencv_to(pyobj_padding, padding, ArgInfo("padding", 0)) &&
        pyopencv_to(pyobj_searchLocations, searchLocations, ArgInfo("searchLocations", 0)) )
    {
        ERRWRAP2(_self_->detect(img, foundLocations, weights, hitThreshold, winStride, padding, searchLocations));
        return Py_BuildValue("(NN)", pyopencv_from(foundLocations), pyopencv_from(weights));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_detectMultiScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    vector_Rect foundLocations;
    vector_double foundWeights;
    double hitThreshold=0;
    PyObject* pyobj_winStride = NULL;
    Size winStride;
    PyObject* pyobj_padding = NULL;
    Size padding;
    double scale=1.05;
    double finalThreshold=2.0;
    bool useMeanshiftGrouping=false;

    const char* keywords[] = { "img", "hitThreshold", "winStride", "padding", "scale", "finalThreshold", "useMeanshiftGrouping", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|dOOddb:HOGDescriptor.detectMultiScale", (char**)keywords, &pyobj_img, &hitThreshold, &pyobj_winStride, &pyobj_padding, &scale, &finalThreshold, &useMeanshiftGrouping) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_winStride, winStride, ArgInfo("winStride", 0)) &&
        pyopencv_to(pyobj_padding, padding, ArgInfo("padding", 0)) )
    {
        ERRWRAP2(_self_->detectMultiScale(img, foundLocations, foundWeights, hitThreshold, winStride, padding, scale, finalThreshold, useMeanshiftGrouping));
        return Py_BuildValue("(NN)", pyopencv_from(foundLocations), pyopencv_from(foundWeights));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    vector_Rect foundLocations;
    vector_double foundWeights;
    double hitThreshold=0;
    PyObject* pyobj_winStride = NULL;
    Size winStride;
    PyObject* pyobj_padding = NULL;
    Size padding;
    double scale=1.05;
    double finalThreshold=2.0;
    bool useMeanshiftGrouping=false;

    const char* keywords[] = { "img", "hitThreshold", "winStride", "padding", "scale", "finalThreshold", "useMeanshiftGrouping", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|dOOddb:HOGDescriptor.detectMultiScale", (char**)keywords, &pyobj_img, &hitThreshold, &pyobj_winStride, &pyobj_padding, &scale, &finalThreshold, &useMeanshiftGrouping) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_winStride, winStride, ArgInfo("winStride", 0)) &&
        pyopencv_to(pyobj_padding, padding, ArgInfo("padding", 0)) )
    {
        ERRWRAP2(_self_->detectMultiScale(img, foundLocations, foundWeights, hitThreshold, winStride, padding, scale, finalThreshold, useMeanshiftGrouping));
        return Py_BuildValue("(NN)", pyopencv_from(foundLocations), pyopencv_from(foundWeights));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_getDaimlerPeopleDetector_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    std::vector<float> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::HOGDescriptor::getDaimlerPeopleDetector());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_getDefaultPeopleDetector_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    std::vector<float> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::HOGDescriptor::getDefaultPeopleDetector());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_getDescriptorSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDescriptorSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_getWinSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWinSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_load(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    PyObject* pyobj_filename = NULL;
    String filename;
    PyObject* pyobj_objname = NULL;
    String objname;
    bool retval;

    const char* keywords[] = { "filename", "objname", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:HOGDescriptor.load", (char**)keywords, &pyobj_filename, &pyobj_objname) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_objname, objname, ArgInfo("objname", 0)) )
    {
        ERRWRAP2(retval = _self_->load(filename, objname));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_save(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    PyObject* pyobj_filename = NULL;
    String filename;
    PyObject* pyobj_objname = NULL;
    String objname;

    const char* keywords[] = { "filename", "objname", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:HOGDescriptor.save", (char**)keywords, &pyobj_filename, &pyobj_objname) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_objname, objname, ArgInfo("objname", 0)) )
    {
        ERRWRAP2(_self_->save(filename, objname));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_HOGDescriptor_setSVMDetector(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HOGDescriptor> * self1 = 0;
    if (!pyopencv_HOGDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HOGDescriptor' or its derivative)");
    Ptr<cv::HOGDescriptor> _self_ = *(self1);
    {
    PyObject* pyobj_svmdetector = NULL;
    Mat svmdetector;

    const char* keywords[] = { "svmdetector", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:HOGDescriptor.setSVMDetector", (char**)keywords, &pyobj_svmdetector) &&
        pyopencv_to(pyobj_svmdetector, svmdetector, ArgInfo("svmdetector", 0)) )
    {
        ERRWRAP2(_self_->setSVMDetector(svmdetector));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_svmdetector = NULL;
    UMat svmdetector;

    const char* keywords[] = { "svmdetector", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:HOGDescriptor.setSVMDetector", (char**)keywords, &pyobj_svmdetector) &&
        pyopencv_to(pyobj_svmdetector, svmdetector, ArgInfo("svmdetector", 0)) )
    {
        ERRWRAP2(_self_->setSVMDetector(svmdetector));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (HOGDescriptor)

static PyGetSetDef pyopencv_HOGDescriptor_getseters[] =
{
    {(char*)"L2HysThreshold", (getter)pyopencv_HOGDescriptor_get_L2HysThreshold, NULL, (char*)"L2HysThreshold", NULL},
    {(char*)"blockSize", (getter)pyopencv_HOGDescriptor_get_blockSize, NULL, (char*)"blockSize", NULL},
    {(char*)"blockStride", (getter)pyopencv_HOGDescriptor_get_blockStride, NULL, (char*)"blockStride", NULL},
    {(char*)"cellSize", (getter)pyopencv_HOGDescriptor_get_cellSize, NULL, (char*)"cellSize", NULL},
    {(char*)"derivAperture", (getter)pyopencv_HOGDescriptor_get_derivAperture, NULL, (char*)"derivAperture", NULL},
    {(char*)"gammaCorrection", (getter)pyopencv_HOGDescriptor_get_gammaCorrection, NULL, (char*)"gammaCorrection", NULL},
    {(char*)"histogramNormType", (getter)pyopencv_HOGDescriptor_get_histogramNormType, NULL, (char*)"histogramNormType", NULL},
    {(char*)"nbins", (getter)pyopencv_HOGDescriptor_get_nbins, NULL, (char*)"nbins", NULL},
    {(char*)"nlevels", (getter)pyopencv_HOGDescriptor_get_nlevels, NULL, (char*)"nlevels", NULL},
    {(char*)"signedGradient", (getter)pyopencv_HOGDescriptor_get_signedGradient, NULL, (char*)"signedGradient", NULL},
    {(char*)"svmDetector", (getter)pyopencv_HOGDescriptor_get_svmDetector, NULL, (char*)"svmDetector", NULL},
    {(char*)"winSigma", (getter)pyopencv_HOGDescriptor_get_winSigma, NULL, (char*)"winSigma", NULL},
    {(char*)"winSize", (getter)pyopencv_HOGDescriptor_get_winSize, NULL, (char*)"winSize", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_HOGDescriptor_methods[] =
{
    {"checkDetectorSize", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_checkDetectorSize, 0), "checkDetectorSize() -> retval\n.   @brief Checks if detector size equal to descriptor size."},
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_compute, 0), "compute(img[, winStride[, padding[, locations]]]) -> descriptors\n.   @brief Computes HOG descriptors of given image.\n.       @param img Matrix of the type CV_8U containing an image where HOG features will be calculated.\n.       @param descriptors Matrix of the type CV_32F\n.       @param winStride Window stride. It must be a multiple of block stride.\n.       @param padding Padding\n.       @param locations Vector of Point"},
    {"computeGradient", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_computeGradient, 0), "computeGradient(img, grad, angleOfs[, paddingTL[, paddingBR]]) -> grad, angleOfs\n.   @brief  Computes gradients and quantized gradient orientations.\n.       @param img Matrix contains the image to be computed\n.       @param grad Matrix of type CV_32FC2 contains computed gradients\n.       @param angleOfs Matrix of type CV_8UC2 contains quantized gradient orientations\n.       @param paddingTL Padding from top-left\n.       @param paddingBR Padding from bottom-right"},
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_detect, 0), "detect(img[, hitThreshold[, winStride[, padding[, searchLocations]]]]) -> foundLocations, weights\n.   @brief Performs object detection without a multi-scale window.\n.       @param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n.       @param foundLocations Vector of point where each point contains left-top corner point of detected object boundaries.\n.       @param weights Vector that will contain confidence values for each detected object.\n.       @param hitThreshold Threshold for the distance between features and SVM classifying plane.\n.       Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient).\n.       But if the free coefficient is omitted (which is allowed), you can specify it manually here.\n.       @param winStride Window stride. It must be a multiple of block stride.\n.       @param padding Padding\n.       @param searchLocations Vector of Point includes set of requested locations to be evaluated."},
    {"detectMultiScale", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_detectMultiScale, 0), "detectMultiScale(img[, hitThreshold[, winStride[, padding[, scale[, finalThreshold[, useMeanshiftGrouping]]]]]]) -> foundLocations, foundWeights\n.   @brief Detects objects of different sizes in the input image. The detected objects are returned as a list\n.       of rectangles.\n.       @param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n.       @param foundLocations Vector of rectangles where each rectangle contains the detected object.\n.       @param foundWeights Vector that will contain confidence values for each detected object.\n.       @param hitThreshold Threshold for the distance between features and SVM classifying plane.\n.       Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient).\n.       But if the free coefficient is omitted (which is allowed), you can specify it manually here.\n.       @param winStride Window stride. It must be a multiple of block stride.\n.       @param padding Padding\n.       @param scale Coefficient of the detection window increase.\n.       @param finalThreshold Final threshold\n.       @param useMeanshiftGrouping indicates grouping algorithm"},
    {"getDaimlerPeopleDetector", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_getDaimlerPeopleDetector_static, METH_STATIC), "getDaimlerPeopleDetector() -> retval\n.   @brief Returns coefficients of the classifier trained for people detection (for 48x96 windows)."},
    {"getDefaultPeopleDetector", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_getDefaultPeopleDetector_static, METH_STATIC), "getDefaultPeopleDetector() -> retval\n.   @brief Returns coefficients of the classifier trained for people detection (for 64x128 windows)."},
    {"getDescriptorSize", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_getDescriptorSize, 0), "getDescriptorSize() -> retval\n.   @brief Returns the number of coefficients required for the classification."},
    {"getWinSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_getWinSigma, 0), "getWinSigma() -> retval\n.   @brief Returns winSigma value"},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_load, 0), "load(filename[, objname]) -> retval\n.   @brief loads HOGDescriptor parameters and coefficients for the linear SVM classifier from a file.\n.       @param filename Path of the file to read.\n.       @param objname The optional name of the node to read (if empty, the first top-level node will be used)."},
    {"save", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_save, 0), "save(filename[, objname]) -> None\n.   @brief saves HOGDescriptor parameters and coefficients for the linear SVM classifier to a file\n.       @param filename File name\n.       @param objname Object name"},
    {"setSVMDetector", CV_PY_FN_WITH_KW_(pyopencv_cv_HOGDescriptor_setSVMDetector, 0), "setSVMDetector(svmdetector) -> None\n.   @brief Sets coefficients for the linear SVM classifier.\n.       @param svmdetector coefficients for the linear SVM classifier."},

    {NULL,          NULL}
};

// Converter (HOGDescriptor)

template<>
struct PyOpenCV_Converter< Ptr<cv::HOGDescriptor> >
{
    static PyObject* from(const Ptr<cv::HOGDescriptor>& r)
    {
        return pyopencv_HOGDescriptor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::HOGDescriptor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::HOGDescriptor> * dst_;
        if (pyopencv_HOGDescriptor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::HOGDescriptor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// HausdorffDistanceExtractor (Generic)
//================================================================================

// GetSet (HausdorffDistanceExtractor)



// Methods (HausdorffDistanceExtractor)

static PyObject* pyopencv_cv_HausdorffDistanceExtractor_getDistanceFlag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HausdorffDistanceExtractor> * self1 = 0;
    if (!pyopencv_HausdorffDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HausdorffDistanceExtractor' or its derivative)");
    Ptr<cv::HausdorffDistanceExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDistanceFlag());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HausdorffDistanceExtractor_getRankProportion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HausdorffDistanceExtractor> * self1 = 0;
    if (!pyopencv_HausdorffDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HausdorffDistanceExtractor' or its derivative)");
    Ptr<cv::HausdorffDistanceExtractor> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRankProportion());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HausdorffDistanceExtractor_setDistanceFlag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HausdorffDistanceExtractor> * self1 = 0;
    if (!pyopencv_HausdorffDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HausdorffDistanceExtractor' or its derivative)");
    Ptr<cv::HausdorffDistanceExtractor> _self_ = *(self1);
    int distanceFlag=0;

    const char* keywords[] = { "distanceFlag", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:HausdorffDistanceExtractor.setDistanceFlag", (char**)keywords, &distanceFlag) )
    {
        ERRWRAP2(_self_->setDistanceFlag(distanceFlag));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_HausdorffDistanceExtractor_setRankProportion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HausdorffDistanceExtractor> * self1 = 0;
    if (!pyopencv_HausdorffDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HausdorffDistanceExtractor' or its derivative)");
    Ptr<cv::HausdorffDistanceExtractor> _self_ = *(self1);
    float rankProportion=0.f;

    const char* keywords[] = { "rankProportion", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:HausdorffDistanceExtractor.setRankProportion", (char**)keywords, &rankProportion) )
    {
        ERRWRAP2(_self_->setRankProportion(rankProportion));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (HausdorffDistanceExtractor)

static PyGetSetDef pyopencv_HausdorffDistanceExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_HausdorffDistanceExtractor_methods[] =
{
    {"getDistanceFlag", CV_PY_FN_WITH_KW_(pyopencv_cv_HausdorffDistanceExtractor_getDistanceFlag, 0), "getDistanceFlag() -> retval\n."},
    {"getRankProportion", CV_PY_FN_WITH_KW_(pyopencv_cv_HausdorffDistanceExtractor_getRankProportion, 0), "getRankProportion() -> retval\n."},
    {"setDistanceFlag", CV_PY_FN_WITH_KW_(pyopencv_cv_HausdorffDistanceExtractor_setDistanceFlag, 0), "setDistanceFlag(distanceFlag) -> None\n.   @brief Set the norm used to compute the Hausdorff value between two shapes. It can be L1 or L2 norm.\n.   \n.       @param distanceFlag Flag indicating which norm is used to compute the Hausdorff distance\n.       (NORM_L1, NORM_L2)."},
    {"setRankProportion", CV_PY_FN_WITH_KW_(pyopencv_cv_HausdorffDistanceExtractor_setRankProportion, 0), "setRankProportion(rankProportion) -> None\n.   @brief This method sets the rank proportion (or fractional value) that establish the Kth ranked value of\n.       the partial Hausdorff distance. Experimentally had been shown that 0.6 is a good value to compare\n.       shapes.\n.   \n.       @param rankProportion fractional value (between 0 and 1)."},

    {NULL,          NULL}
};

// Converter (HausdorffDistanceExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::HausdorffDistanceExtractor> >
{
    static PyObject* from(const Ptr<cv::HausdorffDistanceExtractor>& r)
    {
        return pyopencv_HausdorffDistanceExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::HausdorffDistanceExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::HausdorffDistanceExtractor> * dst_;
        if (pyopencv_HausdorffDistanceExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::HausdorffDistanceExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// HistogramCostExtractor (Generic)
//================================================================================

// GetSet (HistogramCostExtractor)



// Methods (HistogramCostExtractor)

static PyObject* pyopencv_cv_HistogramCostExtractor_buildCostMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HistogramCostExtractor> * self1 = 0;
    if (!pyopencv_HistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HistogramCostExtractor' or its derivative)");
    Ptr<cv::HistogramCostExtractor> _self_ = *(self1);
    {
    PyObject* pyobj_descriptors1 = NULL;
    Mat descriptors1;
    PyObject* pyobj_descriptors2 = NULL;
    Mat descriptors2;
    PyObject* pyobj_costMatrix = NULL;
    Mat costMatrix;

    const char* keywords[] = { "descriptors1", "descriptors2", "costMatrix", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:HistogramCostExtractor.buildCostMatrix", (char**)keywords, &pyobj_descriptors1, &pyobj_descriptors2, &pyobj_costMatrix) &&
        pyopencv_to(pyobj_descriptors1, descriptors1, ArgInfo("descriptors1", 0)) &&
        pyopencv_to(pyobj_descriptors2, descriptors2, ArgInfo("descriptors2", 0)) &&
        pyopencv_to(pyobj_costMatrix, costMatrix, ArgInfo("costMatrix", 1)) )
    {
        ERRWRAP2(_self_->buildCostMatrix(descriptors1, descriptors2, costMatrix));
        return pyopencv_from(costMatrix);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_descriptors1 = NULL;
    UMat descriptors1;
    PyObject* pyobj_descriptors2 = NULL;
    UMat descriptors2;
    PyObject* pyobj_costMatrix = NULL;
    UMat costMatrix;

    const char* keywords[] = { "descriptors1", "descriptors2", "costMatrix", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:HistogramCostExtractor.buildCostMatrix", (char**)keywords, &pyobj_descriptors1, &pyobj_descriptors2, &pyobj_costMatrix) &&
        pyopencv_to(pyobj_descriptors1, descriptors1, ArgInfo("descriptors1", 0)) &&
        pyopencv_to(pyobj_descriptors2, descriptors2, ArgInfo("descriptors2", 0)) &&
        pyopencv_to(pyobj_costMatrix, costMatrix, ArgInfo("costMatrix", 1)) )
    {
        ERRWRAP2(_self_->buildCostMatrix(descriptors1, descriptors2, costMatrix));
        return pyopencv_from(costMatrix);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_HistogramCostExtractor_getDefaultCost(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HistogramCostExtractor> * self1 = 0;
    if (!pyopencv_HistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HistogramCostExtractor' or its derivative)");
    Ptr<cv::HistogramCostExtractor> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultCost());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HistogramCostExtractor_getNDummies(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HistogramCostExtractor> * self1 = 0;
    if (!pyopencv_HistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HistogramCostExtractor' or its derivative)");
    Ptr<cv::HistogramCostExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNDummies());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_HistogramCostExtractor_setDefaultCost(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HistogramCostExtractor> * self1 = 0;
    if (!pyopencv_HistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HistogramCostExtractor' or its derivative)");
    Ptr<cv::HistogramCostExtractor> _self_ = *(self1);
    float defaultCost=0.f;

    const char* keywords[] = { "defaultCost", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:HistogramCostExtractor.setDefaultCost", (char**)keywords, &defaultCost) )
    {
        ERRWRAP2(_self_->setDefaultCost(defaultCost));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_HistogramCostExtractor_setNDummies(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::HistogramCostExtractor> * self1 = 0;
    if (!pyopencv_HistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'HistogramCostExtractor' or its derivative)");
    Ptr<cv::HistogramCostExtractor> _self_ = *(self1);
    int nDummies=0;

    const char* keywords[] = { "nDummies", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:HistogramCostExtractor.setNDummies", (char**)keywords, &nDummies) )
    {
        ERRWRAP2(_self_->setNDummies(nDummies));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (HistogramCostExtractor)

static PyGetSetDef pyopencv_HistogramCostExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_HistogramCostExtractor_methods[] =
{
    {"buildCostMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_HistogramCostExtractor_buildCostMatrix, 0), "buildCostMatrix(descriptors1, descriptors2[, costMatrix]) -> costMatrix\n."},
    {"getDefaultCost", CV_PY_FN_WITH_KW_(pyopencv_cv_HistogramCostExtractor_getDefaultCost, 0), "getDefaultCost() -> retval\n."},
    {"getNDummies", CV_PY_FN_WITH_KW_(pyopencv_cv_HistogramCostExtractor_getNDummies, 0), "getNDummies() -> retval\n."},
    {"setDefaultCost", CV_PY_FN_WITH_KW_(pyopencv_cv_HistogramCostExtractor_setDefaultCost, 0), "setDefaultCost(defaultCost) -> None\n."},
    {"setNDummies", CV_PY_FN_WITH_KW_(pyopencv_cv_HistogramCostExtractor_setNDummies, 0), "setNDummies(nDummies) -> None\n."},

    {NULL,          NULL}
};

// Converter (HistogramCostExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::HistogramCostExtractor> >
{
    static PyObject* from(const Ptr<cv::HistogramCostExtractor>& r)
    {
        return pyopencv_HistogramCostExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::HistogramCostExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::HistogramCostExtractor> * dst_;
        if (pyopencv_HistogramCostExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::HistogramCostExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// KAZE (Generic)
//================================================================================

// GetSet (KAZE)



// Methods (KAZE)

static PyObject* pyopencv_cv_KAZE_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    bool extended=false;
    bool upright=false;
    float threshold=0.001f;
    int nOctaves=4;
    int nOctaveLayers=4;
    PyObject* pyobj_diffusivity = NULL;
    KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2;
    Ptr<KAZE> retval;

    const char* keywords[] = { "extended", "upright", "threshold", "nOctaves", "nOctaveLayers", "diffusivity", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|bbfiiO:KAZE.create", (char**)keywords, &extended, &upright, &threshold, &nOctaves, &nOctaveLayers, &pyobj_diffusivity) &&
        pyopencv_to(pyobj_diffusivity, diffusivity, ArgInfo("diffusivity", 0)) )
    {
        ERRWRAP2(retval = cv::KAZE::create(extended, upright, threshold, nOctaves, nOctaveLayers, diffusivity));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_getDiffusivity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    KAZE::DiffusivityType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDiffusivity());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_getExtended(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getExtended());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_getNOctaveLayers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNOctaveLayers());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_getNOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNOctaves());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_getUpright(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUpright());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_setDiffusivity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    PyObject* pyobj_diff = NULL;
    KAZE_DiffusivityType diff=static_cast<KAZE_DiffusivityType>(0);

    const char* keywords[] = { "diff", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:KAZE.setDiffusivity", (char**)keywords, &pyobj_diff) &&
        pyopencv_to(pyobj_diff, diff, ArgInfo("diff", 0)) )
    {
        ERRWRAP2(_self_->setDiffusivity(diff));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_setExtended(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    bool extended=0;

    const char* keywords[] = { "extended", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:KAZE.setExtended", (char**)keywords, &extended) )
    {
        ERRWRAP2(_self_->setExtended(extended));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_setNOctaveLayers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    int octaveLayers=0;

    const char* keywords[] = { "octaveLayers", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:KAZE.setNOctaveLayers", (char**)keywords, &octaveLayers) )
    {
        ERRWRAP2(_self_->setNOctaveLayers(octaveLayers));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_setNOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    int octaves=0;

    const char* keywords[] = { "octaves", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:KAZE.setNOctaves", (char**)keywords, &octaves) )
    {
        ERRWRAP2(_self_->setNOctaves(octaves));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    double threshold=0;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:KAZE.setThreshold", (char**)keywords, &threshold) )
    {
        ERRWRAP2(_self_->setThreshold(threshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_KAZE_setUpright(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KAZE> * self1 = 0;
    if (!pyopencv_KAZE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KAZE' or its derivative)");
    Ptr<cv::KAZE> _self_ = *(self1);
    bool upright=0;

    const char* keywords[] = { "upright", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:KAZE.setUpright", (char**)keywords, &upright) )
    {
        ERRWRAP2(_self_->setUpright(upright));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (KAZE)

static PyGetSetDef pyopencv_KAZE_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_KAZE_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_create_static, METH_STATIC), "create([, extended[, upright[, threshold[, nOctaves[, nOctaveLayers[, diffusivity]]]]]]) -> retval\n.   @brief The KAZE constructor\n.   \n.       @param extended Set to enable extraction of extended (128-byte) descriptor.\n.       @param upright Set to enable use of upright descriptors (non rotation-invariant).\n.       @param threshold Detector response threshold to accept point\n.       @param nOctaves Maximum octave evolution of the image\n.       @param nOctaveLayers Default number of sublevels per scale level\n.       @param diffusivity Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or\n.       DIFF_CHARBONNIER"},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"getDiffusivity", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_getDiffusivity, 0), "getDiffusivity() -> retval\n."},
    {"getExtended", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_getExtended, 0), "getExtended() -> retval\n."},
    {"getNOctaveLayers", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_getNOctaveLayers, 0), "getNOctaveLayers() -> retval\n."},
    {"getNOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_getNOctaves, 0), "getNOctaves() -> retval\n."},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_getThreshold, 0), "getThreshold() -> retval\n."},
    {"getUpright", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_getUpright, 0), "getUpright() -> retval\n."},
    {"setDiffusivity", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_setDiffusivity, 0), "setDiffusivity(diff) -> None\n."},
    {"setExtended", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_setExtended, 0), "setExtended(extended) -> None\n."},
    {"setNOctaveLayers", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_setNOctaveLayers, 0), "setNOctaveLayers(octaveLayers) -> None\n."},
    {"setNOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_setNOctaves, 0), "setNOctaves(octaves) -> None\n."},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_setThreshold, 0), "setThreshold(threshold) -> None\n."},
    {"setUpright", CV_PY_FN_WITH_KW_(pyopencv_cv_KAZE_setUpright, 0), "setUpright(upright) -> None\n."},

    {NULL,          NULL}
};

// Converter (KAZE)

template<>
struct PyOpenCV_Converter< Ptr<cv::KAZE> >
{
    static PyObject* from(const Ptr<cv::KAZE>& r)
    {
        return pyopencv_KAZE_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::KAZE>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::KAZE> * dst_;
        if (pyopencv_KAZE_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::KAZE> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// KalmanFilter (Generic)
//================================================================================

// GetSet (KalmanFilter)


static PyObject* pyopencv_KalmanFilter_get_controlMatrix(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->controlMatrix);
}

static int pyopencv_KalmanFilter_set_controlMatrix(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the controlMatrix attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->controlMatrix) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_errorCovPost(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->errorCovPost);
}

static int pyopencv_KalmanFilter_set_errorCovPost(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the errorCovPost attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->errorCovPost) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_errorCovPre(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->errorCovPre);
}

static int pyopencv_KalmanFilter_set_errorCovPre(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the errorCovPre attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->errorCovPre) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_gain(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->gain);
}

static int pyopencv_KalmanFilter_set_gain(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the gain attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->gain) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_measurementMatrix(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->measurementMatrix);
}

static int pyopencv_KalmanFilter_set_measurementMatrix(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the measurementMatrix attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->measurementMatrix) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_measurementNoiseCov(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->measurementNoiseCov);
}

static int pyopencv_KalmanFilter_set_measurementNoiseCov(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the measurementNoiseCov attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->measurementNoiseCov) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_processNoiseCov(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->processNoiseCov);
}

static int pyopencv_KalmanFilter_set_processNoiseCov(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the processNoiseCov attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->processNoiseCov) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_statePost(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->statePost);
}

static int pyopencv_KalmanFilter_set_statePost(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the statePost attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->statePost) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_statePre(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->statePre);
}

static int pyopencv_KalmanFilter_set_statePre(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the statePre attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->statePre) ? 0 : -1;
}

static PyObject* pyopencv_KalmanFilter_get_transitionMatrix(pyopencv_KalmanFilter_t* p, void *closure)
{
    return pyopencv_from(p->v->transitionMatrix);
}

static int pyopencv_KalmanFilter_set_transitionMatrix(pyopencv_KalmanFilter_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the transitionMatrix attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->transitionMatrix) ? 0 : -1;
}


// Methods (KalmanFilter)

static int pyopencv_cv_KalmanFilter_KalmanFilter(pyopencv_KalmanFilter_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::KalmanFilter>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::KalmanFilter()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int dynamParams=0;
    int measureParams=0;
    int controlParams=0;
    int type=CV_32F;

    const char* keywords[] = { "dynamParams", "measureParams", "controlParams", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii|ii:KalmanFilter", (char**)keywords, &dynamParams, &measureParams, &controlParams, &type) )
    {
        new (&(self->v)) Ptr<cv::KalmanFilter>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::KalmanFilter(dynamParams, measureParams, controlParams, type)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_KalmanFilter_correct(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KalmanFilter> * self1 = 0;
    if (!pyopencv_KalmanFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KalmanFilter' or its derivative)");
    Ptr<cv::KalmanFilter> _self_ = *(self1);
    {
    PyObject* pyobj_measurement = NULL;
    Mat measurement;
    Mat retval;

    const char* keywords[] = { "measurement", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:KalmanFilter.correct", (char**)keywords, &pyobj_measurement) &&
        pyopencv_to(pyobj_measurement, measurement, ArgInfo("measurement", 0)) )
    {
        ERRWRAP2(retval = _self_->correct(measurement));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_measurement = NULL;
    Mat measurement;
    Mat retval;

    const char* keywords[] = { "measurement", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:KalmanFilter.correct", (char**)keywords, &pyobj_measurement) &&
        pyopencv_to(pyobj_measurement, measurement, ArgInfo("measurement", 0)) )
    {
        ERRWRAP2(retval = _self_->correct(measurement));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_KalmanFilter_predict(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::KalmanFilter> * self1 = 0;
    if (!pyopencv_KalmanFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'KalmanFilter' or its derivative)");
    Ptr<cv::KalmanFilter> _self_ = *(self1);
    {
    PyObject* pyobj_control = NULL;
    Mat control;
    Mat retval;

    const char* keywords[] = { "control", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:KalmanFilter.predict", (char**)keywords, &pyobj_control) &&
        pyopencv_to(pyobj_control, control, ArgInfo("control", 0)) )
    {
        ERRWRAP2(retval = _self_->predict(control));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_control = NULL;
    Mat control;
    Mat retval;

    const char* keywords[] = { "control", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:KalmanFilter.predict", (char**)keywords, &pyobj_control) &&
        pyopencv_to(pyobj_control, control, ArgInfo("control", 0)) )
    {
        ERRWRAP2(retval = _self_->predict(control));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (KalmanFilter)

static PyGetSetDef pyopencv_KalmanFilter_getseters[] =
{
    {(char*)"controlMatrix", (getter)pyopencv_KalmanFilter_get_controlMatrix, (setter)pyopencv_KalmanFilter_set_controlMatrix, (char*)"controlMatrix", NULL},
    {(char*)"errorCovPost", (getter)pyopencv_KalmanFilter_get_errorCovPost, (setter)pyopencv_KalmanFilter_set_errorCovPost, (char*)"errorCovPost", NULL},
    {(char*)"errorCovPre", (getter)pyopencv_KalmanFilter_get_errorCovPre, (setter)pyopencv_KalmanFilter_set_errorCovPre, (char*)"errorCovPre", NULL},
    {(char*)"gain", (getter)pyopencv_KalmanFilter_get_gain, (setter)pyopencv_KalmanFilter_set_gain, (char*)"gain", NULL},
    {(char*)"measurementMatrix", (getter)pyopencv_KalmanFilter_get_measurementMatrix, (setter)pyopencv_KalmanFilter_set_measurementMatrix, (char*)"measurementMatrix", NULL},
    {(char*)"measurementNoiseCov", (getter)pyopencv_KalmanFilter_get_measurementNoiseCov, (setter)pyopencv_KalmanFilter_set_measurementNoiseCov, (char*)"measurementNoiseCov", NULL},
    {(char*)"processNoiseCov", (getter)pyopencv_KalmanFilter_get_processNoiseCov, (setter)pyopencv_KalmanFilter_set_processNoiseCov, (char*)"processNoiseCov", NULL},
    {(char*)"statePost", (getter)pyopencv_KalmanFilter_get_statePost, (setter)pyopencv_KalmanFilter_set_statePost, (char*)"statePost", NULL},
    {(char*)"statePre", (getter)pyopencv_KalmanFilter_get_statePre, (setter)pyopencv_KalmanFilter_set_statePre, (char*)"statePre", NULL},
    {(char*)"transitionMatrix", (getter)pyopencv_KalmanFilter_get_transitionMatrix, (setter)pyopencv_KalmanFilter_set_transitionMatrix, (char*)"transitionMatrix", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_KalmanFilter_methods[] =
{
    {"correct", CV_PY_FN_WITH_KW_(pyopencv_cv_KalmanFilter_correct, 0), "correct(measurement) -> retval\n.   @brief Updates the predicted state from the measurement.\n.   \n.       @param measurement The measured system parameters"},
    {"predict", CV_PY_FN_WITH_KW_(pyopencv_cv_KalmanFilter_predict, 0), "predict([, control]) -> retval\n.   @brief Computes a predicted state.\n.   \n.       @param control The optional input control"},

    {NULL,          NULL}
};

// Converter (KalmanFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::KalmanFilter> >
{
    static PyObject* from(const Ptr<cv::KalmanFilter>& r)
    {
        return pyopencv_KalmanFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::KalmanFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::KalmanFilter> * dst_;
        if (pyopencv_KalmanFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::KalmanFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// KeyPoint (Generic)
//================================================================================

// GetSet (KeyPoint)


static PyObject* pyopencv_KeyPoint_get_angle(pyopencv_KeyPoint_t* p, void *closure)
{
    return pyopencv_from(p->v.angle);
}

static int pyopencv_KeyPoint_set_angle(pyopencv_KeyPoint_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the angle attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.angle) ? 0 : -1;
}

static PyObject* pyopencv_KeyPoint_get_class_id(pyopencv_KeyPoint_t* p, void *closure)
{
    return pyopencv_from(p->v.class_id);
}

static int pyopencv_KeyPoint_set_class_id(pyopencv_KeyPoint_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the class_id attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.class_id) ? 0 : -1;
}

static PyObject* pyopencv_KeyPoint_get_octave(pyopencv_KeyPoint_t* p, void *closure)
{
    return pyopencv_from(p->v.octave);
}

static int pyopencv_KeyPoint_set_octave(pyopencv_KeyPoint_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the octave attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.octave) ? 0 : -1;
}

static PyObject* pyopencv_KeyPoint_get_pt(pyopencv_KeyPoint_t* p, void *closure)
{
    return pyopencv_from(p->v.pt);
}

static int pyopencv_KeyPoint_set_pt(pyopencv_KeyPoint_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the pt attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.pt) ? 0 : -1;
}

static PyObject* pyopencv_KeyPoint_get_response(pyopencv_KeyPoint_t* p, void *closure)
{
    return pyopencv_from(p->v.response);
}

static int pyopencv_KeyPoint_set_response(pyopencv_KeyPoint_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the response attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.response) ? 0 : -1;
}

static PyObject* pyopencv_KeyPoint_get_size(pyopencv_KeyPoint_t* p, void *closure)
{
    return pyopencv_from(p->v.size);
}

static int pyopencv_KeyPoint_set_size(pyopencv_KeyPoint_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the size attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.size) ? 0 : -1;
}


// Methods (KeyPoint)

static int pyopencv_cv_KeyPoint_KeyPoint(pyopencv_KeyPoint_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::KeyPoint());
        return 0;
    }
    }
    PyErr_Clear();

    {
    float x=0.f;
    float y=0.f;
    float _size=0.f;
    float _angle=-1;
    float _response=0;
    int _octave=0;
    int _class_id=-1;

    const char* keywords[] = { "x", "y", "_size", "_angle", "_response", "_octave", "_class_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "fff|ffii:KeyPoint", (char**)keywords, &x, &y, &_size, &_angle, &_response, &_octave, &_class_id) )
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::KeyPoint(x, y, _size, _angle, _response, _octave, _class_id));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_KeyPoint_convert_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {
    PyObject* pyobj_keypoints = NULL;
    vector_KeyPoint keypoints;
    vector_Point2f points2f;
    PyObject* pyobj_keypointIndexes = NULL;
    vector_int keypointIndexes=std::vector<int>();

    const char* keywords[] = { "keypoints", "keypointIndexes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:KeyPoint.convert", (char**)keywords, &pyobj_keypoints, &pyobj_keypointIndexes) &&
        pyopencv_to(pyobj_keypoints, keypoints, ArgInfo("keypoints", 0)) &&
        pyopencv_to(pyobj_keypointIndexes, keypointIndexes, ArgInfo("keypointIndexes", 0)) )
    {
        ERRWRAP2(cv::KeyPoint::convert(keypoints, points2f, keypointIndexes));
        return pyopencv_from(points2f);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points2f = NULL;
    vector_Point2f points2f;
    vector_KeyPoint keypoints;
    float size=1;
    float response=1;
    int octave=0;
    int class_id=-1;

    const char* keywords[] = { "points2f", "size", "response", "octave", "class_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|ffii:KeyPoint.convert", (char**)keywords, &pyobj_points2f, &size, &response, &octave, &class_id) &&
        pyopencv_to(pyobj_points2f, points2f, ArgInfo("points2f", 0)) )
    {
        ERRWRAP2(cv::KeyPoint::convert(points2f, keypoints, size, response, octave, class_id));
        return pyopencv_from(keypoints);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_KeyPoint_overlap_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_kp1 = NULL;
    KeyPoint kp1;
    PyObject* pyobj_kp2 = NULL;
    KeyPoint kp2;
    float retval;

    const char* keywords[] = { "kp1", "kp2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:KeyPoint.overlap", (char**)keywords, &pyobj_kp1, &pyobj_kp2) &&
        pyopencv_to(pyobj_kp1, kp1, ArgInfo("kp1", 0)) &&
        pyopencv_to(pyobj_kp2, kp2, ArgInfo("kp2", 0)) )
    {
        ERRWRAP2(retval = cv::KeyPoint::overlap(kp1, kp2));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (KeyPoint)

static PyGetSetDef pyopencv_KeyPoint_getseters[] =
{
    {(char*)"angle", (getter)pyopencv_KeyPoint_get_angle, (setter)pyopencv_KeyPoint_set_angle, (char*)"angle", NULL},
    {(char*)"class_id", (getter)pyopencv_KeyPoint_get_class_id, (setter)pyopencv_KeyPoint_set_class_id, (char*)"class_id", NULL},
    {(char*)"octave", (getter)pyopencv_KeyPoint_get_octave, (setter)pyopencv_KeyPoint_set_octave, (char*)"octave", NULL},
    {(char*)"pt", (getter)pyopencv_KeyPoint_get_pt, (setter)pyopencv_KeyPoint_set_pt, (char*)"pt", NULL},
    {(char*)"response", (getter)pyopencv_KeyPoint_get_response, (setter)pyopencv_KeyPoint_set_response, (char*)"response", NULL},
    {(char*)"size", (getter)pyopencv_KeyPoint_get_size, (setter)pyopencv_KeyPoint_set_size, (char*)"size", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_KeyPoint_methods[] =
{
    {"convert", CV_PY_FN_WITH_KW_(pyopencv_cv_KeyPoint_convert_static, METH_STATIC), "convert(keypoints[, keypointIndexes]) -> points2f\n.   This method converts vector of keypoints to vector of points or the reverse, where each keypoint is\n.       assigned the same size and the same orientation.\n.   \n.       @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB\n.       @param points2f Array of (x,y) coordinates of each keypoint\n.       @param keypointIndexes Array of indexes of keypoints to be converted to points. (Acts like a mask to\n.       convert only specified keypoints)\n\n\n\nconvert(points2f[, size[, response[, octave[, class_id]]]]) -> keypoints\n.   @overload\n.       @param points2f Array of (x,y) coordinates of each keypoint\n.       @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB\n.       @param size keypoint diameter\n.       @param response keypoint detector response on the keypoint (that is, strength of the keypoint)\n.       @param octave pyramid octave in which the keypoint has been detected\n.       @param class_id object id"},
    {"overlap", CV_PY_FN_WITH_KW_(pyopencv_cv_KeyPoint_overlap_static, METH_STATIC), "overlap(kp1, kp2) -> retval\n.   This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint\n.       regions' intersection and area of keypoint regions' union (considering keypoint region as circle).\n.       If they don't overlap, we get zero. If they coincide at same location with same size, we get 1.\n.       @param kp1 First keypoint\n.       @param kp2 Second keypoint"},

    {NULL,          NULL}
};

// Converter (KeyPoint)

template<>
struct PyOpenCV_Converter< cv::KeyPoint >
{
    static PyObject* from(const cv::KeyPoint& r)
    {
        return pyopencv_KeyPoint_Instance(r);
    }
    static bool to(PyObject* src, cv::KeyPoint& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::KeyPoint * dst_;
        if (pyopencv_KeyPoint_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::KeyPoint for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// LineSegmentDetector (Generic)
//================================================================================

// GetSet (LineSegmentDetector)



// Methods (LineSegmentDetector)

static PyObject* pyopencv_cv_LineSegmentDetector_compareSegments(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!pyopencv_LineSegmentDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'LineSegmentDetector' or its derivative)");
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);
    {
    PyObject* pyobj_size = NULL;
    Size size;
    PyObject* pyobj_lines1 = NULL;
    Mat lines1;
    PyObject* pyobj_lines2 = NULL;
    Mat lines2;
    PyObject* pyobj__image = NULL;
    Mat _image;
    int retval;

    const char* keywords[] = { "size", "lines1", "lines2", "_image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:LineSegmentDetector.compareSegments", (char**)keywords, &pyobj_size, &pyobj_lines1, &pyobj_lines2, &pyobj__image) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) &&
        pyopencv_to(pyobj_lines1, lines1, ArgInfo("lines1", 0)) &&
        pyopencv_to(pyobj_lines2, lines2, ArgInfo("lines2", 0)) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 1)) )
    {
        ERRWRAP2(retval = _self_->compareSegments(size, lines1, lines2, _image));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(_image));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;
    PyObject* pyobj_lines1 = NULL;
    UMat lines1;
    PyObject* pyobj_lines2 = NULL;
    UMat lines2;
    PyObject* pyobj__image = NULL;
    UMat _image;
    int retval;

    const char* keywords[] = { "size", "lines1", "lines2", "_image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:LineSegmentDetector.compareSegments", (char**)keywords, &pyobj_size, &pyobj_lines1, &pyobj_lines2, &pyobj__image) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) &&
        pyopencv_to(pyobj_lines1, lines1, ArgInfo("lines1", 0)) &&
        pyopencv_to(pyobj_lines2, lines2, ArgInfo("lines2", 0)) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 1)) )
    {
        ERRWRAP2(retval = _self_->compareSegments(size, lines1, lines2, _image));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(_image));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_LineSegmentDetector_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!pyopencv_LineSegmentDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'LineSegmentDetector' or its derivative)");
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);
    {
    PyObject* pyobj__image = NULL;
    Mat _image;
    PyObject* pyobj__lines = NULL;
    Mat _lines;
    PyObject* pyobj_width = NULL;
    Mat width;
    PyObject* pyobj_prec = NULL;
    Mat prec;
    PyObject* pyobj_nfa = NULL;
    Mat nfa;

    const char* keywords[] = { "_image", "_lines", "width", "prec", "nfa", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOOO:LineSegmentDetector.detect", (char**)keywords, &pyobj__image, &pyobj__lines, &pyobj_width, &pyobj_prec, &pyobj_nfa) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 0)) &&
        pyopencv_to(pyobj__lines, _lines, ArgInfo("_lines", 1)) &&
        pyopencv_to(pyobj_width, width, ArgInfo("width", 1)) &&
        pyopencv_to(pyobj_prec, prec, ArgInfo("prec", 1)) &&
        pyopencv_to(pyobj_nfa, nfa, ArgInfo("nfa", 1)) )
    {
        ERRWRAP2(_self_->detect(_image, _lines, width, prec, nfa));
        return Py_BuildValue("(NNNN)", pyopencv_from(_lines), pyopencv_from(width), pyopencv_from(prec), pyopencv_from(nfa));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__image = NULL;
    UMat _image;
    PyObject* pyobj__lines = NULL;
    UMat _lines;
    PyObject* pyobj_width = NULL;
    UMat width;
    PyObject* pyobj_prec = NULL;
    UMat prec;
    PyObject* pyobj_nfa = NULL;
    UMat nfa;

    const char* keywords[] = { "_image", "_lines", "width", "prec", "nfa", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOOO:LineSegmentDetector.detect", (char**)keywords, &pyobj__image, &pyobj__lines, &pyobj_width, &pyobj_prec, &pyobj_nfa) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 0)) &&
        pyopencv_to(pyobj__lines, _lines, ArgInfo("_lines", 1)) &&
        pyopencv_to(pyobj_width, width, ArgInfo("width", 1)) &&
        pyopencv_to(pyobj_prec, prec, ArgInfo("prec", 1)) &&
        pyopencv_to(pyobj_nfa, nfa, ArgInfo("nfa", 1)) )
    {
        ERRWRAP2(_self_->detect(_image, _lines, width, prec, nfa));
        return Py_BuildValue("(NNNN)", pyopencv_from(_lines), pyopencv_from(width), pyopencv_from(prec), pyopencv_from(nfa));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_LineSegmentDetector_drawSegments(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::LineSegmentDetector> * self1 = 0;
    if (!pyopencv_LineSegmentDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'LineSegmentDetector' or its derivative)");
    Ptr<cv::LineSegmentDetector> _self_ = *(self1);
    {
    PyObject* pyobj__image = NULL;
    Mat _image;
    PyObject* pyobj_lines = NULL;
    Mat lines;

    const char* keywords[] = { "_image", "lines", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:LineSegmentDetector.drawSegments", (char**)keywords, &pyobj__image, &pyobj_lines) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 1)) &&
        pyopencv_to(pyobj_lines, lines, ArgInfo("lines", 0)) )
    {
        ERRWRAP2(_self_->drawSegments(_image, lines));
        return pyopencv_from(_image);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__image = NULL;
    UMat _image;
    PyObject* pyobj_lines = NULL;
    UMat lines;

    const char* keywords[] = { "_image", "lines", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:LineSegmentDetector.drawSegments", (char**)keywords, &pyobj__image, &pyobj_lines) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 1)) &&
        pyopencv_to(pyobj_lines, lines, ArgInfo("lines", 0)) )
    {
        ERRWRAP2(_self_->drawSegments(_image, lines));
        return pyopencv_from(_image);
    }
    }

    return NULL;
}



// Tables (LineSegmentDetector)

static PyGetSetDef pyopencv_LineSegmentDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_LineSegmentDetector_methods[] =
{
    {"compareSegments", CV_PY_FN_WITH_KW_(pyopencv_cv_LineSegmentDetector_compareSegments, 0), "compareSegments(size, lines1, lines2[, _image]) -> retval, _image\n.   @brief Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels.\n.   \n.       @param size The size of the image, where lines1 and lines2 were found.\n.       @param lines1 The first group of lines that needs to be drawn. It is visualized in blue color.\n.       @param lines2 The second group of lines. They visualized in red color.\n.       @param _image Optional image, where the lines will be drawn. The image should be color(3-channel)\n.       in order for lines1 and lines2 to be drawn in the above mentioned colors."},
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_LineSegmentDetector_detect, 0), "detect(_image[, _lines[, width[, prec[, nfa]]]]) -> _lines, width, prec, nfa\n.   @brief Finds lines in the input image.\n.   \n.       This is the output of the default parameters of the algorithm on the above shown image.\n.   \n.       ![image](pics/building_lsd.png)\n.   \n.       @param _image A grayscale (CV_8UC1) input image. If only a roi needs to be selected, use:\n.       `lsd_ptr-\\>detect(image(roi), lines, ...); lines += Scalar(roi.x, roi.y, roi.x, roi.y);`\n.       @param _lines A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. Where\n.       Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly\n.       oriented depending on the gradient.\n.       @param width Vector of widths of the regions, where the lines are found. E.g. Width of line.\n.       @param prec Vector of precisions with which the lines are found.\n.       @param nfa Vector containing number of false alarms in the line region, with precision of 10%. The\n.       bigger the value, logarithmically better the detection.\n.       - -1 corresponds to 10 mean false alarms\n.       - 0 corresponds to 1 mean false alarm\n.       - 1 corresponds to 0.1 mean false alarms\n.       This vector will be calculated only when the objects type is #LSD_REFINE_ADV."},
    {"drawSegments", CV_PY_FN_WITH_KW_(pyopencv_cv_LineSegmentDetector_drawSegments, 0), "drawSegments(_image, lines) -> _image\n.   @brief Draws the line segments on a given image.\n.       @param _image The image, where the lines will be drawn. Should be bigger or equal to the image,\n.       where the lines were found.\n.       @param lines A vector of the lines that needed to be drawn."},

    {NULL,          NULL}
};

// Converter (LineSegmentDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::LineSegmentDetector> >
{
    static PyObject* from(const Ptr<cv::LineSegmentDetector>& r)
    {
        return pyopencv_LineSegmentDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::LineSegmentDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::LineSegmentDetector> * dst_;
        if (pyopencv_LineSegmentDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::LineSegmentDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// MSER (Generic)
//================================================================================

// GetSet (MSER)



// Methods (MSER)

static PyObject* pyopencv_cv_MSER_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int _delta=5;
    int _min_area=60;
    int _max_area=14400;
    double _max_variation=0.25;
    double _min_diversity=.2;
    int _max_evolution=200;
    double _area_threshold=1.01;
    double _min_margin=0.003;
    int _edge_blur_size=5;
    Ptr<MSER> retval;

    const char* keywords[] = { "_delta", "_min_area", "_max_area", "_max_variation", "_min_diversity", "_max_evolution", "_area_threshold", "_min_margin", "_edge_blur_size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iiiddiddi:MSER.create", (char**)keywords, &_delta, &_min_area, &_max_area, &_max_variation, &_min_diversity, &_max_evolution, &_area_threshold, &_min_margin, &_edge_blur_size) )
    {
        ERRWRAP2(retval = cv::MSER::create(_delta, _min_area, _max_area, _max_variation, _min_diversity, _max_evolution, _area_threshold, _min_margin, _edge_blur_size));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_detectRegions(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_vector_Point msers;
    vector_Rect bboxes;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MSER.detectRegions", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(_self_->detectRegions(image, msers, bboxes));
        return Py_BuildValue("(NN)", pyopencv_from(msers), pyopencv_from(bboxes));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    vector_vector_Point msers;
    vector_Rect bboxes;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MSER.detectRegions", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(_self_->detectRegions(image, msers, bboxes));
        return Py_BuildValue("(NN)", pyopencv_from(msers), pyopencv_from(bboxes));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_getDelta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDelta());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_getMaxArea(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxArea());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_getMinArea(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinArea());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_getPass2Only(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPass2Only());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_setDelta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    int delta=0;

    const char* keywords[] = { "delta", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:MSER.setDelta", (char**)keywords, &delta) )
    {
        ERRWRAP2(_self_->setDelta(delta));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_setMaxArea(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    int maxArea=0;

    const char* keywords[] = { "maxArea", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:MSER.setMaxArea", (char**)keywords, &maxArea) )
    {
        ERRWRAP2(_self_->setMaxArea(maxArea));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_setMinArea(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    int minArea=0;

    const char* keywords[] = { "minArea", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:MSER.setMinArea", (char**)keywords, &minArea) )
    {
        ERRWRAP2(_self_->setMinArea(minArea));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_MSER_setPass2Only(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MSER> * self1 = 0;
    if (!pyopencv_MSER_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MSER' or its derivative)");
    Ptr<cv::MSER> _self_ = *(self1);
    bool f=0;

    const char* keywords[] = { "f", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:MSER.setPass2Only", (char**)keywords, &f) )
    {
        ERRWRAP2(_self_->setPass2Only(f));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (MSER)

static PyGetSetDef pyopencv_MSER_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_MSER_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_create_static, METH_STATIC), "create([, _delta[, _min_area[, _max_area[, _max_variation[, _min_diversity[, _max_evolution[, _area_threshold[, _min_margin[, _edge_blur_size]]]]]]]]]) -> retval\n.   @brief Full consturctor for %MSER detector\n.   \n.       @param _delta it compares \\f$(size_{i}-size_{i-delta})/size_{i-delta}\\f$\n.       @param _min_area prune the area which smaller than minArea\n.       @param _max_area prune the area which bigger than maxArea\n.       @param _max_variation prune the area have similar size to its children\n.       @param _min_diversity for color image, trace back to cut off mser with diversity less than min_diversity\n.       @param _max_evolution  for color image, the evolution steps\n.       @param _area_threshold for color image, the area threshold to cause re-initialize\n.       @param _min_margin for color image, ignore too small margin\n.       @param _edge_blur_size for color image, the aperture size for edge blur"},
    {"detectRegions", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_detectRegions, 0), "detectRegions(image) -> msers, bboxes\n.   @brief Detect %MSER regions\n.   \n.       @param image input image (8UC1, 8UC3 or 8UC4, must be greater or equal than 3x3)\n.       @param msers resulting list of point sets\n.       @param bboxes resulting bounding boxes"},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"getDelta", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_getDelta, 0), "getDelta() -> retval\n."},
    {"getMaxArea", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_getMaxArea, 0), "getMaxArea() -> retval\n."},
    {"getMinArea", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_getMinArea, 0), "getMinArea() -> retval\n."},
    {"getPass2Only", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_getPass2Only, 0), "getPass2Only() -> retval\n."},
    {"setDelta", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_setDelta, 0), "setDelta(delta) -> None\n."},
    {"setMaxArea", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_setMaxArea, 0), "setMaxArea(maxArea) -> None\n."},
    {"setMinArea", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_setMinArea, 0), "setMinArea(minArea) -> None\n."},
    {"setPass2Only", CV_PY_FN_WITH_KW_(pyopencv_cv_MSER_setPass2Only, 0), "setPass2Only(f) -> None\n."},

    {NULL,          NULL}
};

// Converter (MSER)

template<>
struct PyOpenCV_Converter< Ptr<cv::MSER> >
{
    static PyObject* from(const Ptr<cv::MSER>& r)
    {
        return pyopencv_MSER_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::MSER>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::MSER> * dst_;
        if (pyopencv_MSER_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::MSER> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// MergeDebevec (Generic)
//================================================================================

// GetSet (MergeDebevec)



// Methods (MergeDebevec)

static PyObject* pyopencv_cv_MergeDebevec_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeDebevec> * self1 = 0;
    if (!pyopencv_MergeDebevec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeDebevec' or its derivative)");
    Ptr<cv::MergeDebevec> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;
    PyObject* pyobj_response = NULL;
    Mat response;

    const char* keywords[] = { "src", "times", "response", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:MergeDebevec.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_response, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_times = NULL;
    UMat times;
    PyObject* pyobj_response = NULL;
    UMat response;

    const char* keywords[] = { "src", "times", "response", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:MergeDebevec.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_response, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;

    const char* keywords[] = { "src", "times", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:MergeDebevec.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_times = NULL;
    UMat times;

    const char* keywords[] = { "src", "times", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:MergeDebevec.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (MergeDebevec)

static PyGetSetDef pyopencv_MergeDebevec_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_MergeDebevec_methods[] =
{
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeDebevec_process, 0), "process(src, times, response[, dst]) -> dst\n.   \n\n\n\nprocess(src, times[, dst]) -> dst\n."},

    {NULL,          NULL}
};

// Converter (MergeDebevec)

template<>
struct PyOpenCV_Converter< Ptr<cv::MergeDebevec> >
{
    static PyObject* from(const Ptr<cv::MergeDebevec>& r)
    {
        return pyopencv_MergeDebevec_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::MergeDebevec>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::MergeDebevec> * dst_;
        if (pyopencv_MergeDebevec_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::MergeDebevec> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// MergeExposures (Generic)
//================================================================================

// GetSet (MergeExposures)



// Methods (MergeExposures)

static PyObject* pyopencv_cv_MergeExposures_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeExposures> * self1 = 0;
    if (!pyopencv_MergeExposures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeExposures' or its derivative)");
    Ptr<cv::MergeExposures> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;
    PyObject* pyobj_response = NULL;
    Mat response;

    const char* keywords[] = { "src", "times", "response", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:MergeExposures.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_response, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_times = NULL;
    UMat times;
    PyObject* pyobj_response = NULL;
    UMat response;

    const char* keywords[] = { "src", "times", "response", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:MergeExposures.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_response, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (MergeExposures)

static PyGetSetDef pyopencv_MergeExposures_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_MergeExposures_methods[] =
{
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeExposures_process, 0), "process(src, times, response[, dst]) -> dst\n.   @brief Merges images.\n.   \n.       @param src vector of input images\n.       @param dst result image\n.       @param times vector of exposure time values for each image\n.       @param response 256x1 matrix with inverse camera response function for each pixel value, it should\n.       have the same number of channels as images."},

    {NULL,          NULL}
};

// Converter (MergeExposures)

template<>
struct PyOpenCV_Converter< Ptr<cv::MergeExposures> >
{
    static PyObject* from(const Ptr<cv::MergeExposures>& r)
    {
        return pyopencv_MergeExposures_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::MergeExposures>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::MergeExposures> * dst_;
        if (pyopencv_MergeExposures_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::MergeExposures> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// MergeMertens (Generic)
//================================================================================

// GetSet (MergeMertens)



// Methods (MergeMertens)

static PyObject* pyopencv_cv_MergeMertens_getContrastWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeMertens> * self1 = 0;
    if (!pyopencv_MergeMertens_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeMertens' or its derivative)");
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getContrastWeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MergeMertens_getExposureWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeMertens> * self1 = 0;
    if (!pyopencv_MergeMertens_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeMertens' or its derivative)");
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getExposureWeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MergeMertens_getSaturationWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeMertens> * self1 = 0;
    if (!pyopencv_MergeMertens_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeMertens' or its derivative)");
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSaturationWeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MergeMertens_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeMertens> * self1 = 0;
    if (!pyopencv_MergeMertens_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeMertens' or its derivative)");
    Ptr<cv::MergeMertens> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;
    PyObject* pyobj_response = NULL;
    Mat response;

    const char* keywords[] = { "src", "times", "response", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:MergeMertens.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_response, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_times = NULL;
    UMat times;
    PyObject* pyobj_response = NULL;
    UMat response;

    const char* keywords[] = { "src", "times", "response", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:MergeMertens.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_response, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:MergeMertens.process", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->process(src, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:MergeMertens.process", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->process(src, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_MergeMertens_setContrastWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeMertens> * self1 = 0;
    if (!pyopencv_MergeMertens_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeMertens' or its derivative)");
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float contrast_weiht=0.f;

    const char* keywords[] = { "contrast_weiht", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:MergeMertens.setContrastWeight", (char**)keywords, &contrast_weiht) )
    {
        ERRWRAP2(_self_->setContrastWeight(contrast_weiht));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_MergeMertens_setExposureWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeMertens> * self1 = 0;
    if (!pyopencv_MergeMertens_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeMertens' or its derivative)");
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float exposure_weight=0.f;

    const char* keywords[] = { "exposure_weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:MergeMertens.setExposureWeight", (char**)keywords, &exposure_weight) )
    {
        ERRWRAP2(_self_->setExposureWeight(exposure_weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_MergeMertens_setSaturationWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeMertens> * self1 = 0;
    if (!pyopencv_MergeMertens_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeMertens' or its derivative)");
    Ptr<cv::MergeMertens> _self_ = *(self1);
    float saturation_weight=0.f;

    const char* keywords[] = { "saturation_weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:MergeMertens.setSaturationWeight", (char**)keywords, &saturation_weight) )
    {
        ERRWRAP2(_self_->setSaturationWeight(saturation_weight));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (MergeMertens)

static PyGetSetDef pyopencv_MergeMertens_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_MergeMertens_methods[] =
{
    {"getContrastWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeMertens_getContrastWeight, 0), "getContrastWeight() -> retval\n."},
    {"getExposureWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeMertens_getExposureWeight, 0), "getExposureWeight() -> retval\n."},
    {"getSaturationWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeMertens_getSaturationWeight, 0), "getSaturationWeight() -> retval\n."},
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeMertens_process, 0), "process(src, times, response[, dst]) -> dst\n.   \n\n\n\nprocess(src[, dst]) -> dst\n.   @brief Short version of process, that doesn't take extra arguments.\n.   \n.       @param src vector of input images\n.       @param dst result image"},
    {"setContrastWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeMertens_setContrastWeight, 0), "setContrastWeight(contrast_weiht) -> None\n."},
    {"setExposureWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeMertens_setExposureWeight, 0), "setExposureWeight(exposure_weight) -> None\n."},
    {"setSaturationWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeMertens_setSaturationWeight, 0), "setSaturationWeight(saturation_weight) -> None\n."},

    {NULL,          NULL}
};

// Converter (MergeMertens)

template<>
struct PyOpenCV_Converter< Ptr<cv::MergeMertens> >
{
    static PyObject* from(const Ptr<cv::MergeMertens>& r)
    {
        return pyopencv_MergeMertens_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::MergeMertens>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::MergeMertens> * dst_;
        if (pyopencv_MergeMertens_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::MergeMertens> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// MergeRobertson (Generic)
//================================================================================

// GetSet (MergeRobertson)



// Methods (MergeRobertson)

static PyObject* pyopencv_cv_MergeRobertson_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MergeRobertson> * self1 = 0;
    if (!pyopencv_MergeRobertson_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MergeRobertson' or its derivative)");
    Ptr<cv::MergeRobertson> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;
    PyObject* pyobj_response = NULL;
    Mat response;

    const char* keywords[] = { "src", "times", "response", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:MergeRobertson.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_response, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_times = NULL;
    UMat times;
    PyObject* pyobj_response = NULL;
    UMat response;

    const char* keywords[] = { "src", "times", "response", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:MergeRobertson.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_response, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) &&
        pyopencv_to(pyobj_response, response, ArgInfo("response", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times, response));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_times = NULL;
    Mat times;

    const char* keywords[] = { "src", "times", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:MergeRobertson.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_times = NULL;
    UMat times;

    const char* keywords[] = { "src", "times", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:MergeRobertson.process", (char**)keywords, &pyobj_src, &pyobj_times, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_times, times, ArgInfo("times", 0)) )
    {
        ERRWRAP2(_self_->process(src, dst, times));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (MergeRobertson)

static PyGetSetDef pyopencv_MergeRobertson_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_MergeRobertson_methods[] =
{
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_MergeRobertson_process, 0), "process(src, times, response[, dst]) -> dst\n.   \n\n\n\nprocess(src, times[, dst]) -> dst\n."},

    {NULL,          NULL}
};

// Converter (MergeRobertson)

template<>
struct PyOpenCV_Converter< Ptr<cv::MergeRobertson> >
{
    static PyObject* from(const Ptr<cv::MergeRobertson>& r)
    {
        return pyopencv_MergeRobertson_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::MergeRobertson>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::MergeRobertson> * dst_;
        if (pyopencv_MergeRobertson_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::MergeRobertson> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// Moments (Map)
//================================================================================
static bool pyopencv_to(PyObject* src, cv::Moments& dst, const char* name)
{
    PyObject* tmp;
    bool ok;

    if( PyMapping_HasKeyString(src, (char*)"m00") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m00");
        ok = tmp && pyopencv_to(tmp, dst.m00);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m10") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m10");
        ok = tmp && pyopencv_to(tmp, dst.m10);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m01") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m01");
        ok = tmp && pyopencv_to(tmp, dst.m01);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m20") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m20");
        ok = tmp && pyopencv_to(tmp, dst.m20);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m11") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m11");
        ok = tmp && pyopencv_to(tmp, dst.m11);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m02") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m02");
        ok = tmp && pyopencv_to(tmp, dst.m02);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m30") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m30");
        ok = tmp && pyopencv_to(tmp, dst.m30);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m21") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m21");
        ok = tmp && pyopencv_to(tmp, dst.m21);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m12") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m12");
        ok = tmp && pyopencv_to(tmp, dst.m12);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"m03") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"m03");
        ok = tmp && pyopencv_to(tmp, dst.m03);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"mu20") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"mu20");
        ok = tmp && pyopencv_to(tmp, dst.mu20);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"mu11") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"mu11");
        ok = tmp && pyopencv_to(tmp, dst.mu11);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"mu02") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"mu02");
        ok = tmp && pyopencv_to(tmp, dst.mu02);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"mu30") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"mu30");
        ok = tmp && pyopencv_to(tmp, dst.mu30);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"mu21") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"mu21");
        ok = tmp && pyopencv_to(tmp, dst.mu21);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"mu12") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"mu12");
        ok = tmp && pyopencv_to(tmp, dst.mu12);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"mu03") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"mu03");
        ok = tmp && pyopencv_to(tmp, dst.mu03);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"nu20") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"nu20");
        ok = tmp && pyopencv_to(tmp, dst.nu20);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"nu11") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"nu11");
        ok = tmp && pyopencv_to(tmp, dst.nu11);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"nu02") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"nu02");
        ok = tmp && pyopencv_to(tmp, dst.nu02);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"nu30") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"nu30");
        ok = tmp && pyopencv_to(tmp, dst.nu30);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"nu21") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"nu21");
        ok = tmp && pyopencv_to(tmp, dst.nu21);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"nu12") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"nu12");
        ok = tmp && pyopencv_to(tmp, dst.nu12);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    if( PyMapping_HasKeyString(src, (char*)"nu03") )
    {
        tmp = PyMapping_GetItemString(src, (char*)"nu03");
        ok = tmp && pyopencv_to(tmp, dst.nu03);
        Py_DECREF(tmp);
        if(!ok) return false;
    }
    return true;
}

template<> bool pyopencv_to(PyObject* src, cv::Moments& dst, const char* name);

//================================================================================
// MultiTracker (Generic)
//================================================================================

// GetSet (MultiTracker)



// Methods (MultiTracker)

static int pyopencv_cv_MultiTracker_MultiTracker(pyopencv_MultiTracker_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::MultiTracker>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::MultiTracker()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_MultiTracker_add(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MultiTracker> * self1 = 0;
    if (!pyopencv_MultiTracker_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MultiTracker' or its derivative)");
    Ptr<cv::MultiTracker> _self_ = *(self1);
    {
    PyObject* pyobj_newTracker = NULL;
    Ptr<Tracker> newTracker;
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_boundingBox = NULL;
    Rect2d boundingBox;
    bool retval;

    const char* keywords[] = { "newTracker", "image", "boundingBox", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:MultiTracker.add", (char**)keywords, &pyobj_newTracker, &pyobj_image, &pyobj_boundingBox) &&
        pyopencv_to(pyobj_newTracker, newTracker, ArgInfo("newTracker", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_boundingBox, boundingBox, ArgInfo("boundingBox", 0)) )
    {
        ERRWRAP2(retval = _self_->add(newTracker, image, boundingBox));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_newTracker = NULL;
    Ptr<Tracker> newTracker;
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_boundingBox = NULL;
    Rect2d boundingBox;
    bool retval;

    const char* keywords[] = { "newTracker", "image", "boundingBox", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:MultiTracker.add", (char**)keywords, &pyobj_newTracker, &pyobj_image, &pyobj_boundingBox) &&
        pyopencv_to(pyobj_newTracker, newTracker, ArgInfo("newTracker", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_boundingBox, boundingBox, ArgInfo("boundingBox", 0)) )
    {
        ERRWRAP2(retval = _self_->add(newTracker, image, boundingBox));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_MultiTracker_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<MultiTracker> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::MultiTracker::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MultiTracker_getObjects(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MultiTracker> * self1 = 0;
    if (!pyopencv_MultiTracker_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MultiTracker' or its derivative)");
    Ptr<cv::MultiTracker> _self_ = *(self1);
    std::vector<Rect2d> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getObjects());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_MultiTracker_update(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::MultiTracker> * self1 = 0;
    if (!pyopencv_MultiTracker_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'MultiTracker' or its derivative)");
    Ptr<cv::MultiTracker> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_Rect2d boundingBox;
    bool retval;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MultiTracker.update", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->update(image, boundingBox));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(boundingBox));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    vector_Rect2d boundingBox;
    bool retval;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MultiTracker.update", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->update(image, boundingBox));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(boundingBox));
    }
    }

    return NULL;
}



// Tables (MultiTracker)

static PyGetSetDef pyopencv_MultiTracker_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_MultiTracker_methods[] =
{
    {"add", CV_PY_FN_WITH_KW_(pyopencv_cv_MultiTracker_add, 0), "add(newTracker, image, boundingBox) -> retval\n.   * \\brief Add a new object to be tracked.\n.     *\n.     * @param newTracker tracking algorithm to be used\n.     * @param image input image\n.     * @param boundingBox a rectangle represents ROI of the tracked object"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_MultiTracker_create_static, METH_STATIC), "create() -> retval\n.   * \\brief Returns a pointer to a new instance of MultiTracker"},
    {"getObjects", CV_PY_FN_WITH_KW_(pyopencv_cv_MultiTracker_getObjects, 0), "getObjects() -> retval\n.   * \\brief Returns a reference to a storage for the tracked objects, each object corresponds to one tracker algorithm"},
    {"update", CV_PY_FN_WITH_KW_(pyopencv_cv_MultiTracker_update, 0), "update(image) -> retval, boundingBox\n.   * \\brief Update the current tracking status.\n.     * @param image input image\n.     * @param boundingBox the tracking result, represent a list of ROIs of the tracked objects."},

    {NULL,          NULL}
};

// Converter (MultiTracker)

template<>
struct PyOpenCV_Converter< Ptr<cv::MultiTracker> >
{
    static PyObject* from(const Ptr<cv::MultiTracker>& r)
    {
        return pyopencv_MultiTracker_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::MultiTracker>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::MultiTracker> * dst_;
        if (pyopencv_MultiTracker_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::MultiTracker> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// NormHistogramCostExtractor (Generic)
//================================================================================

// GetSet (NormHistogramCostExtractor)



// Methods (NormHistogramCostExtractor)

static PyObject* pyopencv_cv_NormHistogramCostExtractor_getNormFlag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::NormHistogramCostExtractor> * self1 = 0;
    if (!pyopencv_NormHistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'NormHistogramCostExtractor' or its derivative)");
    Ptr<cv::NormHistogramCostExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNormFlag());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_NormHistogramCostExtractor_setNormFlag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::NormHistogramCostExtractor> * self1 = 0;
    if (!pyopencv_NormHistogramCostExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'NormHistogramCostExtractor' or its derivative)");
    Ptr<cv::NormHistogramCostExtractor> _self_ = *(self1);
    int flag=0;

    const char* keywords[] = { "flag", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:NormHistogramCostExtractor.setNormFlag", (char**)keywords, &flag) )
    {
        ERRWRAP2(_self_->setNormFlag(flag));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (NormHistogramCostExtractor)

static PyGetSetDef pyopencv_NormHistogramCostExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_NormHistogramCostExtractor_methods[] =
{
    {"getNormFlag", CV_PY_FN_WITH_KW_(pyopencv_cv_NormHistogramCostExtractor_getNormFlag, 0), "getNormFlag() -> retval\n."},
    {"setNormFlag", CV_PY_FN_WITH_KW_(pyopencv_cv_NormHistogramCostExtractor_setNormFlag, 0), "setNormFlag(flag) -> None\n."},

    {NULL,          NULL}
};

// Converter (NormHistogramCostExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::NormHistogramCostExtractor> >
{
    static PyObject* from(const Ptr<cv::NormHistogramCostExtractor>& r)
    {
        return pyopencv_NormHistogramCostExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::NormHistogramCostExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::NormHistogramCostExtractor> * dst_;
        if (pyopencv_NormHistogramCostExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::NormHistogramCostExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ORB (Generic)
//================================================================================

// GetSet (ORB)



// Methods (ORB)

static PyObject* pyopencv_cv_ORB_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int nfeatures=500;
    float scaleFactor=1.2f;
    int nlevels=8;
    int edgeThreshold=31;
    int firstLevel=0;
    int WTA_K=2;
    PyObject* pyobj_scoreType = NULL;
    ORB_ScoreType scoreType=ORB::HARRIS_SCORE;
    int patchSize=31;
    int fastThreshold=20;
    Ptr<ORB> retval;

    const char* keywords[] = { "nfeatures", "scaleFactor", "nlevels", "edgeThreshold", "firstLevel", "WTA_K", "scoreType", "patchSize", "fastThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ifiiiiOii:ORB.create", (char**)keywords, &nfeatures, &scaleFactor, &nlevels, &edgeThreshold, &firstLevel, &WTA_K, &pyobj_scoreType, &patchSize, &fastThreshold) &&
        pyopencv_to(pyobj_scoreType, scoreType, ArgInfo("scoreType", 0)) )
    {
        ERRWRAP2(retval = cv::ORB::create(nfeatures, scaleFactor, nlevels, edgeThreshold, firstLevel, WTA_K, scoreType, patchSize, fastThreshold));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getEdgeThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEdgeThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getFastThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFastThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getFirstLevel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFirstLevel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getMaxFeatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxFeatures());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getNLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNLevels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getPatchSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPatchSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getScaleFactor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScaleFactor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getScoreType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    ORB::ScoreType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScoreType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_getWTA_K(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWTA_K());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setEdgeThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int edgeThreshold=0;

    const char* keywords[] = { "edgeThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ORB.setEdgeThreshold", (char**)keywords, &edgeThreshold) )
    {
        ERRWRAP2(_self_->setEdgeThreshold(edgeThreshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setFastThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int fastThreshold=0;

    const char* keywords[] = { "fastThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ORB.setFastThreshold", (char**)keywords, &fastThreshold) )
    {
        ERRWRAP2(_self_->setFastThreshold(fastThreshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setFirstLevel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int firstLevel=0;

    const char* keywords[] = { "firstLevel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ORB.setFirstLevel", (char**)keywords, &firstLevel) )
    {
        ERRWRAP2(_self_->setFirstLevel(firstLevel));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setMaxFeatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int maxFeatures=0;

    const char* keywords[] = { "maxFeatures", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ORB.setMaxFeatures", (char**)keywords, &maxFeatures) )
    {
        ERRWRAP2(_self_->setMaxFeatures(maxFeatures));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setNLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int nlevels=0;

    const char* keywords[] = { "nlevels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ORB.setNLevels", (char**)keywords, &nlevels) )
    {
        ERRWRAP2(_self_->setNLevels(nlevels));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setPatchSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int patchSize=0;

    const char* keywords[] = { "patchSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ORB.setPatchSize", (char**)keywords, &patchSize) )
    {
        ERRWRAP2(_self_->setPatchSize(patchSize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setScaleFactor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    double scaleFactor=0;

    const char* keywords[] = { "scaleFactor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ORB.setScaleFactor", (char**)keywords, &scaleFactor) )
    {
        ERRWRAP2(_self_->setScaleFactor(scaleFactor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setScoreType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    PyObject* pyobj_scoreType = NULL;
    ORB_ScoreType scoreType=static_cast<ORB_ScoreType>(0);

    const char* keywords[] = { "scoreType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ORB.setScoreType", (char**)keywords, &pyobj_scoreType) &&
        pyopencv_to(pyobj_scoreType, scoreType, ArgInfo("scoreType", 0)) )
    {
        ERRWRAP2(_self_->setScoreType(scoreType));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ORB_setWTA_K(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ORB> * self1 = 0;
    if (!pyopencv_ORB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ORB' or its derivative)");
    Ptr<cv::ORB> _self_ = *(self1);
    int wta_k=0;

    const char* keywords[] = { "wta_k", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ORB.setWTA_K", (char**)keywords, &wta_k) )
    {
        ERRWRAP2(_self_->setWTA_K(wta_k));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ORB)

static PyGetSetDef pyopencv_ORB_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ORB_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_create_static, METH_STATIC), "create([, nfeatures[, scaleFactor[, nlevels[, edgeThreshold[, firstLevel[, WTA_K[, scoreType[, patchSize[, fastThreshold]]]]]]]]]) -> retval\n.   @brief The ORB constructor\n.   \n.       @param nfeatures The maximum number of features to retain.\n.       @param scaleFactor Pyramid decimation ratio, greater than 1. scaleFactor==2 means the classical\n.       pyramid, where each next level has 4x less pixels than the previous, but such a big scale factor\n.       will degrade feature matching scores dramatically. On the other hand, too close to 1 scale factor\n.       will mean that to cover certain scale range you will need more pyramid levels and so the speed\n.       will suffer.\n.       @param nlevels The number of pyramid levels. The smallest level will have linear size equal to\n.       input_image_linear_size/pow(scaleFactor, nlevels - firstLevel).\n.       @param edgeThreshold This is size of the border where the features are not detected. It should\n.       roughly match the patchSize parameter.\n.       @param firstLevel The level of pyramid to put source image to. Previous layers are filled\n.       with upscaled source image.\n.       @param WTA_K The number of points that produce each element of the oriented BRIEF descriptor. The\n.       default value 2 means the BRIEF where we take a random point pair and compare their brightnesses,\n.       so we get 0/1 response. Other possible values are 3 and 4. For example, 3 means that we take 3\n.       random points (of course, those point coordinates are random, but they are generated from the\n.       pre-defined seed, so each element of BRIEF descriptor is computed deterministically from the pixel\n.       rectangle), find point of maximum brightness and output index of the winner (0, 1 or 2). Such\n.       output will occupy 2 bits, and therefore it will need a special variant of Hamming distance,\n.       denoted as NORM_HAMMING2 (2 bits per bin). When WTA_K=4, we take 4 random points to compute each\n.       bin (that will also occupy 2 bits with possible values 0, 1, 2 or 3).\n.       @param scoreType The default HARRIS_SCORE means that Harris algorithm is used to rank features\n.       (the score is written to KeyPoint::score and is used to retain best nfeatures features);\n.       FAST_SCORE is alternative value of the parameter that produces slightly less stable keypoints,\n.       but it is a little faster to compute.\n.       @param patchSize size of the patch used by the oriented BRIEF descriptor. Of course, on smaller\n.       pyramid layers the perceived image area covered by a feature will be larger.\n.       @param fastThreshold the fast threshold"},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getDefaultName, 0), "getDefaultName() -> retval\n."},
    {"getEdgeThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getEdgeThreshold, 0), "getEdgeThreshold() -> retval\n."},
    {"getFastThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getFastThreshold, 0), "getFastThreshold() -> retval\n."},
    {"getFirstLevel", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getFirstLevel, 0), "getFirstLevel() -> retval\n."},
    {"getMaxFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getMaxFeatures, 0), "getMaxFeatures() -> retval\n."},
    {"getNLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getNLevels, 0), "getNLevels() -> retval\n."},
    {"getPatchSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getPatchSize, 0), "getPatchSize() -> retval\n."},
    {"getScaleFactor", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getScaleFactor, 0), "getScaleFactor() -> retval\n."},
    {"getScoreType", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getScoreType, 0), "getScoreType() -> retval\n."},
    {"getWTA_K", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_getWTA_K, 0), "getWTA_K() -> retval\n."},
    {"setEdgeThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setEdgeThreshold, 0), "setEdgeThreshold(edgeThreshold) -> None\n."},
    {"setFastThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setFastThreshold, 0), "setFastThreshold(fastThreshold) -> None\n."},
    {"setFirstLevel", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setFirstLevel, 0), "setFirstLevel(firstLevel) -> None\n."},
    {"setMaxFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setMaxFeatures, 0), "setMaxFeatures(maxFeatures) -> None\n."},
    {"setNLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setNLevels, 0), "setNLevels(nlevels) -> None\n."},
    {"setPatchSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setPatchSize, 0), "setPatchSize(patchSize) -> None\n."},
    {"setScaleFactor", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setScaleFactor, 0), "setScaleFactor(scaleFactor) -> None\n."},
    {"setScoreType", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setScoreType, 0), "setScoreType(scoreType) -> None\n."},
    {"setWTA_K", CV_PY_FN_WITH_KW_(pyopencv_cv_ORB_setWTA_K, 0), "setWTA_K(wta_k) -> None\n."},

    {NULL,          NULL}
};

// Converter (ORB)

template<>
struct PyOpenCV_Converter< Ptr<cv::ORB> >
{
    static PyObject* from(const Ptr<cv::ORB>& r)
    {
        return pyopencv_ORB_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ORB>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ORB> * dst_;
        if (pyopencv_ORB_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ORB> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// PyRotationWarper (Generic)
//================================================================================

// GetSet (PyRotationWarper)



// Methods (PyRotationWarper)

static int pyopencv_cv_PyRotationWarper_PyRotationWarper(pyopencv_PyRotationWarper_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {
    PyObject* pyobj_type = NULL;
    String type;
    float scale=0.f;

    const char* keywords[] = { "type", "scale", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Of:PyRotationWarper", (char**)keywords, &pyobj_type, &scale) &&
        pyopencv_to(pyobj_type, type, ArgInfo("type", 0)) )
    {
        new (&(self->v)) Ptr<cv::PyRotationWarper>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::PyRotationWarper(type, scale)));
        return 0;
    }
    }
    PyErr_Clear();

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::PyRotationWarper>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::PyRotationWarper()));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_PyRotationWarper_buildMaps(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!pyopencv_PyRotationWarper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'PyRotationWarper' or its derivative)");
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    {
    PyObject* pyobj_src_size = NULL;
    Size src_size;
    PyObject* pyobj_K = NULL;
    Mat K;
    PyObject* pyobj_R = NULL;
    Mat R;
    PyObject* pyobj_xmap = NULL;
    Mat xmap;
    PyObject* pyobj_ymap = NULL;
    Mat ymap;
    Rect retval;

    const char* keywords[] = { "src_size", "K", "R", "xmap", "ymap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:PyRotationWarper.buildMaps", (char**)keywords, &pyobj_src_size, &pyobj_K, &pyobj_R, &pyobj_xmap, &pyobj_ymap) &&
        pyopencv_to(pyobj_src_size, src_size, ArgInfo("src_size", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) &&
        pyopencv_to(pyobj_xmap, xmap, ArgInfo("xmap", 1)) &&
        pyopencv_to(pyobj_ymap, ymap, ArgInfo("ymap", 1)) )
    {
        ERRWRAP2(retval = _self_->buildMaps(src_size, K, R, xmap, ymap));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(xmap), pyopencv_from(ymap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src_size = NULL;
    Size src_size;
    PyObject* pyobj_K = NULL;
    UMat K;
    PyObject* pyobj_R = NULL;
    UMat R;
    PyObject* pyobj_xmap = NULL;
    UMat xmap;
    PyObject* pyobj_ymap = NULL;
    UMat ymap;
    Rect retval;

    const char* keywords[] = { "src_size", "K", "R", "xmap", "ymap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:PyRotationWarper.buildMaps", (char**)keywords, &pyobj_src_size, &pyobj_K, &pyobj_R, &pyobj_xmap, &pyobj_ymap) &&
        pyopencv_to(pyobj_src_size, src_size, ArgInfo("src_size", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) &&
        pyopencv_to(pyobj_xmap, xmap, ArgInfo("xmap", 1)) &&
        pyopencv_to(pyobj_ymap, ymap, ArgInfo("ymap", 1)) )
    {
        ERRWRAP2(retval = _self_->buildMaps(src_size, K, R, xmap, ymap));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(xmap), pyopencv_from(ymap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_PyRotationWarper_getScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!pyopencv_PyRotationWarper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'PyRotationWarper' or its derivative)");
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_PyRotationWarper_setScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!pyopencv_PyRotationWarper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'PyRotationWarper' or its derivative)");
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    float arg1=0.f;

    const char* keywords[] = { "arg1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:PyRotationWarper.setScale", (char**)keywords, &arg1) )
    {
        ERRWRAP2(_self_->setScale(arg1));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_PyRotationWarper_warp(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!pyopencv_PyRotationWarper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'PyRotationWarper' or its derivative)");
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_K = NULL;
    Mat K;
    PyObject* pyobj_R = NULL;
    Mat R;
    int interp_mode=0;
    int border_mode=0;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    Point retval;

    const char* keywords[] = { "src", "K", "R", "interp_mode", "border_mode", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOii|O:PyRotationWarper.warp", (char**)keywords, &pyobj_src, &pyobj_K, &pyobj_R, &interp_mode, &border_mode, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(retval = _self_->warp(src, K, R, interp_mode, border_mode, dst));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(dst));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_K = NULL;
    UMat K;
    PyObject* pyobj_R = NULL;
    UMat R;
    int interp_mode=0;
    int border_mode=0;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    Point retval;

    const char* keywords[] = { "src", "K", "R", "interp_mode", "border_mode", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOii|O:PyRotationWarper.warp", (char**)keywords, &pyobj_src, &pyobj_K, &pyobj_R, &interp_mode, &border_mode, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(retval = _self_->warp(src, K, R, interp_mode, border_mode, dst));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(dst));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_PyRotationWarper_warpBackward(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!pyopencv_PyRotationWarper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'PyRotationWarper' or its derivative)");
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_K = NULL;
    Mat K;
    PyObject* pyobj_R = NULL;
    Mat R;
    int interp_mode=0;
    int border_mode=0;
    PyObject* pyobj_dst_size = NULL;
    Size dst_size;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "K", "R", "interp_mode", "border_mode", "dst_size", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOiiO|O:PyRotationWarper.warpBackward", (char**)keywords, &pyobj_src, &pyobj_K, &pyobj_R, &interp_mode, &border_mode, &pyobj_dst_size, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) &&
        pyopencv_to(pyobj_dst_size, dst_size, ArgInfo("dst_size", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->warpBackward(src, K, R, interp_mode, border_mode, dst_size, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_K = NULL;
    UMat K;
    PyObject* pyobj_R = NULL;
    UMat R;
    int interp_mode=0;
    int border_mode=0;
    PyObject* pyobj_dst_size = NULL;
    Size dst_size;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "K", "R", "interp_mode", "border_mode", "dst_size", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOiiO|O:PyRotationWarper.warpBackward", (char**)keywords, &pyobj_src, &pyobj_K, &pyobj_R, &interp_mode, &border_mode, &pyobj_dst_size, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) &&
        pyopencv_to(pyobj_dst_size, dst_size, ArgInfo("dst_size", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->warpBackward(src, K, R, interp_mode, border_mode, dst_size, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_PyRotationWarper_warpPoint(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!pyopencv_PyRotationWarper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'PyRotationWarper' or its derivative)");
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    {
    PyObject* pyobj_pt = NULL;
    Point2f pt;
    PyObject* pyobj_K = NULL;
    Mat K;
    PyObject* pyobj_R = NULL;
    Mat R;
    Point2f retval;

    const char* keywords[] = { "pt", "K", "R", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:PyRotationWarper.warpPoint", (char**)keywords, &pyobj_pt, &pyobj_K, &pyobj_R) &&
        pyopencv_to(pyobj_pt, pt, ArgInfo("pt", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) )
    {
        ERRWRAP2(retval = _self_->warpPoint(pt, K, R));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_pt = NULL;
    Point2f pt;
    PyObject* pyobj_K = NULL;
    UMat K;
    PyObject* pyobj_R = NULL;
    UMat R;
    Point2f retval;

    const char* keywords[] = { "pt", "K", "R", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:PyRotationWarper.warpPoint", (char**)keywords, &pyobj_pt, &pyobj_K, &pyobj_R) &&
        pyopencv_to(pyobj_pt, pt, ArgInfo("pt", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) )
    {
        ERRWRAP2(retval = _self_->warpPoint(pt, K, R));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_PyRotationWarper_warpRoi(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::PyRotationWarper> * self1 = 0;
    if (!pyopencv_PyRotationWarper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'PyRotationWarper' or its derivative)");
    Ptr<cv::PyRotationWarper> _self_ = *(self1);
    {
    PyObject* pyobj_src_size = NULL;
    Size src_size;
    PyObject* pyobj_K = NULL;
    Mat K;
    PyObject* pyobj_R = NULL;
    Mat R;
    Rect retval;

    const char* keywords[] = { "src_size", "K", "R", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:PyRotationWarper.warpRoi", (char**)keywords, &pyobj_src_size, &pyobj_K, &pyobj_R) &&
        pyopencv_to(pyobj_src_size, src_size, ArgInfo("src_size", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) )
    {
        ERRWRAP2(retval = _self_->warpRoi(src_size, K, R));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src_size = NULL;
    Size src_size;
    PyObject* pyobj_K = NULL;
    UMat K;
    PyObject* pyobj_R = NULL;
    UMat R;
    Rect retval;

    const char* keywords[] = { "src_size", "K", "R", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:PyRotationWarper.warpRoi", (char**)keywords, &pyobj_src_size, &pyobj_K, &pyobj_R) &&
        pyopencv_to(pyobj_src_size, src_size, ArgInfo("src_size", 0)) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) &&
        pyopencv_to(pyobj_R, R, ArgInfo("R", 0)) )
    {
        ERRWRAP2(retval = _self_->warpRoi(src_size, K, R));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (PyRotationWarper)

static PyGetSetDef pyopencv_PyRotationWarper_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_PyRotationWarper_methods[] =
{
    {"buildMaps", CV_PY_FN_WITH_KW_(pyopencv_cv_PyRotationWarper_buildMaps, 0), "buildMaps(src_size, K, R[, xmap[, ymap]]) -> retval, xmap, ymap\n.   @brief Builds the projection maps according to the given camera data.\n.   \n.           @param src_size Source image size\n.           @param K Camera intrinsic parameters\n.           @param R Camera rotation matrix\n.           @param xmap Projection map for the x axis\n.           @param ymap Projection map for the y axis\n.           @return Projected image minimum bounding box"},
    {"getScale", CV_PY_FN_WITH_KW_(pyopencv_cv_PyRotationWarper_getScale, 0), "getScale() -> retval\n."},
    {"setScale", CV_PY_FN_WITH_KW_(pyopencv_cv_PyRotationWarper_setScale, 0), "setScale(arg1) -> None\n."},
    {"warp", CV_PY_FN_WITH_KW_(pyopencv_cv_PyRotationWarper_warp, 0), "warp(src, K, R, interp_mode, border_mode[, dst]) -> retval, dst\n.   @brief Projects the image.\n.   \n.           @param src Source image\n.           @param K Camera intrinsic parameters\n.           @param R Camera rotation matrix\n.           @param interp_mode Interpolation mode\n.           @param border_mode Border extrapolation mode\n.           @param dst Projected image\n.           @return Project image top-left corner"},
    {"warpBackward", CV_PY_FN_WITH_KW_(pyopencv_cv_PyRotationWarper_warpBackward, 0), "warpBackward(src, K, R, interp_mode, border_mode, dst_size[, dst]) -> dst\n.   @brief Projects the image backward.\n.   \n.           @param src Projected image\n.           @param K Camera intrinsic parameters\n.           @param R Camera rotation matrix\n.           @param interp_mode Interpolation mode\n.           @param border_mode Border extrapolation mode\n.           @param dst_size Backward-projected image size\n.           @param dst Backward-projected image"},
    {"warpPoint", CV_PY_FN_WITH_KW_(pyopencv_cv_PyRotationWarper_warpPoint, 0), "warpPoint(pt, K, R) -> retval\n.   @brief Projects the image point.\n.   \n.           @param pt Source point\n.           @param K Camera intrinsic parameters\n.           @param R Camera rotation matrix\n.           @return Projected point"},
    {"warpRoi", CV_PY_FN_WITH_KW_(pyopencv_cv_PyRotationWarper_warpRoi, 0), "warpRoi(src_size, K, R) -> retval\n.   @param src_size Source image bounding box\n.           @param K Camera intrinsic parameters\n.           @param R Camera rotation matrix\n.           @return Projected image minimum bounding box"},

    {NULL,          NULL}
};

// Converter (PyRotationWarper)

template<>
struct PyOpenCV_Converter< Ptr<cv::PyRotationWarper> >
{
    static PyObject* from(const Ptr<cv::PyRotationWarper>& r)
    {
        return pyopencv_PyRotationWarper_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::PyRotationWarper>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::PyRotationWarper> * dst_;
        if (pyopencv_PyRotationWarper_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::PyRotationWarper> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// QRCodeDetector (Generic)
//================================================================================

// GetSet (QRCodeDetector)



// Methods (QRCodeDetector)

static int pyopencv_cv_QRCodeDetector_QRCodeDetector(pyopencv_QRCodeDetector_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::QRCodeDetector>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::QRCodeDetector()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_QRCodeDetector_decode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!pyopencv_QRCodeDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'QRCodeDetector' or its derivative)");
    Ptr<cv::QRCodeDetector> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_points = NULL;
    Mat points;
    PyObject* pyobj_straight_qrcode = NULL;
    Mat straight_qrcode;
    std::string retval;

    const char* keywords[] = { "img", "points", "straight_qrcode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:QRCodeDetector.decode", (char**)keywords, &pyobj_img, &pyobj_points, &pyobj_straight_qrcode) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 0)) &&
        pyopencv_to(pyobj_straight_qrcode, straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        ERRWRAP2(retval = _self_->decode(img, points, straight_qrcode));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(straight_qrcode));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_points = NULL;
    UMat points;
    PyObject* pyobj_straight_qrcode = NULL;
    UMat straight_qrcode;
    std::string retval;

    const char* keywords[] = { "img", "points", "straight_qrcode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:QRCodeDetector.decode", (char**)keywords, &pyobj_img, &pyobj_points, &pyobj_straight_qrcode) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 0)) &&
        pyopencv_to(pyobj_straight_qrcode, straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        ERRWRAP2(retval = _self_->decode(img, points, straight_qrcode));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(straight_qrcode));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_QRCodeDetector_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!pyopencv_QRCodeDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'QRCodeDetector' or its derivative)");
    Ptr<cv::QRCodeDetector> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_points = NULL;
    Mat points;
    bool retval;

    const char* keywords[] = { "img", "points", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:QRCodeDetector.detect", (char**)keywords, &pyobj_img, &pyobj_points) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 1)) )
    {
        ERRWRAP2(retval = _self_->detect(img, points));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(points));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_points = NULL;
    UMat points;
    bool retval;

    const char* keywords[] = { "img", "points", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:QRCodeDetector.detect", (char**)keywords, &pyobj_img, &pyobj_points) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 1)) )
    {
        ERRWRAP2(retval = _self_->detect(img, points));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(points));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_QRCodeDetector_detectAndDecode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!pyopencv_QRCodeDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'QRCodeDetector' or its derivative)");
    Ptr<cv::QRCodeDetector> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_points = NULL;
    Mat points;
    PyObject* pyobj_straight_qrcode = NULL;
    Mat straight_qrcode;
    std::string retval;

    const char* keywords[] = { "img", "points", "straight_qrcode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:QRCodeDetector.detectAndDecode", (char**)keywords, &pyobj_img, &pyobj_points, &pyobj_straight_qrcode) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 1)) &&
        pyopencv_to(pyobj_straight_qrcode, straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        ERRWRAP2(retval = _self_->detectAndDecode(img, points, straight_qrcode));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(points), pyopencv_from(straight_qrcode));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_points = NULL;
    UMat points;
    PyObject* pyobj_straight_qrcode = NULL;
    UMat straight_qrcode;
    std::string retval;

    const char* keywords[] = { "img", "points", "straight_qrcode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:QRCodeDetector.detectAndDecode", (char**)keywords, &pyobj_img, &pyobj_points, &pyobj_straight_qrcode) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 1)) &&
        pyopencv_to(pyobj_straight_qrcode, straight_qrcode, ArgInfo("straight_qrcode", 1)) )
    {
        ERRWRAP2(retval = _self_->detectAndDecode(img, points, straight_qrcode));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(points), pyopencv_from(straight_qrcode));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_QRCodeDetector_setEpsX(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!pyopencv_QRCodeDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'QRCodeDetector' or its derivative)");
    Ptr<cv::QRCodeDetector> _self_ = *(self1);
    double epsX=0;

    const char* keywords[] = { "epsX", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:QRCodeDetector.setEpsX", (char**)keywords, &epsX) )
    {
        ERRWRAP2(_self_->setEpsX(epsX));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_QRCodeDetector_setEpsY(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::QRCodeDetector> * self1 = 0;
    if (!pyopencv_QRCodeDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'QRCodeDetector' or its derivative)");
    Ptr<cv::QRCodeDetector> _self_ = *(self1);
    double epsY=0;

    const char* keywords[] = { "epsY", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:QRCodeDetector.setEpsY", (char**)keywords, &epsY) )
    {
        ERRWRAP2(_self_->setEpsY(epsY));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (QRCodeDetector)

static PyGetSetDef pyopencv_QRCodeDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_QRCodeDetector_methods[] =
{
    {"decode", CV_PY_FN_WITH_KW_(pyopencv_cv_QRCodeDetector_decode, 0), "decode(img, points[, straight_qrcode]) -> retval, straight_qrcode\n.   @brief Decodes QR code in image once it's found by the detect() method.\n.        Returns UTF8-encoded output string or empty string if the code cannot be decoded.\n.   \n.        @param img grayscale or color (BGR) image containing QR code.\n.        @param points Quadrangle vertices found by detect() method (or some other algorithm).\n.        @param straight_qrcode The optional output image containing rectified and binarized QR code"},
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_QRCodeDetector_detect, 0), "detect(img[, points]) -> retval, points\n.   @brief Detects QR code in image and returns the quadrangle containing the code.\n.        @param img grayscale or color (BGR) image containing (or not) QR code.\n.        @param points Output vector of vertices of the minimum-area quadrangle containing the code."},
    {"detectAndDecode", CV_PY_FN_WITH_KW_(pyopencv_cv_QRCodeDetector_detectAndDecode, 0), "detectAndDecode(img[, points[, straight_qrcode]]) -> retval, points, straight_qrcode\n.   @brief Both detects and decodes QR code\n.   \n.        @param img grayscale or color (BGR) image containing QR code.\n.        @param points opiotnal output array of vertices of the found QR code quadrangle. Will be empty if not found.\n.        @param straight_qrcode The optional output image containing rectified and binarized QR code"},
    {"setEpsX", CV_PY_FN_WITH_KW_(pyopencv_cv_QRCodeDetector_setEpsX, 0), "setEpsX(epsX) -> None\n.   @brief sets the epsilon used during the horizontal scan of QR code stop marker detection.\n.        @param epsX Epsilon neighborhood, which allows you to determine the horizontal pattern\n.        of the scheme 1:1:3:1:1 according to QR code standard."},
    {"setEpsY", CV_PY_FN_WITH_KW_(pyopencv_cv_QRCodeDetector_setEpsY, 0), "setEpsY(epsY) -> None\n.   @brief sets the epsilon used during the vertical scan of QR code stop marker detection.\n.        @param epsY Epsilon neighborhood, which allows you to determine the vertical pattern\n.        of the scheme 1:1:3:1:1 according to QR code standard."},

    {NULL,          NULL}
};

// Converter (QRCodeDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::QRCodeDetector> >
{
    static PyObject* from(const Ptr<cv::QRCodeDetector>& r)
    {
        return pyopencv_QRCodeDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::QRCodeDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::QRCodeDetector> * dst_;
        if (pyopencv_QRCodeDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::QRCodeDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ShapeContextDistanceExtractor (Generic)
//================================================================================

// GetSet (ShapeContextDistanceExtractor)



// Methods (ShapeContextDistanceExtractor)

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getAngularBins(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAngularBins());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getBendingEnergyWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBendingEnergyWeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getCostExtractor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    Ptr<HistogramCostExtractor> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCostExtractor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getImageAppearanceWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getImageAppearanceWeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getImages(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    {
    PyObject* pyobj_image1 = NULL;
    Mat image1;
    PyObject* pyobj_image2 = NULL;
    Mat image2;

    const char* keywords[] = { "image1", "image2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:ShapeContextDistanceExtractor.getImages", (char**)keywords, &pyobj_image1, &pyobj_image2) &&
        pyopencv_to(pyobj_image1, image1, ArgInfo("image1", 1)) &&
        pyopencv_to(pyobj_image2, image2, ArgInfo("image2", 1)) )
    {
        ERRWRAP2(_self_->getImages(image1, image2));
        return Py_BuildValue("(NN)", pyopencv_from(image1), pyopencv_from(image2));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image1 = NULL;
    UMat image1;
    PyObject* pyobj_image2 = NULL;
    UMat image2;

    const char* keywords[] = { "image1", "image2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:ShapeContextDistanceExtractor.getImages", (char**)keywords, &pyobj_image1, &pyobj_image2) &&
        pyopencv_to(pyobj_image1, image1, ArgInfo("image1", 1)) &&
        pyopencv_to(pyobj_image2, image2, ArgInfo("image2", 1)) )
    {
        ERRWRAP2(_self_->getImages(image1, image2));
        return Py_BuildValue("(NN)", pyopencv_from(image1), pyopencv_from(image2));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getInnerRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInnerRadius());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getOuterRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getOuterRadius());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getRadialBins(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRadialBins());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getRotationInvariant(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRotationInvariant());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getShapeContextWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getShapeContextWeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getStdDev(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getStdDev());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_getTransformAlgorithm(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    Ptr<ShapeTransformer> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTransformAlgorithm());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setAngularBins(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    int nAngularBins=0;

    const char* keywords[] = { "nAngularBins", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ShapeContextDistanceExtractor.setAngularBins", (char**)keywords, &nAngularBins) )
    {
        ERRWRAP2(_self_->setAngularBins(nAngularBins));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setBendingEnergyWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float bendingEnergyWeight=0.f;

    const char* keywords[] = { "bendingEnergyWeight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ShapeContextDistanceExtractor.setBendingEnergyWeight", (char**)keywords, &bendingEnergyWeight) )
    {
        ERRWRAP2(_self_->setBendingEnergyWeight(bendingEnergyWeight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setCostExtractor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    PyObject* pyobj_comparer = NULL;
    Ptr<HistogramCostExtractor> comparer;

    const char* keywords[] = { "comparer", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ShapeContextDistanceExtractor.setCostExtractor", (char**)keywords, &pyobj_comparer) &&
        pyopencv_to(pyobj_comparer, comparer, ArgInfo("comparer", 0)) )
    {
        ERRWRAP2(_self_->setCostExtractor(comparer));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setImageAppearanceWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float imageAppearanceWeight=0.f;

    const char* keywords[] = { "imageAppearanceWeight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ShapeContextDistanceExtractor.setImageAppearanceWeight", (char**)keywords, &imageAppearanceWeight) )
    {
        ERRWRAP2(_self_->setImageAppearanceWeight(imageAppearanceWeight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setImages(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    {
    PyObject* pyobj_image1 = NULL;
    Mat image1;
    PyObject* pyobj_image2 = NULL;
    Mat image2;

    const char* keywords[] = { "image1", "image2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ShapeContextDistanceExtractor.setImages", (char**)keywords, &pyobj_image1, &pyobj_image2) &&
        pyopencv_to(pyobj_image1, image1, ArgInfo("image1", 0)) &&
        pyopencv_to(pyobj_image2, image2, ArgInfo("image2", 0)) )
    {
        ERRWRAP2(_self_->setImages(image1, image2));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image1 = NULL;
    UMat image1;
    PyObject* pyobj_image2 = NULL;
    UMat image2;

    const char* keywords[] = { "image1", "image2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ShapeContextDistanceExtractor.setImages", (char**)keywords, &pyobj_image1, &pyobj_image2) &&
        pyopencv_to(pyobj_image1, image1, ArgInfo("image1", 0)) &&
        pyopencv_to(pyobj_image2, image2, ArgInfo("image2", 0)) )
    {
        ERRWRAP2(_self_->setImages(image1, image2));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setInnerRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float innerRadius=0.f;

    const char* keywords[] = { "innerRadius", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ShapeContextDistanceExtractor.setInnerRadius", (char**)keywords, &innerRadius) )
    {
        ERRWRAP2(_self_->setInnerRadius(innerRadius));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    int iterations=0;

    const char* keywords[] = { "iterations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ShapeContextDistanceExtractor.setIterations", (char**)keywords, &iterations) )
    {
        ERRWRAP2(_self_->setIterations(iterations));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setOuterRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float outerRadius=0.f;

    const char* keywords[] = { "outerRadius", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ShapeContextDistanceExtractor.setOuterRadius", (char**)keywords, &outerRadius) )
    {
        ERRWRAP2(_self_->setOuterRadius(outerRadius));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setRadialBins(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    int nRadialBins=0;

    const char* keywords[] = { "nRadialBins", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ShapeContextDistanceExtractor.setRadialBins", (char**)keywords, &nRadialBins) )
    {
        ERRWRAP2(_self_->setRadialBins(nRadialBins));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setRotationInvariant(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    bool rotationInvariant=0;

    const char* keywords[] = { "rotationInvariant", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:ShapeContextDistanceExtractor.setRotationInvariant", (char**)keywords, &rotationInvariant) )
    {
        ERRWRAP2(_self_->setRotationInvariant(rotationInvariant));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setShapeContextWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float shapeContextWeight=0.f;

    const char* keywords[] = { "shapeContextWeight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ShapeContextDistanceExtractor.setShapeContextWeight", (char**)keywords, &shapeContextWeight) )
    {
        ERRWRAP2(_self_->setShapeContextWeight(shapeContextWeight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setStdDev(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    float sigma=0.f;

    const char* keywords[] = { "sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ShapeContextDistanceExtractor.setStdDev", (char**)keywords, &sigma) )
    {
        ERRWRAP2(_self_->setStdDev(sigma));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeContextDistanceExtractor_setTransformAlgorithm(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeContextDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeContextDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeContextDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeContextDistanceExtractor> _self_ = *(self1);
    PyObject* pyobj_transformer = NULL;
    Ptr<ShapeTransformer> transformer;

    const char* keywords[] = { "transformer", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ShapeContextDistanceExtractor.setTransformAlgorithm", (char**)keywords, &pyobj_transformer) &&
        pyopencv_to(pyobj_transformer, transformer, ArgInfo("transformer", 0)) )
    {
        ERRWRAP2(_self_->setTransformAlgorithm(transformer));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ShapeContextDistanceExtractor)

static PyGetSetDef pyopencv_ShapeContextDistanceExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ShapeContextDistanceExtractor_methods[] =
{
    {"getAngularBins", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getAngularBins, 0), "getAngularBins() -> retval\n."},
    {"getBendingEnergyWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getBendingEnergyWeight, 0), "getBendingEnergyWeight() -> retval\n."},
    {"getCostExtractor", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getCostExtractor, 0), "getCostExtractor() -> retval\n."},
    {"getImageAppearanceWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getImageAppearanceWeight, 0), "getImageAppearanceWeight() -> retval\n."},
    {"getImages", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getImages, 0), "getImages([, image1[, image2]]) -> image1, image2\n."},
    {"getInnerRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getInnerRadius, 0), "getInnerRadius() -> retval\n."},
    {"getIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getIterations, 0), "getIterations() -> retval\n."},
    {"getOuterRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getOuterRadius, 0), "getOuterRadius() -> retval\n."},
    {"getRadialBins", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getRadialBins, 0), "getRadialBins() -> retval\n."},
    {"getRotationInvariant", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getRotationInvariant, 0), "getRotationInvariant() -> retval\n."},
    {"getShapeContextWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getShapeContextWeight, 0), "getShapeContextWeight() -> retval\n."},
    {"getStdDev", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getStdDev, 0), "getStdDev() -> retval\n."},
    {"getTransformAlgorithm", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_getTransformAlgorithm, 0), "getTransformAlgorithm() -> retval\n."},
    {"setAngularBins", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setAngularBins, 0), "setAngularBins(nAngularBins) -> None\n.   @brief Establish the number of angular bins for the Shape Context Descriptor used in the shape matching\n.       pipeline.\n.   \n.       @param nAngularBins The number of angular bins in the shape context descriptor."},
    {"setBendingEnergyWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setBendingEnergyWeight, 0), "setBendingEnergyWeight(bendingEnergyWeight) -> None\n.   @brief Set the weight of the Bending Energy in the final value of the shape distance. The bending energy\n.       definition depends on what transformation is being used to align the shapes. The final value of the\n.       shape distance is a user-defined linear combination of the shape context distance, an image\n.       appearance distance, and a bending energy.\n.   \n.       @param bendingEnergyWeight The weight of the Bending Energy in the final distance value."},
    {"setCostExtractor", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setCostExtractor, 0), "setCostExtractor(comparer) -> None\n.   @brief Set the algorithm used for building the shape context descriptor cost matrix.\n.   \n.       @param comparer Smart pointer to a HistogramCostExtractor, an algorithm that defines the cost\n.       matrix between descriptors."},
    {"setImageAppearanceWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setImageAppearanceWeight, 0), "setImageAppearanceWeight(imageAppearanceWeight) -> None\n.   @brief Set the weight of the Image Appearance cost in the final value of the shape distance. The image\n.       appearance cost is defined as the sum of squared brightness differences in Gaussian windows around\n.       corresponding image points. The final value of the shape distance is a user-defined linear\n.       combination of the shape context distance, an image appearance distance, and a bending energy. If\n.       this value is set to a number different from 0, is mandatory to set the images that correspond to\n.       each shape.\n.   \n.       @param imageAppearanceWeight The weight of the appearance cost in the final distance value."},
    {"setImages", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setImages, 0), "setImages(image1, image2) -> None\n.   @brief Set the images that correspond to each shape. This images are used in the calculation of the Image\n.       Appearance cost.\n.   \n.       @param image1 Image corresponding to the shape defined by contours1.\n.       @param image2 Image corresponding to the shape defined by contours2."},
    {"setInnerRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setInnerRadius, 0), "setInnerRadius(innerRadius) -> None\n.   @brief Set the inner radius of the shape context descriptor.\n.   \n.       @param innerRadius The value of the inner radius."},
    {"setIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setIterations, 0), "setIterations(iterations) -> None\n."},
    {"setOuterRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setOuterRadius, 0), "setOuterRadius(outerRadius) -> None\n.   @brief Set the outer radius of the shape context descriptor.\n.   \n.       @param outerRadius The value of the outer radius."},
    {"setRadialBins", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setRadialBins, 0), "setRadialBins(nRadialBins) -> None\n.   @brief Establish the number of radial bins for the Shape Context Descriptor used in the shape matching\n.       pipeline.\n.   \n.       @param nRadialBins The number of radial bins in the shape context descriptor."},
    {"setRotationInvariant", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setRotationInvariant, 0), "setRotationInvariant(rotationInvariant) -> None\n."},
    {"setShapeContextWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setShapeContextWeight, 0), "setShapeContextWeight(shapeContextWeight) -> None\n.   @brief Set the weight of the shape context distance in the final value of the shape distance. The shape\n.       context distance between two shapes is defined as the symmetric sum of shape context matching costs\n.       over best matching points. The final value of the shape distance is a user-defined linear\n.       combination of the shape context distance, an image appearance distance, and a bending energy.\n.   \n.       @param shapeContextWeight The weight of the shape context distance in the final distance value."},
    {"setStdDev", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setStdDev, 0), "setStdDev(sigma) -> None\n.   @brief Set the value of the standard deviation for the Gaussian window for the image appearance cost.\n.   \n.       @param sigma Standard Deviation."},
    {"setTransformAlgorithm", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeContextDistanceExtractor_setTransformAlgorithm, 0), "setTransformAlgorithm(transformer) -> None\n.   @brief Set the algorithm used for aligning the shapes.\n.   \n.       @param transformer Smart pointer to a ShapeTransformer, an algorithm that defines the aligning\n.       transformation."},

    {NULL,          NULL}
};

// Converter (ShapeContextDistanceExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::ShapeContextDistanceExtractor> >
{
    static PyObject* from(const Ptr<cv::ShapeContextDistanceExtractor>& r)
    {
        return pyopencv_ShapeContextDistanceExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ShapeContextDistanceExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ShapeContextDistanceExtractor> * dst_;
        if (pyopencv_ShapeContextDistanceExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ShapeContextDistanceExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ShapeDistanceExtractor (Generic)
//================================================================================

// GetSet (ShapeDistanceExtractor)



// Methods (ShapeDistanceExtractor)

static PyObject* pyopencv_cv_ShapeDistanceExtractor_computeDistance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeDistanceExtractor> * self1 = 0;
    if (!pyopencv_ShapeDistanceExtractor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeDistanceExtractor' or its derivative)");
    Ptr<cv::ShapeDistanceExtractor> _self_ = *(self1);
    {
    PyObject* pyobj_contour1 = NULL;
    Mat contour1;
    PyObject* pyobj_contour2 = NULL;
    Mat contour2;
    float retval;

    const char* keywords[] = { "contour1", "contour2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ShapeDistanceExtractor.computeDistance", (char**)keywords, &pyobj_contour1, &pyobj_contour2) &&
        pyopencv_to(pyobj_contour1, contour1, ArgInfo("contour1", 0)) &&
        pyopencv_to(pyobj_contour2, contour2, ArgInfo("contour2", 0)) )
    {
        ERRWRAP2(retval = _self_->computeDistance(contour1, contour2));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_contour1 = NULL;
    UMat contour1;
    PyObject* pyobj_contour2 = NULL;
    UMat contour2;
    float retval;

    const char* keywords[] = { "contour1", "contour2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ShapeDistanceExtractor.computeDistance", (char**)keywords, &pyobj_contour1, &pyobj_contour2) &&
        pyopencv_to(pyobj_contour1, contour1, ArgInfo("contour1", 0)) &&
        pyopencv_to(pyobj_contour2, contour2, ArgInfo("contour2", 0)) )
    {
        ERRWRAP2(retval = _self_->computeDistance(contour1, contour2));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (ShapeDistanceExtractor)

static PyGetSetDef pyopencv_ShapeDistanceExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ShapeDistanceExtractor_methods[] =
{
    {"computeDistance", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeDistanceExtractor_computeDistance, 0), "computeDistance(contour1, contour2) -> retval\n.   @brief Compute the shape distance between two shapes defined by its contours.\n.   \n.       @param contour1 Contour defining first shape.\n.       @param contour2 Contour defining second shape."},

    {NULL,          NULL}
};

// Converter (ShapeDistanceExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::ShapeDistanceExtractor> >
{
    static PyObject* from(const Ptr<cv::ShapeDistanceExtractor>& r)
    {
        return pyopencv_ShapeDistanceExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ShapeDistanceExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ShapeDistanceExtractor> * dst_;
        if (pyopencv_ShapeDistanceExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ShapeDistanceExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ShapeTransformer (Generic)
//================================================================================

// GetSet (ShapeTransformer)



// Methods (ShapeTransformer)

static PyObject* pyopencv_cv_ShapeTransformer_applyTransformation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeTransformer> * self1 = 0;
    if (!pyopencv_ShapeTransformer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeTransformer' or its derivative)");
    Ptr<cv::ShapeTransformer> _self_ = *(self1);
    {
    PyObject* pyobj_input = NULL;
    Mat input;
    PyObject* pyobj_output = NULL;
    Mat output;
    float retval;

    const char* keywords[] = { "input", "output", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ShapeTransformer.applyTransformation", (char**)keywords, &pyobj_input, &pyobj_output) &&
        pyopencv_to(pyobj_input, input, ArgInfo("input", 0)) &&
        pyopencv_to(pyobj_output, output, ArgInfo("output", 1)) )
    {
        ERRWRAP2(retval = _self_->applyTransformation(input, output));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(output));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_input = NULL;
    UMat input;
    PyObject* pyobj_output = NULL;
    UMat output;
    float retval;

    const char* keywords[] = { "input", "output", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ShapeTransformer.applyTransformation", (char**)keywords, &pyobj_input, &pyobj_output) &&
        pyopencv_to(pyobj_input, input, ArgInfo("input", 0)) &&
        pyopencv_to(pyobj_output, output, ArgInfo("output", 1)) )
    {
        ERRWRAP2(retval = _self_->applyTransformation(input, output));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(output));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeTransformer_estimateTransformation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeTransformer> * self1 = 0;
    if (!pyopencv_ShapeTransformer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeTransformer' or its derivative)");
    Ptr<cv::ShapeTransformer> _self_ = *(self1);
    {
    PyObject* pyobj_transformingShape = NULL;
    Mat transformingShape;
    PyObject* pyobj_targetShape = NULL;
    Mat targetShape;
    PyObject* pyobj_matches = NULL;
    vector_DMatch matches;

    const char* keywords[] = { "transformingShape", "targetShape", "matches", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:ShapeTransformer.estimateTransformation", (char**)keywords, &pyobj_transformingShape, &pyobj_targetShape, &pyobj_matches) &&
        pyopencv_to(pyobj_transformingShape, transformingShape, ArgInfo("transformingShape", 0)) &&
        pyopencv_to(pyobj_targetShape, targetShape, ArgInfo("targetShape", 0)) &&
        pyopencv_to(pyobj_matches, matches, ArgInfo("matches", 0)) )
    {
        ERRWRAP2(_self_->estimateTransformation(transformingShape, targetShape, matches));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_transformingShape = NULL;
    UMat transformingShape;
    PyObject* pyobj_targetShape = NULL;
    UMat targetShape;
    PyObject* pyobj_matches = NULL;
    vector_DMatch matches;

    const char* keywords[] = { "transformingShape", "targetShape", "matches", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:ShapeTransformer.estimateTransformation", (char**)keywords, &pyobj_transformingShape, &pyobj_targetShape, &pyobj_matches) &&
        pyopencv_to(pyobj_transformingShape, transformingShape, ArgInfo("transformingShape", 0)) &&
        pyopencv_to(pyobj_targetShape, targetShape, ArgInfo("targetShape", 0)) &&
        pyopencv_to(pyobj_matches, matches, ArgInfo("matches", 0)) )
    {
        ERRWRAP2(_self_->estimateTransformation(transformingShape, targetShape, matches));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ShapeTransformer_warpImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ShapeTransformer> * self1 = 0;
    if (!pyopencv_ShapeTransformer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ShapeTransformer' or its derivative)");
    Ptr<cv::ShapeTransformer> _self_ = *(self1);
    {
    PyObject* pyobj_transformingImage = NULL;
    Mat transformingImage;
    PyObject* pyobj_output = NULL;
    Mat output;
    int flags=INTER_LINEAR;
    int borderMode=BORDER_CONSTANT;
    PyObject* pyobj_borderValue = NULL;
    Scalar borderValue;

    const char* keywords[] = { "transformingImage", "output", "flags", "borderMode", "borderValue", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OiiO:ShapeTransformer.warpImage", (char**)keywords, &pyobj_transformingImage, &pyobj_output, &flags, &borderMode, &pyobj_borderValue) &&
        pyopencv_to(pyobj_transformingImage, transformingImage, ArgInfo("transformingImage", 0)) &&
        pyopencv_to(pyobj_output, output, ArgInfo("output", 1)) &&
        pyopencv_to(pyobj_borderValue, borderValue, ArgInfo("borderValue", 0)) )
    {
        ERRWRAP2(_self_->warpImage(transformingImage, output, flags, borderMode, borderValue));
        return pyopencv_from(output);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_transformingImage = NULL;
    UMat transformingImage;
    PyObject* pyobj_output = NULL;
    UMat output;
    int flags=INTER_LINEAR;
    int borderMode=BORDER_CONSTANT;
    PyObject* pyobj_borderValue = NULL;
    Scalar borderValue;

    const char* keywords[] = { "transformingImage", "output", "flags", "borderMode", "borderValue", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OiiO:ShapeTransformer.warpImage", (char**)keywords, &pyobj_transformingImage, &pyobj_output, &flags, &borderMode, &pyobj_borderValue) &&
        pyopencv_to(pyobj_transformingImage, transformingImage, ArgInfo("transformingImage", 0)) &&
        pyopencv_to(pyobj_output, output, ArgInfo("output", 1)) &&
        pyopencv_to(pyobj_borderValue, borderValue, ArgInfo("borderValue", 0)) )
    {
        ERRWRAP2(_self_->warpImage(transformingImage, output, flags, borderMode, borderValue));
        return pyopencv_from(output);
    }
    }

    return NULL;
}



// Tables (ShapeTransformer)

static PyGetSetDef pyopencv_ShapeTransformer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ShapeTransformer_methods[] =
{
    {"applyTransformation", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeTransformer_applyTransformation, 0), "applyTransformation(input[, output]) -> retval, output\n.   @brief Apply a transformation, given a pre-estimated transformation parameters.\n.   \n.       @param input Contour (set of points) to apply the transformation.\n.       @param output Output contour."},
    {"estimateTransformation", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeTransformer_estimateTransformation, 0), "estimateTransformation(transformingShape, targetShape, matches) -> None\n.   @brief Estimate the transformation parameters of the current transformer algorithm, based on point matches.\n.   \n.       @param transformingShape Contour defining first shape.\n.       @param targetShape Contour defining second shape (Target).\n.       @param matches Standard vector of Matches between points."},
    {"warpImage", CV_PY_FN_WITH_KW_(pyopencv_cv_ShapeTransformer_warpImage, 0), "warpImage(transformingImage[, output[, flags[, borderMode[, borderValue]]]]) -> output\n.   @brief Apply a transformation, given a pre-estimated transformation parameters, to an Image.\n.   \n.       @param transformingImage Input image.\n.       @param output Output image.\n.       @param flags Image interpolation method.\n.       @param borderMode border style.\n.       @param borderValue border value."},

    {NULL,          NULL}
};

// Converter (ShapeTransformer)

template<>
struct PyOpenCV_Converter< Ptr<cv::ShapeTransformer> >
{
    static PyObject* from(const Ptr<cv::ShapeTransformer>& r)
    {
        return pyopencv_ShapeTransformer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ShapeTransformer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ShapeTransformer> * dst_;
        if (pyopencv_ShapeTransformer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ShapeTransformer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// SimpleBlobDetector (Generic)
//================================================================================

// GetSet (SimpleBlobDetector)



// Methods (SimpleBlobDetector)

static PyObject* pyopencv_cv_SimpleBlobDetector_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_parameters = NULL;
    SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params();
    Ptr<SimpleBlobDetector> retval;

    const char* keywords[] = { "parameters", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:SimpleBlobDetector.create", (char**)keywords, &pyobj_parameters) &&
        pyopencv_to(pyobj_parameters, parameters, ArgInfo("parameters", 0)) )
    {
        ERRWRAP2(retval = cv::SimpleBlobDetector::create(parameters));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_SimpleBlobDetector_getDefaultName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SimpleBlobDetector> * self1 = 0;
    if (!pyopencv_SimpleBlobDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SimpleBlobDetector' or its derivative)");
    Ptr<cv::SimpleBlobDetector> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultName());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (SimpleBlobDetector)

static PyGetSetDef pyopencv_SimpleBlobDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_SimpleBlobDetector_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_SimpleBlobDetector_create_static, METH_STATIC), "create([, parameters]) -> retval\n."},
    {"getDefaultName", CV_PY_FN_WITH_KW_(pyopencv_cv_SimpleBlobDetector_getDefaultName, 0), "getDefaultName() -> retval\n."},

    {NULL,          NULL}
};

// Converter (SimpleBlobDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::SimpleBlobDetector> >
{
    static PyObject* from(const Ptr<cv::SimpleBlobDetector>& r)
    {
        return pyopencv_SimpleBlobDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::SimpleBlobDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::SimpleBlobDetector> * dst_;
        if (pyopencv_SimpleBlobDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::SimpleBlobDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// SimpleBlobDetector_Params (Generic)
//================================================================================

// GetSet (SimpleBlobDetector_Params)


static PyObject* pyopencv_SimpleBlobDetector_Params_get_blobColor(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.blobColor);
}

static int pyopencv_SimpleBlobDetector_Params_set_blobColor(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the blobColor attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.blobColor) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_filterByArea(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.filterByArea);
}

static int pyopencv_SimpleBlobDetector_Params_set_filterByArea(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the filterByArea attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.filterByArea) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_filterByCircularity(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.filterByCircularity);
}

static int pyopencv_SimpleBlobDetector_Params_set_filterByCircularity(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the filterByCircularity attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.filterByCircularity) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_filterByColor(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.filterByColor);
}

static int pyopencv_SimpleBlobDetector_Params_set_filterByColor(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the filterByColor attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.filterByColor) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_filterByConvexity(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.filterByConvexity);
}

static int pyopencv_SimpleBlobDetector_Params_set_filterByConvexity(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the filterByConvexity attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.filterByConvexity) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_filterByInertia(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.filterByInertia);
}

static int pyopencv_SimpleBlobDetector_Params_set_filterByInertia(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the filterByInertia attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.filterByInertia) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_maxArea(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.maxArea);
}

static int pyopencv_SimpleBlobDetector_Params_set_maxArea(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxArea attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.maxArea) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_maxCircularity(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.maxCircularity);
}

static int pyopencv_SimpleBlobDetector_Params_set_maxCircularity(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxCircularity attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.maxCircularity) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_maxConvexity(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.maxConvexity);
}

static int pyopencv_SimpleBlobDetector_Params_set_maxConvexity(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxConvexity attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.maxConvexity) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_maxInertiaRatio(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.maxInertiaRatio);
}

static int pyopencv_SimpleBlobDetector_Params_set_maxInertiaRatio(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxInertiaRatio attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.maxInertiaRatio) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_maxThreshold(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.maxThreshold);
}

static int pyopencv_SimpleBlobDetector_Params_set_maxThreshold(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxThreshold attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.maxThreshold) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_minArea(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.minArea);
}

static int pyopencv_SimpleBlobDetector_Params_set_minArea(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minArea attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minArea) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_minCircularity(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.minCircularity);
}

static int pyopencv_SimpleBlobDetector_Params_set_minCircularity(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minCircularity attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minCircularity) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_minConvexity(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.minConvexity);
}

static int pyopencv_SimpleBlobDetector_Params_set_minConvexity(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minConvexity attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minConvexity) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_minDistBetweenBlobs(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.minDistBetweenBlobs);
}

static int pyopencv_SimpleBlobDetector_Params_set_minDistBetweenBlobs(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minDistBetweenBlobs attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minDistBetweenBlobs) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_minInertiaRatio(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.minInertiaRatio);
}

static int pyopencv_SimpleBlobDetector_Params_set_minInertiaRatio(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minInertiaRatio attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minInertiaRatio) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_minRepeatability(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.minRepeatability);
}

static int pyopencv_SimpleBlobDetector_Params_set_minRepeatability(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minRepeatability attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minRepeatability) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_minThreshold(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.minThreshold);
}

static int pyopencv_SimpleBlobDetector_Params_set_minThreshold(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minThreshold attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.minThreshold) ? 0 : -1;
}

static PyObject* pyopencv_SimpleBlobDetector_Params_get_thresholdStep(pyopencv_SimpleBlobDetector_Params_t* p, void *closure)
{
    return pyopencv_from(p->v.thresholdStep);
}

static int pyopencv_SimpleBlobDetector_Params_set_thresholdStep(pyopencv_SimpleBlobDetector_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the thresholdStep attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.thresholdStep) ? 0 : -1;
}


// Methods (SimpleBlobDetector_Params)

static int pyopencv_cv_SimpleBlobDetector_Params_SimpleBlobDetector_Params(pyopencv_SimpleBlobDetector_Params_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::SimpleBlobDetector::Params());
        return 0;
    }

    return -1;
}



// Tables (SimpleBlobDetector_Params)

static PyGetSetDef pyopencv_SimpleBlobDetector_Params_getseters[] =
{
    {(char*)"blobColor", (getter)pyopencv_SimpleBlobDetector_Params_get_blobColor, (setter)pyopencv_SimpleBlobDetector_Params_set_blobColor, (char*)"blobColor", NULL},
    {(char*)"filterByArea", (getter)pyopencv_SimpleBlobDetector_Params_get_filterByArea, (setter)pyopencv_SimpleBlobDetector_Params_set_filterByArea, (char*)"filterByArea", NULL},
    {(char*)"filterByCircularity", (getter)pyopencv_SimpleBlobDetector_Params_get_filterByCircularity, (setter)pyopencv_SimpleBlobDetector_Params_set_filterByCircularity, (char*)"filterByCircularity", NULL},
    {(char*)"filterByColor", (getter)pyopencv_SimpleBlobDetector_Params_get_filterByColor, (setter)pyopencv_SimpleBlobDetector_Params_set_filterByColor, (char*)"filterByColor", NULL},
    {(char*)"filterByConvexity", (getter)pyopencv_SimpleBlobDetector_Params_get_filterByConvexity, (setter)pyopencv_SimpleBlobDetector_Params_set_filterByConvexity, (char*)"filterByConvexity", NULL},
    {(char*)"filterByInertia", (getter)pyopencv_SimpleBlobDetector_Params_get_filterByInertia, (setter)pyopencv_SimpleBlobDetector_Params_set_filterByInertia, (char*)"filterByInertia", NULL},
    {(char*)"maxArea", (getter)pyopencv_SimpleBlobDetector_Params_get_maxArea, (setter)pyopencv_SimpleBlobDetector_Params_set_maxArea, (char*)"maxArea", NULL},
    {(char*)"maxCircularity", (getter)pyopencv_SimpleBlobDetector_Params_get_maxCircularity, (setter)pyopencv_SimpleBlobDetector_Params_set_maxCircularity, (char*)"maxCircularity", NULL},
    {(char*)"maxConvexity", (getter)pyopencv_SimpleBlobDetector_Params_get_maxConvexity, (setter)pyopencv_SimpleBlobDetector_Params_set_maxConvexity, (char*)"maxConvexity", NULL},
    {(char*)"maxInertiaRatio", (getter)pyopencv_SimpleBlobDetector_Params_get_maxInertiaRatio, (setter)pyopencv_SimpleBlobDetector_Params_set_maxInertiaRatio, (char*)"maxInertiaRatio", NULL},
    {(char*)"maxThreshold", (getter)pyopencv_SimpleBlobDetector_Params_get_maxThreshold, (setter)pyopencv_SimpleBlobDetector_Params_set_maxThreshold, (char*)"maxThreshold", NULL},
    {(char*)"minArea", (getter)pyopencv_SimpleBlobDetector_Params_get_minArea, (setter)pyopencv_SimpleBlobDetector_Params_set_minArea, (char*)"minArea", NULL},
    {(char*)"minCircularity", (getter)pyopencv_SimpleBlobDetector_Params_get_minCircularity, (setter)pyopencv_SimpleBlobDetector_Params_set_minCircularity, (char*)"minCircularity", NULL},
    {(char*)"minConvexity", (getter)pyopencv_SimpleBlobDetector_Params_get_minConvexity, (setter)pyopencv_SimpleBlobDetector_Params_set_minConvexity, (char*)"minConvexity", NULL},
    {(char*)"minDistBetweenBlobs", (getter)pyopencv_SimpleBlobDetector_Params_get_minDistBetweenBlobs, (setter)pyopencv_SimpleBlobDetector_Params_set_minDistBetweenBlobs, (char*)"minDistBetweenBlobs", NULL},
    {(char*)"minInertiaRatio", (getter)pyopencv_SimpleBlobDetector_Params_get_minInertiaRatio, (setter)pyopencv_SimpleBlobDetector_Params_set_minInertiaRatio, (char*)"minInertiaRatio", NULL},
    {(char*)"minRepeatability", (getter)pyopencv_SimpleBlobDetector_Params_get_minRepeatability, (setter)pyopencv_SimpleBlobDetector_Params_set_minRepeatability, (char*)"minRepeatability", NULL},
    {(char*)"minThreshold", (getter)pyopencv_SimpleBlobDetector_Params_get_minThreshold, (setter)pyopencv_SimpleBlobDetector_Params_set_minThreshold, (char*)"minThreshold", NULL},
    {(char*)"thresholdStep", (getter)pyopencv_SimpleBlobDetector_Params_get_thresholdStep, (setter)pyopencv_SimpleBlobDetector_Params_set_thresholdStep, (char*)"thresholdStep", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_SimpleBlobDetector_Params_methods[] =
{

    {NULL,          NULL}
};

// Converter (SimpleBlobDetector_Params)

template<>
struct PyOpenCV_Converter< cv::SimpleBlobDetector::Params >
{
    static PyObject* from(const cv::SimpleBlobDetector::Params& r)
    {
        return pyopencv_SimpleBlobDetector_Params_Instance(r);
    }
    static bool to(PyObject* src, cv::SimpleBlobDetector::Params& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::SimpleBlobDetector::Params * dst_;
        if (pyopencv_SimpleBlobDetector_Params_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::SimpleBlobDetector::Params for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// SparseOpticalFlow (Generic)
//================================================================================

// GetSet (SparseOpticalFlow)



// Methods (SparseOpticalFlow)

static PyObject* pyopencv_cv_SparseOpticalFlow_calc(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparseOpticalFlow> * self1 = 0;
    if (!pyopencv_SparseOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparseOpticalFlow' or its derivative)");
    Ptr<cv::SparseOpticalFlow> _self_ = *(self1);
    {
    PyObject* pyobj_prevImg = NULL;
    Mat prevImg;
    PyObject* pyobj_nextImg = NULL;
    Mat nextImg;
    PyObject* pyobj_prevPts = NULL;
    Mat prevPts;
    PyObject* pyobj_nextPts = NULL;
    Mat nextPts;
    PyObject* pyobj_status = NULL;
    Mat status;
    PyObject* pyobj_err = NULL;
    Mat err;

    const char* keywords[] = { "prevImg", "nextImg", "prevPts", "nextPts", "status", "err", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|OO:SparseOpticalFlow.calc", (char**)keywords, &pyobj_prevImg, &pyobj_nextImg, &pyobj_prevPts, &pyobj_nextPts, &pyobj_status, &pyobj_err) &&
        pyopencv_to(pyobj_prevImg, prevImg, ArgInfo("prevImg", 0)) &&
        pyopencv_to(pyobj_nextImg, nextImg, ArgInfo("nextImg", 0)) &&
        pyopencv_to(pyobj_prevPts, prevPts, ArgInfo("prevPts", 0)) &&
        pyopencv_to(pyobj_nextPts, nextPts, ArgInfo("nextPts", 1)) &&
        pyopencv_to(pyobj_status, status, ArgInfo("status", 1)) &&
        pyopencv_to(pyobj_err, err, ArgInfo("err", 1)) )
    {
        ERRWRAP2(_self_->calc(prevImg, nextImg, prevPts, nextPts, status, err));
        return Py_BuildValue("(NNN)", pyopencv_from(nextPts), pyopencv_from(status), pyopencv_from(err));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_prevImg = NULL;
    UMat prevImg;
    PyObject* pyobj_nextImg = NULL;
    UMat nextImg;
    PyObject* pyobj_prevPts = NULL;
    UMat prevPts;
    PyObject* pyobj_nextPts = NULL;
    UMat nextPts;
    PyObject* pyobj_status = NULL;
    UMat status;
    PyObject* pyobj_err = NULL;
    UMat err;

    const char* keywords[] = { "prevImg", "nextImg", "prevPts", "nextPts", "status", "err", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|OO:SparseOpticalFlow.calc", (char**)keywords, &pyobj_prevImg, &pyobj_nextImg, &pyobj_prevPts, &pyobj_nextPts, &pyobj_status, &pyobj_err) &&
        pyopencv_to(pyobj_prevImg, prevImg, ArgInfo("prevImg", 0)) &&
        pyopencv_to(pyobj_nextImg, nextImg, ArgInfo("nextImg", 0)) &&
        pyopencv_to(pyobj_prevPts, prevPts, ArgInfo("prevPts", 0)) &&
        pyopencv_to(pyobj_nextPts, nextPts, ArgInfo("nextPts", 1)) &&
        pyopencv_to(pyobj_status, status, ArgInfo("status", 1)) &&
        pyopencv_to(pyobj_err, err, ArgInfo("err", 1)) )
    {
        ERRWRAP2(_self_->calc(prevImg, nextImg, prevPts, nextPts, status, err));
        return Py_BuildValue("(NNN)", pyopencv_from(nextPts), pyopencv_from(status), pyopencv_from(err));
    }
    }

    return NULL;
}



// Tables (SparseOpticalFlow)

static PyGetSetDef pyopencv_SparseOpticalFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_SparseOpticalFlow_methods[] =
{
    {"calc", CV_PY_FN_WITH_KW_(pyopencv_cv_SparseOpticalFlow_calc, 0), "calc(prevImg, nextImg, prevPts, nextPts[, status[, err]]) -> nextPts, status, err\n.   @brief Calculates a sparse optical flow.\n.   \n.       @param prevImg First input image.\n.       @param nextImg Second input image of the same size and the same type as prevImg.\n.       @param prevPts Vector of 2D points for which the flow needs to be found.\n.       @param nextPts Output vector of 2D points containing the calculated new positions of input features in the second image.\n.       @param status Output status vector. Each element of the vector is set to 1 if the\n.                     flow for the corresponding features has been found. Otherwise, it is set to 0.\n.       @param err Optional output vector that contains error response for each point (inverse confidence)."},

    {NULL,          NULL}
};

// Converter (SparseOpticalFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::SparseOpticalFlow> >
{
    static PyObject* from(const Ptr<cv::SparseOpticalFlow>& r)
    {
        return pyopencv_SparseOpticalFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::SparseOpticalFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::SparseOpticalFlow> * dst_;
        if (pyopencv_SparseOpticalFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::SparseOpticalFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// SparsePyrLKOpticalFlow (Generic)
//================================================================================

// GetSet (SparsePyrLKOpticalFlow)



// Methods (SparsePyrLKOpticalFlow)

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_winSize = NULL;
    Size winSize=Size(21, 21);
    int maxLevel=3;
    PyObject* pyobj_crit = NULL;
    TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01);
    int flags=0;
    double minEigThreshold=1e-4;
    Ptr<SparsePyrLKOpticalFlow> retval;

    const char* keywords[] = { "winSize", "maxLevel", "crit", "flags", "minEigThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OiOid:SparsePyrLKOpticalFlow.create", (char**)keywords, &pyobj_winSize, &maxLevel, &pyobj_crit, &flags, &minEigThreshold) &&
        pyopencv_to(pyobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        pyopencv_to(pyobj_crit, crit, ArgInfo("crit", 0)) )
    {
        ERRWRAP2(retval = cv::SparsePyrLKOpticalFlow::create(winSize, maxLevel, crit, flags, minEigThreshold));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_getFlags(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFlags());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_getMaxLevel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxLevel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_getMinEigThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinEigThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_getTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    TermCriteria retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTermCriteria());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_getWinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWinSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_setFlags(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    int flags=0;

    const char* keywords[] = { "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:SparsePyrLKOpticalFlow.setFlags", (char**)keywords, &flags) )
    {
        ERRWRAP2(_self_->setFlags(flags));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_setMaxLevel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    int maxLevel=0;

    const char* keywords[] = { "maxLevel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:SparsePyrLKOpticalFlow.setMaxLevel", (char**)keywords, &maxLevel) )
    {
        ERRWRAP2(_self_->setMaxLevel(maxLevel));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_setMinEigThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    double minEigThreshold=0;

    const char* keywords[] = { "minEigThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:SparsePyrLKOpticalFlow.setMinEigThreshold", (char**)keywords, &minEigThreshold) )
    {
        ERRWRAP2(_self_->setMinEigThreshold(minEigThreshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_setTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    PyObject* pyobj_crit = NULL;
    TermCriteria crit;

    const char* keywords[] = { "crit", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:SparsePyrLKOpticalFlow.setTermCriteria", (char**)keywords, &pyobj_crit) &&
        pyopencv_to(pyobj_crit, crit, ArgInfo("crit", 0)) )
    {
        ERRWRAP2(_self_->setTermCriteria(crit));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_SparsePyrLKOpticalFlow_setWinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::SparsePyrLKOpticalFlow> * self1 = 0;
    if (!pyopencv_SparsePyrLKOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'SparsePyrLKOpticalFlow' or its derivative)");
    Ptr<cv::SparsePyrLKOpticalFlow> _self_ = *(self1);
    PyObject* pyobj_winSize = NULL;
    Size winSize;

    const char* keywords[] = { "winSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:SparsePyrLKOpticalFlow.setWinSize", (char**)keywords, &pyobj_winSize) &&
        pyopencv_to(pyobj_winSize, winSize, ArgInfo("winSize", 0)) )
    {
        ERRWRAP2(_self_->setWinSize(winSize));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (SparsePyrLKOpticalFlow)

static PyGetSetDef pyopencv_SparsePyrLKOpticalFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_SparsePyrLKOpticalFlow_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_create_static, METH_STATIC), "create([, winSize[, maxLevel[, crit[, flags[, minEigThreshold]]]]]) -> retval\n."},
    {"getFlags", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_getFlags, 0), "getFlags() -> retval\n."},
    {"getMaxLevel", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_getMaxLevel, 0), "getMaxLevel() -> retval\n."},
    {"getMinEigThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_getMinEigThreshold, 0), "getMinEigThreshold() -> retval\n."},
    {"getTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_getTermCriteria, 0), "getTermCriteria() -> retval\n."},
    {"getWinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_getWinSize, 0), "getWinSize() -> retval\n."},
    {"setFlags", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_setFlags, 0), "setFlags(flags) -> None\n."},
    {"setMaxLevel", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_setMaxLevel, 0), "setMaxLevel(maxLevel) -> None\n."},
    {"setMinEigThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_setMinEigThreshold, 0), "setMinEigThreshold(minEigThreshold) -> None\n."},
    {"setTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_setTermCriteria, 0), "setTermCriteria(crit) -> None\n."},
    {"setWinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_SparsePyrLKOpticalFlow_setWinSize, 0), "setWinSize(winSize) -> None\n."},

    {NULL,          NULL}
};

// Converter (SparsePyrLKOpticalFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::SparsePyrLKOpticalFlow> >
{
    static PyObject* from(const Ptr<cv::SparsePyrLKOpticalFlow>& r)
    {
        return pyopencv_SparsePyrLKOpticalFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::SparsePyrLKOpticalFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::SparsePyrLKOpticalFlow> * dst_;
        if (pyopencv_SparsePyrLKOpticalFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::SparsePyrLKOpticalFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// StereoBM (Generic)
//================================================================================

// GetSet (StereoBM)



// Methods (StereoBM)

static PyObject* pyopencv_cv_StereoBM_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int numDisparities=0;
    int blockSize=21;
    Ptr<StereoBM> retval;

    const char* keywords[] = { "numDisparities", "blockSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ii:StereoBM.create", (char**)keywords, &numDisparities, &blockSize) )
    {
        ERRWRAP2(retval = cv::StereoBM::create(numDisparities, blockSize));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_getPreFilterCap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPreFilterCap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_getPreFilterSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPreFilterSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_getPreFilterType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPreFilterType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_getROI1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    Rect retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getROI1());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_getROI2(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    Rect retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getROI2());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_getSmallerBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSmallerBlockSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_getTextureThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTextureThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_getUniquenessRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUniquenessRatio());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_setPreFilterCap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int preFilterCap=0;

    const char* keywords[] = { "preFilterCap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoBM.setPreFilterCap", (char**)keywords, &preFilterCap) )
    {
        ERRWRAP2(_self_->setPreFilterCap(preFilterCap));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_setPreFilterSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int preFilterSize=0;

    const char* keywords[] = { "preFilterSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoBM.setPreFilterSize", (char**)keywords, &preFilterSize) )
    {
        ERRWRAP2(_self_->setPreFilterSize(preFilterSize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_setPreFilterType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int preFilterType=0;

    const char* keywords[] = { "preFilterType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoBM.setPreFilterType", (char**)keywords, &preFilterType) )
    {
        ERRWRAP2(_self_->setPreFilterType(preFilterType));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_setROI1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    PyObject* pyobj_roi1 = NULL;
    Rect roi1;

    const char* keywords[] = { "roi1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:StereoBM.setROI1", (char**)keywords, &pyobj_roi1) &&
        pyopencv_to(pyobj_roi1, roi1, ArgInfo("roi1", 0)) )
    {
        ERRWRAP2(_self_->setROI1(roi1));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_setROI2(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    PyObject* pyobj_roi2 = NULL;
    Rect roi2;

    const char* keywords[] = { "roi2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:StereoBM.setROI2", (char**)keywords, &pyobj_roi2) &&
        pyopencv_to(pyobj_roi2, roi2, ArgInfo("roi2", 0)) )
    {
        ERRWRAP2(_self_->setROI2(roi2));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_setSmallerBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int blockSize=0;

    const char* keywords[] = { "blockSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoBM.setSmallerBlockSize", (char**)keywords, &blockSize) )
    {
        ERRWRAP2(_self_->setSmallerBlockSize(blockSize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_setTextureThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int textureThreshold=0;

    const char* keywords[] = { "textureThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoBM.setTextureThreshold", (char**)keywords, &textureThreshold) )
    {
        ERRWRAP2(_self_->setTextureThreshold(textureThreshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoBM_setUniquenessRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoBM> * self1 = 0;
    if (!pyopencv_StereoBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoBM' or its derivative)");
    Ptr<cv::StereoBM> _self_ = *(self1);
    int uniquenessRatio=0;

    const char* keywords[] = { "uniquenessRatio", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoBM.setUniquenessRatio", (char**)keywords, &uniquenessRatio) )
    {
        ERRWRAP2(_self_->setUniquenessRatio(uniquenessRatio));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (StereoBM)

static PyGetSetDef pyopencv_StereoBM_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_StereoBM_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_create_static, METH_STATIC), "create([, numDisparities[, blockSize]]) -> retval\n.   @brief Creates StereoBM object\n.   \n.       @param numDisparities the disparity search range. For each pixel algorithm will find the best\n.       disparity from 0 (default minimum disparity) to numDisparities. The search range can then be\n.       shifted by changing the minimum disparity.\n.       @param blockSize the linear size of the blocks compared by the algorithm. The size should be odd\n.       (as the block is centered at the current pixel). Larger block size implies smoother, though less\n.       accurate disparity map. Smaller block size gives more detailed disparity map, but there is higher\n.       chance for algorithm to find a wrong correspondence.\n.   \n.       The function create StereoBM object. You can then call StereoBM::compute() to compute disparity for\n.       a specific stereo pair."},
    {"getPreFilterCap", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_getPreFilterCap, 0), "getPreFilterCap() -> retval\n."},
    {"getPreFilterSize", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_getPreFilterSize, 0), "getPreFilterSize() -> retval\n."},
    {"getPreFilterType", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_getPreFilterType, 0), "getPreFilterType() -> retval\n."},
    {"getROI1", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_getROI1, 0), "getROI1() -> retval\n."},
    {"getROI2", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_getROI2, 0), "getROI2() -> retval\n."},
    {"getSmallerBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_getSmallerBlockSize, 0), "getSmallerBlockSize() -> retval\n."},
    {"getTextureThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_getTextureThreshold, 0), "getTextureThreshold() -> retval\n."},
    {"getUniquenessRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_getUniquenessRatio, 0), "getUniquenessRatio() -> retval\n."},
    {"setPreFilterCap", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_setPreFilterCap, 0), "setPreFilterCap(preFilterCap) -> None\n."},
    {"setPreFilterSize", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_setPreFilterSize, 0), "setPreFilterSize(preFilterSize) -> None\n."},
    {"setPreFilterType", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_setPreFilterType, 0), "setPreFilterType(preFilterType) -> None\n."},
    {"setROI1", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_setROI1, 0), "setROI1(roi1) -> None\n."},
    {"setROI2", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_setROI2, 0), "setROI2(roi2) -> None\n."},
    {"setSmallerBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_setSmallerBlockSize, 0), "setSmallerBlockSize(blockSize) -> None\n."},
    {"setTextureThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_setTextureThreshold, 0), "setTextureThreshold(textureThreshold) -> None\n."},
    {"setUniquenessRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoBM_setUniquenessRatio, 0), "setUniquenessRatio(uniquenessRatio) -> None\n."},

    {NULL,          NULL}
};

// Converter (StereoBM)

template<>
struct PyOpenCV_Converter< Ptr<cv::StereoBM> >
{
    static PyObject* from(const Ptr<cv::StereoBM>& r)
    {
        return pyopencv_StereoBM_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::StereoBM>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::StereoBM> * dst_;
        if (pyopencv_StereoBM_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::StereoBM> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// StereoMatcher (Generic)
//================================================================================

// GetSet (StereoMatcher)



// Methods (StereoMatcher)

static PyObject* pyopencv_cv_StereoMatcher_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_left = NULL;
    Mat left;
    PyObject* pyobj_right = NULL;
    Mat right;
    PyObject* pyobj_disparity = NULL;
    Mat disparity;

    const char* keywords[] = { "left", "right", "disparity", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:StereoMatcher.compute", (char**)keywords, &pyobj_left, &pyobj_right, &pyobj_disparity) &&
        pyopencv_to(pyobj_left, left, ArgInfo("left", 0)) &&
        pyopencv_to(pyobj_right, right, ArgInfo("right", 0)) &&
        pyopencv_to(pyobj_disparity, disparity, ArgInfo("disparity", 1)) )
    {
        ERRWRAP2(_self_->compute(left, right, disparity));
        return pyopencv_from(disparity);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_left = NULL;
    UMat left;
    PyObject* pyobj_right = NULL;
    UMat right;
    PyObject* pyobj_disparity = NULL;
    UMat disparity;

    const char* keywords[] = { "left", "right", "disparity", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:StereoMatcher.compute", (char**)keywords, &pyobj_left, &pyobj_right, &pyobj_disparity) &&
        pyopencv_to(pyobj_left, left, ArgInfo("left", 0)) &&
        pyopencv_to(pyobj_right, right, ArgInfo("right", 0)) &&
        pyopencv_to(pyobj_disparity, disparity, ArgInfo("disparity", 1)) )
    {
        ERRWRAP2(_self_->compute(left, right, disparity));
        return pyopencv_from(disparity);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_getBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBlockSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_getDisp12MaxDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDisp12MaxDiff());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_getMinDisparity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinDisparity());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_getNumDisparities(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumDisparities());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_getSpeckleRange(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSpeckleRange());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_getSpeckleWindowSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSpeckleWindowSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_setBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int blockSize=0;

    const char* keywords[] = { "blockSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoMatcher.setBlockSize", (char**)keywords, &blockSize) )
    {
        ERRWRAP2(_self_->setBlockSize(blockSize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_setDisp12MaxDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int disp12MaxDiff=0;

    const char* keywords[] = { "disp12MaxDiff", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoMatcher.setDisp12MaxDiff", (char**)keywords, &disp12MaxDiff) )
    {
        ERRWRAP2(_self_->setDisp12MaxDiff(disp12MaxDiff));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_setMinDisparity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int minDisparity=0;

    const char* keywords[] = { "minDisparity", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoMatcher.setMinDisparity", (char**)keywords, &minDisparity) )
    {
        ERRWRAP2(_self_->setMinDisparity(minDisparity));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_setNumDisparities(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int numDisparities=0;

    const char* keywords[] = { "numDisparities", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoMatcher.setNumDisparities", (char**)keywords, &numDisparities) )
    {
        ERRWRAP2(_self_->setNumDisparities(numDisparities));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_setSpeckleRange(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int speckleRange=0;

    const char* keywords[] = { "speckleRange", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoMatcher.setSpeckleRange", (char**)keywords, &speckleRange) )
    {
        ERRWRAP2(_self_->setSpeckleRange(speckleRange));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoMatcher_setSpeckleWindowSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoMatcher> * self1 = 0;
    if (!pyopencv_StereoMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoMatcher' or its derivative)");
    Ptr<cv::StereoMatcher> _self_ = *(self1);
    int speckleWindowSize=0;

    const char* keywords[] = { "speckleWindowSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoMatcher.setSpeckleWindowSize", (char**)keywords, &speckleWindowSize) )
    {
        ERRWRAP2(_self_->setSpeckleWindowSize(speckleWindowSize));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (StereoMatcher)

static PyGetSetDef pyopencv_StereoMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_StereoMatcher_methods[] =
{
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_compute, 0), "compute(left, right[, disparity]) -> disparity\n.   @brief Computes disparity map for the specified stereo pair\n.   \n.       @param left Left 8-bit single-channel image.\n.       @param right Right image of the same size and the same type as the left one.\n.       @param disparity Output disparity map. It has the same size as the input images. Some algorithms,\n.       like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value\n.       has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map."},
    {"getBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_getBlockSize, 0), "getBlockSize() -> retval\n."},
    {"getDisp12MaxDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_getDisp12MaxDiff, 0), "getDisp12MaxDiff() -> retval\n."},
    {"getMinDisparity", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_getMinDisparity, 0), "getMinDisparity() -> retval\n."},
    {"getNumDisparities", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_getNumDisparities, 0), "getNumDisparities() -> retval\n."},
    {"getSpeckleRange", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_getSpeckleRange, 0), "getSpeckleRange() -> retval\n."},
    {"getSpeckleWindowSize", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_getSpeckleWindowSize, 0), "getSpeckleWindowSize() -> retval\n."},
    {"setBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_setBlockSize, 0), "setBlockSize(blockSize) -> None\n."},
    {"setDisp12MaxDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_setDisp12MaxDiff, 0), "setDisp12MaxDiff(disp12MaxDiff) -> None\n."},
    {"setMinDisparity", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_setMinDisparity, 0), "setMinDisparity(minDisparity) -> None\n."},
    {"setNumDisparities", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_setNumDisparities, 0), "setNumDisparities(numDisparities) -> None\n."},
    {"setSpeckleRange", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_setSpeckleRange, 0), "setSpeckleRange(speckleRange) -> None\n."},
    {"setSpeckleWindowSize", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoMatcher_setSpeckleWindowSize, 0), "setSpeckleWindowSize(speckleWindowSize) -> None\n."},

    {NULL,          NULL}
};

// Converter (StereoMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::StereoMatcher> >
{
    static PyObject* from(const Ptr<cv::StereoMatcher>& r)
    {
        return pyopencv_StereoMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::StereoMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::StereoMatcher> * dst_;
        if (pyopencv_StereoMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::StereoMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// StereoSGBM (Generic)
//================================================================================

// GetSet (StereoSGBM)



// Methods (StereoSGBM)

static PyObject* pyopencv_cv_StereoSGBM_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    int minDisparity=0;
    int numDisparities=16;
    int blockSize=3;
    int P1=0;
    int P2=0;
    int disp12MaxDiff=0;
    int preFilterCap=0;
    int uniquenessRatio=0;
    int speckleWindowSize=0;
    int speckleRange=0;
    int mode=StereoSGBM::MODE_SGBM;
    Ptr<StereoSGBM> retval;

    const char* keywords[] = { "minDisparity", "numDisparities", "blockSize", "P1", "P2", "disp12MaxDiff", "preFilterCap", "uniquenessRatio", "speckleWindowSize", "speckleRange", "mode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iiiiiiiiiii:StereoSGBM.create", (char**)keywords, &minDisparity, &numDisparities, &blockSize, &P1, &P2, &disp12MaxDiff, &preFilterCap, &uniquenessRatio, &speckleWindowSize, &speckleRange, &mode) )
    {
        ERRWRAP2(retval = cv::StereoSGBM::create(minDisparity, numDisparities, blockSize, P1, P2, disp12MaxDiff, preFilterCap, uniquenessRatio, speckleWindowSize, speckleRange, mode));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_getMode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMode());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_getP1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getP1());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_getP2(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getP2());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_getPreFilterCap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPreFilterCap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_getUniquenessRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUniquenessRatio());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_setMode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int mode=0;

    const char* keywords[] = { "mode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoSGBM.setMode", (char**)keywords, &mode) )
    {
        ERRWRAP2(_self_->setMode(mode));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_setP1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int P1=0;

    const char* keywords[] = { "P1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoSGBM.setP1", (char**)keywords, &P1) )
    {
        ERRWRAP2(_self_->setP1(P1));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_setP2(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int P2=0;

    const char* keywords[] = { "P2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoSGBM.setP2", (char**)keywords, &P2) )
    {
        ERRWRAP2(_self_->setP2(P2));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_setPreFilterCap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int preFilterCap=0;

    const char* keywords[] = { "preFilterCap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoSGBM.setPreFilterCap", (char**)keywords, &preFilterCap) )
    {
        ERRWRAP2(_self_->setPreFilterCap(preFilterCap));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_StereoSGBM_setUniquenessRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::StereoSGBM> * self1 = 0;
    if (!pyopencv_StereoSGBM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'StereoSGBM' or its derivative)");
    Ptr<cv::StereoSGBM> _self_ = *(self1);
    int uniquenessRatio=0;

    const char* keywords[] = { "uniquenessRatio", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:StereoSGBM.setUniquenessRatio", (char**)keywords, &uniquenessRatio) )
    {
        ERRWRAP2(_self_->setUniquenessRatio(uniquenessRatio));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (StereoSGBM)

static PyGetSetDef pyopencv_StereoSGBM_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_StereoSGBM_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_create_static, METH_STATIC), "create([, minDisparity[, numDisparities[, blockSize[, P1[, P2[, disp12MaxDiff[, preFilterCap[, uniquenessRatio[, speckleWindowSize[, speckleRange[, mode]]]]]]]]]]]) -> retval\n.   @brief Creates StereoSGBM object\n.   \n.       @param minDisparity Minimum possible disparity value. Normally, it is zero but sometimes\n.       rectification algorithms can shift images, so this parameter needs to be adjusted accordingly.\n.       @param numDisparities Maximum disparity minus minimum disparity. The value is always greater than\n.       zero. In the current implementation, this parameter must be divisible by 16.\n.       @param blockSize Matched block size. It must be an odd number \\>=1 . Normally, it should be\n.       somewhere in the 3..11 range.\n.       @param P1 The first parameter controlling the disparity smoothness. See below.\n.       @param P2 The second parameter controlling the disparity smoothness. The larger the values are,\n.       the smoother the disparity is. P1 is the penalty on the disparity change by plus or minus 1\n.       between neighbor pixels. P2 is the penalty on the disparity change by more than 1 between neighbor\n.       pixels. The algorithm requires P2 \\> P1 . See stereo_match.cpp sample where some reasonably good\n.       P1 and P2 values are shown (like 8\\*number_of_image_channels\\*SADWindowSize\\*SADWindowSize and\n.       32\\*number_of_image_channels\\*SADWindowSize\\*SADWindowSize , respectively).\n.       @param disp12MaxDiff Maximum allowed difference (in integer pixel units) in the left-right\n.       disparity check. Set it to a non-positive value to disable the check.\n.       @param preFilterCap Truncation value for the prefiltered image pixels. The algorithm first\n.       computes x-derivative at each pixel and clips its value by [-preFilterCap, preFilterCap] interval.\n.       The result values are passed to the Birchfield-Tomasi pixel cost function.\n.       @param uniquenessRatio Margin in percentage by which the best (minimum) computed cost function\n.       value should \"win\" the second best value to consider the found match correct. Normally, a value\n.       within the 5-15 range is good enough.\n.       @param speckleWindowSize Maximum size of smooth disparity regions to consider their noise speckles\n.       and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the\n.       50-200 range.\n.       @param speckleRange Maximum disparity variation within each connected component. If you do speckle\n.       filtering, set the parameter to a positive value, it will be implicitly multiplied by 16.\n.       Normally, 1 or 2 is good enough.\n.       @param mode Set it to StereoSGBM::MODE_HH to run the full-scale two-pass dynamic programming\n.       algorithm. It will consume O(W\\*H\\*numDisparities) bytes, which is large for 640x480 stereo and\n.       huge for HD-size pictures. By default, it is set to false .\n.   \n.       The first constructor initializes StereoSGBM with all the default parameters. So, you only have to\n.       set StereoSGBM::numDisparities at minimum. The second constructor enables you to set each parameter\n.       to a custom value."},
    {"getMode", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_getMode, 0), "getMode() -> retval\n."},
    {"getP1", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_getP1, 0), "getP1() -> retval\n."},
    {"getP2", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_getP2, 0), "getP2() -> retval\n."},
    {"getPreFilterCap", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_getPreFilterCap, 0), "getPreFilterCap() -> retval\n."},
    {"getUniquenessRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_getUniquenessRatio, 0), "getUniquenessRatio() -> retval\n."},
    {"setMode", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_setMode, 0), "setMode(mode) -> None\n."},
    {"setP1", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_setP1, 0), "setP1(P1) -> None\n."},
    {"setP2", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_setP2, 0), "setP2(P2) -> None\n."},
    {"setPreFilterCap", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_setPreFilterCap, 0), "setPreFilterCap(preFilterCap) -> None\n."},
    {"setUniquenessRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_StereoSGBM_setUniquenessRatio, 0), "setUniquenessRatio(uniquenessRatio) -> None\n."},

    {NULL,          NULL}
};

// Converter (StereoSGBM)

template<>
struct PyOpenCV_Converter< Ptr<cv::StereoSGBM> >
{
    static PyObject* from(const Ptr<cv::StereoSGBM>& r)
    {
        return pyopencv_StereoSGBM_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::StereoSGBM>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::StereoSGBM> * dst_;
        if (pyopencv_StereoSGBM_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::StereoSGBM> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// Stitcher (Generic)
//================================================================================

// GetSet (Stitcher)



// Methods (Stitcher)

static PyObject* pyopencv_cv_Stitcher_composePanorama(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    {
    PyObject* pyobj_pano = NULL;
    Mat pano;
    Status retval;

    const char* keywords[] = { "pano", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:Stitcher.composePanorama", (char**)keywords, &pyobj_pano) &&
        pyopencv_to(pyobj_pano, pano, ArgInfo("pano", 1)) )
    {
        ERRWRAP2(retval = _self_->composePanorama(pano));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(pano));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_pano = NULL;
    UMat pano;
    Status retval;

    const char* keywords[] = { "pano", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:Stitcher.composePanorama", (char**)keywords, &pyobj_pano) &&
        pyopencv_to(pyobj_pano, pano, ArgInfo("pano", 1)) )
    {
        ERRWRAP2(retval = _self_->composePanorama(pano));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(pano));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_compositingResol(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->compositingResol());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_mode = NULL;
    Mode mode=Stitcher::PANORAMA;
    Ptr<Stitcher> retval;

    const char* keywords[] = { "mode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:Stitcher.create", (char**)keywords, &pyobj_mode) &&
        pyopencv_to(pyobj_mode, mode, ArgInfo("mode", 0)) )
    {
        ERRWRAP2(retval = cv::Stitcher::create(mode));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_estimateTransform(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;
    Status retval;

    const char* keywords[] = { "images", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Stitcher.estimateTransform", (char**)keywords, &pyobj_images, &pyobj_masks) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(retval = _self_->estimateTransform(images, masks));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;
    Status retval;

    const char* keywords[] = { "images", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Stitcher.estimateTransform", (char**)keywords, &pyobj_images, &pyobj_masks) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(retval = _self_->estimateTransform(images, masks));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_interpolationFlags(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    InterpolationFlags retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->interpolationFlags());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_panoConfidenceThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->panoConfidenceThresh());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_registrationResol(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->registrationResol());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_seamEstimationResol(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->seamEstimationResol());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_setCompositingResol(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double resol_mpx=0;

    const char* keywords[] = { "resol_mpx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:Stitcher.setCompositingResol", (char**)keywords, &resol_mpx) )
    {
        ERRWRAP2(_self_->setCompositingResol(resol_mpx));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_setInterpolationFlags(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    PyObject* pyobj_interp_flags = NULL;
    InterpolationFlags interp_flags=static_cast<InterpolationFlags>(0);

    const char* keywords[] = { "interp_flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Stitcher.setInterpolationFlags", (char**)keywords, &pyobj_interp_flags) &&
        pyopencv_to(pyobj_interp_flags, interp_flags, ArgInfo("interp_flags", 0)) )
    {
        ERRWRAP2(_self_->setInterpolationFlags(interp_flags));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_setPanoConfidenceThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double conf_thresh=0;

    const char* keywords[] = { "conf_thresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:Stitcher.setPanoConfidenceThresh", (char**)keywords, &conf_thresh) )
    {
        ERRWRAP2(_self_->setPanoConfidenceThresh(conf_thresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_setRegistrationResol(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double resol_mpx=0;

    const char* keywords[] = { "resol_mpx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:Stitcher.setRegistrationResol", (char**)keywords, &resol_mpx) )
    {
        ERRWRAP2(_self_->setRegistrationResol(resol_mpx));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_setSeamEstimationResol(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double resol_mpx=0;

    const char* keywords[] = { "resol_mpx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:Stitcher.setSeamEstimationResol", (char**)keywords, &resol_mpx) )
    {
        ERRWRAP2(_self_->setSeamEstimationResol(resol_mpx));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_setWaveCorrection(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    bool flag=0;

    const char* keywords[] = { "flag", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:Stitcher.setWaveCorrection", (char**)keywords, &flag) )
    {
        ERRWRAP2(_self_->setWaveCorrection(flag));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_stitch(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_pano = NULL;
    Mat pano;
    Status retval;

    const char* keywords[] = { "images", "pano", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Stitcher.stitch", (char**)keywords, &pyobj_images, &pyobj_pano) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_pano, pano, ArgInfo("pano", 1)) )
    {
        ERRWRAP2(retval = _self_->stitch(images, pano));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(pano));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_pano = NULL;
    UMat pano;
    Status retval;

    const char* keywords[] = { "images", "pano", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Stitcher.stitch", (char**)keywords, &pyobj_images, &pyobj_pano) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_pano, pano, ArgInfo("pano", 1)) )
    {
        ERRWRAP2(retval = _self_->stitch(images, pano));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(pano));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;
    PyObject* pyobj_pano = NULL;
    Mat pano;
    Status retval;

    const char* keywords[] = { "images", "masks", "pano", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:Stitcher.stitch", (char**)keywords, &pyobj_images, &pyobj_masks, &pyobj_pano) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) &&
        pyopencv_to(pyobj_pano, pano, ArgInfo("pano", 1)) )
    {
        ERRWRAP2(retval = _self_->stitch(images, masks, pano));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(pano));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks;
    PyObject* pyobj_pano = NULL;
    UMat pano;
    Status retval;

    const char* keywords[] = { "images", "masks", "pano", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:Stitcher.stitch", (char**)keywords, &pyobj_images, &pyobj_masks, &pyobj_pano) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) &&
        pyopencv_to(pyobj_pano, pano, ArgInfo("pano", 1)) )
    {
        ERRWRAP2(retval = _self_->stitch(images, masks, pano));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(pano));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_waveCorrection(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->waveCorrection());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Stitcher_workScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Stitcher> * self1 = 0;
    if (!pyopencv_Stitcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Stitcher' or its derivative)");
    Ptr<cv::Stitcher> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->workScale());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (Stitcher)

static PyGetSetDef pyopencv_Stitcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_Stitcher_methods[] =
{
    {"composePanorama", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_composePanorama, 0), "composePanorama([, pano]) -> retval, pano\n.   @overload"},
    {"compositingResol", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_compositingResol, 0), "compositingResol() -> retval\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_create_static, METH_STATIC), "create([, mode]) -> retval\n.   @brief Creates a Stitcher configured in one of the stitching modes.\n.   \n.       @param mode Scenario for stitcher operation. This is usually determined by source of images\n.       to stitch and their transformation. Default parameters will be chosen for operation in given\n.       scenario.\n.       @return Stitcher class instance."},
    {"estimateTransform", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_estimateTransform, 0), "estimateTransform(images[, masks]) -> retval\n.   @brief These functions try to match the given images and to estimate rotations of each camera.\n.   \n.       @note Use the functions only if you're aware of the stitching pipeline, otherwise use\n.       Stitcher::stitch.\n.   \n.       @param images Input images.\n.       @param masks Masks for each input image specifying where to look for keypoints (optional).\n.       @return Status code."},
    {"interpolationFlags", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_interpolationFlags, 0), "interpolationFlags() -> retval\n."},
    {"panoConfidenceThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_panoConfidenceThresh, 0), "panoConfidenceThresh() -> retval\n."},
    {"registrationResol", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_registrationResol, 0), "registrationResol() -> retval\n."},
    {"seamEstimationResol", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_seamEstimationResol, 0), "seamEstimationResol() -> retval\n."},
    {"setCompositingResol", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_setCompositingResol, 0), "setCompositingResol(resol_mpx) -> None\n."},
    {"setInterpolationFlags", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_setInterpolationFlags, 0), "setInterpolationFlags(interp_flags) -> None\n."},
    {"setPanoConfidenceThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_setPanoConfidenceThresh, 0), "setPanoConfidenceThresh(conf_thresh) -> None\n."},
    {"setRegistrationResol", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_setRegistrationResol, 0), "setRegistrationResol(resol_mpx) -> None\n."},
    {"setSeamEstimationResol", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_setSeamEstimationResol, 0), "setSeamEstimationResol(resol_mpx) -> None\n."},
    {"setWaveCorrection", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_setWaveCorrection, 0), "setWaveCorrection(flag) -> None\n."},
    {"stitch", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_stitch, 0), "stitch(images[, pano]) -> retval, pano\n.   @overload\n\n\n\nstitch(images, masks[, pano]) -> retval, pano\n.   @brief These functions try to stitch the given images.\n.   \n.       @param images Input images.\n.       @param masks Masks for each input image specifying where to look for keypoints (optional).\n.       @param pano Final pano.\n.       @return Status code."},
    {"waveCorrection", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_waveCorrection, 0), "waveCorrection() -> retval\n."},
    {"workScale", CV_PY_FN_WITH_KW_(pyopencv_cv_Stitcher_workScale, 0), "workScale() -> retval\n."},

    {NULL,          NULL}
};

// Converter (Stitcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::Stitcher> >
{
    static PyObject* from(const Ptr<cv::Stitcher>& r)
    {
        return pyopencv_Stitcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::Stitcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::Stitcher> * dst_;
        if (pyopencv_Stitcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::Stitcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// Subdiv2D (Generic)
//================================================================================

// GetSet (Subdiv2D)



// Methods (Subdiv2D)

static int pyopencv_cv_Subdiv2D_Subdiv2D(pyopencv_Subdiv2D_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::Subdiv2D>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::Subdiv2D()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_rect = NULL;
    Rect rect;

    const char* keywords[] = { "rect", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Subdiv2D", (char**)keywords, &pyobj_rect) &&
        pyopencv_to(pyobj_rect, rect, ArgInfo("rect", 0)) )
    {
        new (&(self->v)) Ptr<cv::Subdiv2D>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::Subdiv2D(rect)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_Subdiv2D_edgeDst(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    Point2f dstpt;
    int retval;

    const char* keywords[] = { "edge", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:Subdiv2D.edgeDst", (char**)keywords, &edge) )
    {
        ERRWRAP2(retval = _self_->edgeDst(edge, &dstpt));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(dstpt));
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_edgeOrg(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    Point2f orgpt;
    int retval;

    const char* keywords[] = { "edge", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:Subdiv2D.edgeOrg", (char**)keywords, &edge) )
    {
        ERRWRAP2(retval = _self_->edgeOrg(edge, &orgpt));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(orgpt));
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_findNearest(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    PyObject* pyobj_pt = NULL;
    Point2f pt;
    Point2f nearestPt;
    int retval;

    const char* keywords[] = { "pt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Subdiv2D.findNearest", (char**)keywords, &pyobj_pt) &&
        pyopencv_to(pyobj_pt, pt, ArgInfo("pt", 0)) )
    {
        ERRWRAP2(retval = _self_->findNearest(pt, &nearestPt));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(nearestPt));
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_getEdge(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    int nextEdgeType=0;
    int retval;

    const char* keywords[] = { "edge", "nextEdgeType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:Subdiv2D.getEdge", (char**)keywords, &edge, &nextEdgeType) )
    {
        ERRWRAP2(retval = _self_->getEdge(edge, nextEdgeType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_getEdgeList(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    vector_Vec4f edgeList;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->getEdgeList(edgeList));
        return pyopencv_from(edgeList);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_getLeadingEdgeList(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    vector_int leadingEdgeList;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->getLeadingEdgeList(leadingEdgeList));
        return pyopencv_from(leadingEdgeList);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_getTriangleList(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    vector_Vec6f triangleList;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->getTriangleList(triangleList));
        return pyopencv_from(triangleList);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_getVertex(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int vertex=0;
    int firstEdge;
    Point2f retval;

    const char* keywords[] = { "vertex", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:Subdiv2D.getVertex", (char**)keywords, &vertex) )
    {
        ERRWRAP2(retval = _self_->getVertex(vertex, &firstEdge));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(firstEdge));
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_getVoronoiFacetList(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    PyObject* pyobj_idx = NULL;
    vector_int idx;
    vector_vector_Point2f facetList;
    vector_Point2f facetCenters;

    const char* keywords[] = { "idx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Subdiv2D.getVoronoiFacetList", (char**)keywords, &pyobj_idx) &&
        pyopencv_to(pyobj_idx, idx, ArgInfo("idx", 0)) )
    {
        ERRWRAP2(_self_->getVoronoiFacetList(idx, facetList, facetCenters));
        return Py_BuildValue("(NN)", pyopencv_from(facetList), pyopencv_from(facetCenters));
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_initDelaunay(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    PyObject* pyobj_rect = NULL;
    Rect rect;

    const char* keywords[] = { "rect", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Subdiv2D.initDelaunay", (char**)keywords, &pyobj_rect) &&
        pyopencv_to(pyobj_rect, rect, ArgInfo("rect", 0)) )
    {
        ERRWRAP2(_self_->initDelaunay(rect));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_insert(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    {
    PyObject* pyobj_pt = NULL;
    Point2f pt;
    int retval;

    const char* keywords[] = { "pt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Subdiv2D.insert", (char**)keywords, &pyobj_pt) &&
        pyopencv_to(pyobj_pt, pt, ArgInfo("pt", 0)) )
    {
        ERRWRAP2(retval = _self_->insert(pt));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ptvec = NULL;
    vector_Point2f ptvec;

    const char* keywords[] = { "ptvec", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Subdiv2D.insert", (char**)keywords, &pyobj_ptvec) &&
        pyopencv_to(pyobj_ptvec, ptvec, ArgInfo("ptvec", 0)) )
    {
        ERRWRAP2(_self_->insert(ptvec));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_locate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    PyObject* pyobj_pt = NULL;
    Point2f pt;
    int edge;
    int vertex;
    int retval;

    const char* keywords[] = { "pt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Subdiv2D.locate", (char**)keywords, &pyobj_pt) &&
        pyopencv_to(pyobj_pt, pt, ArgInfo("pt", 0)) )
    {
        ERRWRAP2(retval = _self_->locate(pt, edge, vertex));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(edge), pyopencv_from(vertex));
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_nextEdge(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    int retval;

    const char* keywords[] = { "edge", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:Subdiv2D.nextEdge", (char**)keywords, &edge) )
    {
        ERRWRAP2(retval = _self_->nextEdge(edge));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_rotateEdge(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    int rotate=0;
    int retval;

    const char* keywords[] = { "edge", "rotate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:Subdiv2D.rotateEdge", (char**)keywords, &edge, &rotate) )
    {
        ERRWRAP2(retval = _self_->rotateEdge(edge, rotate));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Subdiv2D_symEdge(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Subdiv2D> * self1 = 0;
    if (!pyopencv_Subdiv2D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Subdiv2D' or its derivative)");
    Ptr<cv::Subdiv2D> _self_ = *(self1);
    int edge=0;
    int retval;

    const char* keywords[] = { "edge", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:Subdiv2D.symEdge", (char**)keywords, &edge) )
    {
        ERRWRAP2(retval = _self_->symEdge(edge));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (Subdiv2D)

static PyGetSetDef pyopencv_Subdiv2D_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_Subdiv2D_methods[] =
{
    {"edgeDst", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_edgeDst, 0), "edgeDst(edge) -> retval, dstpt\n.   @brief Returns the edge destination.\n.   \n.       @param edge Subdivision edge ID.\n.       @param dstpt Output vertex location.\n.   \n.       @returns vertex ID."},
    {"edgeOrg", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_edgeOrg, 0), "edgeOrg(edge) -> retval, orgpt\n.   @brief Returns the edge origin.\n.   \n.       @param edge Subdivision edge ID.\n.       @param orgpt Output vertex location.\n.   \n.       @returns vertex ID."},
    {"findNearest", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_findNearest, 0), "findNearest(pt) -> retval, nearestPt\n.   @brief Finds the subdivision vertex closest to the given point.\n.   \n.       @param pt Input point.\n.       @param nearestPt Output subdivision vertex point.\n.   \n.       The function is another function that locates the input point within the subdivision. It finds the\n.       subdivision vertex that is the closest to the input point. It is not necessarily one of vertices\n.       of the facet containing the input point, though the facet (located using locate() ) is used as a\n.       starting point.\n.   \n.       @returns vertex ID."},
    {"getEdge", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_getEdge, 0), "getEdge(edge, nextEdgeType) -> retval\n.   @brief Returns one of the edges related to the given edge.\n.   \n.       @param edge Subdivision edge ID.\n.       @param nextEdgeType Parameter specifying which of the related edges to return.\n.       The following values are possible:\n.       -   NEXT_AROUND_ORG next around the edge origin ( eOnext on the picture below if e is the input edge)\n.       -   NEXT_AROUND_DST next around the edge vertex ( eDnext )\n.       -   PREV_AROUND_ORG previous around the edge origin (reversed eRnext )\n.       -   PREV_AROUND_DST previous around the edge destination (reversed eLnext )\n.       -   NEXT_AROUND_LEFT next around the left facet ( eLnext )\n.       -   NEXT_AROUND_RIGHT next around the right facet ( eRnext )\n.       -   PREV_AROUND_LEFT previous around the left facet (reversed eOnext )\n.       -   PREV_AROUND_RIGHT previous around the right facet (reversed eDnext )\n.   \n.       ![sample output](pics/quadedge.png)\n.   \n.       @returns edge ID related to the input edge."},
    {"getEdgeList", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_getEdgeList, 0), "getEdgeList() -> edgeList\n.   @brief Returns a list of all edges.\n.   \n.       @param edgeList Output vector.\n.   \n.       The function gives each edge as a 4 numbers vector, where each two are one of the edge\n.       vertices. i.e. org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3]."},
    {"getLeadingEdgeList", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_getLeadingEdgeList, 0), "getLeadingEdgeList() -> leadingEdgeList\n.   @brief Returns a list of the leading edge ID connected to each triangle.\n.   \n.       @param leadingEdgeList Output vector.\n.   \n.       The function gives one edge ID for each triangle."},
    {"getTriangleList", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_getTriangleList, 0), "getTriangleList() -> triangleList\n.   @brief Returns a list of all triangles.\n.   \n.       @param triangleList Output vector.\n.   \n.       The function gives each triangle as a 6 numbers vector, where each two are one of the triangle\n.       vertices. i.e. p1_x = v[0], p1_y = v[1], p2_x = v[2], p2_y = v[3], p3_x = v[4], p3_y = v[5]."},
    {"getVertex", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_getVertex, 0), "getVertex(vertex) -> retval, firstEdge\n.   @brief Returns vertex location from vertex ID.\n.   \n.       @param vertex vertex ID.\n.       @param firstEdge Optional. The first edge ID which is connected to the vertex.\n.       @returns vertex (x,y)"},
    {"getVoronoiFacetList", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_getVoronoiFacetList, 0), "getVoronoiFacetList(idx) -> facetList, facetCenters\n.   @brief Returns a list of all Voroni facets.\n.   \n.       @param idx Vector of vertices IDs to consider. For all vertices you can pass empty vector.\n.       @param facetList Output vector of the Voroni facets.\n.       @param facetCenters Output vector of the Voroni facets center points."},
    {"initDelaunay", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_initDelaunay, 0), "initDelaunay(rect) -> None\n.   @brief Creates a new empty Delaunay subdivision\n.   \n.       @param rect Rectangle that includes all of the 2D points that are to be added to the subdivision."},
    {"insert", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_insert, 0), "insert(pt) -> retval\n.   @brief Insert a single point into a Delaunay triangulation.\n.   \n.       @param pt Point to insert.\n.   \n.       The function inserts a single point into a subdivision and modifies the subdivision topology\n.       appropriately. If a point with the same coordinates exists already, no new point is added.\n.       @returns the ID of the point.\n.   \n.       @note If the point is outside of the triangulation specified rect a runtime error is raised.\n\n\n\ninsert(ptvec) -> None\n.   @brief Insert multiple points into a Delaunay triangulation.\n.   \n.       @param ptvec Points to insert.\n.   \n.       The function inserts a vector of points into a subdivision and modifies the subdivision topology\n.       appropriately."},
    {"locate", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_locate, 0), "locate(pt) -> retval, edge, vertex\n.   @brief Returns the location of a point within a Delaunay triangulation.\n.   \n.       @param pt Point to locate.\n.       @param edge Output edge that the point belongs to or is located to the right of it.\n.       @param vertex Optional output vertex the input point coincides with.\n.   \n.       The function locates the input point within the subdivision and gives one of the triangle edges\n.       or vertices.\n.   \n.       @returns an integer which specify one of the following five cases for point location:\n.       -  The point falls into some facet. The function returns #PTLOC_INSIDE and edge will contain one of\n.          edges of the facet.\n.       -  The point falls onto the edge. The function returns #PTLOC_ON_EDGE and edge will contain this edge.\n.       -  The point coincides with one of the subdivision vertices. The function returns #PTLOC_VERTEX and\n.          vertex will contain a pointer to the vertex.\n.       -  The point is outside the subdivision reference rectangle. The function returns #PTLOC_OUTSIDE_RECT\n.          and no pointers are filled.\n.       -  One of input arguments is invalid. A runtime error is raised or, if silent or \"parent\" error\n.          processing mode is selected, #PTLOC_ERROR is returned."},
    {"nextEdge", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_nextEdge, 0), "nextEdge(edge) -> retval\n.   @brief Returns next edge around the edge origin.\n.   \n.       @param edge Subdivision edge ID.\n.   \n.       @returns an integer which is next edge ID around the edge origin: eOnext on the\n.       picture above if e is the input edge)."},
    {"rotateEdge", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_rotateEdge, 0), "rotateEdge(edge, rotate) -> retval\n.   @brief Returns another edge of the same quad-edge.\n.   \n.       @param edge Subdivision edge ID.\n.       @param rotate Parameter specifying which of the edges of the same quad-edge as the input\n.       one to return. The following values are possible:\n.       -   0 - the input edge ( e on the picture below if e is the input edge)\n.       -   1 - the rotated edge ( eRot )\n.       -   2 - the reversed edge (reversed e (in green))\n.       -   3 - the reversed rotated edge (reversed eRot (in green))\n.   \n.       @returns one of the edges ID of the same quad-edge as the input edge."},
    {"symEdge", CV_PY_FN_WITH_KW_(pyopencv_cv_Subdiv2D_symEdge, 0), "symEdge(edge) -> retval\n."},

    {NULL,          NULL}
};

// Converter (Subdiv2D)

template<>
struct PyOpenCV_Converter< Ptr<cv::Subdiv2D> >
{
    static PyObject* from(const Ptr<cv::Subdiv2D>& r)
    {
        return pyopencv_Subdiv2D_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::Subdiv2D>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::Subdiv2D> * dst_;
        if (pyopencv_Subdiv2D_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::Subdiv2D> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ThinPlateSplineShapeTransformer (Generic)
//================================================================================

// GetSet (ThinPlateSplineShapeTransformer)



// Methods (ThinPlateSplineShapeTransformer)

static PyObject* pyopencv_cv_ThinPlateSplineShapeTransformer_getRegularizationParameter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ThinPlateSplineShapeTransformer> * self1 = 0;
    if (!pyopencv_ThinPlateSplineShapeTransformer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ThinPlateSplineShapeTransformer' or its derivative)");
    Ptr<cv::ThinPlateSplineShapeTransformer> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRegularizationParameter());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ThinPlateSplineShapeTransformer_setRegularizationParameter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::ThinPlateSplineShapeTransformer> * self1 = 0;
    if (!pyopencv_ThinPlateSplineShapeTransformer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ThinPlateSplineShapeTransformer' or its derivative)");
    Ptr<cv::ThinPlateSplineShapeTransformer> _self_ = *(self1);
    double beta=0;

    const char* keywords[] = { "beta", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ThinPlateSplineShapeTransformer.setRegularizationParameter", (char**)keywords, &beta) )
    {
        ERRWRAP2(_self_->setRegularizationParameter(beta));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ThinPlateSplineShapeTransformer)

static PyGetSetDef pyopencv_ThinPlateSplineShapeTransformer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ThinPlateSplineShapeTransformer_methods[] =
{
    {"getRegularizationParameter", CV_PY_FN_WITH_KW_(pyopencv_cv_ThinPlateSplineShapeTransformer_getRegularizationParameter, 0), "getRegularizationParameter() -> retval\n."},
    {"setRegularizationParameter", CV_PY_FN_WITH_KW_(pyopencv_cv_ThinPlateSplineShapeTransformer_setRegularizationParameter, 0), "setRegularizationParameter(beta) -> None\n.   @brief Set the regularization parameter for relaxing the exact interpolation requirements of the TPS\n.       algorithm.\n.   \n.       @param beta value of the regularization parameter."},

    {NULL,          NULL}
};

// Converter (ThinPlateSplineShapeTransformer)

template<>
struct PyOpenCV_Converter< Ptr<cv::ThinPlateSplineShapeTransformer> >
{
    static PyObject* from(const Ptr<cv::ThinPlateSplineShapeTransformer>& r)
    {
        return pyopencv_ThinPlateSplineShapeTransformer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ThinPlateSplineShapeTransformer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ThinPlateSplineShapeTransformer> * dst_;
        if (pyopencv_ThinPlateSplineShapeTransformer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ThinPlateSplineShapeTransformer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TickMeter (Generic)
//================================================================================

// GetSet (TickMeter)



// Methods (TickMeter)

static int pyopencv_cv_TickMeter_TickMeter(pyopencv_TickMeter_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::TickMeter>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::TickMeter()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_TickMeter_getCounter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TickMeter> * self1 = 0;
    if (!pyopencv_TickMeter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TickMeter' or its derivative)");
    Ptr<cv::TickMeter> _self_ = *(self1);
    int64 retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCounter());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TickMeter_getTimeMicro(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TickMeter> * self1 = 0;
    if (!pyopencv_TickMeter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TickMeter' or its derivative)");
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTimeMicro());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TickMeter_getTimeMilli(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TickMeter> * self1 = 0;
    if (!pyopencv_TickMeter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TickMeter' or its derivative)");
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTimeMilli());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TickMeter_getTimeSec(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TickMeter> * self1 = 0;
    if (!pyopencv_TickMeter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TickMeter' or its derivative)");
    Ptr<cv::TickMeter> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTimeSec());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TickMeter_getTimeTicks(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TickMeter> * self1 = 0;
    if (!pyopencv_TickMeter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TickMeter' or its derivative)");
    Ptr<cv::TickMeter> _self_ = *(self1);
    int64 retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTimeTicks());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TickMeter_reset(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TickMeter> * self1 = 0;
    if (!pyopencv_TickMeter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TickMeter' or its derivative)");
    Ptr<cv::TickMeter> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->reset());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_TickMeter_start(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TickMeter> * self1 = 0;
    if (!pyopencv_TickMeter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TickMeter' or its derivative)");
    Ptr<cv::TickMeter> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->start());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_TickMeter_stop(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TickMeter> * self1 = 0;
    if (!pyopencv_TickMeter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TickMeter' or its derivative)");
    Ptr<cv::TickMeter> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->stop());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (TickMeter)

static PyGetSetDef pyopencv_TickMeter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TickMeter_methods[] =
{
    {"getCounter", CV_PY_FN_WITH_KW_(pyopencv_cv_TickMeter_getCounter, 0), "getCounter() -> retval\n.   returns internal counter value."},
    {"getTimeMicro", CV_PY_FN_WITH_KW_(pyopencv_cv_TickMeter_getTimeMicro, 0), "getTimeMicro() -> retval\n.   returns passed time in microseconds."},
    {"getTimeMilli", CV_PY_FN_WITH_KW_(pyopencv_cv_TickMeter_getTimeMilli, 0), "getTimeMilli() -> retval\n.   returns passed time in milliseconds."},
    {"getTimeSec", CV_PY_FN_WITH_KW_(pyopencv_cv_TickMeter_getTimeSec, 0), "getTimeSec() -> retval\n.   returns passed time in seconds."},
    {"getTimeTicks", CV_PY_FN_WITH_KW_(pyopencv_cv_TickMeter_getTimeTicks, 0), "getTimeTicks() -> retval\n.   returns counted ticks."},
    {"reset", CV_PY_FN_WITH_KW_(pyopencv_cv_TickMeter_reset, 0), "reset() -> None\n.   resets internal values."},
    {"start", CV_PY_FN_WITH_KW_(pyopencv_cv_TickMeter_start, 0), "start() -> None\n.   starts counting ticks."},
    {"stop", CV_PY_FN_WITH_KW_(pyopencv_cv_TickMeter_stop, 0), "stop() -> None\n.   stops counting ticks."},

    {NULL,          NULL}
};

// Converter (TickMeter)

template<>
struct PyOpenCV_Converter< Ptr<cv::TickMeter> >
{
    static PyObject* from(const Ptr<cv::TickMeter>& r)
    {
        return pyopencv_TickMeter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TickMeter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TickMeter> * dst_;
        if (pyopencv_TickMeter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TickMeter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// Tonemap (Generic)
//================================================================================

// GetSet (Tonemap)



// Methods (Tonemap)

static PyObject* pyopencv_cv_Tonemap_getGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Tonemap> * self1 = 0;
    if (!pyopencv_Tonemap_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Tonemap' or its derivative)");
    Ptr<cv::Tonemap> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGamma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_Tonemap_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Tonemap> * self1 = 0;
    if (!pyopencv_Tonemap_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Tonemap' or its derivative)");
    Ptr<cv::Tonemap> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Tonemap.process", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->process(src, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:Tonemap.process", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->process(src, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Tonemap_setGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Tonemap> * self1 = 0;
    if (!pyopencv_Tonemap_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Tonemap' or its derivative)");
    Ptr<cv::Tonemap> _self_ = *(self1);
    float gamma=0.f;

    const char* keywords[] = { "gamma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:Tonemap.setGamma", (char**)keywords, &gamma) )
    {
        ERRWRAP2(_self_->setGamma(gamma));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (Tonemap)

static PyGetSetDef pyopencv_Tonemap_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_Tonemap_methods[] =
{
    {"getGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_Tonemap_getGamma, 0), "getGamma() -> retval\n."},
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_Tonemap_process, 0), "process(src[, dst]) -> dst\n.   @brief Tonemaps image\n.   \n.       @param src source image - CV_32FC3 Mat (float 32 bits 3 channels)\n.       @param dst destination image - CV_32FC3 Mat with values in [0, 1] range"},
    {"setGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_Tonemap_setGamma, 0), "setGamma(gamma) -> None\n."},

    {NULL,          NULL}
};

// Converter (Tonemap)

template<>
struct PyOpenCV_Converter< Ptr<cv::Tonemap> >
{
    static PyObject* from(const Ptr<cv::Tonemap>& r)
    {
        return pyopencv_Tonemap_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::Tonemap>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::Tonemap> * dst_;
        if (pyopencv_Tonemap_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::Tonemap> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TonemapDrago (Generic)
//================================================================================

// GetSet (TonemapDrago)



// Methods (TonemapDrago)

static PyObject* pyopencv_cv_TonemapDrago_getBias(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapDrago> * self1 = 0;
    if (!pyopencv_TonemapDrago_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapDrago' or its derivative)");
    Ptr<cv::TonemapDrago> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBias());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapDrago_getSaturation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapDrago> * self1 = 0;
    if (!pyopencv_TonemapDrago_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapDrago' or its derivative)");
    Ptr<cv::TonemapDrago> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSaturation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapDrago_setBias(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapDrago> * self1 = 0;
    if (!pyopencv_TonemapDrago_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapDrago' or its derivative)");
    Ptr<cv::TonemapDrago> _self_ = *(self1);
    float bias=0.f;

    const char* keywords[] = { "bias", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:TonemapDrago.setBias", (char**)keywords, &bias) )
    {
        ERRWRAP2(_self_->setBias(bias));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapDrago_setSaturation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapDrago> * self1 = 0;
    if (!pyopencv_TonemapDrago_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapDrago' or its derivative)");
    Ptr<cv::TonemapDrago> _self_ = *(self1);
    float saturation=0.f;

    const char* keywords[] = { "saturation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:TonemapDrago.setSaturation", (char**)keywords, &saturation) )
    {
        ERRWRAP2(_self_->setSaturation(saturation));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (TonemapDrago)

static PyGetSetDef pyopencv_TonemapDrago_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TonemapDrago_methods[] =
{
    {"getBias", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapDrago_getBias, 0), "getBias() -> retval\n."},
    {"getSaturation", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapDrago_getSaturation, 0), "getSaturation() -> retval\n."},
    {"setBias", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapDrago_setBias, 0), "setBias(bias) -> None\n."},
    {"setSaturation", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapDrago_setSaturation, 0), "setSaturation(saturation) -> None\n."},

    {NULL,          NULL}
};

// Converter (TonemapDrago)

template<>
struct PyOpenCV_Converter< Ptr<cv::TonemapDrago> >
{
    static PyObject* from(const Ptr<cv::TonemapDrago>& r)
    {
        return pyopencv_TonemapDrago_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TonemapDrago>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TonemapDrago> * dst_;
        if (pyopencv_TonemapDrago_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TonemapDrago> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TonemapMantiuk (Generic)
//================================================================================

// GetSet (TonemapMantiuk)



// Methods (TonemapMantiuk)

static PyObject* pyopencv_cv_TonemapMantiuk_getSaturation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapMantiuk> * self1 = 0;
    if (!pyopencv_TonemapMantiuk_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapMantiuk' or its derivative)");
    Ptr<cv::TonemapMantiuk> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSaturation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapMantiuk_getScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapMantiuk> * self1 = 0;
    if (!pyopencv_TonemapMantiuk_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapMantiuk' or its derivative)");
    Ptr<cv::TonemapMantiuk> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapMantiuk_setSaturation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapMantiuk> * self1 = 0;
    if (!pyopencv_TonemapMantiuk_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapMantiuk' or its derivative)");
    Ptr<cv::TonemapMantiuk> _self_ = *(self1);
    float saturation=0.f;

    const char* keywords[] = { "saturation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:TonemapMantiuk.setSaturation", (char**)keywords, &saturation) )
    {
        ERRWRAP2(_self_->setSaturation(saturation));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapMantiuk_setScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapMantiuk> * self1 = 0;
    if (!pyopencv_TonemapMantiuk_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapMantiuk' or its derivative)");
    Ptr<cv::TonemapMantiuk> _self_ = *(self1);
    float scale=0.f;

    const char* keywords[] = { "scale", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:TonemapMantiuk.setScale", (char**)keywords, &scale) )
    {
        ERRWRAP2(_self_->setScale(scale));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (TonemapMantiuk)

static PyGetSetDef pyopencv_TonemapMantiuk_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TonemapMantiuk_methods[] =
{
    {"getSaturation", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapMantiuk_getSaturation, 0), "getSaturation() -> retval\n."},
    {"getScale", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapMantiuk_getScale, 0), "getScale() -> retval\n."},
    {"setSaturation", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapMantiuk_setSaturation, 0), "setSaturation(saturation) -> None\n."},
    {"setScale", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapMantiuk_setScale, 0), "setScale(scale) -> None\n."},

    {NULL,          NULL}
};

// Converter (TonemapMantiuk)

template<>
struct PyOpenCV_Converter< Ptr<cv::TonemapMantiuk> >
{
    static PyObject* from(const Ptr<cv::TonemapMantiuk>& r)
    {
        return pyopencv_TonemapMantiuk_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TonemapMantiuk>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TonemapMantiuk> * dst_;
        if (pyopencv_TonemapMantiuk_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TonemapMantiuk> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TonemapReinhard (Generic)
//================================================================================

// GetSet (TonemapReinhard)



// Methods (TonemapReinhard)

static PyObject* pyopencv_cv_TonemapReinhard_getColorAdaptation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!pyopencv_TonemapReinhard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapReinhard' or its derivative)");
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getColorAdaptation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapReinhard_getIntensity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!pyopencv_TonemapReinhard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapReinhard' or its derivative)");
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIntensity());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapReinhard_getLightAdaptation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!pyopencv_TonemapReinhard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapReinhard' or its derivative)");
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLightAdaptation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapReinhard_setColorAdaptation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!pyopencv_TonemapReinhard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapReinhard' or its derivative)");
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float color_adapt=0.f;

    const char* keywords[] = { "color_adapt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:TonemapReinhard.setColorAdaptation", (char**)keywords, &color_adapt) )
    {
        ERRWRAP2(_self_->setColorAdaptation(color_adapt));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapReinhard_setIntensity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!pyopencv_TonemapReinhard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapReinhard' or its derivative)");
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float intensity=0.f;

    const char* keywords[] = { "intensity", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:TonemapReinhard.setIntensity", (char**)keywords, &intensity) )
    {
        ERRWRAP2(_self_->setIntensity(intensity));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_TonemapReinhard_setLightAdaptation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TonemapReinhard> * self1 = 0;
    if (!pyopencv_TonemapReinhard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TonemapReinhard' or its derivative)");
    Ptr<cv::TonemapReinhard> _self_ = *(self1);
    float light_adapt=0.f;

    const char* keywords[] = { "light_adapt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:TonemapReinhard.setLightAdaptation", (char**)keywords, &light_adapt) )
    {
        ERRWRAP2(_self_->setLightAdaptation(light_adapt));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (TonemapReinhard)

static PyGetSetDef pyopencv_TonemapReinhard_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TonemapReinhard_methods[] =
{
    {"getColorAdaptation", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapReinhard_getColorAdaptation, 0), "getColorAdaptation() -> retval\n."},
    {"getIntensity", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapReinhard_getIntensity, 0), "getIntensity() -> retval\n."},
    {"getLightAdaptation", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapReinhard_getLightAdaptation, 0), "getLightAdaptation() -> retval\n."},
    {"setColorAdaptation", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapReinhard_setColorAdaptation, 0), "setColorAdaptation(color_adapt) -> None\n."},
    {"setIntensity", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapReinhard_setIntensity, 0), "setIntensity(intensity) -> None\n."},
    {"setLightAdaptation", CV_PY_FN_WITH_KW_(pyopencv_cv_TonemapReinhard_setLightAdaptation, 0), "setLightAdaptation(light_adapt) -> None\n."},

    {NULL,          NULL}
};

// Converter (TonemapReinhard)

template<>
struct PyOpenCV_Converter< Ptr<cv::TonemapReinhard> >
{
    static PyObject* from(const Ptr<cv::TonemapReinhard>& r)
    {
        return pyopencv_TonemapReinhard_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TonemapReinhard>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TonemapReinhard> * dst_;
        if (pyopencv_TonemapReinhard_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TonemapReinhard> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// Tracker (Generic)
//================================================================================

// GetSet (Tracker)



// Methods (Tracker)

static PyObject* pyopencv_cv_Tracker_init(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Tracker> * self1 = 0;
    if (!pyopencv_Tracker_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Tracker' or its derivative)");
    Ptr<cv::Tracker> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_boundingBox = NULL;
    Rect2d boundingBox;
    bool retval;

    const char* keywords[] = { "image", "boundingBox", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:Tracker.init", (char**)keywords, &pyobj_image, &pyobj_boundingBox) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_boundingBox, boundingBox, ArgInfo("boundingBox", 0)) )
    {
        ERRWRAP2(retval = _self_->init(image, boundingBox));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_boundingBox = NULL;
    Rect2d boundingBox;
    bool retval;

    const char* keywords[] = { "image", "boundingBox", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:Tracker.init", (char**)keywords, &pyobj_image, &pyobj_boundingBox) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_boundingBox, boundingBox, ArgInfo("boundingBox", 0)) )
    {
        ERRWRAP2(retval = _self_->init(image, boundingBox));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_Tracker_update(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::Tracker> * self1 = 0;
    if (!pyopencv_Tracker_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'Tracker' or its derivative)");
    Ptr<cv::Tracker> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    Rect2d boundingBox;
    bool retval;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Tracker.update", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->update(image, boundingBox));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(boundingBox));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    Rect2d boundingBox;
    bool retval;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Tracker.update", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->update(image, boundingBox));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(boundingBox));
    }
    }

    return NULL;
}



// Tables (Tracker)

static PyGetSetDef pyopencv_Tracker_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_Tracker_methods[] =
{
    {"init", CV_PY_FN_WITH_KW_(pyopencv_cv_Tracker_init, 0), "init(image, boundingBox) -> retval\n.   @brief Initialize the tracker with a known bounding box that surrounded the target\n.       @param image The initial frame\n.       @param boundingBox The initial bounding box\n.   \n.       @return True if initialization went succesfully, false otherwise"},
    {"update", CV_PY_FN_WITH_KW_(pyopencv_cv_Tracker_update, 0), "update(image) -> retval, boundingBox\n.   @brief Update the tracker, find the new most likely bounding box for the target\n.       @param image The current frame\n.       @param boundingBox The bounding box that represent the new target location, if true was returned, not\n.       modified otherwise\n.   \n.       @return True means that target was located and false means that tracker cannot locate target in\n.       current frame. Note, that latter *does not* imply that tracker has failed, maybe target is indeed\n.       missing from the frame (say, out of sight)"},

    {NULL,          NULL}
};

// Converter (Tracker)

template<>
struct PyOpenCV_Converter< Ptr<cv::Tracker> >
{
    static PyObject* from(const Ptr<cv::Tracker>& r)
    {
        return pyopencv_Tracker_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::Tracker>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::Tracker> * dst_;
        if (pyopencv_Tracker_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::Tracker> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TrackerBoosting (Generic)
//================================================================================

// GetSet (TrackerBoosting)



// Methods (TrackerBoosting)

static PyObject* pyopencv_cv_TrackerBoosting_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<TrackerBoosting> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::TrackerBoosting::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (TrackerBoosting)

static PyGetSetDef pyopencv_TrackerBoosting_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TrackerBoosting_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerBoosting_create_static, METH_STATIC), "create() -> retval\n.   @brief Constructor\n.       @param parameters BOOSTING parameters TrackerBoosting::Params"},

    {NULL,          NULL}
};

// Converter (TrackerBoosting)

template<>
struct PyOpenCV_Converter< Ptr<cv::TrackerBoosting> >
{
    static PyObject* from(const Ptr<cv::TrackerBoosting>& r)
    {
        return pyopencv_TrackerBoosting_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TrackerBoosting>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TrackerBoosting> * dst_;
        if (pyopencv_TrackerBoosting_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TrackerBoosting> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TrackerCSRT (Generic)
//================================================================================

// GetSet (TrackerCSRT)



// Methods (TrackerCSRT)

static PyObject* pyopencv_cv_TrackerCSRT_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<TrackerCSRT> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::TrackerCSRT::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_TrackerCSRT_setInitialMask(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::TrackerCSRT> * self1 = 0;
    if (!pyopencv_TrackerCSRT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'TrackerCSRT' or its derivative)");
    Ptr<cv::TrackerCSRT> _self_ = *(self1);
    {
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:TrackerCSRT.setInitialMask", (char**)keywords, &pyobj_mask) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->setInitialMask(mask));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:TrackerCSRT.setInitialMask", (char**)keywords, &pyobj_mask) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->setInitialMask(mask));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (TrackerCSRT)

static PyGetSetDef pyopencv_TrackerCSRT_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TrackerCSRT_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerCSRT_create_static, METH_STATIC), "create() -> retval\n.   @brief Constructor\n.     @param parameters CSRT parameters TrackerCSRT::Params"},
    {"setInitialMask", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerCSRT_setInitialMask, 0), "setInitialMask(mask) -> None\n."},

    {NULL,          NULL}
};

// Converter (TrackerCSRT)

template<>
struct PyOpenCV_Converter< Ptr<cv::TrackerCSRT> >
{
    static PyObject* from(const Ptr<cv::TrackerCSRT>& r)
    {
        return pyopencv_TrackerCSRT_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TrackerCSRT>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TrackerCSRT> * dst_;
        if (pyopencv_TrackerCSRT_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TrackerCSRT> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TrackerGOTURN (Generic)
//================================================================================

// GetSet (TrackerGOTURN)



// Methods (TrackerGOTURN)

static PyObject* pyopencv_cv_TrackerGOTURN_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<TrackerGOTURN> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::TrackerGOTURN::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (TrackerGOTURN)

static PyGetSetDef pyopencv_TrackerGOTURN_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TrackerGOTURN_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerGOTURN_create_static, METH_STATIC), "create() -> retval\n.   @brief Constructor\n.     @param parameters GOTURN parameters TrackerGOTURN::Params"},

    {NULL,          NULL}
};

// Converter (TrackerGOTURN)

template<>
struct PyOpenCV_Converter< Ptr<cv::TrackerGOTURN> >
{
    static PyObject* from(const Ptr<cv::TrackerGOTURN>& r)
    {
        return pyopencv_TrackerGOTURN_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TrackerGOTURN>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TrackerGOTURN> * dst_;
        if (pyopencv_TrackerGOTURN_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TrackerGOTURN> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TrackerKCF (Generic)
//================================================================================

// GetSet (TrackerKCF)



// Methods (TrackerKCF)

static PyObject* pyopencv_cv_TrackerKCF_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<TrackerKCF> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::TrackerKCF::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (TrackerKCF)

static PyGetSetDef pyopencv_TrackerKCF_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TrackerKCF_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerKCF_create_static, METH_STATIC), "create() -> retval\n.   @brief Constructor\n.     @param parameters KCF parameters TrackerKCF::Params"},

    {NULL,          NULL}
};

// Converter (TrackerKCF)

template<>
struct PyOpenCV_Converter< Ptr<cv::TrackerKCF> >
{
    static PyObject* from(const Ptr<cv::TrackerKCF>& r)
    {
        return pyopencv_TrackerKCF_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TrackerKCF>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TrackerKCF> * dst_;
        if (pyopencv_TrackerKCF_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TrackerKCF> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TrackerMIL (Generic)
//================================================================================

// GetSet (TrackerMIL)



// Methods (TrackerMIL)

static PyObject* pyopencv_cv_TrackerMIL_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<TrackerMIL> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::TrackerMIL::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (TrackerMIL)

static PyGetSetDef pyopencv_TrackerMIL_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TrackerMIL_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerMIL_create_static, METH_STATIC), "create() -> retval\n.   @brief Constructor\n.       @param parameters MIL parameters TrackerMIL::Params"},

    {NULL,          NULL}
};

// Converter (TrackerMIL)

template<>
struct PyOpenCV_Converter< Ptr<cv::TrackerMIL> >
{
    static PyObject* from(const Ptr<cv::TrackerMIL>& r)
    {
        return pyopencv_TrackerMIL_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TrackerMIL>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TrackerMIL> * dst_;
        if (pyopencv_TrackerMIL_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TrackerMIL> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TrackerMOSSE (Generic)
//================================================================================

// GetSet (TrackerMOSSE)



// Methods (TrackerMOSSE)

static PyObject* pyopencv_cv_TrackerMOSSE_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<TrackerMOSSE> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::TrackerMOSSE::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (TrackerMOSSE)

static PyGetSetDef pyopencv_TrackerMOSSE_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TrackerMOSSE_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerMOSSE_create_static, METH_STATIC), "create() -> retval\n.   @brief Constructor"},

    {NULL,          NULL}
};

// Converter (TrackerMOSSE)

template<>
struct PyOpenCV_Converter< Ptr<cv::TrackerMOSSE> >
{
    static PyObject* from(const Ptr<cv::TrackerMOSSE>& r)
    {
        return pyopencv_TrackerMOSSE_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TrackerMOSSE>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TrackerMOSSE> * dst_;
        if (pyopencv_TrackerMOSSE_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TrackerMOSSE> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TrackerMedianFlow (Generic)
//================================================================================

// GetSet (TrackerMedianFlow)



// Methods (TrackerMedianFlow)

static PyObject* pyopencv_cv_TrackerMedianFlow_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<TrackerMedianFlow> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::TrackerMedianFlow::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (TrackerMedianFlow)

static PyGetSetDef pyopencv_TrackerMedianFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TrackerMedianFlow_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerMedianFlow_create_static, METH_STATIC), "create() -> retval\n.   @brief Constructor\n.       @param parameters Median Flow parameters TrackerMedianFlow::Params"},

    {NULL,          NULL}
};

// Converter (TrackerMedianFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::TrackerMedianFlow> >
{
    static PyObject* from(const Ptr<cv::TrackerMedianFlow>& r)
    {
        return pyopencv_TrackerMedianFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TrackerMedianFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TrackerMedianFlow> * dst_;
        if (pyopencv_TrackerMedianFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TrackerMedianFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// TrackerTLD (Generic)
//================================================================================

// GetSet (TrackerTLD)



// Methods (TrackerTLD)

static PyObject* pyopencv_cv_TrackerTLD_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<TrackerTLD> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::TrackerTLD::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (TrackerTLD)

static PyGetSetDef pyopencv_TrackerTLD_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_TrackerTLD_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_TrackerTLD_create_static, METH_STATIC), "create() -> retval\n.   @brief Constructor\n.       @param parameters TLD parameters TrackerTLD::Params"},

    {NULL,          NULL}
};

// Converter (TrackerTLD)

template<>
struct PyOpenCV_Converter< Ptr<cv::TrackerTLD> >
{
    static PyObject* from(const Ptr<cv::TrackerTLD>& r)
    {
        return pyopencv_TrackerTLD_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::TrackerTLD>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::TrackerTLD> * dst_;
        if (pyopencv_TrackerTLD_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::TrackerTLD> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// UMat (Generic)
//================================================================================

// GetSet (UMat)


static PyObject* pyopencv_UMat_get_offset(pyopencv_UMat_t* p, void *closure)
{
    return pyopencv_from(p->v->offset);
}

static int pyopencv_UMat_set_offset(pyopencv_UMat_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the offset attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->offset) ? 0 : -1;
}


// Methods (UMat)

static int pyopencv_cv_UMat_UMat(pyopencv_UMat_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {
    PyObject* pyobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "usageFlags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:UMat", (char**)keywords, &pyobj_usageFlags) &&
        pyopencv_to(pyobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(usageFlags)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "rows", "cols", "type", "usageFlags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iii|O:UMat", (char**)keywords, &rows, &cols, &type, &pyobj_usageFlags) &&
        pyopencv_to(pyobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(rows, cols, type, usageFlags)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;
    int type=0;
    PyObject* pyobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "size", "type", "usageFlags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:UMat", (char**)keywords, &pyobj_size, &type, &pyobj_usageFlags) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) &&
        pyopencv_to(pyobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(size, type, usageFlags)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "rows", "cols", "type", "s", "usageFlags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiO|O:UMat", (char**)keywords, &rows, &cols, &type, &pyobj_s, &pyobj_usageFlags) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(rows, cols, type, s, usageFlags)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;
    int type=0;
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "size", "type", "s", "usageFlags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO|O:UMat", (char**)keywords, &pyobj_size, &type, &pyobj_s, &pyobj_usageFlags) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(size, type, s, usageFlags)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_m = NULL;
    UMat m;

    const char* keywords[] = { "m", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:UMat", (char**)keywords, &pyobj_m) &&
        pyopencv_to(pyobj_m, m, ArgInfo("m", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(m)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_m = NULL;
    UMat m;
    PyObject* pyobj_rowRange = NULL;
    Range rowRange;
    PyObject* pyobj_colRange = NULL;
    Range colRange=Range::all();

    const char* keywords[] = { "m", "rowRange", "colRange", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:UMat", (char**)keywords, &pyobj_m, &pyobj_rowRange, &pyobj_colRange) &&
        pyopencv_to(pyobj_m, m, ArgInfo("m", 0)) &&
        pyopencv_to(pyobj_rowRange, rowRange, ArgInfo("rowRange", 0)) &&
        pyopencv_to(pyobj_colRange, colRange, ArgInfo("colRange", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(m, rowRange, colRange)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_m = NULL;
    UMat m;
    PyObject* pyobj_roi = NULL;
    Rect roi;

    const char* keywords[] = { "m", "roi", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:UMat", (char**)keywords, &pyobj_m, &pyobj_roi) &&
        pyopencv_to(pyobj_m, m, ArgInfo("m", 0)) &&
        pyopencv_to(pyobj_roi, roi, ArgInfo("roi", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(m, roi)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_m = NULL;
    UMat m;
    PyObject* pyobj_ranges = NULL;
    vector_Range ranges;

    const char* keywords[] = { "m", "ranges", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:UMat", (char**)keywords, &pyobj_m, &pyobj_ranges) &&
        pyopencv_to(pyobj_m, m, ArgInfo("m", 0)) &&
        pyopencv_to(pyobj_ranges, ranges, ArgInfo("ranges", 0)) )
    {
        new (&(self->v)) Ptr<cv::UMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::UMat(m, ranges)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_UMat_context_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    void* retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv_UMat_context());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_UMat_get(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::UMat> * self1 = 0;
    if (!pyopencv_UMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'UMat' or its derivative)");
    Ptr<cv::UMat> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv_UMat_get(_self_));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_UMat_handle(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::UMat> * self1 = 0;
    if (!pyopencv_UMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'UMat' or its derivative)");
    Ptr<cv::UMat> _self_ = *(self1);
    PyObject* pyobj_accessFlags = NULL;
    AccessFlag accessFlags=static_cast<AccessFlag>(0);
    void* retval;

    const char* keywords[] = { "accessFlags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:UMat.handle", (char**)keywords, &pyobj_accessFlags) &&
        pyopencv_to(pyobj_accessFlags, accessFlags, ArgInfo("accessFlags", 0)) )
    {
        ERRWRAP2(retval = _self_->handle(accessFlags));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_UMat_isContinuous(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::UMat> * self1 = 0;
    if (!pyopencv_UMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'UMat' or its derivative)");
    Ptr<cv::UMat> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isContinuous());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_UMat_isSubmatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::UMat> * self1 = 0;
    if (!pyopencv_UMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'UMat' or its derivative)");
    Ptr<cv::UMat> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isSubmatrix());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_UMat_queue_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    void* retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv_UMat_queue());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (UMat)

static PyGetSetDef pyopencv_UMat_getseters[] =
{
    {(char*)"offset", (getter)pyopencv_UMat_get_offset, (setter)pyopencv_UMat_set_offset, (char*)"offset", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_UMat_methods[] =
{
    {"context", CV_PY_FN_WITH_KW_(pyopencv_cv_UMat_context_static, METH_STATIC), "context() -> retval\n."},
    {"get", CV_PY_FN_WITH_KW_(pyopencv_cv_UMat_get, 0), "get() -> retval\n."},
    {"handle", CV_PY_FN_WITH_KW_(pyopencv_cv_UMat_handle, 0), "handle(accessFlags) -> retval\n."},
    {"isContinuous", CV_PY_FN_WITH_KW_(pyopencv_cv_UMat_isContinuous, 0), "isContinuous() -> retval\n."},
    {"isSubmatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_UMat_isSubmatrix, 0), "isSubmatrix() -> retval\n."},
    {"queue", CV_PY_FN_WITH_KW_(pyopencv_cv_UMat_queue_static, METH_STATIC), "queue() -> retval\n."},

    {NULL,          NULL}
};

// Converter (UMat)

template<>
struct PyOpenCV_Converter< Ptr<cv::UMat> >
{
    static PyObject* from(const Ptr<cv::UMat>& r)
    {
        return pyopencv_UMat_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::UMat>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::UMat> * dst_;
        if (pyopencv_UMat_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
    {
        Ptr<Mat> _src;
        if (pyopencv_to(src, _src, name))
        {
            return cv_mappable_to(_src, dst);
        }
    }

        failmsg("Expected Ptr<cv::UMat> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// VariationalRefinement (Generic)
//================================================================================

// GetSet (VariationalRefinement)



// Methods (VariationalRefinement)

static PyObject* pyopencv_cv_VariationalRefinement_calcUV(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    {
    PyObject* pyobj_I0 = NULL;
    Mat I0;
    PyObject* pyobj_I1 = NULL;
    Mat I1;
    PyObject* pyobj_flow_u = NULL;
    Mat flow_u;
    PyObject* pyobj_flow_v = NULL;
    Mat flow_v;

    const char* keywords[] = { "I0", "I1", "flow_u", "flow_v", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO:VariationalRefinement.calcUV", (char**)keywords, &pyobj_I0, &pyobj_I1, &pyobj_flow_u, &pyobj_flow_v) &&
        pyopencv_to(pyobj_I0, I0, ArgInfo("I0", 0)) &&
        pyopencv_to(pyobj_I1, I1, ArgInfo("I1", 0)) &&
        pyopencv_to(pyobj_flow_u, flow_u, ArgInfo("flow_u", 1)) &&
        pyopencv_to(pyobj_flow_v, flow_v, ArgInfo("flow_v", 1)) )
    {
        ERRWRAP2(_self_->calcUV(I0, I1, flow_u, flow_v));
        return Py_BuildValue("(NN)", pyopencv_from(flow_u), pyopencv_from(flow_v));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_I0 = NULL;
    UMat I0;
    PyObject* pyobj_I1 = NULL;
    UMat I1;
    PyObject* pyobj_flow_u = NULL;
    UMat flow_u;
    PyObject* pyobj_flow_v = NULL;
    UMat flow_v;

    const char* keywords[] = { "I0", "I1", "flow_u", "flow_v", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO:VariationalRefinement.calcUV", (char**)keywords, &pyobj_I0, &pyobj_I1, &pyobj_flow_u, &pyobj_flow_v) &&
        pyopencv_to(pyobj_I0, I0, ArgInfo("I0", 0)) &&
        pyopencv_to(pyobj_I1, I1, ArgInfo("I1", 0)) &&
        pyopencv_to(pyobj_flow_u, flow_u, ArgInfo("flow_u", 1)) &&
        pyopencv_to(pyobj_flow_v, flow_v, ArgInfo("flow_v", 1)) )
    {
        ERRWRAP2(_self_->calcUV(I0, I1, flow_u, flow_v));
        return Py_BuildValue("(NN)", pyopencv_from(flow_u), pyopencv_from(flow_v));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    Ptr<VariationalRefinement> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::VariationalRefinement::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_getAlpha(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAlpha());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_getDelta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDelta());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_getFixedPointIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFixedPointIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_getGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGamma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_getOmega(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getOmega());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_getSorIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSorIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_setAlpha(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:VariationalRefinement.setAlpha", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setAlpha(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_setDelta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:VariationalRefinement.setDelta", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setDelta(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_setFixedPointIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:VariationalRefinement.setFixedPointIterations", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setFixedPointIterations(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_setGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:VariationalRefinement.setGamma", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setGamma(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_setOmega(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:VariationalRefinement.setOmega", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setOmega(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_VariationalRefinement_setSorIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VariationalRefinement> * self1 = 0;
    if (!pyopencv_VariationalRefinement_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VariationalRefinement' or its derivative)");
    Ptr<cv::VariationalRefinement> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:VariationalRefinement.setSorIterations", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setSorIterations(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (VariationalRefinement)

static PyGetSetDef pyopencv_VariationalRefinement_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_VariationalRefinement_methods[] =
{
    {"calcUV", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_calcUV, 0), "calcUV(I0, I1, flow_u, flow_v) -> flow_u, flow_v\n.   @brief @ref calc function overload to handle separate horizontal (u) and vertical (v) flow components\n.   (to avoid extra splits/merges)"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_create_static, METH_STATIC), "create() -> retval\n.   @brief Creates an instance of VariationalRefinement"},
    {"getAlpha", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_getAlpha, 0), "getAlpha() -> retval\n.   @brief Weight of the smoothness term\n.   @see setAlpha"},
    {"getDelta", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_getDelta, 0), "getDelta() -> retval\n.   @brief Weight of the color constancy term\n.   @see setDelta"},
    {"getFixedPointIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_getFixedPointIterations, 0), "getFixedPointIterations() -> retval\n.   @brief Number of outer (fixed-point) iterations in the minimization procedure.\n.   @see setFixedPointIterations"},
    {"getGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_getGamma, 0), "getGamma() -> retval\n.   @brief Weight of the gradient constancy term\n.   @see setGamma"},
    {"getOmega", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_getOmega, 0), "getOmega() -> retval\n.   @brief Relaxation factor in SOR\n.   @see setOmega"},
    {"getSorIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_getSorIterations, 0), "getSorIterations() -> retval\n.   @brief Number of inner successive over-relaxation (SOR) iterations\n.           in the minimization procedure to solve the respective linear system.\n.   @see setSorIterations"},
    {"setAlpha", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_setAlpha, 0), "setAlpha(val) -> None\n.   @copybrief getAlpha @see getAlpha"},
    {"setDelta", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_setDelta, 0), "setDelta(val) -> None\n.   @copybrief getDelta @see getDelta"},
    {"setFixedPointIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_setFixedPointIterations, 0), "setFixedPointIterations(val) -> None\n.   @copybrief getFixedPointIterations @see getFixedPointIterations"},
    {"setGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_setGamma, 0), "setGamma(val) -> None\n.   @copybrief getGamma @see getGamma"},
    {"setOmega", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_setOmega, 0), "setOmega(val) -> None\n.   @copybrief getOmega @see getOmega"},
    {"setSorIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_VariationalRefinement_setSorIterations, 0), "setSorIterations(val) -> None\n.   @copybrief getSorIterations @see getSorIterations"},

    {NULL,          NULL}
};

// Converter (VariationalRefinement)

template<>
struct PyOpenCV_Converter< Ptr<cv::VariationalRefinement> >
{
    static PyObject* from(const Ptr<cv::VariationalRefinement>& r)
    {
        return pyopencv_VariationalRefinement_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::VariationalRefinement>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::VariationalRefinement> * dst_;
        if (pyopencv_VariationalRefinement_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::VariationalRefinement> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// VideoCapture (Generic)
//================================================================================

// GetSet (VideoCapture)



// Methods (VideoCapture)

static int pyopencv_cv_VideoCapture_VideoCapture(pyopencv_VideoCapture_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::VideoCapture>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::VideoCapture()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    int apiPreference=CAP_ANY;

    const char* keywords[] = { "filename", "apiPreference", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:VideoCapture", (char**)keywords, &pyobj_filename, &apiPreference) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        new (&(self->v)) Ptr<cv::VideoCapture>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::VideoCapture(filename, apiPreference)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int index=0;
    int apiPreference=CAP_ANY;

    const char* keywords[] = { "index", "apiPreference", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|i:VideoCapture", (char**)keywords, &index, &apiPreference) )
    {
        new (&(self->v)) Ptr<cv::VideoCapture>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::VideoCapture(index, apiPreference)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_VideoCapture_get(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    int propId=0;
    double retval;

    const char* keywords[] = { "propId", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:VideoCapture.get", (char**)keywords, &propId) )
    {
        ERRWRAP2(retval = _self_->get(propId));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_getBackendName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBackendName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_getExceptionMode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getExceptionMode());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_grab(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->grab());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_isOpened(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isOpened());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_open(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    {
    PyObject* pyobj_filename = NULL;
    String filename;
    int apiPreference=CAP_ANY;
    bool retval;

    const char* keywords[] = { "filename", "apiPreference", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:VideoCapture.open", (char**)keywords, &pyobj_filename, &apiPreference) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        ERRWRAP2(retval = _self_->open(filename, apiPreference));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    int index=0;
    int apiPreference=CAP_ANY;
    bool retval;

    const char* keywords[] = { "index", "apiPreference", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|i:VideoCapture.open", (char**)keywords, &index, &apiPreference) )
    {
        ERRWRAP2(retval = _self_->open(index, apiPreference));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    bool retval;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:VideoCapture.read", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(retval = _self_->read(image));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(image));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    bool retval;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:VideoCapture.read", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(retval = _self_->read(image));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(image));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_release(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->release());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_retrieve(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    int flag=0;
    bool retval;

    const char* keywords[] = { "image", "flag", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Oi:VideoCapture.retrieve", (char**)keywords, &pyobj_image, &flag) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(retval = _self_->retrieve(image, flag));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(image));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    int flag=0;
    bool retval;

    const char* keywords[] = { "image", "flag", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Oi:VideoCapture.retrieve", (char**)keywords, &pyobj_image, &flag) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(retval = _self_->retrieve(image, flag));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(image));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_set(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    int propId=0;
    double value=0;
    bool retval;

    const char* keywords[] = { "propId", "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "id:VideoCapture.set", (char**)keywords, &propId, &value) )
    {
        ERRWRAP2(retval = _self_->set(propId, value));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoCapture_setExceptionMode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoCapture> * self1 = 0;
    if (!pyopencv_VideoCapture_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoCapture' or its derivative)");
    Ptr<cv::VideoCapture> _self_ = *(self1);
    bool enable=0;

    const char* keywords[] = { "enable", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:VideoCapture.setExceptionMode", (char**)keywords, &enable) )
    {
        ERRWRAP2(_self_->setExceptionMode(enable));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (VideoCapture)

static PyGetSetDef pyopencv_VideoCapture_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_VideoCapture_methods[] =
{
    {"get", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_get, 0), "get(propId) -> retval\n.   @brief Returns the specified VideoCapture property\n.   \n.       @param propId Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)\n.       or one from @ref videoio_flags_others\n.       @return Value for the specified property. Value 0 is returned when querying a property that is\n.       not supported by the backend used by the VideoCapture instance.\n.   \n.       @note Reading / writing properties involves many layers. Some unexpected result might happens\n.       along this chain.\n.       @code{.txt}\n.       VideoCapture -> API Backend -> Operating System -> Device Driver -> Device Hardware\n.       @endcode\n.       The returned value might be different from what really used by the device or it could be encoded\n.       using device dependent rules (eg. steps or percentage). Effective behaviour depends from device\n.       driver and API Backend"},
    {"getBackendName", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_getBackendName, 0), "getBackendName() -> retval\n.   @brief Returns used backend API name\n.   \n.        @note Stream should be opened."},
    {"getExceptionMode", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_getExceptionMode, 0), "getExceptionMode() -> retval\n."},
    {"grab", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_grab, 0), "grab() -> retval\n.   @brief Grabs the next frame from video file or capturing device.\n.   \n.       @return `true` (non-zero) in the case of success.\n.   \n.       The method/function grabs the next frame from video file or camera and returns true (non-zero) in\n.       the case of success.\n.   \n.       The primary use of the function is in multi-camera environments, especially when the cameras do not\n.       have hardware synchronization. That is, you call VideoCapture::grab() for each camera and after that\n.       call the slower method VideoCapture::retrieve() to decode and get frame from each camera. This way\n.       the overhead on demosaicing or motion jpeg decompression etc. is eliminated and the retrieved frames\n.       from different cameras will be closer in time.\n.   \n.       Also, when a connected camera is multi-head (for example, a stereo camera or a Kinect device), the\n.       correct way of retrieving data from it is to call VideoCapture::grab() first and then call\n.       VideoCapture::retrieve() one or more times with different values of the channel parameter.\n.   \n.       @ref tutorial_kinect_openni"},
    {"isOpened", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_isOpened, 0), "isOpened() -> retval\n.   @brief Returns true if video capturing has been initialized already.\n.   \n.       If the previous call to VideoCapture constructor or VideoCapture::open() succeeded, the method returns\n.       true."},
    {"open", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_open, 0), "open(filename[, apiPreference]) -> retval\n.   @brief  Opens a video file or a capturing device or an IP video stream for video capturing.\n.   \n.       @overload\n.   \n.       Parameters are same as the constructor VideoCapture(const String& filename, int apiPreference = CAP_ANY)\n.       @return `true` if the file has been successfully opened\n.   \n.       The method first calls VideoCapture::release to close the already opened file or camera.\n\n\n\nopen(index[, apiPreference]) -> retval\n.   @brief  Opens a camera for video capturing\n.   \n.       @overload\n.   \n.       Parameters are same as the constructor VideoCapture(int index, int apiPreference = CAP_ANY)\n.       @return `true` if the camera has been successfully opened.\n.   \n.       The method first calls VideoCapture::release to close the already opened file or camera."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_read, 0), "read([, image]) -> retval, image\n.   @brief Grabs, decodes and returns the next video frame.\n.   \n.       @param [out] image the video frame is returned here. If no frames has been grabbed the image will be empty.\n.       @return `false` if no frames has been grabbed\n.   \n.       The method/function combines VideoCapture::grab() and VideoCapture::retrieve() in one call. This is the\n.       most convenient method for reading video files or capturing data from decode and returns the just\n.       grabbed frame. If no frames has been grabbed (camera has been disconnected, or there are no more\n.       frames in video file), the method returns false and the function returns empty image (with %cv::Mat, test it with Mat::empty()).\n.   \n.       @note In @ref videoio_c \"C API\", functions cvRetrieveFrame() and cv.RetrieveFrame() return image stored inside the video\n.       capturing structure. It is not allowed to modify or release the image! You can copy the frame using\n.       cvCloneImage and then do whatever you want with the copy."},
    {"release", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_release, 0), "release() -> None\n.   @brief Closes video file or capturing device.\n.   \n.       The method is automatically called by subsequent VideoCapture::open and by VideoCapture\n.       destructor.\n.   \n.       The C function also deallocates memory and clears \\*capture pointer."},
    {"retrieve", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_retrieve, 0), "retrieve([, image[, flag]]) -> retval, image\n.   @brief Decodes and returns the grabbed video frame.\n.   \n.       @param [out] image the video frame is returned here. If no frames has been grabbed the image will be empty.\n.       @param flag it could be a frame index or a driver specific flag\n.       @return `false` if no frames has been grabbed\n.   \n.       The method decodes and returns the just grabbed frame. If no frames has been grabbed\n.       (camera has been disconnected, or there are no more frames in video file), the method returns false\n.       and the function returns an empty image (with %cv::Mat, test it with Mat::empty()).\n.   \n.       @sa read()\n.   \n.       @note In @ref videoio_c \"C API\", functions cvRetrieveFrame() and cv.RetrieveFrame() return image stored inside the video\n.       capturing structure. It is not allowed to modify or release the image! You can copy the frame using\n.       cvCloneImage and then do whatever you want with the copy."},
    {"set", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_set, 0), "set(propId, value) -> retval\n.   @brief Sets a property in the VideoCapture.\n.   \n.       @param propId Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)\n.       or one from @ref videoio_flags_others\n.       @param value Value of the property.\n.       @return `true` if the property is supported by backend used by the VideoCapture instance.\n.       @note Even if it returns `true` this doesn't ensure that the property\n.       value has been accepted by the capture device. See note in VideoCapture::get()"},
    {"setExceptionMode", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoCapture_setExceptionMode, 0), "setExceptionMode(enable) -> None\n.   Switches exceptions mode\n.        *\n.        * methods raise exceptions if not successful instead of returning an error code"},

    {NULL,          NULL}
};

// Converter (VideoCapture)

template<>
struct PyOpenCV_Converter< Ptr<cv::VideoCapture> >
{
    static PyObject* from(const Ptr<cv::VideoCapture>& r)
    {
        return pyopencv_VideoCapture_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::VideoCapture>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::VideoCapture> * dst_;
        if (pyopencv_VideoCapture_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::VideoCapture> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// VideoWriter (Generic)
//================================================================================

// GetSet (VideoWriter)



// Methods (VideoWriter)

static int pyopencv_cv_VideoWriter_VideoWriter(pyopencv_VideoWriter_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::VideoWriter>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::VideoWriter()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    int fourcc=0;
    double fps=0;
    PyObject* pyobj_frameSize = NULL;
    Size frameSize;
    bool isColor=true;

    const char* keywords[] = { "filename", "fourcc", "fps", "frameSize", "isColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OidO|b:VideoWriter", (char**)keywords, &pyobj_filename, &fourcc, &fps, &pyobj_frameSize, &isColor) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_frameSize, frameSize, ArgInfo("frameSize", 0)) )
    {
        new (&(self->v)) Ptr<cv::VideoWriter>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::VideoWriter(filename, fourcc, fps, frameSize, isColor)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    int apiPreference=0;
    int fourcc=0;
    double fps=0;
    PyObject* pyobj_frameSize = NULL;
    Size frameSize;
    bool isColor=true;

    const char* keywords[] = { "filename", "apiPreference", "fourcc", "fps", "frameSize", "isColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiidO|b:VideoWriter", (char**)keywords, &pyobj_filename, &apiPreference, &fourcc, &fps, &pyobj_frameSize, &isColor) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_frameSize, frameSize, ArgInfo("frameSize", 0)) )
    {
        new (&(self->v)) Ptr<cv::VideoWriter>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::VideoWriter(filename, apiPreference, fourcc, fps, frameSize, isColor)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_VideoWriter_fourcc_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;

    PyObject* pyobj_c1 = NULL;
    char c1;
    PyObject* pyobj_c2 = NULL;
    char c2;
    PyObject* pyobj_c3 = NULL;
    char c3;
    PyObject* pyobj_c4 = NULL;
    char c4;
    int retval;

    const char* keywords[] = { "c1", "c2", "c3", "c4", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO:VideoWriter.fourcc", (char**)keywords, &pyobj_c1, &pyobj_c2, &pyobj_c3, &pyobj_c4) &&
        convert_to_char(pyobj_c1, &c1, ArgInfo("c1", 0)) &&
        convert_to_char(pyobj_c2, &c2, ArgInfo("c2", 0)) &&
        convert_to_char(pyobj_c3, &c3, ArgInfo("c3", 0)) &&
        convert_to_char(pyobj_c4, &c4, ArgInfo("c4", 0)) )
    {
        ERRWRAP2(retval = cv::VideoWriter::fourcc(c1, c2, c3, c4));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoWriter_get(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoWriter> * self1 = 0;
    if (!pyopencv_VideoWriter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoWriter' or its derivative)");
    Ptr<cv::VideoWriter> _self_ = *(self1);
    int propId=0;
    double retval;

    const char* keywords[] = { "propId", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:VideoWriter.get", (char**)keywords, &propId) )
    {
        ERRWRAP2(retval = _self_->get(propId));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoWriter_getBackendName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoWriter> * self1 = 0;
    if (!pyopencv_VideoWriter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoWriter' or its derivative)");
    Ptr<cv::VideoWriter> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBackendName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoWriter_isOpened(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoWriter> * self1 = 0;
    if (!pyopencv_VideoWriter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoWriter' or its derivative)");
    Ptr<cv::VideoWriter> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isOpened());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoWriter_open(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoWriter> * self1 = 0;
    if (!pyopencv_VideoWriter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoWriter' or its derivative)");
    Ptr<cv::VideoWriter> _self_ = *(self1);
    {
    PyObject* pyobj_filename = NULL;
    String filename;
    int fourcc=0;
    double fps=0;
    PyObject* pyobj_frameSize = NULL;
    Size frameSize;
    bool isColor=true;
    bool retval;

    const char* keywords[] = { "filename", "fourcc", "fps", "frameSize", "isColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OidO|b:VideoWriter.open", (char**)keywords, &pyobj_filename, &fourcc, &fps, &pyobj_frameSize, &isColor) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_frameSize, frameSize, ArgInfo("frameSize", 0)) )
    {
        ERRWRAP2(retval = _self_->open(filename, fourcc, fps, frameSize, isColor));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    int apiPreference=0;
    int fourcc=0;
    double fps=0;
    PyObject* pyobj_frameSize = NULL;
    Size frameSize;
    bool isColor=true;
    bool retval;

    const char* keywords[] = { "filename", "apiPreference", "fourcc", "fps", "frameSize", "isColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiidO|b:VideoWriter.open", (char**)keywords, &pyobj_filename, &apiPreference, &fourcc, &fps, &pyobj_frameSize, &isColor) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_frameSize, frameSize, ArgInfo("frameSize", 0)) )
    {
        ERRWRAP2(retval = _self_->open(filename, apiPreference, fourcc, fps, frameSize, isColor));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoWriter_release(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoWriter> * self1 = 0;
    if (!pyopencv_VideoWriter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoWriter' or its derivative)");
    Ptr<cv::VideoWriter> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->release());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoWriter_set(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoWriter> * self1 = 0;
    if (!pyopencv_VideoWriter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoWriter' or its derivative)");
    Ptr<cv::VideoWriter> _self_ = *(self1);
    int propId=0;
    double value=0;
    bool retval;

    const char* keywords[] = { "propId", "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "id:VideoWriter.set", (char**)keywords, &propId, &value) )
    {
        ERRWRAP2(retval = _self_->set(propId, value));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_VideoWriter_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv;


    Ptr<cv::VideoWriter> * self1 = 0;
    if (!pyopencv_VideoWriter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'VideoWriter' or its derivative)");
    Ptr<cv::VideoWriter> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:VideoWriter.write", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(_self_->write(image));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;

    const char* keywords[] = { "image", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:VideoWriter.write", (char**)keywords, &pyobj_image) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(_self_->write(image));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (VideoWriter)

static PyGetSetDef pyopencv_VideoWriter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_VideoWriter_methods[] =
{
    {"fourcc", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoWriter_fourcc_static, METH_STATIC), "fourcc(c1, c2, c3, c4) -> retval\n.   @brief Concatenates 4 chars to a fourcc code\n.   \n.       @return a fourcc code\n.   \n.       This static method constructs the fourcc code of the codec to be used in the constructor\n.       VideoWriter::VideoWriter or VideoWriter::open."},
    {"get", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoWriter_get, 0), "get(propId) -> retval\n.   @brief Returns the specified VideoWriter property\n.   \n.        @param propId Property identifier from cv::VideoWriterProperties (eg. cv::VIDEOWRITER_PROP_QUALITY)\n.        or one of @ref videoio_flags_others\n.   \n.        @return Value for the specified property. Value 0 is returned when querying a property that is\n.        not supported by the backend used by the VideoWriter instance."},
    {"getBackendName", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoWriter_getBackendName, 0), "getBackendName() -> retval\n.   @brief Returns used backend API name\n.   \n.        @note Stream should be opened."},
    {"isOpened", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoWriter_isOpened, 0), "isOpened() -> retval\n.   @brief Returns true if video writer has been successfully initialized."},
    {"open", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoWriter_open, 0), "open(filename, fourcc, fps, frameSize[, isColor]) -> retval\n.   @brief Initializes or reinitializes video writer.\n.   \n.       The method opens video writer. Parameters are the same as in the constructor\n.       VideoWriter::VideoWriter.\n.       @return `true` if video writer has been successfully initialized\n.   \n.       The method first calls VideoWriter::release to close the already opened file.\n\n\n\nopen(filename, apiPreference, fourcc, fps, frameSize[, isColor]) -> retval\n.   @overload"},
    {"release", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoWriter_release, 0), "release() -> None\n.   @brief Closes the video writer.\n.   \n.       The method is automatically called by subsequent VideoWriter::open and by the VideoWriter\n.       destructor."},
    {"set", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoWriter_set, 0), "set(propId, value) -> retval\n.   @brief Sets a property in the VideoWriter.\n.   \n.        @param propId Property identifier from cv::VideoWriterProperties (eg. cv::VIDEOWRITER_PROP_QUALITY)\n.        or one of @ref videoio_flags_others\n.   \n.        @param value Value of the property.\n.        @return  `true` if the property is supported by the backend used by the VideoWriter instance."},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_VideoWriter_write, 0), "write(image) -> None\n.   @brief Writes the next video frame\n.   \n.       @param image The written frame. In general, color images are expected in BGR format.\n.   \n.       The function/method writes the specified image to video file. It must have the same size as has\n.       been specified when opening the video writer."},

    {NULL,          NULL}
};

// Converter (VideoWriter)

template<>
struct PyOpenCV_Converter< Ptr<cv::VideoWriter> >
{
    static PyObject* from(const Ptr<cv::VideoWriter>& r)
    {
        return pyopencv_VideoWriter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::VideoWriter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::VideoWriter> * dst_;
        if (pyopencv_VideoWriter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::VideoWriter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// WarperCreator (Generic)
//================================================================================

// GetSet (WarperCreator)



// Methods (WarperCreator)



// Tables (WarperCreator)

static PyGetSetDef pyopencv_WarperCreator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_WarperCreator_methods[] =
{

    {NULL,          NULL}
};

// Converter (WarperCreator)

template<>
struct PyOpenCV_Converter< Ptr<cv::WarperCreator> >
{
    static PyObject* from(const Ptr<cv::WarperCreator>& r)
    {
        return pyopencv_WarperCreator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::WarperCreator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::WarperCreator> * dst_;
        if (pyopencv_WarperCreator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::WarperCreator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// aruco_Board (Generic)
//================================================================================

// GetSet (aruco_Board)


static PyObject* pyopencv_aruco_Board_get_dictionary(pyopencv_aruco_Board_t* p, void *closure)
{
    return pyopencv_from(p->v->dictionary);
}

static PyObject* pyopencv_aruco_Board_get_ids(pyopencv_aruco_Board_t* p, void *closure)
{
    return pyopencv_from(p->v->ids);
}

static PyObject* pyopencv_aruco_Board_get_objPoints(pyopencv_aruco_Board_t* p, void *closure)
{
    return pyopencv_from(p->v->objPoints);
}


// Methods (aruco_Board)

static PyObject* pyopencv_cv_aruco_aruco_Board_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    {
    PyObject* pyobj_objPoints = NULL;
    vector_Mat objPoints;
    PyObject* pyobj_dictionary = NULL;
    Ptr<Dictionary> dictionary;
    PyObject* pyobj_ids = NULL;
    Mat ids;
    Ptr<Board> retval;

    const char* keywords[] = { "objPoints", "dictionary", "ids", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:aruco_Board.create", (char**)keywords, &pyobj_objPoints, &pyobj_dictionary, &pyobj_ids) &&
        pyopencv_to(pyobj_objPoints, objPoints, ArgInfo("objPoints", 0)) &&
        pyopencv_to(pyobj_dictionary, dictionary, ArgInfo("dictionary", 0)) &&
        pyopencv_to(pyobj_ids, ids, ArgInfo("ids", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::Board::create(objPoints, dictionary, ids));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_objPoints = NULL;
    vector_Mat objPoints;
    PyObject* pyobj_dictionary = NULL;
    Ptr<Dictionary> dictionary;
    PyObject* pyobj_ids = NULL;
    UMat ids;
    Ptr<Board> retval;

    const char* keywords[] = { "objPoints", "dictionary", "ids", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:aruco_Board.create", (char**)keywords, &pyobj_objPoints, &pyobj_dictionary, &pyobj_ids) &&
        pyopencv_to(pyobj_objPoints, objPoints, ArgInfo("objPoints", 0)) &&
        pyopencv_to(pyobj_dictionary, dictionary, ArgInfo("dictionary", 0)) &&
        pyopencv_to(pyobj_ids, ids, ArgInfo("ids", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::Board::create(objPoints, dictionary, ids));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (aruco_Board)

static PyGetSetDef pyopencv_aruco_Board_getseters[] =
{
    {(char*)"dictionary", (getter)pyopencv_aruco_Board_get_dictionary, NULL, (char*)"dictionary", NULL},
    {(char*)"ids", (getter)pyopencv_aruco_Board_get_ids, NULL, (char*)"ids", NULL},
    {(char*)"objPoints", (getter)pyopencv_aruco_Board_get_objPoints, NULL, (char*)"objPoints", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_aruco_Board_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_Board_create_static, METH_STATIC), "create(objPoints, dictionary, ids) -> retval\n.   * @brief Provide way to create Board by passing necessary data. Specially needed in Python.\n.       *\n.       * @param objPoints array of object points of all the marker corners in the board\n.       * @param dictionary the dictionary of markers employed for this board\n.       * @param ids vector of the identifiers of the markers in the board\n.       *"},

    {NULL,          NULL}
};

// Converter (aruco_Board)

template<>
struct PyOpenCV_Converter< Ptr<cv::aruco::Board> >
{
    static PyObject* from(const Ptr<cv::aruco::Board>& r)
    {
        return pyopencv_aruco_Board_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::aruco::Board>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::aruco::Board> * dst_;
        if (pyopencv_aruco_Board_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::aruco::Board> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// aruco_CharucoBoard (Generic)
//================================================================================

// GetSet (aruco_CharucoBoard)


static PyObject* pyopencv_aruco_CharucoBoard_get_chessboardCorners(pyopencv_aruco_CharucoBoard_t* p, void *closure)
{
    return pyopencv_from(p->v->chessboardCorners);
}

static PyObject* pyopencv_aruco_CharucoBoard_get_nearestMarkerCorners(pyopencv_aruco_CharucoBoard_t* p, void *closure)
{
    return pyopencv_from(p->v->nearestMarkerCorners);
}

static PyObject* pyopencv_aruco_CharucoBoard_get_nearestMarkerIdx(pyopencv_aruco_CharucoBoard_t* p, void *closure)
{
    return pyopencv_from(p->v->nearestMarkerIdx);
}


// Methods (aruco_CharucoBoard)

static PyObject* pyopencv_cv_aruco_aruco_CharucoBoard_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    int squaresX=0;
    int squaresY=0;
    float squareLength=0.f;
    float markerLength=0.f;
    PyObject* pyobj_dictionary = NULL;
    Ptr<Dictionary> dictionary;
    Ptr<CharucoBoard> retval;

    const char* keywords[] = { "squaresX", "squaresY", "squareLength", "markerLength", "dictionary", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiffO:aruco_CharucoBoard.create", (char**)keywords, &squaresX, &squaresY, &squareLength, &markerLength, &pyobj_dictionary) &&
        pyopencv_to(pyobj_dictionary, dictionary, ArgInfo("dictionary", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::CharucoBoard::create(squaresX, squaresY, squareLength, markerLength, dictionary));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_CharucoBoard_draw(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::CharucoBoard> * self1 = 0;
    if (!pyopencv_aruco_CharucoBoard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_CharucoBoard' or its derivative)");
    Ptr<cv::aruco::CharucoBoard> _self_ = *(self1);
    {
    PyObject* pyobj_outSize = NULL;
    Size outSize;
    PyObject* pyobj_img = NULL;
    Mat img;
    int marginSize=0;
    int borderBits=1;

    const char* keywords[] = { "outSize", "img", "marginSize", "borderBits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oii:aruco_CharucoBoard.draw", (char**)keywords, &pyobj_outSize, &pyobj_img, &marginSize, &borderBits) &&
        pyopencv_to(pyobj_outSize, outSize, ArgInfo("outSize", 0)) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 1)) )
    {
        ERRWRAP2(_self_->draw(outSize, img, marginSize, borderBits));
        return pyopencv_from(img);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_outSize = NULL;
    Size outSize;
    PyObject* pyobj_img = NULL;
    UMat img;
    int marginSize=0;
    int borderBits=1;

    const char* keywords[] = { "outSize", "img", "marginSize", "borderBits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oii:aruco_CharucoBoard.draw", (char**)keywords, &pyobj_outSize, &pyobj_img, &marginSize, &borderBits) &&
        pyopencv_to(pyobj_outSize, outSize, ArgInfo("outSize", 0)) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 1)) )
    {
        ERRWRAP2(_self_->draw(outSize, img, marginSize, borderBits));
        return pyopencv_from(img);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_CharucoBoard_getChessboardSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::CharucoBoard> * self1 = 0;
    if (!pyopencv_aruco_CharucoBoard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_CharucoBoard' or its derivative)");
    Ptr<cv::aruco::CharucoBoard> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getChessboardSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_CharucoBoard_getMarkerLength(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::CharucoBoard> * self1 = 0;
    if (!pyopencv_aruco_CharucoBoard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_CharucoBoard' or its derivative)");
    Ptr<cv::aruco::CharucoBoard> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMarkerLength());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_CharucoBoard_getSquareLength(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::CharucoBoard> * self1 = 0;
    if (!pyopencv_aruco_CharucoBoard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_CharucoBoard' or its derivative)");
    Ptr<cv::aruco::CharucoBoard> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSquareLength());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (aruco_CharucoBoard)

static PyGetSetDef pyopencv_aruco_CharucoBoard_getseters[] =
{
    {(char*)"chessboardCorners", (getter)pyopencv_aruco_CharucoBoard_get_chessboardCorners, NULL, (char*)"chessboardCorners", NULL},
    {(char*)"nearestMarkerCorners", (getter)pyopencv_aruco_CharucoBoard_get_nearestMarkerCorners, NULL, (char*)"nearestMarkerCorners", NULL},
    {(char*)"nearestMarkerIdx", (getter)pyopencv_aruco_CharucoBoard_get_nearestMarkerIdx, NULL, (char*)"nearestMarkerIdx", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_aruco_CharucoBoard_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_CharucoBoard_create_static, METH_STATIC), "create(squaresX, squaresY, squareLength, markerLength, dictionary) -> retval\n.   * @brief Create a CharucoBoard object\n.        *\n.        * @param squaresX number of chessboard squares in X direction\n.        * @param squaresY number of chessboard squares in Y direction\n.        * @param squareLength chessboard square side length (normally in meters)\n.        * @param markerLength marker side length (same unit than squareLength)\n.        * @param dictionary dictionary of markers indicating the type of markers.\n.        * The first markers in the dictionary are used to fill the white chessboard squares.\n.        * @return the output CharucoBoard object\n.        *\n.        * This functions creates a CharucoBoard object given the number of squares in each direction\n.        * and the size of the markers and chessboard squares."},
    {"draw", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_CharucoBoard_draw, 0), "draw(outSize[, img[, marginSize[, borderBits]]]) -> img\n.   * @brief Draw a ChArUco board\n.        *\n.        * @param outSize size of the output image in pixels.\n.        * @param img output image with the board. The size of this image will be outSize\n.        * and the board will be on the center, keeping the board proportions.\n.        * @param marginSize minimum margins (in pixels) of the board in the output image\n.        * @param borderBits width of the marker borders.\n.        *\n.        * This function return the image of the ChArUco board, ready to be printed."},
    {"getChessboardSize", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_CharucoBoard_getChessboardSize, 0), "getChessboardSize() -> retval\n.   *"},
    {"getMarkerLength", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_CharucoBoard_getMarkerLength, 0), "getMarkerLength() -> retval\n.   *"},
    {"getSquareLength", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_CharucoBoard_getSquareLength, 0), "getSquareLength() -> retval\n.   *"},

    {NULL,          NULL}
};

// Converter (aruco_CharucoBoard)

template<>
struct PyOpenCV_Converter< Ptr<cv::aruco::CharucoBoard> >
{
    static PyObject* from(const Ptr<cv::aruco::CharucoBoard>& r)
    {
        return pyopencv_aruco_CharucoBoard_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::aruco::CharucoBoard>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::aruco::CharucoBoard> * dst_;
        if (pyopencv_aruco_CharucoBoard_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::aruco::CharucoBoard> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// aruco_DetectorParameters (Generic)
//================================================================================

// GetSet (aruco_DetectorParameters)


static PyObject* pyopencv_aruco_DetectorParameters_get_adaptiveThreshConstant(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->adaptiveThreshConstant);
}

static int pyopencv_aruco_DetectorParameters_set_adaptiveThreshConstant(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptiveThreshConstant attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->adaptiveThreshConstant) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_adaptiveThreshWinSizeMax(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->adaptiveThreshWinSizeMax);
}

static int pyopencv_aruco_DetectorParameters_set_adaptiveThreshWinSizeMax(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptiveThreshWinSizeMax attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->adaptiveThreshWinSizeMax) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_adaptiveThreshWinSizeMin(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->adaptiveThreshWinSizeMin);
}

static int pyopencv_aruco_DetectorParameters_set_adaptiveThreshWinSizeMin(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptiveThreshWinSizeMin attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->adaptiveThreshWinSizeMin) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_adaptiveThreshWinSizeStep(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->adaptiveThreshWinSizeStep);
}

static int pyopencv_aruco_DetectorParameters_set_adaptiveThreshWinSizeStep(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptiveThreshWinSizeStep attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->adaptiveThreshWinSizeStep) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_aprilTagCriticalRad(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->aprilTagCriticalRad);
}

static int pyopencv_aruco_DetectorParameters_set_aprilTagCriticalRad(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aprilTagCriticalRad attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->aprilTagCriticalRad) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_aprilTagDeglitch(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->aprilTagDeglitch);
}

static int pyopencv_aruco_DetectorParameters_set_aprilTagDeglitch(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aprilTagDeglitch attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->aprilTagDeglitch) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_aprilTagMaxLineFitMse(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->aprilTagMaxLineFitMse);
}

static int pyopencv_aruco_DetectorParameters_set_aprilTagMaxLineFitMse(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aprilTagMaxLineFitMse attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->aprilTagMaxLineFitMse) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_aprilTagMaxNmaxima(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->aprilTagMaxNmaxima);
}

static int pyopencv_aruco_DetectorParameters_set_aprilTagMaxNmaxima(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aprilTagMaxNmaxima attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->aprilTagMaxNmaxima) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_aprilTagMinClusterPixels(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->aprilTagMinClusterPixels);
}

static int pyopencv_aruco_DetectorParameters_set_aprilTagMinClusterPixels(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aprilTagMinClusterPixels attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->aprilTagMinClusterPixels) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_aprilTagMinWhiteBlackDiff(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->aprilTagMinWhiteBlackDiff);
}

static int pyopencv_aruco_DetectorParameters_set_aprilTagMinWhiteBlackDiff(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aprilTagMinWhiteBlackDiff attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->aprilTagMinWhiteBlackDiff) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_aprilTagQuadDecimate(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->aprilTagQuadDecimate);
}

static int pyopencv_aruco_DetectorParameters_set_aprilTagQuadDecimate(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aprilTagQuadDecimate attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->aprilTagQuadDecimate) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_aprilTagQuadSigma(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->aprilTagQuadSigma);
}

static int pyopencv_aruco_DetectorParameters_set_aprilTagQuadSigma(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aprilTagQuadSigma attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->aprilTagQuadSigma) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_cornerRefinementMaxIterations(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->cornerRefinementMaxIterations);
}

static int pyopencv_aruco_DetectorParameters_set_cornerRefinementMaxIterations(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the cornerRefinementMaxIterations attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->cornerRefinementMaxIterations) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_cornerRefinementMethod(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->cornerRefinementMethod);
}

static int pyopencv_aruco_DetectorParameters_set_cornerRefinementMethod(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the cornerRefinementMethod attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->cornerRefinementMethod) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_cornerRefinementMinAccuracy(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->cornerRefinementMinAccuracy);
}

static int pyopencv_aruco_DetectorParameters_set_cornerRefinementMinAccuracy(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the cornerRefinementMinAccuracy attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->cornerRefinementMinAccuracy) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_cornerRefinementWinSize(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->cornerRefinementWinSize);
}

static int pyopencv_aruco_DetectorParameters_set_cornerRefinementWinSize(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the cornerRefinementWinSize attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->cornerRefinementWinSize) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_detectInvertedMarker(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->detectInvertedMarker);
}

static int pyopencv_aruco_DetectorParameters_set_detectInvertedMarker(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the detectInvertedMarker attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->detectInvertedMarker) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_errorCorrectionRate(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->errorCorrectionRate);
}

static int pyopencv_aruco_DetectorParameters_set_errorCorrectionRate(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the errorCorrectionRate attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->errorCorrectionRate) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_markerBorderBits(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->markerBorderBits);
}

static int pyopencv_aruco_DetectorParameters_set_markerBorderBits(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the markerBorderBits attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->markerBorderBits) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_maxErroneousBitsInBorderRate(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->maxErroneousBitsInBorderRate);
}

static int pyopencv_aruco_DetectorParameters_set_maxErroneousBitsInBorderRate(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxErroneousBitsInBorderRate attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->maxErroneousBitsInBorderRate) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_maxMarkerPerimeterRate(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->maxMarkerPerimeterRate);
}

static int pyopencv_aruco_DetectorParameters_set_maxMarkerPerimeterRate(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxMarkerPerimeterRate attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->maxMarkerPerimeterRate) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_minCornerDistanceRate(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->minCornerDistanceRate);
}

static int pyopencv_aruco_DetectorParameters_set_minCornerDistanceRate(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minCornerDistanceRate attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->minCornerDistanceRate) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_minDistanceToBorder(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->minDistanceToBorder);
}

static int pyopencv_aruco_DetectorParameters_set_minDistanceToBorder(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minDistanceToBorder attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->minDistanceToBorder) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_minMarkerDistanceRate(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->minMarkerDistanceRate);
}

static int pyopencv_aruco_DetectorParameters_set_minMarkerDistanceRate(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minMarkerDistanceRate attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->minMarkerDistanceRate) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_minMarkerPerimeterRate(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->minMarkerPerimeterRate);
}

static int pyopencv_aruco_DetectorParameters_set_minMarkerPerimeterRate(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minMarkerPerimeterRate attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->minMarkerPerimeterRate) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_minOtsuStdDev(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->minOtsuStdDev);
}

static int pyopencv_aruco_DetectorParameters_set_minOtsuStdDev(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minOtsuStdDev attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->minOtsuStdDev) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_perspectiveRemoveIgnoredMarginPerCell(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->perspectiveRemoveIgnoredMarginPerCell);
}

static int pyopencv_aruco_DetectorParameters_set_perspectiveRemoveIgnoredMarginPerCell(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the perspectiveRemoveIgnoredMarginPerCell attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->perspectiveRemoveIgnoredMarginPerCell) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_perspectiveRemovePixelPerCell(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->perspectiveRemovePixelPerCell);
}

static int pyopencv_aruco_DetectorParameters_set_perspectiveRemovePixelPerCell(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the perspectiveRemovePixelPerCell attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->perspectiveRemovePixelPerCell) ? 0 : -1;
}

static PyObject* pyopencv_aruco_DetectorParameters_get_polygonalApproxAccuracyRate(pyopencv_aruco_DetectorParameters_t* p, void *closure)
{
    return pyopencv_from(p->v->polygonalApproxAccuracyRate);
}

static int pyopencv_aruco_DetectorParameters_set_polygonalApproxAccuracyRate(pyopencv_aruco_DetectorParameters_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the polygonalApproxAccuracyRate attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->polygonalApproxAccuracyRate) ? 0 : -1;
}


// Methods (aruco_DetectorParameters)

static PyObject* pyopencv_cv_aruco_aruco_DetectorParameters_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    Ptr<DetectorParameters> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::aruco::DetectorParameters::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (aruco_DetectorParameters)

static PyGetSetDef pyopencv_aruco_DetectorParameters_getseters[] =
{
    {(char*)"adaptiveThreshConstant", (getter)pyopencv_aruco_DetectorParameters_get_adaptiveThreshConstant, (setter)pyopencv_aruco_DetectorParameters_set_adaptiveThreshConstant, (char*)"adaptiveThreshConstant", NULL},
    {(char*)"adaptiveThreshWinSizeMax", (getter)pyopencv_aruco_DetectorParameters_get_adaptiveThreshWinSizeMax, (setter)pyopencv_aruco_DetectorParameters_set_adaptiveThreshWinSizeMax, (char*)"adaptiveThreshWinSizeMax", NULL},
    {(char*)"adaptiveThreshWinSizeMin", (getter)pyopencv_aruco_DetectorParameters_get_adaptiveThreshWinSizeMin, (setter)pyopencv_aruco_DetectorParameters_set_adaptiveThreshWinSizeMin, (char*)"adaptiveThreshWinSizeMin", NULL},
    {(char*)"adaptiveThreshWinSizeStep", (getter)pyopencv_aruco_DetectorParameters_get_adaptiveThreshWinSizeStep, (setter)pyopencv_aruco_DetectorParameters_set_adaptiveThreshWinSizeStep, (char*)"adaptiveThreshWinSizeStep", NULL},
    {(char*)"aprilTagCriticalRad", (getter)pyopencv_aruco_DetectorParameters_get_aprilTagCriticalRad, (setter)pyopencv_aruco_DetectorParameters_set_aprilTagCriticalRad, (char*)"aprilTagCriticalRad", NULL},
    {(char*)"aprilTagDeglitch", (getter)pyopencv_aruco_DetectorParameters_get_aprilTagDeglitch, (setter)pyopencv_aruco_DetectorParameters_set_aprilTagDeglitch, (char*)"aprilTagDeglitch", NULL},
    {(char*)"aprilTagMaxLineFitMse", (getter)pyopencv_aruco_DetectorParameters_get_aprilTagMaxLineFitMse, (setter)pyopencv_aruco_DetectorParameters_set_aprilTagMaxLineFitMse, (char*)"aprilTagMaxLineFitMse", NULL},
    {(char*)"aprilTagMaxNmaxima", (getter)pyopencv_aruco_DetectorParameters_get_aprilTagMaxNmaxima, (setter)pyopencv_aruco_DetectorParameters_set_aprilTagMaxNmaxima, (char*)"aprilTagMaxNmaxima", NULL},
    {(char*)"aprilTagMinClusterPixels", (getter)pyopencv_aruco_DetectorParameters_get_aprilTagMinClusterPixels, (setter)pyopencv_aruco_DetectorParameters_set_aprilTagMinClusterPixels, (char*)"aprilTagMinClusterPixels", NULL},
    {(char*)"aprilTagMinWhiteBlackDiff", (getter)pyopencv_aruco_DetectorParameters_get_aprilTagMinWhiteBlackDiff, (setter)pyopencv_aruco_DetectorParameters_set_aprilTagMinWhiteBlackDiff, (char*)"aprilTagMinWhiteBlackDiff", NULL},
    {(char*)"aprilTagQuadDecimate", (getter)pyopencv_aruco_DetectorParameters_get_aprilTagQuadDecimate, (setter)pyopencv_aruco_DetectorParameters_set_aprilTagQuadDecimate, (char*)"aprilTagQuadDecimate", NULL},
    {(char*)"aprilTagQuadSigma", (getter)pyopencv_aruco_DetectorParameters_get_aprilTagQuadSigma, (setter)pyopencv_aruco_DetectorParameters_set_aprilTagQuadSigma, (char*)"aprilTagQuadSigma", NULL},
    {(char*)"cornerRefinementMaxIterations", (getter)pyopencv_aruco_DetectorParameters_get_cornerRefinementMaxIterations, (setter)pyopencv_aruco_DetectorParameters_set_cornerRefinementMaxIterations, (char*)"cornerRefinementMaxIterations", NULL},
    {(char*)"cornerRefinementMethod", (getter)pyopencv_aruco_DetectorParameters_get_cornerRefinementMethod, (setter)pyopencv_aruco_DetectorParameters_set_cornerRefinementMethod, (char*)"cornerRefinementMethod", NULL},
    {(char*)"cornerRefinementMinAccuracy", (getter)pyopencv_aruco_DetectorParameters_get_cornerRefinementMinAccuracy, (setter)pyopencv_aruco_DetectorParameters_set_cornerRefinementMinAccuracy, (char*)"cornerRefinementMinAccuracy", NULL},
    {(char*)"cornerRefinementWinSize", (getter)pyopencv_aruco_DetectorParameters_get_cornerRefinementWinSize, (setter)pyopencv_aruco_DetectorParameters_set_cornerRefinementWinSize, (char*)"cornerRefinementWinSize", NULL},
    {(char*)"detectInvertedMarker", (getter)pyopencv_aruco_DetectorParameters_get_detectInvertedMarker, (setter)pyopencv_aruco_DetectorParameters_set_detectInvertedMarker, (char*)"detectInvertedMarker", NULL},
    {(char*)"errorCorrectionRate", (getter)pyopencv_aruco_DetectorParameters_get_errorCorrectionRate, (setter)pyopencv_aruco_DetectorParameters_set_errorCorrectionRate, (char*)"errorCorrectionRate", NULL},
    {(char*)"markerBorderBits", (getter)pyopencv_aruco_DetectorParameters_get_markerBorderBits, (setter)pyopencv_aruco_DetectorParameters_set_markerBorderBits, (char*)"markerBorderBits", NULL},
    {(char*)"maxErroneousBitsInBorderRate", (getter)pyopencv_aruco_DetectorParameters_get_maxErroneousBitsInBorderRate, (setter)pyopencv_aruco_DetectorParameters_set_maxErroneousBitsInBorderRate, (char*)"maxErroneousBitsInBorderRate", NULL},
    {(char*)"maxMarkerPerimeterRate", (getter)pyopencv_aruco_DetectorParameters_get_maxMarkerPerimeterRate, (setter)pyopencv_aruco_DetectorParameters_set_maxMarkerPerimeterRate, (char*)"maxMarkerPerimeterRate", NULL},
    {(char*)"minCornerDistanceRate", (getter)pyopencv_aruco_DetectorParameters_get_minCornerDistanceRate, (setter)pyopencv_aruco_DetectorParameters_set_minCornerDistanceRate, (char*)"minCornerDistanceRate", NULL},
    {(char*)"minDistanceToBorder", (getter)pyopencv_aruco_DetectorParameters_get_minDistanceToBorder, (setter)pyopencv_aruco_DetectorParameters_set_minDistanceToBorder, (char*)"minDistanceToBorder", NULL},
    {(char*)"minMarkerDistanceRate", (getter)pyopencv_aruco_DetectorParameters_get_minMarkerDistanceRate, (setter)pyopencv_aruco_DetectorParameters_set_minMarkerDistanceRate, (char*)"minMarkerDistanceRate", NULL},
    {(char*)"minMarkerPerimeterRate", (getter)pyopencv_aruco_DetectorParameters_get_minMarkerPerimeterRate, (setter)pyopencv_aruco_DetectorParameters_set_minMarkerPerimeterRate, (char*)"minMarkerPerimeterRate", NULL},
    {(char*)"minOtsuStdDev", (getter)pyopencv_aruco_DetectorParameters_get_minOtsuStdDev, (setter)pyopencv_aruco_DetectorParameters_set_minOtsuStdDev, (char*)"minOtsuStdDev", NULL},
    {(char*)"perspectiveRemoveIgnoredMarginPerCell", (getter)pyopencv_aruco_DetectorParameters_get_perspectiveRemoveIgnoredMarginPerCell, (setter)pyopencv_aruco_DetectorParameters_set_perspectiveRemoveIgnoredMarginPerCell, (char*)"perspectiveRemoveIgnoredMarginPerCell", NULL},
    {(char*)"perspectiveRemovePixelPerCell", (getter)pyopencv_aruco_DetectorParameters_get_perspectiveRemovePixelPerCell, (setter)pyopencv_aruco_DetectorParameters_set_perspectiveRemovePixelPerCell, (char*)"perspectiveRemovePixelPerCell", NULL},
    {(char*)"polygonalApproxAccuracyRate", (getter)pyopencv_aruco_DetectorParameters_get_polygonalApproxAccuracyRate, (setter)pyopencv_aruco_DetectorParameters_set_polygonalApproxAccuracyRate, (char*)"polygonalApproxAccuracyRate", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_aruco_DetectorParameters_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_DetectorParameters_create_static, METH_STATIC), "create() -> retval\n."},

    {NULL,          NULL}
};

// Converter (aruco_DetectorParameters)

template<>
struct PyOpenCV_Converter< Ptr<cv::aruco::DetectorParameters> >
{
    static PyObject* from(const Ptr<cv::aruco::DetectorParameters>& r)
    {
        return pyopencv_aruco_DetectorParameters_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::aruco::DetectorParameters>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::aruco::DetectorParameters> * dst_;
        if (pyopencv_aruco_DetectorParameters_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::aruco::DetectorParameters> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// aruco_Dictionary (Generic)
//================================================================================

// GetSet (aruco_Dictionary)


static PyObject* pyopencv_aruco_Dictionary_get_bytesList(pyopencv_aruco_Dictionary_t* p, void *closure)
{
    return pyopencv_from(p->v->bytesList);
}

static int pyopencv_aruco_Dictionary_set_bytesList(pyopencv_aruco_Dictionary_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the bytesList attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->bytesList) ? 0 : -1;
}

static PyObject* pyopencv_aruco_Dictionary_get_markerSize(pyopencv_aruco_Dictionary_t* p, void *closure)
{
    return pyopencv_from(p->v->markerSize);
}

static int pyopencv_aruco_Dictionary_set_markerSize(pyopencv_aruco_Dictionary_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the markerSize attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->markerSize) ? 0 : -1;
}

static PyObject* pyopencv_aruco_Dictionary_get_maxCorrectionBits(pyopencv_aruco_Dictionary_t* p, void *closure)
{
    return pyopencv_from(p->v->maxCorrectionBits);
}

static int pyopencv_aruco_Dictionary_set_maxCorrectionBits(pyopencv_aruco_Dictionary_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxCorrectionBits attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->maxCorrectionBits) ? 0 : -1;
}


// Methods (aruco_Dictionary)

static PyObject* pyopencv_cv_aruco_aruco_Dictionary_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    int nMarkers=0;
    int markerSize=0;
    int randomSeed=0;
    Ptr<Dictionary> retval;

    const char* keywords[] = { "nMarkers", "markerSize", "randomSeed", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii|i:aruco_Dictionary.create", (char**)keywords, &nMarkers, &markerSize, &randomSeed) )
    {
        ERRWRAP2(retval = cv::aruco::Dictionary::create(nMarkers, markerSize, randomSeed));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_Dictionary_create_from_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    int nMarkers=0;
    int markerSize=0;
    PyObject* pyobj_baseDictionary = NULL;
    Ptr<Dictionary> baseDictionary;
    int randomSeed=0;
    Ptr<Dictionary> retval;

    const char* keywords[] = { "nMarkers", "markerSize", "baseDictionary", "randomSeed", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiO|i:aruco_Dictionary.create_from", (char**)keywords, &nMarkers, &markerSize, &pyobj_baseDictionary, &randomSeed) &&
        pyopencv_to(pyobj_baseDictionary, baseDictionary, ArgInfo("baseDictionary", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::Dictionary::create(nMarkers, markerSize, baseDictionary, randomSeed));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_Dictionary_drawMarker(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::Dictionary> * self1 = 0;
    if (!pyopencv_aruco_Dictionary_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_Dictionary' or its derivative)");
    Ptr<cv::aruco::Dictionary> _self_ = *(self1);
    {
    int id=0;
    int sidePixels=0;
    PyObject* pyobj__img = NULL;
    Mat _img;
    int borderBits=1;

    const char* keywords[] = { "id", "sidePixels", "_img", "borderBits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii|Oi:aruco_Dictionary.drawMarker", (char**)keywords, &id, &sidePixels, &pyobj__img, &borderBits) &&
        pyopencv_to(pyobj__img, _img, ArgInfo("_img", 1)) )
    {
        ERRWRAP2(_self_->drawMarker(id, sidePixels, _img, borderBits));
        return pyopencv_from(_img);
    }
    }
    PyErr_Clear();

    {
    int id=0;
    int sidePixels=0;
    PyObject* pyobj__img = NULL;
    UMat _img;
    int borderBits=1;

    const char* keywords[] = { "id", "sidePixels", "_img", "borderBits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii|Oi:aruco_Dictionary.drawMarker", (char**)keywords, &id, &sidePixels, &pyobj__img, &borderBits) &&
        pyopencv_to(pyobj__img, _img, ArgInfo("_img", 1)) )
    {
        ERRWRAP2(_self_->drawMarker(id, sidePixels, _img, borderBits));
        return pyopencv_from(_img);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_Dictionary_get_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    int dict=0;
    Ptr<Dictionary> retval;

    const char* keywords[] = { "dict", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:aruco_Dictionary.get", (char**)keywords, &dict) )
    {
        ERRWRAP2(retval = cv::aruco::Dictionary::get(dict));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_Dictionary_getBitsFromByteList_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    {
    PyObject* pyobj_byteList = NULL;
    Mat byteList;
    int markerSize=0;
    Mat retval;

    const char* keywords[] = { "byteList", "markerSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:aruco_Dictionary.getBitsFromByteList", (char**)keywords, &pyobj_byteList, &markerSize) &&
        pyopencv_to(pyobj_byteList, byteList, ArgInfo("byteList", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::Dictionary::getBitsFromByteList(byteList, markerSize));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_byteList = NULL;
    Mat byteList;
    int markerSize=0;
    Mat retval;

    const char* keywords[] = { "byteList", "markerSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:aruco_Dictionary.getBitsFromByteList", (char**)keywords, &pyobj_byteList, &markerSize) &&
        pyopencv_to(pyobj_byteList, byteList, ArgInfo("byteList", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::Dictionary::getBitsFromByteList(byteList, markerSize));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_Dictionary_getByteListFromBits_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    {
    PyObject* pyobj_bits = NULL;
    Mat bits;
    Mat retval;

    const char* keywords[] = { "bits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:aruco_Dictionary.getByteListFromBits", (char**)keywords, &pyobj_bits) &&
        pyopencv_to(pyobj_bits, bits, ArgInfo("bits", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::Dictionary::getByteListFromBits(bits));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_bits = NULL;
    Mat bits;
    Mat retval;

    const char* keywords[] = { "bits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:aruco_Dictionary.getByteListFromBits", (char**)keywords, &pyobj_bits) &&
        pyopencv_to(pyobj_bits, bits, ArgInfo("bits", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::Dictionary::getByteListFromBits(bits));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (aruco_Dictionary)

static PyGetSetDef pyopencv_aruco_Dictionary_getseters[] =
{
    {(char*)"bytesList", (getter)pyopencv_aruco_Dictionary_get_bytesList, (setter)pyopencv_aruco_Dictionary_set_bytesList, (char*)"bytesList", NULL},
    {(char*)"markerSize", (getter)pyopencv_aruco_Dictionary_get_markerSize, (setter)pyopencv_aruco_Dictionary_set_markerSize, (char*)"markerSize", NULL},
    {(char*)"maxCorrectionBits", (getter)pyopencv_aruco_Dictionary_get_maxCorrectionBits, (setter)pyopencv_aruco_Dictionary_set_maxCorrectionBits, (char*)"maxCorrectionBits", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_aruco_Dictionary_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_Dictionary_create_static, METH_STATIC), "create(nMarkers, markerSize[, randomSeed]) -> retval\n.   * @see generateCustomDictionary"},
    {"create_from", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_Dictionary_create_from_static, METH_STATIC), "create_from(nMarkers, markerSize, baseDictionary[, randomSeed]) -> retval\n.   * @see generateCustomDictionary"},
    {"drawMarker", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_Dictionary_drawMarker, 0), "drawMarker(id, sidePixels[, _img[, borderBits]]) -> _img\n.   * @brief Draw a canonical marker image"},
    {"get", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_Dictionary_get_static, METH_STATIC), "get(dict) -> retval\n.   * @see getPredefinedDictionary"},
    {"getBitsFromByteList", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_Dictionary_getBitsFromByteList_static, METH_STATIC), "getBitsFromByteList(byteList, markerSize) -> retval\n.   * @brief Transform list of bytes to matrix of bits"},
    {"getByteListFromBits", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_Dictionary_getByteListFromBits_static, METH_STATIC), "getByteListFromBits(bits) -> retval\n.   * @brief Transform matrix of bits to list of bytes in the 4 rotations"},

    {NULL,          NULL}
};

// Converter (aruco_Dictionary)

template<>
struct PyOpenCV_Converter< Ptr<cv::aruco::Dictionary> >
{
    static PyObject* from(const Ptr<cv::aruco::Dictionary>& r)
    {
        return pyopencv_aruco_Dictionary_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::aruco::Dictionary>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::aruco::Dictionary> * dst_;
        if (pyopencv_aruco_Dictionary_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::aruco::Dictionary> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// aruco_GridBoard (Generic)
//================================================================================

// GetSet (aruco_GridBoard)



// Methods (aruco_GridBoard)

static PyObject* pyopencv_cv_aruco_aruco_GridBoard_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;

    int markersX=0;
    int markersY=0;
    float markerLength=0.f;
    float markerSeparation=0.f;
    PyObject* pyobj_dictionary = NULL;
    Ptr<Dictionary> dictionary;
    int firstMarker=0;
    Ptr<GridBoard> retval;

    const char* keywords[] = { "markersX", "markersY", "markerLength", "markerSeparation", "dictionary", "firstMarker", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiffO|i:aruco_GridBoard.create", (char**)keywords, &markersX, &markersY, &markerLength, &markerSeparation, &pyobj_dictionary, &firstMarker) &&
        pyopencv_to(pyobj_dictionary, dictionary, ArgInfo("dictionary", 0)) )
    {
        ERRWRAP2(retval = cv::aruco::GridBoard::create(markersX, markersY, markerLength, markerSeparation, dictionary, firstMarker));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_GridBoard_draw(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::GridBoard> * self1 = 0;
    if (!pyopencv_aruco_GridBoard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_GridBoard' or its derivative)");
    Ptr<cv::aruco::GridBoard> _self_ = *(self1);
    {
    PyObject* pyobj_outSize = NULL;
    Size outSize;
    PyObject* pyobj_img = NULL;
    Mat img;
    int marginSize=0;
    int borderBits=1;

    const char* keywords[] = { "outSize", "img", "marginSize", "borderBits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oii:aruco_GridBoard.draw", (char**)keywords, &pyobj_outSize, &pyobj_img, &marginSize, &borderBits) &&
        pyopencv_to(pyobj_outSize, outSize, ArgInfo("outSize", 0)) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 1)) )
    {
        ERRWRAP2(_self_->draw(outSize, img, marginSize, borderBits));
        return pyopencv_from(img);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_outSize = NULL;
    Size outSize;
    PyObject* pyobj_img = NULL;
    UMat img;
    int marginSize=0;
    int borderBits=1;

    const char* keywords[] = { "outSize", "img", "marginSize", "borderBits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oii:aruco_GridBoard.draw", (char**)keywords, &pyobj_outSize, &pyobj_img, &marginSize, &borderBits) &&
        pyopencv_to(pyobj_outSize, outSize, ArgInfo("outSize", 0)) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 1)) )
    {
        ERRWRAP2(_self_->draw(outSize, img, marginSize, borderBits));
        return pyopencv_from(img);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_GridBoard_getGridSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::GridBoard> * self1 = 0;
    if (!pyopencv_aruco_GridBoard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_GridBoard' or its derivative)");
    Ptr<cv::aruco::GridBoard> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGridSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_GridBoard_getMarkerLength(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::GridBoard> * self1 = 0;
    if (!pyopencv_aruco_GridBoard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_GridBoard' or its derivative)");
    Ptr<cv::aruco::GridBoard> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMarkerLength());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_aruco_aruco_GridBoard_getMarkerSeparation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::aruco;


    Ptr<cv::aruco::GridBoard> * self1 = 0;
    if (!pyopencv_aruco_GridBoard_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'aruco_GridBoard' or its derivative)");
    Ptr<cv::aruco::GridBoard> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMarkerSeparation());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (aruco_GridBoard)

static PyGetSetDef pyopencv_aruco_GridBoard_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_aruco_GridBoard_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_GridBoard_create_static, METH_STATIC), "create(markersX, markersY, markerLength, markerSeparation, dictionary[, firstMarker]) -> retval\n.   * @brief Create a GridBoard object\n.        *\n.        * @param markersX number of markers in X direction\n.        * @param markersY number of markers in Y direction\n.        * @param markerLength marker side length (normally in meters)\n.        * @param markerSeparation separation between two markers (same unit as markerLength)\n.        * @param dictionary dictionary of markers indicating the type of markers\n.        * @param firstMarker id of first marker in dictionary to use on board.\n.        * @return the output GridBoard object\n.        *\n.        * This functions creates a GridBoard object given the number of markers in each direction and\n.        * the marker size and marker separation."},
    {"draw", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_GridBoard_draw, 0), "draw(outSize[, img[, marginSize[, borderBits]]]) -> img\n.   * @brief Draw a GridBoard\n.        *\n.        * @param outSize size of the output image in pixels.\n.        * @param img output image with the board. The size of this image will be outSize\n.        * and the board will be on the center, keeping the board proportions.\n.        * @param marginSize minimum margins (in pixels) of the board in the output image\n.        * @param borderBits width of the marker borders.\n.        *\n.        * This function return the image of the GridBoard, ready to be printed."},
    {"getGridSize", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_GridBoard_getGridSize, 0), "getGridSize() -> retval\n.   *"},
    {"getMarkerLength", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_GridBoard_getMarkerLength, 0), "getMarkerLength() -> retval\n.   *"},
    {"getMarkerSeparation", CV_PY_FN_WITH_KW_(pyopencv_cv_aruco_aruco_GridBoard_getMarkerSeparation, 0), "getMarkerSeparation() -> retval\n.   *"},

    {NULL,          NULL}
};

// Converter (aruco_GridBoard)

template<>
struct PyOpenCV_Converter< Ptr<cv::aruco::GridBoard> >
{
    static PyObject* from(const Ptr<cv::aruco::GridBoard>& r)
    {
        return pyopencv_aruco_GridBoard_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::aruco::GridBoard>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::aruco::GridBoard> * dst_;
        if (pyopencv_aruco_GridBoard_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::aruco::GridBoard> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bgsegm_BackgroundSubtractorCNT (Generic)
//================================================================================

// GetSet (bgsegm_BackgroundSubtractorCNT)



// Methods (bgsegm_BackgroundSubtractorCNT)

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_fgmask = NULL;
    Mat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:bgsegm_BackgroundSubtractorCNT.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_fgmask = NULL;
    UMat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:bgsegm_BackgroundSubtractorCNT.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getBackgroundImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    {
    PyObject* pyobj_backgroundImage = NULL;
    Mat backgroundImage;

    const char* keywords[] = { "backgroundImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bgsegm_BackgroundSubtractorCNT.getBackgroundImage", (char**)keywords, &pyobj_backgroundImage) &&
        pyopencv_to(pyobj_backgroundImage, backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage));
        return pyopencv_from(backgroundImage);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_backgroundImage = NULL;
    UMat backgroundImage;

    const char* keywords[] = { "backgroundImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bgsegm_BackgroundSubtractorCNT.getBackgroundImage", (char**)keywords, &pyobj_backgroundImage) &&
        pyopencv_to(pyobj_backgroundImage, backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage));
        return pyopencv_from(backgroundImage);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getIsParallel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIsParallel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getMaxPixelStability(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxPixelStability());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getMinPixelStability(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinPixelStability());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getUseHistory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseHistory());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_setIsParallel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    bool value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:bgsegm_BackgroundSubtractorCNT.setIsParallel", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setIsParallel(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_setMaxPixelStability(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    int value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:bgsegm_BackgroundSubtractorCNT.setMaxPixelStability", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setMaxPixelStability(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_setMinPixelStability(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    int value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:bgsegm_BackgroundSubtractorCNT.setMinPixelStability", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setMinPixelStability(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_setUseHistory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorCNT> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorCNT_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorCNT' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorCNT> _self_ = *(self1);
    bool value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:bgsegm_BackgroundSubtractorCNT.setUseHistory", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setUseHistory(value));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (bgsegm_BackgroundSubtractorCNT)

static PyGetSetDef pyopencv_bgsegm_BackgroundSubtractorCNT_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bgsegm_BackgroundSubtractorCNT_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_apply, 0), "apply(image[, fgmask[, learningRate]]) -> fgmask\n."},
    {"getBackgroundImage", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getBackgroundImage, 0), "getBackgroundImage([, backgroundImage]) -> backgroundImage\n."},
    {"getIsParallel", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getIsParallel, 0), "getIsParallel() -> retval\n.   @brief Returns if we're parallelizing the algorithm."},
    {"getMaxPixelStability", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getMaxPixelStability, 0), "getMaxPixelStability() -> retval\n.   @brief Returns maximum allowed credit for a pixel in history."},
    {"getMinPixelStability", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getMinPixelStability, 0), "getMinPixelStability() -> retval\n.   @brief Returns number of frames with same pixel color to consider stable."},
    {"getUseHistory", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_getUseHistory, 0), "getUseHistory() -> retval\n.   @brief Returns if we're giving a pixel credit for being stable for a long time."},
    {"setIsParallel", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_setIsParallel, 0), "setIsParallel(value) -> None\n.   @brief Sets if we're parallelizing the algorithm."},
    {"setMaxPixelStability", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_setMaxPixelStability, 0), "setMaxPixelStability(value) -> None\n.   @brief Sets the maximum allowed credit for a pixel in history."},
    {"setMinPixelStability", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_setMinPixelStability, 0), "setMinPixelStability(value) -> None\n.   @brief Sets the number of frames with same pixel color to consider stable."},
    {"setUseHistory", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorCNT_setUseHistory, 0), "setUseHistory(value) -> None\n.   @brief Sets if we're giving a pixel credit for being stable for a long time."},

    {NULL,          NULL}
};

// Converter (bgsegm_BackgroundSubtractorCNT)

template<>
struct PyOpenCV_Converter< Ptr<cv::bgsegm::BackgroundSubtractorCNT> >
{
    static PyObject* from(const Ptr<cv::bgsegm::BackgroundSubtractorCNT>& r)
    {
        return pyopencv_bgsegm_BackgroundSubtractorCNT_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bgsegm::BackgroundSubtractorCNT>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bgsegm::BackgroundSubtractorCNT> * dst_;
        if (pyopencv_bgsegm_BackgroundSubtractorCNT_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bgsegm::BackgroundSubtractorCNT> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bgsegm_BackgroundSubtractorGMG (Generic)
//================================================================================

// GetSet (bgsegm_BackgroundSubtractorGMG)



// Methods (bgsegm_BackgroundSubtractorGMG)

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getBackgroundPrior(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBackgroundPrior());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getDecisionThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDecisionThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultLearningRate());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getMaxFeatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxFeatures());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getMaxVal(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxVal());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getMinVal(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinVal());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getNumFrames(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumFrames());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getQuantizationLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getQuantizationLevels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getSmoothingRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSmoothingRadius());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUpdateBackgroundModel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setBackgroundPrior(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double bgprior=0;

    const char* keywords[] = { "bgprior", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:bgsegm_BackgroundSubtractorGMG.setBackgroundPrior", (char**)keywords, &bgprior) )
    {
        ERRWRAP2(_self_->setBackgroundPrior(bgprior));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setDecisionThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double thresh=0;

    const char* keywords[] = { "thresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:bgsegm_BackgroundSubtractorGMG.setDecisionThreshold", (char**)keywords, &thresh) )
    {
        ERRWRAP2(_self_->setDecisionThreshold(thresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double lr=0;

    const char* keywords[] = { "lr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:bgsegm_BackgroundSubtractorGMG.setDefaultLearningRate", (char**)keywords, &lr) )
    {
        ERRWRAP2(_self_->setDefaultLearningRate(lr));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setMaxFeatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    int maxFeatures=0;

    const char* keywords[] = { "maxFeatures", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:bgsegm_BackgroundSubtractorGMG.setMaxFeatures", (char**)keywords, &maxFeatures) )
    {
        ERRWRAP2(_self_->setMaxFeatures(maxFeatures));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setMaxVal(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:bgsegm_BackgroundSubtractorGMG.setMaxVal", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxVal(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setMinVal(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:bgsegm_BackgroundSubtractorGMG.setMinVal", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMinVal(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setNumFrames(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    int nframes=0;

    const char* keywords[] = { "nframes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:bgsegm_BackgroundSubtractorGMG.setNumFrames", (char**)keywords, &nframes) )
    {
        ERRWRAP2(_self_->setNumFrames(nframes));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setQuantizationLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    int nlevels=0;

    const char* keywords[] = { "nlevels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:bgsegm_BackgroundSubtractorGMG.setQuantizationLevels", (char**)keywords, &nlevels) )
    {
        ERRWRAP2(_self_->setQuantizationLevels(nlevels));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setSmoothingRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    int radius=0;

    const char* keywords[] = { "radius", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:bgsegm_BackgroundSubtractorGMG.setSmoothingRadius", (char**)keywords, &radius) )
    {
        ERRWRAP2(_self_->setSmoothingRadius(radius));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGMG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGMG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGMG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGMG> _self_ = *(self1);
    bool update=0;

    const char* keywords[] = { "update", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:bgsegm_BackgroundSubtractorGMG.setUpdateBackgroundModel", (char**)keywords, &update) )
    {
        ERRWRAP2(_self_->setUpdateBackgroundModel(update));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (bgsegm_BackgroundSubtractorGMG)

static PyGetSetDef pyopencv_bgsegm_BackgroundSubtractorGMG_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bgsegm_BackgroundSubtractorGMG_methods[] =
{
    {"getBackgroundPrior", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getBackgroundPrior, 0), "getBackgroundPrior() -> retval\n.   @brief Returns the prior probability that each individual pixel is a background pixel."},
    {"getDecisionThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getDecisionThreshold, 0), "getDecisionThreshold() -> retval\n.   @brief Returns the value of decision threshold.\n.   \n.       Decision value is the value above which pixel is determined to be FG."},
    {"getDefaultLearningRate", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate, 0), "getDefaultLearningRate() -> retval\n.   @brief Returns the learning rate of the algorithm.\n.   \n.       It lies between 0.0 and 1.0. It determines how quickly features are \"forgotten\" from\n.       histograms."},
    {"getMaxFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getMaxFeatures, 0), "getMaxFeatures() -> retval\n.   @brief Returns total number of distinct colors to maintain in histogram."},
    {"getMaxVal", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getMaxVal, 0), "getMaxVal() -> retval\n.   @brief Returns the maximum value taken on by pixels in image sequence. e.g. 1.0 or 255."},
    {"getMinVal", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getMinVal, 0), "getMinVal() -> retval\n.   @brief Returns the minimum value taken on by pixels in image sequence. Usually 0."},
    {"getNumFrames", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getNumFrames, 0), "getNumFrames() -> retval\n.   @brief Returns the number of frames used to initialize background model."},
    {"getQuantizationLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getQuantizationLevels, 0), "getQuantizationLevels() -> retval\n.   @brief Returns the parameter used for quantization of color-space.\n.   \n.       It is the number of discrete levels in each channel to be used in histograms."},
    {"getSmoothingRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getSmoothingRadius, 0), "getSmoothingRadius() -> retval\n.   @brief Returns the kernel radius used for morphological operations"},
    {"getUpdateBackgroundModel", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel, 0), "getUpdateBackgroundModel() -> retval\n.   @brief Returns the status of background model update"},
    {"setBackgroundPrior", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setBackgroundPrior, 0), "setBackgroundPrior(bgprior) -> None\n.   @brief Sets the prior probability that each individual pixel is a background pixel."},
    {"setDecisionThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setDecisionThreshold, 0), "setDecisionThreshold(thresh) -> None\n.   @brief Sets the value of decision threshold."},
    {"setDefaultLearningRate", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate, 0), "setDefaultLearningRate(lr) -> None\n.   @brief Sets the learning rate of the algorithm."},
    {"setMaxFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setMaxFeatures, 0), "setMaxFeatures(maxFeatures) -> None\n.   @brief Sets total number of distinct colors to maintain in histogram."},
    {"setMaxVal", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setMaxVal, 0), "setMaxVal(val) -> None\n.   @brief Sets the maximum value taken on by pixels in image sequence."},
    {"setMinVal", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setMinVal, 0), "setMinVal(val) -> None\n.   @brief Sets the minimum value taken on by pixels in image sequence."},
    {"setNumFrames", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setNumFrames, 0), "setNumFrames(nframes) -> None\n.   @brief Sets the number of frames used to initialize background model."},
    {"setQuantizationLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setQuantizationLevels, 0), "setQuantizationLevels(nlevels) -> None\n.   @brief Sets the parameter used for quantization of color-space"},
    {"setSmoothingRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setSmoothingRadius, 0), "setSmoothingRadius(radius) -> None\n.   @brief Sets the kernel radius used for morphological operations"},
    {"setUpdateBackgroundModel", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel, 0), "setUpdateBackgroundModel(update) -> None\n.   @brief Sets the status of background model update"},

    {NULL,          NULL}
};

// Converter (bgsegm_BackgroundSubtractorGMG)

template<>
struct PyOpenCV_Converter< Ptr<cv::bgsegm::BackgroundSubtractorGMG> >
{
    static PyObject* from(const Ptr<cv::bgsegm::BackgroundSubtractorGMG>& r)
    {
        return pyopencv_bgsegm_BackgroundSubtractorGMG_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bgsegm::BackgroundSubtractorGMG>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bgsegm::BackgroundSubtractorGMG> * dst_;
        if (pyopencv_bgsegm_BackgroundSubtractorGMG_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bgsegm::BackgroundSubtractorGMG> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bgsegm_BackgroundSubtractorGSOC (Generic)
//================================================================================

// GetSet (bgsegm_BackgroundSubtractorGSOC)



// Methods (bgsegm_BackgroundSubtractorGSOC)

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGSOC_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGSOC> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGSOC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGSOC' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGSOC> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_fgmask = NULL;
    Mat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:bgsegm_BackgroundSubtractorGSOC.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_fgmask = NULL;
    UMat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:bgsegm_BackgroundSubtractorGSOC.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGSOC_getBackgroundImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorGSOC> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorGSOC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorGSOC' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorGSOC> _self_ = *(self1);
    {
    PyObject* pyobj_backgroundImage = NULL;
    Mat backgroundImage;

    const char* keywords[] = { "backgroundImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bgsegm_BackgroundSubtractorGSOC.getBackgroundImage", (char**)keywords, &pyobj_backgroundImage) &&
        pyopencv_to(pyobj_backgroundImage, backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage));
        return pyopencv_from(backgroundImage);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_backgroundImage = NULL;
    UMat backgroundImage;

    const char* keywords[] = { "backgroundImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bgsegm_BackgroundSubtractorGSOC.getBackgroundImage", (char**)keywords, &pyobj_backgroundImage) &&
        pyopencv_to(pyobj_backgroundImage, backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage));
        return pyopencv_from(backgroundImage);
    }
    }

    return NULL;
}



// Tables (bgsegm_BackgroundSubtractorGSOC)

static PyGetSetDef pyopencv_bgsegm_BackgroundSubtractorGSOC_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bgsegm_BackgroundSubtractorGSOC_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGSOC_apply, 0), "apply(image[, fgmask[, learningRate]]) -> fgmask\n."},
    {"getBackgroundImage", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorGSOC_getBackgroundImage, 0), "getBackgroundImage([, backgroundImage]) -> backgroundImage\n."},

    {NULL,          NULL}
};

// Converter (bgsegm_BackgroundSubtractorGSOC)

template<>
struct PyOpenCV_Converter< Ptr<cv::bgsegm::BackgroundSubtractorGSOC> >
{
    static PyObject* from(const Ptr<cv::bgsegm::BackgroundSubtractorGSOC>& r)
    {
        return pyopencv_bgsegm_BackgroundSubtractorGSOC_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bgsegm::BackgroundSubtractorGSOC>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bgsegm::BackgroundSubtractorGSOC> * dst_;
        if (pyopencv_bgsegm_BackgroundSubtractorGSOC_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bgsegm::BackgroundSubtractorGSOC> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bgsegm_BackgroundSubtractorLSBP (Generic)
//================================================================================

// GetSet (bgsegm_BackgroundSubtractorLSBP)



// Methods (bgsegm_BackgroundSubtractorLSBP)

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorLSBP_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorLSBP> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorLSBP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorLSBP' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorLSBP> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_fgmask = NULL;
    Mat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:bgsegm_BackgroundSubtractorLSBP.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_fgmask = NULL;
    UMat fgmask;
    double learningRate=-1;

    const char* keywords[] = { "image", "fgmask", "learningRate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Od:bgsegm_BackgroundSubtractorLSBP.apply", (char**)keywords, &pyobj_image, &pyobj_fgmask, &learningRate) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_fgmask, fgmask, ArgInfo("fgmask", 1)) )
    {
        ERRWRAP2(_self_->apply(image, fgmask, learningRate));
        return pyopencv_from(fgmask);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorLSBP_getBackgroundImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorLSBP> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorLSBP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorLSBP' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorLSBP> _self_ = *(self1);
    {
    PyObject* pyobj_backgroundImage = NULL;
    Mat backgroundImage;

    const char* keywords[] = { "backgroundImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bgsegm_BackgroundSubtractorLSBP.getBackgroundImage", (char**)keywords, &pyobj_backgroundImage) &&
        pyopencv_to(pyobj_backgroundImage, backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage));
        return pyopencv_from(backgroundImage);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_backgroundImage = NULL;
    UMat backgroundImage;

    const char* keywords[] = { "backgroundImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bgsegm_BackgroundSubtractorLSBP.getBackgroundImage", (char**)keywords, &pyobj_backgroundImage) &&
        pyopencv_to(pyobj_backgroundImage, backgroundImage, ArgInfo("backgroundImage", 1)) )
    {
        ERRWRAP2(_self_->getBackgroundImage(backgroundImage));
        return pyopencv_from(backgroundImage);
    }
    }

    return NULL;
}



// Tables (bgsegm_BackgroundSubtractorLSBP)

static PyGetSetDef pyopencv_bgsegm_BackgroundSubtractorLSBP_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bgsegm_BackgroundSubtractorLSBP_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorLSBP_apply, 0), "apply(image[, fgmask[, learningRate]]) -> fgmask\n."},
    {"getBackgroundImage", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorLSBP_getBackgroundImage, 0), "getBackgroundImage([, backgroundImage]) -> backgroundImage\n."},

    {NULL,          NULL}
};

// Converter (bgsegm_BackgroundSubtractorLSBP)

template<>
struct PyOpenCV_Converter< Ptr<cv::bgsegm::BackgroundSubtractorLSBP> >
{
    static PyObject* from(const Ptr<cv::bgsegm::BackgroundSubtractorLSBP>& r)
    {
        return pyopencv_bgsegm_BackgroundSubtractorLSBP_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bgsegm::BackgroundSubtractorLSBP>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bgsegm::BackgroundSubtractorLSBP> * dst_;
        if (pyopencv_bgsegm_BackgroundSubtractorLSBP_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bgsegm::BackgroundSubtractorLSBP> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bgsegm_BackgroundSubtractorLSBPDesc (Generic)
//================================================================================

// GetSet (bgsegm_BackgroundSubtractorLSBPDesc)



// Methods (bgsegm_BackgroundSubtractorLSBPDesc)



// Tables (bgsegm_BackgroundSubtractorLSBPDesc)

static PyGetSetDef pyopencv_bgsegm_BackgroundSubtractorLSBPDesc_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bgsegm_BackgroundSubtractorLSBPDesc_methods[] =
{

    {NULL,          NULL}
};

// Converter (bgsegm_BackgroundSubtractorLSBPDesc)

template<>
struct PyOpenCV_Converter< Ptr<cv::bgsegm::BackgroundSubtractorLSBPDesc> >
{
    static PyObject* from(const Ptr<cv::bgsegm::BackgroundSubtractorLSBPDesc>& r)
    {
        return pyopencv_bgsegm_BackgroundSubtractorLSBPDesc_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bgsegm::BackgroundSubtractorLSBPDesc>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bgsegm::BackgroundSubtractorLSBPDesc> * dst_;
        if (pyopencv_bgsegm_BackgroundSubtractorLSBPDesc_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bgsegm::BackgroundSubtractorLSBPDesc> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bgsegm_BackgroundSubtractorMOG (Generic)
//================================================================================

// GetSet (bgsegm_BackgroundSubtractorMOG)



// Methods (bgsegm_BackgroundSubtractorMOG)

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_getBackgroundRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorMOG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorMOG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorMOG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorMOG> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBackgroundRatio());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_getHistory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorMOG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorMOG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorMOG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorMOG> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getHistory());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_getNMixtures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorMOG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorMOG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorMOG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorMOG> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNMixtures());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_getNoiseSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorMOG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorMOG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorMOG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorMOG> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNoiseSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_setBackgroundRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorMOG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorMOG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorMOG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorMOG> _self_ = *(self1);
    double backgroundRatio=0;

    const char* keywords[] = { "backgroundRatio", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:bgsegm_BackgroundSubtractorMOG.setBackgroundRatio", (char**)keywords, &backgroundRatio) )
    {
        ERRWRAP2(_self_->setBackgroundRatio(backgroundRatio));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_setHistory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorMOG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorMOG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorMOG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorMOG> _self_ = *(self1);
    int nframes=0;

    const char* keywords[] = { "nframes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:bgsegm_BackgroundSubtractorMOG.setHistory", (char**)keywords, &nframes) )
    {
        ERRWRAP2(_self_->setHistory(nframes));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_setNMixtures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorMOG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorMOG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorMOG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorMOG> _self_ = *(self1);
    int nmix=0;

    const char* keywords[] = { "nmix", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:bgsegm_BackgroundSubtractorMOG.setNMixtures", (char**)keywords, &nmix) )
    {
        ERRWRAP2(_self_->setNMixtures(nmix));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_setNoiseSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::BackgroundSubtractorMOG> * self1 = 0;
    if (!pyopencv_bgsegm_BackgroundSubtractorMOG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_BackgroundSubtractorMOG' or its derivative)");
    Ptr<cv::bgsegm::BackgroundSubtractorMOG> _self_ = *(self1);
    double noiseSigma=0;

    const char* keywords[] = { "noiseSigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:bgsegm_BackgroundSubtractorMOG.setNoiseSigma", (char**)keywords, &noiseSigma) )
    {
        ERRWRAP2(_self_->setNoiseSigma(noiseSigma));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (bgsegm_BackgroundSubtractorMOG)

static PyGetSetDef pyopencv_bgsegm_BackgroundSubtractorMOG_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bgsegm_BackgroundSubtractorMOG_methods[] =
{
    {"getBackgroundRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_getBackgroundRatio, 0), "getBackgroundRatio() -> retval\n."},
    {"getHistory", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_getHistory, 0), "getHistory() -> retval\n."},
    {"getNMixtures", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_getNMixtures, 0), "getNMixtures() -> retval\n."},
    {"getNoiseSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_getNoiseSigma, 0), "getNoiseSigma() -> retval\n."},
    {"setBackgroundRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_setBackgroundRatio, 0), "setBackgroundRatio(backgroundRatio) -> None\n."},
    {"setHistory", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_setHistory, 0), "setHistory(nframes) -> None\n."},
    {"setNMixtures", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_setNMixtures, 0), "setNMixtures(nmix) -> None\n."},
    {"setNoiseSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_BackgroundSubtractorMOG_setNoiseSigma, 0), "setNoiseSigma(noiseSigma) -> None\n."},

    {NULL,          NULL}
};

// Converter (bgsegm_BackgroundSubtractorMOG)

template<>
struct PyOpenCV_Converter< Ptr<cv::bgsegm::BackgroundSubtractorMOG> >
{
    static PyObject* from(const Ptr<cv::bgsegm::BackgroundSubtractorMOG>& r)
    {
        return pyopencv_bgsegm_BackgroundSubtractorMOG_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bgsegm::BackgroundSubtractorMOG>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bgsegm::BackgroundSubtractorMOG> * dst_;
        if (pyopencv_bgsegm_BackgroundSubtractorMOG_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bgsegm::BackgroundSubtractorMOG> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bgsegm_SyntheticSequenceGenerator (Generic)
//================================================================================

// GetSet (bgsegm_SyntheticSequenceGenerator)



// Methods (bgsegm_SyntheticSequenceGenerator)

static int pyopencv_cv_bgsegm_bgsegm_SyntheticSequenceGenerator_SyntheticSequenceGenerator(pyopencv_bgsegm_SyntheticSequenceGenerator_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;

    {
    PyObject* pyobj_background = NULL;
    Mat background;
    PyObject* pyobj_object = NULL;
    Mat object;
    double amplitude=0;
    double wavelength=0;
    double wavespeed=0;
    double objspeed=0;

    const char* keywords[] = { "background", "object", "amplitude", "wavelength", "wavespeed", "objspeed", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOdddd:SyntheticSequenceGenerator", (char**)keywords, &pyobj_background, &pyobj_object, &amplitude, &wavelength, &wavespeed, &objspeed) &&
        pyopencv_to(pyobj_background, background, ArgInfo("background", 0)) &&
        pyopencv_to(pyobj_object, object, ArgInfo("object", 0)) )
    {
        new (&(self->v)) Ptr<cv::bgsegm::SyntheticSequenceGenerator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::bgsegm::SyntheticSequenceGenerator(background, object, amplitude, wavelength, wavespeed, objspeed)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_background = NULL;
    UMat background;
    PyObject* pyobj_object = NULL;
    UMat object;
    double amplitude=0;
    double wavelength=0;
    double wavespeed=0;
    double objspeed=0;

    const char* keywords[] = { "background", "object", "amplitude", "wavelength", "wavespeed", "objspeed", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOdddd:SyntheticSequenceGenerator", (char**)keywords, &pyobj_background, &pyobj_object, &amplitude, &wavelength, &wavespeed, &objspeed) &&
        pyopencv_to(pyobj_background, background, ArgInfo("background", 0)) &&
        pyopencv_to(pyobj_object, object, ArgInfo("object", 0)) )
    {
        new (&(self->v)) Ptr<cv::bgsegm::SyntheticSequenceGenerator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::bgsegm::SyntheticSequenceGenerator(background, object, amplitude, wavelength, wavespeed, objspeed)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_bgsegm_bgsegm_SyntheticSequenceGenerator_getNextFrame(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bgsegm;


    Ptr<cv::bgsegm::SyntheticSequenceGenerator> * self1 = 0;
    if (!pyopencv_bgsegm_SyntheticSequenceGenerator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bgsegm_SyntheticSequenceGenerator' or its derivative)");
    Ptr<cv::bgsegm::SyntheticSequenceGenerator> _self_ = *(self1);
    {
    PyObject* pyobj_frame = NULL;
    Mat frame;
    PyObject* pyobj_gtMask = NULL;
    Mat gtMask;

    const char* keywords[] = { "frame", "gtMask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:bgsegm_SyntheticSequenceGenerator.getNextFrame", (char**)keywords, &pyobj_frame, &pyobj_gtMask) &&
        pyopencv_to(pyobj_frame, frame, ArgInfo("frame", 1)) &&
        pyopencv_to(pyobj_gtMask, gtMask, ArgInfo("gtMask", 1)) )
    {
        ERRWRAP2(_self_->getNextFrame(frame, gtMask));
        return Py_BuildValue("(NN)", pyopencv_from(frame), pyopencv_from(gtMask));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_frame = NULL;
    UMat frame;
    PyObject* pyobj_gtMask = NULL;
    UMat gtMask;

    const char* keywords[] = { "frame", "gtMask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:bgsegm_SyntheticSequenceGenerator.getNextFrame", (char**)keywords, &pyobj_frame, &pyobj_gtMask) &&
        pyopencv_to(pyobj_frame, frame, ArgInfo("frame", 1)) &&
        pyopencv_to(pyobj_gtMask, gtMask, ArgInfo("gtMask", 1)) )
    {
        ERRWRAP2(_self_->getNextFrame(frame, gtMask));
        return Py_BuildValue("(NN)", pyopencv_from(frame), pyopencv_from(gtMask));
    }
    }

    return NULL;
}



// Tables (bgsegm_SyntheticSequenceGenerator)

static PyGetSetDef pyopencv_bgsegm_SyntheticSequenceGenerator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bgsegm_SyntheticSequenceGenerator_methods[] =
{
    {"getNextFrame", CV_PY_FN_WITH_KW_(pyopencv_cv_bgsegm_bgsegm_SyntheticSequenceGenerator_getNextFrame, 0), "getNextFrame([, frame[, gtMask]]) -> frame, gtMask\n.   @brief Obtain the next frame in the sequence.\n.   \n.       @param frame Output frame.\n.       @param gtMask Output ground-truth (reference) segmentation mask object/background."},

    {NULL,          NULL}
};

// Converter (bgsegm_SyntheticSequenceGenerator)

template<>
struct PyOpenCV_Converter< Ptr<cv::bgsegm::SyntheticSequenceGenerator> >
{
    static PyObject* from(const Ptr<cv::bgsegm::SyntheticSequenceGenerator>& r)
    {
        return pyopencv_bgsegm_SyntheticSequenceGenerator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bgsegm::SyntheticSequenceGenerator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bgsegm::SyntheticSequenceGenerator> * dst_;
        if (pyopencv_bgsegm_SyntheticSequenceGenerator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bgsegm::SyntheticSequenceGenerator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bioinspired_Retina (Generic)
//================================================================================

// GetSet (bioinspired_Retina)



// Methods (bioinspired_Retina)

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_activateContoursProcessing(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    bool activate=0;

    const char* keywords[] = { "activate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:bioinspired_Retina.activateContoursProcessing", (char**)keywords, &activate) )
    {
        ERRWRAP2(_self_->activateContoursProcessing(activate));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_activateMovingContoursProcessing(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    bool activate=0;

    const char* keywords[] = { "activate", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:bioinspired_Retina.activateMovingContoursProcessing", (char**)keywords, &activate) )
    {
        ERRWRAP2(_self_->activateMovingContoursProcessing(activate));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_applyFastToneMapping(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    {
    PyObject* pyobj_inputImage = NULL;
    Mat inputImage;
    PyObject* pyobj_outputToneMappedImage = NULL;
    Mat outputToneMappedImage;

    const char* keywords[] = { "inputImage", "outputToneMappedImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:bioinspired_Retina.applyFastToneMapping", (char**)keywords, &pyobj_inputImage, &pyobj_outputToneMappedImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        pyopencv_to(pyobj_outputToneMappedImage, outputToneMappedImage, ArgInfo("outputToneMappedImage", 1)) )
    {
        ERRWRAP2(_self_->applyFastToneMapping(inputImage, outputToneMappedImage));
        return pyopencv_from(outputToneMappedImage);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputImage = NULL;
    UMat inputImage;
    PyObject* pyobj_outputToneMappedImage = NULL;
    UMat outputToneMappedImage;

    const char* keywords[] = { "inputImage", "outputToneMappedImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:bioinspired_Retina.applyFastToneMapping", (char**)keywords, &pyobj_inputImage, &pyobj_outputToneMappedImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        pyopencv_to(pyobj_outputToneMappedImage, outputToneMappedImage, ArgInfo("outputToneMappedImage", 1)) )
    {
        ERRWRAP2(_self_->applyFastToneMapping(inputImage, outputToneMappedImage));
        return pyopencv_from(outputToneMappedImage);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_clearBuffers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clearBuffers());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;

    {
    PyObject* pyobj_inputSize = NULL;
    Size inputSize;
    Ptr<Retina> retval;

    const char* keywords[] = { "inputSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:bioinspired_Retina.create", (char**)keywords, &pyobj_inputSize) &&
        pyopencv_to(pyobj_inputSize, inputSize, ArgInfo("inputSize", 0)) )
    {
        ERRWRAP2(retval = cv::bioinspired::Retina::create(inputSize));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputSize = NULL;
    Size inputSize;
    bool colorMode=0;
    int colorSamplingMethod=RETINA_COLOR_BAYER;
    bool useRetinaLogSampling=false;
    float reductionFactor=1.0f;
    float samplingStrenght=10.0f;
    Ptr<Retina> retval;

    const char* keywords[] = { "inputSize", "colorMode", "colorSamplingMethod", "useRetinaLogSampling", "reductionFactor", "samplingStrenght", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Ob|ibff:bioinspired_Retina.create", (char**)keywords, &pyobj_inputSize, &colorMode, &colorSamplingMethod, &useRetinaLogSampling, &reductionFactor, &samplingStrenght) &&
        pyopencv_to(pyobj_inputSize, inputSize, ArgInfo("inputSize", 0)) )
    {
        ERRWRAP2(retval = cv::bioinspired::Retina::create(inputSize, colorMode, colorSamplingMethod, useRetinaLogSampling, reductionFactor, samplingStrenght));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_getInputSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInputSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_getMagno(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    {
    PyObject* pyobj_retinaOutput_magno = NULL;
    Mat retinaOutput_magno;

    const char* keywords[] = { "retinaOutput_magno", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_Retina.getMagno", (char**)keywords, &pyobj_retinaOutput_magno) &&
        pyopencv_to(pyobj_retinaOutput_magno, retinaOutput_magno, ArgInfo("retinaOutput_magno", 1)) )
    {
        ERRWRAP2(_self_->getMagno(retinaOutput_magno));
        return pyopencv_from(retinaOutput_magno);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_retinaOutput_magno = NULL;
    UMat retinaOutput_magno;

    const char* keywords[] = { "retinaOutput_magno", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_Retina.getMagno", (char**)keywords, &pyobj_retinaOutput_magno) &&
        pyopencv_to(pyobj_retinaOutput_magno, retinaOutput_magno, ArgInfo("retinaOutput_magno", 1)) )
    {
        ERRWRAP2(_self_->getMagno(retinaOutput_magno));
        return pyopencv_from(retinaOutput_magno);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_getMagnoRAW(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    {
    PyObject* pyobj_retinaOutput_magno = NULL;
    Mat retinaOutput_magno;

    const char* keywords[] = { "retinaOutput_magno", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_Retina.getMagnoRAW", (char**)keywords, &pyobj_retinaOutput_magno) &&
        pyopencv_to(pyobj_retinaOutput_magno, retinaOutput_magno, ArgInfo("retinaOutput_magno", 1)) )
    {
        ERRWRAP2(_self_->getMagnoRAW(retinaOutput_magno));
        return pyopencv_from(retinaOutput_magno);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_retinaOutput_magno = NULL;
    UMat retinaOutput_magno;

    const char* keywords[] = { "retinaOutput_magno", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_Retina.getMagnoRAW", (char**)keywords, &pyobj_retinaOutput_magno) &&
        pyopencv_to(pyobj_retinaOutput_magno, retinaOutput_magno, ArgInfo("retinaOutput_magno", 1)) )
    {
        ERRWRAP2(_self_->getMagnoRAW(retinaOutput_magno));
        return pyopencv_from(retinaOutput_magno);
    }
    }
    PyErr_Clear();

    {
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMagnoRAW());
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_getOutputSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getOutputSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_getParvo(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    {
    PyObject* pyobj_retinaOutput_parvo = NULL;
    Mat retinaOutput_parvo;

    const char* keywords[] = { "retinaOutput_parvo", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_Retina.getParvo", (char**)keywords, &pyobj_retinaOutput_parvo) &&
        pyopencv_to(pyobj_retinaOutput_parvo, retinaOutput_parvo, ArgInfo("retinaOutput_parvo", 1)) )
    {
        ERRWRAP2(_self_->getParvo(retinaOutput_parvo));
        return pyopencv_from(retinaOutput_parvo);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_retinaOutput_parvo = NULL;
    UMat retinaOutput_parvo;

    const char* keywords[] = { "retinaOutput_parvo", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_Retina.getParvo", (char**)keywords, &pyobj_retinaOutput_parvo) &&
        pyopencv_to(pyobj_retinaOutput_parvo, retinaOutput_parvo, ArgInfo("retinaOutput_parvo", 1)) )
    {
        ERRWRAP2(_self_->getParvo(retinaOutput_parvo));
        return pyopencv_from(retinaOutput_parvo);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_getParvoRAW(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    {
    PyObject* pyobj_retinaOutput_parvo = NULL;
    Mat retinaOutput_parvo;

    const char* keywords[] = { "retinaOutput_parvo", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_Retina.getParvoRAW", (char**)keywords, &pyobj_retinaOutput_parvo) &&
        pyopencv_to(pyobj_retinaOutput_parvo, retinaOutput_parvo, ArgInfo("retinaOutput_parvo", 1)) )
    {
        ERRWRAP2(_self_->getParvoRAW(retinaOutput_parvo));
        return pyopencv_from(retinaOutput_parvo);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_retinaOutput_parvo = NULL;
    UMat retinaOutput_parvo;

    const char* keywords[] = { "retinaOutput_parvo", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_Retina.getParvoRAW", (char**)keywords, &pyobj_retinaOutput_parvo) &&
        pyopencv_to(pyobj_retinaOutput_parvo, retinaOutput_parvo, ArgInfo("retinaOutput_parvo", 1)) )
    {
        ERRWRAP2(_self_->getParvoRAW(retinaOutput_parvo));
        return pyopencv_from(retinaOutput_parvo);
    }
    }
    PyErr_Clear();

    {
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getParvoRAW());
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_printSetup(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->printSetup());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_run(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    {
    PyObject* pyobj_inputImage = NULL;
    Mat inputImage;

    const char* keywords[] = { "inputImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:bioinspired_Retina.run", (char**)keywords, &pyobj_inputImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) )
    {
        ERRWRAP2(_self_->run(inputImage));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputImage = NULL;
    UMat inputImage;

    const char* keywords[] = { "inputImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:bioinspired_Retina.run", (char**)keywords, &pyobj_inputImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) )
    {
        ERRWRAP2(_self_->run(inputImage));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_setColorSaturation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    bool saturateColors=true;
    float colorSaturationValue=4.0f;

    const char* keywords[] = { "saturateColors", "colorSaturationValue", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|bf:bioinspired_Retina.setColorSaturation", (char**)keywords, &saturateColors, &colorSaturationValue) )
    {
        ERRWRAP2(_self_->setColorSaturation(saturateColors, colorSaturationValue));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_setup(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    PyObject* pyobj_retinaParameterFile = NULL;
    String retinaParameterFile="";
    bool applyDefaultSetupOnFailure=true;

    const char* keywords[] = { "retinaParameterFile", "applyDefaultSetupOnFailure", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Ob:bioinspired_Retina.setup", (char**)keywords, &pyobj_retinaParameterFile, &applyDefaultSetupOnFailure) &&
        pyopencv_to(pyobj_retinaParameterFile, retinaParameterFile, ArgInfo("retinaParameterFile", 0)) )
    {
        ERRWRAP2(_self_->setup(retinaParameterFile, applyDefaultSetupOnFailure));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_setupIPLMagnoChannel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    bool normaliseOutput=true;
    float parasolCells_beta=0.f;
    float parasolCells_tau=0.f;
    float parasolCells_k=7.f;
    float amacrinCellsTemporalCutFrequency=1.2f;
    float V0CompressionParameter=0.95f;
    float localAdaptintegration_tau=0.f;
    float localAdaptintegration_k=7.f;

    const char* keywords[] = { "normaliseOutput", "parasolCells_beta", "parasolCells_tau", "parasolCells_k", "amacrinCellsTemporalCutFrequency", "V0CompressionParameter", "localAdaptintegration_tau", "localAdaptintegration_k", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|bfffffff:bioinspired_Retina.setupIPLMagnoChannel", (char**)keywords, &normaliseOutput, &parasolCells_beta, &parasolCells_tau, &parasolCells_k, &amacrinCellsTemporalCutFrequency, &V0CompressionParameter, &localAdaptintegration_tau, &localAdaptintegration_k) )
    {
        ERRWRAP2(_self_->setupIPLMagnoChannel(normaliseOutput, parasolCells_beta, parasolCells_tau, parasolCells_k, amacrinCellsTemporalCutFrequency, V0CompressionParameter, localAdaptintegration_tau, localAdaptintegration_k));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_setupOPLandIPLParvoChannel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    bool colorMode=true;
    bool normaliseOutput=true;
    float photoreceptorsLocalAdaptationSensitivity=0.7f;
    float photoreceptorsTemporalConstant=0.5f;
    float photoreceptorsSpatialConstant=0.53f;
    float horizontalCellsGain=0.f;
    float HcellsTemporalConstant=1.f;
    float HcellsSpatialConstant=7.f;
    float ganglionCellsSensitivity=0.7f;

    const char* keywords[] = { "colorMode", "normaliseOutput", "photoreceptorsLocalAdaptationSensitivity", "photoreceptorsTemporalConstant", "photoreceptorsSpatialConstant", "horizontalCellsGain", "HcellsTemporalConstant", "HcellsSpatialConstant", "ganglionCellsSensitivity", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|bbfffffff:bioinspired_Retina.setupOPLandIPLParvoChannel", (char**)keywords, &colorMode, &normaliseOutput, &photoreceptorsLocalAdaptationSensitivity, &photoreceptorsTemporalConstant, &photoreceptorsSpatialConstant, &horizontalCellsGain, &HcellsTemporalConstant, &HcellsSpatialConstant, &ganglionCellsSensitivity) )
    {
        ERRWRAP2(_self_->setupOPLandIPLParvoChannel(colorMode, normaliseOutput, photoreceptorsLocalAdaptationSensitivity, photoreceptorsTemporalConstant, photoreceptorsSpatialConstant, horizontalCellsGain, HcellsTemporalConstant, HcellsSpatialConstant, ganglionCellsSensitivity));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_Retina_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::Retina> * self1 = 0;
    if (!pyopencv_bioinspired_Retina_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_Retina' or its derivative)");
    Ptr<cv::bioinspired::Retina> _self_ = *(self1);
    PyObject* pyobj_fs = NULL;
    String fs;

    const char* keywords[] = { "fs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:bioinspired_Retina.write", (char**)keywords, &pyobj_fs) &&
        pyopencv_to(pyobj_fs, fs, ArgInfo("fs", 0)) )
    {
        ERRWRAP2(_self_->write(fs));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (bioinspired_Retina)

static PyGetSetDef pyopencv_bioinspired_Retina_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bioinspired_Retina_methods[] =
{
    {"activateContoursProcessing", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_activateContoursProcessing, 0), "activateContoursProcessing(activate) -> None\n.   @brief Activate/desactivate the Parvocellular pathway processing (contours information extraction), by\n.       default, it is activated\n.       @param activate true if Parvocellular (contours information extraction) output should be\n.       activated, false if not... if activated, the Parvocellular output can be retrieved using the\n.       Retina::getParvo methods"},
    {"activateMovingContoursProcessing", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_activateMovingContoursProcessing, 0), "activateMovingContoursProcessing(activate) -> None\n.   @brief Activate/desactivate the Magnocellular pathway processing (motion information extraction), by\n.       default, it is activated\n.       @param activate true if Magnocellular output should be activated, false if not... if activated,\n.       the Magnocellular output can be retrieved using the **getMagno** methods"},
    {"applyFastToneMapping", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_applyFastToneMapping, 0), "applyFastToneMapping(inputImage[, outputToneMappedImage]) -> outputToneMappedImage\n.   @brief Method which processes an image in the aim to correct its luminance correct\n.       backlight problems, enhance details in shadows.\n.   \n.       This method is designed to perform High Dynamic Range image tone mapping (compress \\>8bit/pixel\n.       images to 8bit/pixel). This is a simplified version of the Retina Parvocellular model\n.       (simplified version of the run/getParvo methods call) since it does not include the\n.       spatio-temporal filter modelling the Outer Plexiform Layer of the retina that performs spectral\n.       whitening and many other stuff. However, it works great for tone mapping and in a faster way.\n.   \n.       Check the demos and experiments section to see examples and the way to perform tone mapping\n.       using the original retina model and the method.\n.   \n.       @param inputImage the input image to process (should be coded in float format : CV_32F,\n.       CV_32FC1, CV_32F_C3, CV_32F_C4, the 4th channel won't be considered).\n.       @param outputToneMappedImage the output 8bit/channel tone mapped image (CV_8U or CV_8UC3 format)."},
    {"clearBuffers", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_clearBuffers, 0), "clearBuffers() -> None\n.   @brief Clears all retina buffers\n.   \n.       (equivalent to opening the eyes after a long period of eye close ;o) whatchout the temporal\n.       transition occuring just after this method call."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_create_static, METH_STATIC), "create(inputSize) -> retval\n.   @overload\n\n\n\ncreate(inputSize, colorMode[, colorSamplingMethod[, useRetinaLogSampling[, reductionFactor[, samplingStrenght]]]]) -> retval\n.   @brief Constructors from standardized interfaces : retreive a smart pointer to a Retina instance\n.   \n.       @param inputSize the input frame size\n.       @param colorMode the chosen processing mode : with or without color processing\n.       @param colorSamplingMethod specifies which kind of color sampling will be used :\n.       -   cv::bioinspired::RETINA_COLOR_RANDOM: each pixel position is either R, G or B in a random choice\n.       -   cv::bioinspired::RETINA_COLOR_DIAGONAL: color sampling is RGBRGBRGB..., line 2 BRGBRGBRG..., line 3, GBRGBRGBR...\n.       -   cv::bioinspired::RETINA_COLOR_BAYER: standard bayer sampling\n.       @param useRetinaLogSampling activate retina log sampling, if true, the 2 following parameters can\n.       be used\n.       @param reductionFactor only usefull if param useRetinaLogSampling=true, specifies the reduction\n.       factor of the output frame (as the center (fovea) is high resolution and corners can be\n.       underscaled, then a reduction of the output is allowed without precision leak\n.       @param samplingStrenght only usefull if param useRetinaLogSampling=true, specifies the strenght of\n.       the log scale that is applied"},
    {"getInputSize", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_getInputSize, 0), "getInputSize() -> retval\n.   @brief Retreive retina input buffer size\n.       @return the retina input buffer size"},
    {"getMagno", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_getMagno, 0), "getMagno([, retinaOutput_magno]) -> retinaOutput_magno\n.   @brief Accessor of the motion channel of the retina (models peripheral vision).\n.   \n.       Warning, getMagnoRAW methods return buffers that are not rescaled within range [0;255] while\n.       the non RAW method allows a normalized matrix to be retrieved.\n.       @param retinaOutput_magno the output buffer (reallocated if necessary), format can be :\n.       -   a Mat, this output is rescaled for standard 8bits image processing use in OpenCV\n.       -   RAW methods actually return a 1D matrix (encoding is M1, M2,... Mn), this output is the\n.       original retina filter model output, without any quantification or rescaling.\n.       @see getMagnoRAW"},
    {"getMagnoRAW", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_getMagnoRAW, 0), "getMagnoRAW([, retinaOutput_magno]) -> retinaOutput_magno\n.   @brief Accessor of the motion channel of the retina (models peripheral vision).\n.       @see getMagno\n\n\n\ngetMagnoRAW() -> retval\n.   @overload"},
    {"getOutputSize", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_getOutputSize, 0), "getOutputSize() -> retval\n.   @brief Retreive retina output buffer size that can be different from the input if a spatial log\n.       transformation is applied\n.       @return the retina output buffer size"},
    {"getParvo", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_getParvo, 0), "getParvo([, retinaOutput_parvo]) -> retinaOutput_parvo\n.   @brief Accessor of the details channel of the retina (models foveal vision).\n.   \n.       Warning, getParvoRAW methods return buffers that are not rescaled within range [0;255] while\n.       the non RAW method allows a normalized matrix to be retrieved.\n.   \n.       @param retinaOutput_parvo the output buffer (reallocated if necessary), format can be :\n.       -   a Mat, this output is rescaled for standard 8bits image processing use in OpenCV\n.       -   RAW methods actually return a 1D matrix (encoding is R1, R2, ... Rn, G1, G2, ..., Gn, B1,\n.       B2, ...Bn), this output is the original retina filter model output, without any\n.       quantification or rescaling.\n.       @see getParvoRAW"},
    {"getParvoRAW", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_getParvoRAW, 0), "getParvoRAW([, retinaOutput_parvo]) -> retinaOutput_parvo\n.   @brief Accessor of the details channel of the retina (models foveal vision).\n.       @see getParvo\n\n\n\ngetParvoRAW() -> retval\n.   @overload"},
    {"printSetup", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_printSetup, 0), "printSetup() -> retval\n.   @brief Outputs a string showing the used parameters setup\n.       @return a string which contains formated parameters information"},
    {"run", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_run, 0), "run(inputImage) -> None\n.   @brief Method which allows retina to be applied on an input image,\n.   \n.       after run, encapsulated retina module is ready to deliver its outputs using dedicated\n.       acccessors, see getParvo and getMagno methods\n.       @param inputImage the input Mat image to be processed, can be gray level or BGR coded in any\n.       format (from 8bit to 16bits)"},
    {"setColorSaturation", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_setColorSaturation, 0), "setColorSaturation([, saturateColors[, colorSaturationValue]]) -> None\n.   @brief Activate color saturation as the final step of the color demultiplexing process -\\> this\n.       saturation is a sigmoide function applied to each channel of the demultiplexed image.\n.       @param saturateColors boolean that activates color saturation (if true) or desactivate (if false)\n.       @param colorSaturationValue the saturation factor : a simple factor applied on the chrominance\n.       buffers"},
    {"setup", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_setup, 0), "setup([, retinaParameterFile[, applyDefaultSetupOnFailure]]) -> None\n.   @brief Try to open an XML retina parameters file to adjust current retina instance setup\n.   \n.       - if the xml file does not exist, then default setup is applied\n.       - warning, Exceptions are thrown if read XML file is not valid\n.       @param retinaParameterFile the parameters filename\n.       @param applyDefaultSetupOnFailure set to true if an error must be thrown on error\n.   \n.       You can retrieve the current parameters structure using the method Retina::getParameters and update\n.       it before running method Retina::setup."},
    {"setupIPLMagnoChannel", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_setupIPLMagnoChannel, 0), "setupIPLMagnoChannel([, normaliseOutput[, parasolCells_beta[, parasolCells_tau[, parasolCells_k[, amacrinCellsTemporalCutFrequency[, V0CompressionParameter[, localAdaptintegration_tau[, localAdaptintegration_k]]]]]]]]) -> None\n.   @brief Set parameters values for the Inner Plexiform Layer (IPL) magnocellular channel\n.   \n.       this channel processes signals output from OPL processing stage in peripheral vision, it allows\n.       motion information enhancement. It is decorrelated from the details channel. See reference\n.       papers for more details.\n.   \n.       @param normaliseOutput specifies if (true) output is rescaled between 0 and 255 of not (false)\n.       @param parasolCells_beta the low pass filter gain used for local contrast adaptation at the\n.       IPL level of the retina (for ganglion cells local adaptation), typical value is 0\n.       @param parasolCells_tau the low pass filter time constant used for local contrast adaptation\n.       at the IPL level of the retina (for ganglion cells local adaptation), unit is frame, typical\n.       value is 0 (immediate response)\n.       @param parasolCells_k the low pass filter spatial constant used for local contrast adaptation\n.       at the IPL level of the retina (for ganglion cells local adaptation), unit is pixels, typical\n.       value is 5\n.       @param amacrinCellsTemporalCutFrequency the time constant of the first order high pass fiter of\n.       the magnocellular way (motion information channel), unit is frames, typical value is 1.2\n.       @param V0CompressionParameter the compression strengh of the ganglion cells local adaptation\n.       output, set a value between 0.6 and 1 for best results, a high value increases more the low\n.       value sensitivity... and the output saturates faster, recommended value: 0.95\n.       @param localAdaptintegration_tau specifies the temporal constant of the low pas filter\n.       involved in the computation of the local \"motion mean\" for the local adaptation computation\n.       @param localAdaptintegration_k specifies the spatial constant of the low pas filter involved\n.       in the computation of the local \"motion mean\" for the local adaptation computation"},
    {"setupOPLandIPLParvoChannel", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_setupOPLandIPLParvoChannel, 0), "setupOPLandIPLParvoChannel([, colorMode[, normaliseOutput[, photoreceptorsLocalAdaptationSensitivity[, photoreceptorsTemporalConstant[, photoreceptorsSpatialConstant[, horizontalCellsGain[, HcellsTemporalConstant[, HcellsSpatialConstant[, ganglionCellsSensitivity]]]]]]]]]) -> None\n.   @brief Setup the OPL and IPL parvo channels (see biologocal model)\n.   \n.       OPL is referred as Outer Plexiform Layer of the retina, it allows the spatio-temporal filtering\n.       which withens the spectrum and reduces spatio-temporal noise while attenuating global luminance\n.       (low frequency energy) IPL parvo is the OPL next processing stage, it refers to a part of the\n.       Inner Plexiform layer of the retina, it allows high contours sensitivity in foveal vision. See\n.       reference papers for more informations.\n.       for more informations, please have a look at the paper Benoit A., Caplier A., Durette B., Herault, J., \"USING HUMAN VISUAL SYSTEM MODELING FOR BIO-INSPIRED LOW LEVEL IMAGE PROCESSING\", Elsevier, Computer Vision and Image Understanding 114 (2010), pp. 758-773, DOI: http://dx.doi.org/10.1016/j.cviu.2010.01.011\n.       @param colorMode specifies if (true) color is processed of not (false) to then processing gray\n.       level image\n.       @param normaliseOutput specifies if (true) output is rescaled between 0 and 255 of not (false)\n.       @param photoreceptorsLocalAdaptationSensitivity the photoreceptors sensitivity renage is 0-1\n.       (more log compression effect when value increases)\n.       @param photoreceptorsTemporalConstant the time constant of the first order low pass filter of\n.       the photoreceptors, use it to cut high temporal frequencies (noise or fast motion), unit is\n.       frames, typical value is 1 frame\n.       @param photoreceptorsSpatialConstant the spatial constant of the first order low pass filter of\n.       the photoreceptors, use it to cut high spatial frequencies (noise or thick contours), unit is\n.       pixels, typical value is 1 pixel\n.       @param horizontalCellsGain gain of the horizontal cells network, if 0, then the mean value of\n.       the output is zero, if the parameter is near 1, then, the luminance is not filtered and is\n.       still reachable at the output, typicall value is 0\n.       @param HcellsTemporalConstant the time constant of the first order low pass filter of the\n.       horizontal cells, use it to cut low temporal frequencies (local luminance variations), unit is\n.       frames, typical value is 1 frame, as the photoreceptors\n.       @param HcellsSpatialConstant the spatial constant of the first order low pass filter of the\n.       horizontal cells, use it to cut low spatial frequencies (local luminance), unit is pixels,\n.       typical value is 5 pixel, this value is also used for local contrast computing when computing\n.       the local contrast adaptation at the ganglion cells level (Inner Plexiform Layer parvocellular\n.       channel model)\n.       @param ganglionCellsSensitivity the compression strengh of the ganglion cells local adaptation\n.       output, set a value between 0.6 and 1 for best results, a high value increases more the low\n.       value sensitivity... and the output saturates faster, recommended value: 0.7"},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_Retina_write, 0), "write(fs) -> None\n.   @brief Write xml/yml formated parameters information\n.       @param fs the filename of the xml file that will be open and writen with formatted parameters\n.       information"},

    {NULL,          NULL}
};

// Converter (bioinspired_Retina)

template<>
struct PyOpenCV_Converter< Ptr<cv::bioinspired::Retina> >
{
    static PyObject* from(const Ptr<cv::bioinspired::Retina>& r)
    {
        return pyopencv_bioinspired_Retina_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bioinspired::Retina>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bioinspired::Retina> * dst_;
        if (pyopencv_bioinspired_Retina_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bioinspired::Retina> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bioinspired_RetinaFastToneMapping (Generic)
//================================================================================

// GetSet (bioinspired_RetinaFastToneMapping)



// Methods (bioinspired_RetinaFastToneMapping)

static PyObject* pyopencv_cv_bioinspired_bioinspired_RetinaFastToneMapping_applyFastToneMapping(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::RetinaFastToneMapping> * self1 = 0;
    if (!pyopencv_bioinspired_RetinaFastToneMapping_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_RetinaFastToneMapping' or its derivative)");
    Ptr<cv::bioinspired::RetinaFastToneMapping> _self_ = *(self1);
    {
    PyObject* pyobj_inputImage = NULL;
    Mat inputImage;
    PyObject* pyobj_outputToneMappedImage = NULL;
    Mat outputToneMappedImage;

    const char* keywords[] = { "inputImage", "outputToneMappedImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:bioinspired_RetinaFastToneMapping.applyFastToneMapping", (char**)keywords, &pyobj_inputImage, &pyobj_outputToneMappedImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        pyopencv_to(pyobj_outputToneMappedImage, outputToneMappedImage, ArgInfo("outputToneMappedImage", 1)) )
    {
        ERRWRAP2(_self_->applyFastToneMapping(inputImage, outputToneMappedImage));
        return pyopencv_from(outputToneMappedImage);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputImage = NULL;
    UMat inputImage;
    PyObject* pyobj_outputToneMappedImage = NULL;
    UMat outputToneMappedImage;

    const char* keywords[] = { "inputImage", "outputToneMappedImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:bioinspired_RetinaFastToneMapping.applyFastToneMapping", (char**)keywords, &pyobj_inputImage, &pyobj_outputToneMappedImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        pyopencv_to(pyobj_outputToneMappedImage, outputToneMappedImage, ArgInfo("outputToneMappedImage", 1)) )
    {
        ERRWRAP2(_self_->applyFastToneMapping(inputImage, outputToneMappedImage));
        return pyopencv_from(outputToneMappedImage);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_RetinaFastToneMapping_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;

    PyObject* pyobj_inputSize = NULL;
    Size inputSize;
    Ptr<RetinaFastToneMapping> retval;

    const char* keywords[] = { "inputSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:bioinspired_RetinaFastToneMapping.create", (char**)keywords, &pyobj_inputSize) &&
        pyopencv_to(pyobj_inputSize, inputSize, ArgInfo("inputSize", 0)) )
    {
        ERRWRAP2(retval = cv::bioinspired::RetinaFastToneMapping::create(inputSize));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_RetinaFastToneMapping_setup(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::RetinaFastToneMapping> * self1 = 0;
    if (!pyopencv_bioinspired_RetinaFastToneMapping_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_RetinaFastToneMapping' or its derivative)");
    Ptr<cv::bioinspired::RetinaFastToneMapping> _self_ = *(self1);
    float photoreceptorsNeighborhoodRadius=3.f;
    float ganglioncellsNeighborhoodRadius=1.f;
    float meanLuminanceModulatorK=1.f;

    const char* keywords[] = { "photoreceptorsNeighborhoodRadius", "ganglioncellsNeighborhoodRadius", "meanLuminanceModulatorK", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|fff:bioinspired_RetinaFastToneMapping.setup", (char**)keywords, &photoreceptorsNeighborhoodRadius, &ganglioncellsNeighborhoodRadius, &meanLuminanceModulatorK) )
    {
        ERRWRAP2(_self_->setup(photoreceptorsNeighborhoodRadius, ganglioncellsNeighborhoodRadius, meanLuminanceModulatorK));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (bioinspired_RetinaFastToneMapping)

static PyGetSetDef pyopencv_bioinspired_RetinaFastToneMapping_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bioinspired_RetinaFastToneMapping_methods[] =
{
    {"applyFastToneMapping", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_RetinaFastToneMapping_applyFastToneMapping, 0), "applyFastToneMapping(inputImage[, outputToneMappedImage]) -> outputToneMappedImage\n.   @brief applies a luminance correction (initially High Dynamic Range (HDR) tone mapping)\n.   \n.       using only the 2 local adaptation stages of the retina parvocellular channel : photoreceptors\n.       level and ganlion cells level. Spatio temporal filtering is applied but limited to temporal\n.       smoothing and eventually high frequencies attenuation. This is a lighter method than the one\n.       available using the regular retina::run method. It is then faster but it does not include\n.       complete temporal filtering nor retina spectral whitening. Then, it can have a more limited\n.       effect on images with a very high dynamic range. This is an adptation of the original still\n.       image HDR tone mapping algorithm of David Alleyson, Sabine Susstruck and Laurence Meylan's\n.       work, please cite: -> Meylan L., Alleysson D., and Susstrunk S., A Model of Retinal Local\n.       Adaptation for the Tone Mapping of Color Filter Array Images, Journal of Optical Society of\n.       America, A, Vol. 24, N 9, September, 1st, 2007, pp. 2807-2816\n.   \n.       @param inputImage the input image to process RGB or gray levels\n.       @param outputToneMappedImage the output tone mapped image"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_RetinaFastToneMapping_create_static, METH_STATIC), "create(inputSize) -> retval\n."},
    {"setup", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_RetinaFastToneMapping_setup, 0), "setup([, photoreceptorsNeighborhoodRadius[, ganglioncellsNeighborhoodRadius[, meanLuminanceModulatorK]]]) -> None\n.   @brief updates tone mapping behaviors by adjusing the local luminance computation area\n.   \n.       @param photoreceptorsNeighborhoodRadius the first stage local adaptation area\n.       @param ganglioncellsNeighborhoodRadius the second stage local adaptation area\n.       @param meanLuminanceModulatorK the factor applied to modulate the meanLuminance information\n.       (default is 1, see reference paper)"},

    {NULL,          NULL}
};

// Converter (bioinspired_RetinaFastToneMapping)

template<>
struct PyOpenCV_Converter< Ptr<cv::bioinspired::RetinaFastToneMapping> >
{
    static PyObject* from(const Ptr<cv::bioinspired::RetinaFastToneMapping>& r)
    {
        return pyopencv_bioinspired_RetinaFastToneMapping_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bioinspired::RetinaFastToneMapping>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bioinspired::RetinaFastToneMapping> * dst_;
        if (pyopencv_bioinspired_RetinaFastToneMapping_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bioinspired::RetinaFastToneMapping> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// bioinspired_TransientAreasSegmentationModule (Generic)
//================================================================================

// GetSet (bioinspired_TransientAreasSegmentationModule)



// Methods (bioinspired_TransientAreasSegmentationModule)

static PyObject* pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_clearAllBuffers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::TransientAreasSegmentationModule> * self1 = 0;
    if (!pyopencv_bioinspired_TransientAreasSegmentationModule_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_TransientAreasSegmentationModule' or its derivative)");
    Ptr<cv::bioinspired::TransientAreasSegmentationModule> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clearAllBuffers());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;

    PyObject* pyobj_inputSize = NULL;
    Size inputSize;
    Ptr<TransientAreasSegmentationModule> retval;

    const char* keywords[] = { "inputSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:bioinspired_TransientAreasSegmentationModule.create", (char**)keywords, &pyobj_inputSize) &&
        pyopencv_to(pyobj_inputSize, inputSize, ArgInfo("inputSize", 0)) )
    {
        ERRWRAP2(retval = cv::bioinspired::TransientAreasSegmentationModule::create(inputSize));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_getSegmentationPicture(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::TransientAreasSegmentationModule> * self1 = 0;
    if (!pyopencv_bioinspired_TransientAreasSegmentationModule_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_TransientAreasSegmentationModule' or its derivative)");
    Ptr<cv::bioinspired::TransientAreasSegmentationModule> _self_ = *(self1);
    {
    PyObject* pyobj_transientAreas = NULL;
    Mat transientAreas;

    const char* keywords[] = { "transientAreas", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_TransientAreasSegmentationModule.getSegmentationPicture", (char**)keywords, &pyobj_transientAreas) &&
        pyopencv_to(pyobj_transientAreas, transientAreas, ArgInfo("transientAreas", 1)) )
    {
        ERRWRAP2(_self_->getSegmentationPicture(transientAreas));
        return pyopencv_from(transientAreas);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_transientAreas = NULL;
    UMat transientAreas;

    const char* keywords[] = { "transientAreas", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:bioinspired_TransientAreasSegmentationModule.getSegmentationPicture", (char**)keywords, &pyobj_transientAreas) &&
        pyopencv_to(pyobj_transientAreas, transientAreas, ArgInfo("transientAreas", 1)) )
    {
        ERRWRAP2(_self_->getSegmentationPicture(transientAreas));
        return pyopencv_from(transientAreas);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_getSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::TransientAreasSegmentationModule> * self1 = 0;
    if (!pyopencv_bioinspired_TransientAreasSegmentationModule_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_TransientAreasSegmentationModule' or its derivative)");
    Ptr<cv::bioinspired::TransientAreasSegmentationModule> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_printSetup(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::TransientAreasSegmentationModule> * self1 = 0;
    if (!pyopencv_bioinspired_TransientAreasSegmentationModule_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_TransientAreasSegmentationModule' or its derivative)");
    Ptr<cv::bioinspired::TransientAreasSegmentationModule> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->printSetup());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_run(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::TransientAreasSegmentationModule> * self1 = 0;
    if (!pyopencv_bioinspired_TransientAreasSegmentationModule_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_TransientAreasSegmentationModule' or its derivative)");
    Ptr<cv::bioinspired::TransientAreasSegmentationModule> _self_ = *(self1);
    {
    PyObject* pyobj_inputToSegment = NULL;
    Mat inputToSegment;
    int channelIndex=0;

    const char* keywords[] = { "inputToSegment", "channelIndex", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:bioinspired_TransientAreasSegmentationModule.run", (char**)keywords, &pyobj_inputToSegment, &channelIndex) &&
        pyopencv_to(pyobj_inputToSegment, inputToSegment, ArgInfo("inputToSegment", 0)) )
    {
        ERRWRAP2(_self_->run(inputToSegment, channelIndex));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputToSegment = NULL;
    UMat inputToSegment;
    int channelIndex=0;

    const char* keywords[] = { "inputToSegment", "channelIndex", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:bioinspired_TransientAreasSegmentationModule.run", (char**)keywords, &pyobj_inputToSegment, &channelIndex) &&
        pyopencv_to(pyobj_inputToSegment, inputToSegment, ArgInfo("inputToSegment", 0)) )
    {
        ERRWRAP2(_self_->run(inputToSegment, channelIndex));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_setup(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::TransientAreasSegmentationModule> * self1 = 0;
    if (!pyopencv_bioinspired_TransientAreasSegmentationModule_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_TransientAreasSegmentationModule' or its derivative)");
    Ptr<cv::bioinspired::TransientAreasSegmentationModule> _self_ = *(self1);
    PyObject* pyobj_segmentationParameterFile = NULL;
    String segmentationParameterFile="";
    bool applyDefaultSetupOnFailure=true;

    const char* keywords[] = { "segmentationParameterFile", "applyDefaultSetupOnFailure", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Ob:bioinspired_TransientAreasSegmentationModule.setup", (char**)keywords, &pyobj_segmentationParameterFile, &applyDefaultSetupOnFailure) &&
        pyopencv_to(pyobj_segmentationParameterFile, segmentationParameterFile, ArgInfo("segmentationParameterFile", 0)) )
    {
        ERRWRAP2(_self_->setup(segmentationParameterFile, applyDefaultSetupOnFailure));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::bioinspired;


    Ptr<cv::bioinspired::TransientAreasSegmentationModule> * self1 = 0;
    if (!pyopencv_bioinspired_TransientAreasSegmentationModule_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'bioinspired_TransientAreasSegmentationModule' or its derivative)");
    Ptr<cv::bioinspired::TransientAreasSegmentationModule> _self_ = *(self1);
    PyObject* pyobj_fs = NULL;
    String fs;

    const char* keywords[] = { "fs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:bioinspired_TransientAreasSegmentationModule.write", (char**)keywords, &pyobj_fs) &&
        pyopencv_to(pyobj_fs, fs, ArgInfo("fs", 0)) )
    {
        ERRWRAP2(_self_->write(fs));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (bioinspired_TransientAreasSegmentationModule)

static PyGetSetDef pyopencv_bioinspired_TransientAreasSegmentationModule_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_bioinspired_TransientAreasSegmentationModule_methods[] =
{
    {"clearAllBuffers", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_clearAllBuffers, 0), "clearAllBuffers() -> None\n.   @brief cleans all the buffers of the instance"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_create_static, METH_STATIC), "create(inputSize) -> retval\n.   @brief allocator\n.       @param inputSize : size of the images input to segment (output will be the same size)"},
    {"getSegmentationPicture", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_getSegmentationPicture, 0), "getSegmentationPicture([, transientAreas]) -> transientAreas\n.   @brief access function\n.       return the last segmentation result: a boolean picture which is resampled between 0 and 255 for a display purpose"},
    {"getSize", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_getSize, 0), "getSize() -> retval\n.   @brief return the sze of the manage input and output images"},
    {"printSetup", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_printSetup, 0), "printSetup() -> retval\n.   @brief parameters setup display method\n.       @return a string which contains formatted parameters information"},
    {"run", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_run, 0), "run(inputToSegment[, channelIndex]) -> None\n.   @brief main processing method, get result using methods getSegmentationPicture()\n.       @param inputToSegment : the image to process, it must match the instance buffer size !\n.       @param channelIndex : the channel to process in case of multichannel images"},
    {"setup", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_setup, 0), "setup([, segmentationParameterFile[, applyDefaultSetupOnFailure]]) -> None\n.   @brief try to open an XML segmentation parameters file to adjust current segmentation instance setup\n.   \n.       - if the xml file does not exist, then default setup is applied\n.       - warning, Exceptions are thrown if read XML file is not valid\n.       @param segmentationParameterFile : the parameters filename\n.       @param applyDefaultSetupOnFailure : set to true if an error must be thrown on error"},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_bioinspired_bioinspired_TransientAreasSegmentationModule_write, 0), "write(fs) -> None\n.   @brief write xml/yml formated parameters information\n.       @param fs : the filename of the xml file that will be open and writen with formatted parameters information"},

    {NULL,          NULL}
};

// Converter (bioinspired_TransientAreasSegmentationModule)

template<>
struct PyOpenCV_Converter< Ptr<cv::bioinspired::TransientAreasSegmentationModule> >
{
    static PyObject* from(const Ptr<cv::bioinspired::TransientAreasSegmentationModule>& r)
    {
        return pyopencv_bioinspired_TransientAreasSegmentationModule_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::bioinspired::TransientAreasSegmentationModule>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::bioinspired::TransientAreasSegmentationModule> * dst_;
        if (pyopencv_bioinspired_TransientAreasSegmentationModule_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::bioinspired::TransientAreasSegmentationModule> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// cuda_BufferPool (Generic)
//================================================================================

// GetSet (cuda_BufferPool)



// Methods (cuda_BufferPool)

static PyObject* pyopencv_cv_cuda_cuda_BufferPool_getAllocator(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::BufferPool> * self1 = 0;
    if (!pyopencv_cuda_BufferPool_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_BufferPool' or its derivative)");
    Ptr<cv::cuda::BufferPool> _self_ = *(self1);
    Ptr<GpuMat::Allocator> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAllocator());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_BufferPool_getBuffer(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::BufferPool> * self1 = 0;
    if (!pyopencv_cuda_BufferPool_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_BufferPool' or its derivative)");
    Ptr<cv::cuda::BufferPool> _self_ = *(self1);
    {
    int rows=0;
    int cols=0;
    int type=0;
    GpuMat retval;

    const char* keywords[] = { "rows", "cols", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iii:cuda_BufferPool.getBuffer", (char**)keywords, &rows, &cols, &type) )
    {
        ERRWRAP2(retval = _self_->getBuffer(rows, cols, type));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;
    int type=0;
    GpuMat retval;

    const char* keywords[] = { "size", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:cuda_BufferPool.getBuffer", (char**)keywords, &pyobj_size, &type) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) )
    {
        ERRWRAP2(retval = _self_->getBuffer(size, type));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (cuda_BufferPool)

static PyGetSetDef pyopencv_cuda_BufferPool_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_cuda_BufferPool_methods[] =
{
    {"getAllocator", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_BufferPool_getAllocator, 0), "getAllocator() -> retval\n."},
    {"getBuffer", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_BufferPool_getBuffer, 0), "getBuffer(rows, cols, type) -> retval\n.   \n\n\n\ngetBuffer(size, type) -> retval\n."},

    {NULL,          NULL}
};

// Converter (cuda_BufferPool)

template<>
struct PyOpenCV_Converter< Ptr<cv::cuda::BufferPool> >
{
    static PyObject* from(const Ptr<cv::cuda::BufferPool>& r)
    {
        return pyopencv_cuda_BufferPool_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::cuda::BufferPool>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::cuda::BufferPool> * dst_;
        if (pyopencv_cuda_BufferPool_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::cuda::BufferPool> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// cuda_DeviceInfo (Generic)
//================================================================================

// GetSet (cuda_DeviceInfo)



// Methods (cuda_DeviceInfo)

static int pyopencv_cv_cuda_cuda_DeviceInfo_DeviceInfo(pyopencv_cuda_DeviceInfo_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::cuda::DeviceInfo>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::DeviceInfo()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int device_id=0;

    const char* keywords[] = { "device_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:DeviceInfo", (char**)keywords, &device_id) )
    {
        new (&(self->v)) Ptr<cv::cuda::DeviceInfo>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::DeviceInfo(device_id)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_ECCEnabled(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->ECCEnabled());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_asyncEngineCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->asyncEngineCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_canMapHostMemory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->canMapHostMemory());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_clockRate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->clockRate());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_computeMode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    DeviceInfo::ComputeMode retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->computeMode());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_concurrentKernels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->concurrentKernels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_deviceID(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->deviceID());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_freeMemory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->freeMemory());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_integrated(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->integrated());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_isCompatible(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isCompatible());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_kernelExecTimeoutEnabled(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->kernelExecTimeoutEnabled());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_l2CacheSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->l2CacheSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_majorVersion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->majorVersion());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxGridSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxGridSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface1D(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxSurface1D());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface1DLayered(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxSurface1DLayered());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface2D(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxSurface2D());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface2DLayered(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxSurface2DLayered());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface3D(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxSurface3D());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxSurfaceCubemap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxSurfaceCubemap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxSurfaceCubemapLayered(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxSurfaceCubemapLayered());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture1D(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture1D());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture1DLayered(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture1DLayered());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture1DLinear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture1DLinear());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture1DMipmap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture1DMipmap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2D(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture2D());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2DGather(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture2DGather());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2DLayered(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture2DLayered());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2DLinear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture2DLinear());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2DMipmap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture2DMipmap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture3D(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTexture3D());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTextureCubemap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTextureCubemap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxTextureCubemapLayered(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec2i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxTextureCubemapLayered());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxThreadsDim(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    Vec3i retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxThreadsDim());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxThreadsPerBlock(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxThreadsPerBlock());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_maxThreadsPerMultiProcessor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxThreadsPerMultiProcessor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_memPitch(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->memPitch());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_memoryBusWidth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->memoryBusWidth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_memoryClockRate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->memoryClockRate());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_minorVersion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->minorVersion());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_multiProcessorCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->multiProcessorCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_pciBusID(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->pciBusID());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_pciDeviceID(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->pciDeviceID());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_pciDomainID(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->pciDomainID());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_queryMemory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t totalMemory=0;
    size_t freeMemory=0;

    const char* keywords[] = { "totalMemory", "freeMemory", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "II:cuda_DeviceInfo.queryMemory", (char**)keywords, &totalMemory, &freeMemory) )
    {
        ERRWRAP2(_self_->queryMemory(totalMemory, freeMemory));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_regsPerBlock(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->regsPerBlock());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_sharedMemPerBlock(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->sharedMemPerBlock());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_surfaceAlignment(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->surfaceAlignment());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_tccDriver(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->tccDriver());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_textureAlignment(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->textureAlignment());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_texturePitchAlignment(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->texturePitchAlignment());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_totalConstMem(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->totalConstMem());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_totalGlobalMem(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->totalGlobalMem());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_totalMemory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->totalMemory());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_unifiedAddressing(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->unifiedAddressing());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_DeviceInfo_warpSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::DeviceInfo> * self1 = 0;
    if (!pyopencv_cuda_DeviceInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_DeviceInfo' or its derivative)");
    Ptr<cv::cuda::DeviceInfo> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->warpSize());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (cuda_DeviceInfo)

static PyGetSetDef pyopencv_cuda_DeviceInfo_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_cuda_DeviceInfo_methods[] =
{
    {"ECCEnabled", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_ECCEnabled, 0), "ECCEnabled() -> retval\n."},
    {"asyncEngineCount", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_asyncEngineCount, 0), "asyncEngineCount() -> retval\n."},
    {"canMapHostMemory", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_canMapHostMemory, 0), "canMapHostMemory() -> retval\n."},
    {"clockRate", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_clockRate, 0), "clockRate() -> retval\n."},
    {"computeMode", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_computeMode, 0), "computeMode() -> retval\n."},
    {"concurrentKernels", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_concurrentKernels, 0), "concurrentKernels() -> retval\n."},
    {"deviceID", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_deviceID, 0), "deviceID() -> retval\n.   @brief Returns system index of the CUDA device starting with 0."},
    {"freeMemory", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_freeMemory, 0), "freeMemory() -> retval\n."},
    {"integrated", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_integrated, 0), "integrated() -> retval\n."},
    {"isCompatible", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_isCompatible, 0), "isCompatible() -> retval\n.   @brief Checks the CUDA module and device compatibility.\n.   \n.       This function returns true if the CUDA module can be run on the specified device. Otherwise, it\n.       returns false ."},
    {"kernelExecTimeoutEnabled", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_kernelExecTimeoutEnabled, 0), "kernelExecTimeoutEnabled() -> retval\n."},
    {"l2CacheSize", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_l2CacheSize, 0), "l2CacheSize() -> retval\n."},
    {"majorVersion", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_majorVersion, 0), "majorVersion() -> retval\n."},
    {"maxGridSize", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxGridSize, 0), "maxGridSize() -> retval\n."},
    {"maxSurface1D", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface1D, 0), "maxSurface1D() -> retval\n."},
    {"maxSurface1DLayered", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface1DLayered, 0), "maxSurface1DLayered() -> retval\n."},
    {"maxSurface2D", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface2D, 0), "maxSurface2D() -> retval\n."},
    {"maxSurface2DLayered", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface2DLayered, 0), "maxSurface2DLayered() -> retval\n."},
    {"maxSurface3D", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxSurface3D, 0), "maxSurface3D() -> retval\n."},
    {"maxSurfaceCubemap", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxSurfaceCubemap, 0), "maxSurfaceCubemap() -> retval\n."},
    {"maxSurfaceCubemapLayered", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxSurfaceCubemapLayered, 0), "maxSurfaceCubemapLayered() -> retval\n."},
    {"maxTexture1D", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture1D, 0), "maxTexture1D() -> retval\n."},
    {"maxTexture1DLayered", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture1DLayered, 0), "maxTexture1DLayered() -> retval\n."},
    {"maxTexture1DLinear", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture1DLinear, 0), "maxTexture1DLinear() -> retval\n."},
    {"maxTexture1DMipmap", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture1DMipmap, 0), "maxTexture1DMipmap() -> retval\n."},
    {"maxTexture2D", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2D, 0), "maxTexture2D() -> retval\n."},
    {"maxTexture2DGather", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2DGather, 0), "maxTexture2DGather() -> retval\n."},
    {"maxTexture2DLayered", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2DLayered, 0), "maxTexture2DLayered() -> retval\n."},
    {"maxTexture2DLinear", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2DLinear, 0), "maxTexture2DLinear() -> retval\n."},
    {"maxTexture2DMipmap", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture2DMipmap, 0), "maxTexture2DMipmap() -> retval\n."},
    {"maxTexture3D", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTexture3D, 0), "maxTexture3D() -> retval\n."},
    {"maxTextureCubemap", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTextureCubemap, 0), "maxTextureCubemap() -> retval\n."},
    {"maxTextureCubemapLayered", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxTextureCubemapLayered, 0), "maxTextureCubemapLayered() -> retval\n."},
    {"maxThreadsDim", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxThreadsDim, 0), "maxThreadsDim() -> retval\n."},
    {"maxThreadsPerBlock", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxThreadsPerBlock, 0), "maxThreadsPerBlock() -> retval\n."},
    {"maxThreadsPerMultiProcessor", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_maxThreadsPerMultiProcessor, 0), "maxThreadsPerMultiProcessor() -> retval\n."},
    {"memPitch", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_memPitch, 0), "memPitch() -> retval\n."},
    {"memoryBusWidth", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_memoryBusWidth, 0), "memoryBusWidth() -> retval\n."},
    {"memoryClockRate", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_memoryClockRate, 0), "memoryClockRate() -> retval\n."},
    {"minorVersion", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_minorVersion, 0), "minorVersion() -> retval\n."},
    {"multiProcessorCount", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_multiProcessorCount, 0), "multiProcessorCount() -> retval\n."},
    {"pciBusID", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_pciBusID, 0), "pciBusID() -> retval\n."},
    {"pciDeviceID", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_pciDeviceID, 0), "pciDeviceID() -> retval\n."},
    {"pciDomainID", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_pciDomainID, 0), "pciDomainID() -> retval\n."},
    {"queryMemory", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_queryMemory, 0), "queryMemory(totalMemory, freeMemory) -> None\n."},
    {"regsPerBlock", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_regsPerBlock, 0), "regsPerBlock() -> retval\n."},
    {"sharedMemPerBlock", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_sharedMemPerBlock, 0), "sharedMemPerBlock() -> retval\n."},
    {"surfaceAlignment", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_surfaceAlignment, 0), "surfaceAlignment() -> retval\n."},
    {"tccDriver", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_tccDriver, 0), "tccDriver() -> retval\n."},
    {"textureAlignment", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_textureAlignment, 0), "textureAlignment() -> retval\n."},
    {"texturePitchAlignment", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_texturePitchAlignment, 0), "texturePitchAlignment() -> retval\n."},
    {"totalConstMem", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_totalConstMem, 0), "totalConstMem() -> retval\n."},
    {"totalGlobalMem", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_totalGlobalMem, 0), "totalGlobalMem() -> retval\n."},
    {"totalMemory", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_totalMemory, 0), "totalMemory() -> retval\n."},
    {"unifiedAddressing", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_unifiedAddressing, 0), "unifiedAddressing() -> retval\n."},
    {"warpSize", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_DeviceInfo_warpSize, 0), "warpSize() -> retval\n."},

    {NULL,          NULL}
};

// Converter (cuda_DeviceInfo)

template<>
struct PyOpenCV_Converter< Ptr<cv::cuda::DeviceInfo> >
{
    static PyObject* from(const Ptr<cv::cuda::DeviceInfo>& r)
    {
        return pyopencv_cuda_DeviceInfo_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::cuda::DeviceInfo>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::cuda::DeviceInfo> * dst_;
        if (pyopencv_cuda_DeviceInfo_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::cuda::DeviceInfo> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// cuda_Event (Generic)
//================================================================================

// GetSet (cuda_Event)



// Methods (cuda_Event)

static int pyopencv_cv_cuda_cuda_Event_Event(pyopencv_cuda_Event_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    PyObject* pyobj_flags = NULL;
    Event_CreateFlags flags=Event::CreateFlags::DEFAULT;

    const char* keywords[] = { "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:Event", (char**)keywords, &pyobj_flags) &&
        pyopencv_to(pyobj_flags, flags, ArgInfo("flags", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::Event>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::Event(flags)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_cuda_cuda_Event_elapsedTime_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    PyObject* pyobj_start = NULL;
    Event start;
    PyObject* pyobj_end = NULL;
    Event end;
    float retval;

    const char* keywords[] = { "start", "end", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_Event.elapsedTime", (char**)keywords, &pyobj_start, &pyobj_end) &&
        pyopencv_to(pyobj_start, start, ArgInfo("start", 0)) &&
        pyopencv_to(pyobj_end, end, ArgInfo("end", 0)) )
    {
        ERRWRAP2(retval = cv::cuda::Event::elapsedTime(start, end));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_Event_queryIfComplete(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::Event> * self1 = 0;
    if (!pyopencv_cuda_Event_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_Event' or its derivative)");
    Ptr<cv::cuda::Event> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->queryIfComplete());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_Event_record(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::Event> * self1 = 0;
    if (!pyopencv_cuda_Event_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_Event' or its derivative)");
    Ptr<cv::cuda::Event> _self_ = *(self1);
    PyObject* pyobj_stream = NULL;
    Stream stream=Stream::Null();

    const char* keywords[] = { "stream", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:cuda_Event.record", (char**)keywords, &pyobj_stream) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->record(stream));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_Event_waitForCompletion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::Event> * self1 = 0;
    if (!pyopencv_cuda_Event_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_Event' or its derivative)");
    Ptr<cv::cuda::Event> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->waitForCompletion());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (cuda_Event)

static PyGetSetDef pyopencv_cuda_Event_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_cuda_Event_methods[] =
{
    {"elapsedTime", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_Event_elapsedTime_static, METH_STATIC), "elapsedTime(start, end) -> retval\n."},
    {"queryIfComplete", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_Event_queryIfComplete, 0), "queryIfComplete() -> retval\n."},
    {"record", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_Event_record, 0), "record([, stream]) -> None\n."},
    {"waitForCompletion", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_Event_waitForCompletion, 0), "waitForCompletion() -> None\n."},

    {NULL,          NULL}
};

// Converter (cuda_Event)

template<>
struct PyOpenCV_Converter< Ptr<cv::cuda::Event> >
{
    static PyObject* from(const Ptr<cv::cuda::Event>& r)
    {
        return pyopencv_cuda_Event_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::cuda::Event>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::cuda::Event> * dst_;
        if (pyopencv_cuda_Event_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::cuda::Event> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// cuda_GpuMat (Generic)
//================================================================================

// GetSet (cuda_GpuMat)


static PyObject* pyopencv_cuda_GpuMat_get_step(pyopencv_cuda_GpuMat_t* p, void *closure)
{
    return pyopencv_from(p->v->step);
}


// Methods (cuda_GpuMat)

static int pyopencv_cv_cuda_cuda_GpuMat_GpuMat(pyopencv_cuda_GpuMat_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    {
    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    const char* keywords[] = { "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:GpuMat", (char**)keywords, &pyobj_allocator) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(allocator)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    const char* keywords[] = { "rows", "cols", "type", "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iii|O:GpuMat", (char**)keywords, &rows, &cols, &type, &pyobj_allocator) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(rows, cols, type, allocator)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;
    int type=0;
    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    const char* keywords[] = { "size", "type", "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:GpuMat", (char**)keywords, &pyobj_size, &type, &pyobj_allocator) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(size, type, allocator)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    const char* keywords[] = { "rows", "cols", "type", "s", "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiO|O:GpuMat", (char**)keywords, &rows, &cols, &type, &pyobj_s, &pyobj_allocator) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(rows, cols, type, s, allocator)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;
    int type=0;
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    const char* keywords[] = { "size", "type", "s", "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO|O:GpuMat", (char**)keywords, &pyobj_size, &type, &pyobj_s, &pyobj_allocator) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(size, type, s, allocator)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_m = NULL;
    GpuMat m;

    const char* keywords[] = { "m", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:GpuMat", (char**)keywords, &pyobj_m) &&
        pyopencv_to(pyobj_m, m, ArgInfo("m", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(m)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_m = NULL;
    GpuMat m;
    PyObject* pyobj_rowRange = NULL;
    Range rowRange;
    PyObject* pyobj_colRange = NULL;
    Range colRange;

    const char* keywords[] = { "m", "rowRange", "colRange", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:GpuMat", (char**)keywords, &pyobj_m, &pyobj_rowRange, &pyobj_colRange) &&
        pyopencv_to(pyobj_m, m, ArgInfo("m", 0)) &&
        pyopencv_to(pyobj_rowRange, rowRange, ArgInfo("rowRange", 0)) &&
        pyopencv_to(pyobj_colRange, colRange, ArgInfo("colRange", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(m, rowRange, colRange)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_m = NULL;
    GpuMat m;
    PyObject* pyobj_roi = NULL;
    Rect roi;

    const char* keywords[] = { "m", "roi", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:GpuMat", (char**)keywords, &pyobj_m, &pyobj_roi) &&
        pyopencv_to(pyobj_m, m, ArgInfo("m", 0)) &&
        pyopencv_to(pyobj_roi, roi, ArgInfo("roi", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(m, roi)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    Mat arr;
    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    const char* keywords[] = { "arr", "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:GpuMat", (char**)keywords, &pyobj_arr, &pyobj_allocator) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(arr, allocator)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    cuda::GpuMat arr;
    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    const char* keywords[] = { "arr", "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:GpuMat", (char**)keywords, &pyobj_arr, &pyobj_allocator) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(arr, allocator)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    UMat arr;
    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator=GpuMat::defaultAllocator();

    const char* keywords[] = { "arr", "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:GpuMat", (char**)keywords, &pyobj_arr, &pyobj_allocator) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::GpuMat>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::GpuMat(arr, allocator)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_adjustROI(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int dtop=0;
    int dbottom=0;
    int dleft=0;
    int dright=0;
    GpuMat retval;

    const char* keywords[] = { "dtop", "dbottom", "dleft", "dright", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiii:cuda_GpuMat.adjustROI", (char**)keywords, &dtop, &dbottom, &dleft, &dright) )
    {
        ERRWRAP2(retval = _self_->adjustROI(dtop, dbottom, dleft, dright));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_assignTo(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    PyObject* pyobj_m = NULL;
    GpuMat m;
    int type=-1;

    const char* keywords[] = { "m", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:cuda_GpuMat.assignTo", (char**)keywords, &pyobj_m, &type) &&
        pyopencv_to(pyobj_m, m, ArgInfo("m", 0)) )
    {
        ERRWRAP2(_self_->assignTo(m, type));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_channels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->channels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_clone(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    GpuMat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->clone());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_col(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int x=0;
    GpuMat retval;

    const char* keywords[] = { "x", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:cuda_GpuMat.col", (char**)keywords, &x) )
    {
        ERRWRAP2(retval = _self_->col(x));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_colRange(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    {
    int startcol=0;
    int endcol=0;
    GpuMat retval;

    const char* keywords[] = { "startcol", "endcol", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_GpuMat.colRange", (char**)keywords, &startcol, &endcol) )
    {
        ERRWRAP2(retval = _self_->colRange(startcol, endcol));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_r = NULL;
    Range r;
    GpuMat retval;

    const char* keywords[] = { "r", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_GpuMat.colRange", (char**)keywords, &pyobj_r) &&
        pyopencv_to(pyobj_r, r, ArgInfo("r", 0)) )
    {
        ERRWRAP2(retval = _self_->colRange(r));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_convertTo(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    int rtype=0;

    const char* keywords[] = { "rtype", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    int rtype=0;

    const char* keywords[] = { "rtype", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    int rtype=0;

    const char* keywords[] = { "rtype", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    int rtype=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    int rtype=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    int rtype=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    int rtype=0;
    double alpha=0;
    double beta=0.0;

    const char* keywords[] = { "rtype", "alpha", "dst", "beta", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "id|Od:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &pyobj_dst, &beta) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    int rtype=0;
    double alpha=0;
    double beta=0.0;

    const char* keywords[] = { "rtype", "alpha", "dst", "beta", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "id|Od:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &pyobj_dst, &beta) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    int rtype=0;
    double alpha=0;
    double beta=0.0;

    const char* keywords[] = { "rtype", "alpha", "dst", "beta", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "id|Od:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &pyobj_dst, &beta) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    int rtype=0;
    double alpha=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "alpha", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "idO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    int rtype=0;
    double alpha=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "alpha", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "idO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    int rtype=0;
    double alpha=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "alpha", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "idO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    int rtype=0;
    double alpha=0;
    double beta=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "alpha", "beta", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iddO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &beta, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    int rtype=0;
    double alpha=0;
    double beta=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "alpha", "beta", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iddO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &beta, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    int rtype=0;
    double alpha=0;
    double beta=0;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "rtype", "alpha", "beta", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iddO|O:cuda_GpuMat.convertTo", (char**)keywords, &rtype, &alpha, &beta, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->convertTo(dst, rtype, alpha, beta, stream));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_copyTo(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->copyTo(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->copyTo(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->copyTo(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "mask", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_mask, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, mask));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    PyObject* pyobj_mask = NULL;
    cuda::GpuMat mask;

    const char* keywords[] = { "mask", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_mask, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, mask));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "mask", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_mask, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, mask));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "mask", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_mask, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, mask, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    PyObject* pyobj_mask = NULL;
    cuda::GpuMat mask;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "mask", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_mask, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, mask, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "mask", "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:cuda_GpuMat.copyTo", (char**)keywords, &pyobj_mask, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->copyTo(dst, mask, stream));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_create(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    {
    int rows=0;
    int cols=0;
    int type=0;

    const char* keywords[] = { "rows", "cols", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iii:cuda_GpuMat.create", (char**)keywords, &rows, &cols, &type) )
    {
        ERRWRAP2(_self_->create(rows, cols, type));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;
    int type=0;

    const char* keywords[] = { "size", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:cuda_GpuMat.create", (char**)keywords, &pyobj_size, &type) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) )
    {
        ERRWRAP2(_self_->create(size, type));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_defaultAllocator_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    GpuMat::Allocator* retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::cuda::GpuMat::defaultAllocator());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_depth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->depth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_download(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:cuda_GpuMat.download", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->download(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:cuda_GpuMat.download", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->download(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:cuda_GpuMat.download", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->download(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.download", (char**)keywords, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->download(dst, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    cuda::GpuMat dst;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.download", (char**)keywords, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->download(dst, stream));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "stream", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:cuda_GpuMat.download", (char**)keywords, &pyobj_stream, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->download(dst, stream));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_elemSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->elemSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_elemSize1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->elemSize1());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_isContinuous(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isContinuous());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_locateROI(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    PyObject* pyobj_wholeSize = NULL;
    Size wholeSize;
    PyObject* pyobj_ofs = NULL;
    Point ofs;

    const char* keywords[] = { "wholeSize", "ofs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_GpuMat.locateROI", (char**)keywords, &pyobj_wholeSize, &pyobj_ofs) &&
        pyopencv_to(pyobj_wholeSize, wholeSize, ArgInfo("wholeSize", 0)) &&
        pyopencv_to(pyobj_ofs, ofs, ArgInfo("ofs", 0)) )
    {
        ERRWRAP2(_self_->locateROI(wholeSize, ofs));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_reshape(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int cn=0;
    int rows=0;
    GpuMat retval;

    const char* keywords[] = { "cn", "rows", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|i:cuda_GpuMat.reshape", (char**)keywords, &cn, &rows) )
    {
        ERRWRAP2(retval = _self_->reshape(cn, rows));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_row(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int y=0;
    GpuMat retval;

    const char* keywords[] = { "y", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:cuda_GpuMat.row", (char**)keywords, &y) )
    {
        ERRWRAP2(retval = _self_->row(y));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_rowRange(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    {
    int startrow=0;
    int endrow=0;
    GpuMat retval;

    const char* keywords[] = { "startrow", "endrow", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_GpuMat.rowRange", (char**)keywords, &startrow, &endrow) )
    {
        ERRWRAP2(retval = _self_->rowRange(startrow, endrow));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_r = NULL;
    Range r;
    GpuMat retval;

    const char* keywords[] = { "r", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_GpuMat.rowRange", (char**)keywords, &pyobj_r) &&
        pyopencv_to(pyobj_r, r, ArgInfo("r", 0)) )
    {
        ERRWRAP2(retval = _self_->rowRange(r));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_setDefaultAllocator_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    PyObject* pyobj_allocator = NULL;
    GpuMat_Allocator* allocator;

    const char* keywords[] = { "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_GpuMat.setDefaultAllocator", (char**)keywords, &pyobj_allocator) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        ERRWRAP2(cv::cuda::GpuMat::setDefaultAllocator(allocator));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_setTo(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    {
    PyObject* pyobj_s = NULL;
    Scalar s;
    GpuMat retval;

    const char* keywords[] = { "s", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_GpuMat.setTo", (char**)keywords, &pyobj_s) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) )
    {
        ERRWRAP2(retval = _self_->setTo(s));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_stream = NULL;
    Stream stream;
    GpuMat retval;

    const char* keywords[] = { "s", "stream", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_GpuMat.setTo", (char**)keywords, &pyobj_s, &pyobj_stream) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(retval = _self_->setTo(s, stream));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    GpuMat retval;

    const char* keywords[] = { "s", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_GpuMat.setTo", (char**)keywords, &pyobj_s, &pyobj_mask) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->setTo(s, mask));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_mask = NULL;
    cuda::GpuMat mask;
    GpuMat retval;

    const char* keywords[] = { "s", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_GpuMat.setTo", (char**)keywords, &pyobj_s, &pyobj_mask) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->setTo(s, mask));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    GpuMat retval;

    const char* keywords[] = { "s", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_GpuMat.setTo", (char**)keywords, &pyobj_s, &pyobj_mask) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->setTo(s, mask));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_stream = NULL;
    Stream stream;
    GpuMat retval;

    const char* keywords[] = { "s", "mask", "stream", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:cuda_GpuMat.setTo", (char**)keywords, &pyobj_s, &pyobj_mask, &pyobj_stream) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(retval = _self_->setTo(s, mask, stream));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_mask = NULL;
    cuda::GpuMat mask;
    PyObject* pyobj_stream = NULL;
    Stream stream;
    GpuMat retval;

    const char* keywords[] = { "s", "mask", "stream", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:cuda_GpuMat.setTo", (char**)keywords, &pyobj_s, &pyobj_mask, &pyobj_stream) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(retval = _self_->setTo(s, mask, stream));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_s = NULL;
    Scalar s;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    PyObject* pyobj_stream = NULL;
    Stream stream;
    GpuMat retval;

    const char* keywords[] = { "s", "mask", "stream", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:cuda_GpuMat.setTo", (char**)keywords, &pyobj_s, &pyobj_mask, &pyobj_stream) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(retval = _self_->setTo(s, mask, stream));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_size(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->size());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_step1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->step1());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_swap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    PyObject* pyobj_mat = NULL;
    GpuMat mat;

    const char* keywords[] = { "mat", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_GpuMat.swap", (char**)keywords, &pyobj_mat) &&
        pyopencv_to(pyobj_mat, mat, ArgInfo("mat", 0)) )
    {
        ERRWRAP2(_self_->swap(mat));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_type(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->type());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_updateContinuityFlag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->updateContinuityFlag());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_GpuMat_upload(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::GpuMat> * self1 = 0;
    if (!pyopencv_cuda_GpuMat_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_GpuMat' or its derivative)");
    Ptr<cv::cuda::GpuMat> _self_ = *(self1);
    {
    PyObject* pyobj_arr = NULL;
    Mat arr;

    const char* keywords[] = { "arr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_GpuMat.upload", (char**)keywords, &pyobj_arr) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) )
    {
        ERRWRAP2(_self_->upload(arr));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    cuda::GpuMat arr;

    const char* keywords[] = { "arr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_GpuMat.upload", (char**)keywords, &pyobj_arr) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) )
    {
        ERRWRAP2(_self_->upload(arr));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    UMat arr;

    const char* keywords[] = { "arr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_GpuMat.upload", (char**)keywords, &pyobj_arr) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) )
    {
        ERRWRAP2(_self_->upload(arr));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    Mat arr;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "arr", "stream", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_GpuMat.upload", (char**)keywords, &pyobj_arr, &pyobj_stream) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->upload(arr, stream));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    cuda::GpuMat arr;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "arr", "stream", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_GpuMat.upload", (char**)keywords, &pyobj_arr, &pyobj_stream) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->upload(arr, stream));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    UMat arr;
    PyObject* pyobj_stream = NULL;
    Stream stream;

    const char* keywords[] = { "arr", "stream", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:cuda_GpuMat.upload", (char**)keywords, &pyobj_arr, &pyobj_stream) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_stream, stream, ArgInfo("stream", 0)) )
    {
        ERRWRAP2(_self_->upload(arr, stream));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (cuda_GpuMat)

static PyGetSetDef pyopencv_cuda_GpuMat_getseters[] =
{
    {(char*)"step", (getter)pyopencv_cuda_GpuMat_get_step, NULL, (char*)"step", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_cuda_GpuMat_methods[] =
{
    {"adjustROI", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_adjustROI, 0), "adjustROI(dtop, dbottom, dleft, dright) -> retval\n."},
    {"assignTo", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_assignTo, 0), "assignTo(m[, type]) -> None\n."},
    {"channels", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_channels, 0), "channels() -> retval\n."},
    {"clone", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_clone, 0), "clone() -> retval\n."},
    {"col", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_col, 0), "col(x) -> retval\n."},
    {"colRange", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_colRange, 0), "colRange(startcol, endcol) -> retval\n.   \n\n\n\ncolRange(r) -> retval\n."},
    {"convertTo", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_convertTo, 0), "convertTo(rtype[, dst]) -> dst\n.   \n\n\n\nconvertTo(rtype, stream[, dst]) -> dst\n.   \n\n\n\nconvertTo(rtype, alpha[, dst[, beta]]) -> dst\n.   \n\n\n\nconvertTo(rtype, alpha, stream[, dst]) -> dst\n.   \n\n\n\nconvertTo(rtype, alpha, beta, stream[, dst]) -> dst\n."},
    {"copyTo", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_copyTo, 0), "copyTo([, dst]) -> dst\n.   \n\n\n\ncopyTo(stream[, dst]) -> dst\n.   \n\n\n\ncopyTo(mask[, dst]) -> dst\n.   \n\n\n\ncopyTo(mask, stream[, dst]) -> dst\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_create, 0), "create(rows, cols, type) -> None\n.   \n\n\n\ncreate(size, type) -> None\n."},
    {"defaultAllocator", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_defaultAllocator_static, METH_STATIC), "defaultAllocator() -> retval\n."},
    {"depth", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_depth, 0), "depth() -> retval\n."},
    {"download", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_download, 0), "download([, dst]) -> dst\n.   @brief Performs data download from GpuMat (Blocking call)\n.   \n.       This function copies data from device memory to host memory. As being a blocking call, it is\n.       guaranteed that the copy operation is finished when this function returns.\n\n\n\ndownload(stream[, dst]) -> dst\n.   @brief Performs data download from GpuMat (Non-Blocking call)\n.   \n.       This function copies data from device memory to host memory. As being a non-blocking call, this\n.       function may return even if the copy operation is not finished.\n.   \n.       The copy operation may be overlapped with operations in other non-default streams if \\p stream is\n.       not the default stream and \\p dst is HostMem allocated with HostMem::PAGE_LOCKED option."},
    {"elemSize", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_elemSize, 0), "elemSize() -> retval\n."},
    {"elemSize1", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_elemSize1, 0), "elemSize1() -> retval\n."},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_empty, 0), "empty() -> retval\n."},
    {"isContinuous", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_isContinuous, 0), "isContinuous() -> retval\n."},
    {"locateROI", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_locateROI, 0), "locateROI(wholeSize, ofs) -> None\n."},
    {"reshape", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_reshape, 0), "reshape(cn[, rows]) -> retval\n."},
    {"row", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_row, 0), "row(y) -> retval\n."},
    {"rowRange", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_rowRange, 0), "rowRange(startrow, endrow) -> retval\n.   \n\n\n\nrowRange(r) -> retval\n."},
    {"setDefaultAllocator", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_setDefaultAllocator_static, METH_STATIC), "setDefaultAllocator(allocator) -> None\n."},
    {"setTo", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_setTo, 0), "setTo(s) -> retval\n.   \n\n\n\nsetTo(s, stream) -> retval\n.   \n\n\n\nsetTo(s, mask) -> retval\n.   \n\n\n\nsetTo(s, mask, stream) -> retval\n."},
    {"size", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_size, 0), "size() -> retval\n."},
    {"step1", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_step1, 0), "step1() -> retval\n."},
    {"swap", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_swap, 0), "swap(mat) -> None\n."},
    {"type", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_type, 0), "type() -> retval\n."},
    {"updateContinuityFlag", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_updateContinuityFlag, 0), "updateContinuityFlag() -> None\n."},
    {"upload", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_GpuMat_upload, 0), "upload(arr) -> None\n.   @brief Performs data upload to GpuMat (Blocking call)\n.   \n.       This function copies data from host memory to device memory. As being a blocking call, it is\n.       guaranteed that the copy operation is finished when this function returns.\n\n\n\nupload(arr, stream) -> None\n.   @brief Performs data upload to GpuMat (Non-Blocking call)\n.   \n.       This function copies data from host memory to device memory. As being a non-blocking call, this\n.       function may return even if the copy operation is not finished.\n.   \n.       The copy operation may be overlapped with operations in other non-default streams if \\p stream is\n.       not the default stream and \\p dst is HostMem allocated with HostMem::PAGE_LOCKED option."},

    {NULL,          NULL}
};

// Converter (cuda_GpuMat)

template<>
struct PyOpenCV_Converter< Ptr<cv::cuda::GpuMat> >
{
    static PyObject* from(const Ptr<cv::cuda::GpuMat>& r)
    {
        return pyopencv_cuda_GpuMat_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::cuda::GpuMat>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::cuda::GpuMat> * dst_;
        if (pyopencv_cuda_GpuMat_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::cuda::GpuMat> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// cuda_GpuMat_Allocator (Generic)
//================================================================================

// GetSet (cuda_GpuMat_Allocator)



// Methods (cuda_GpuMat_Allocator)



// Tables (cuda_GpuMat_Allocator)

static PyGetSetDef pyopencv_cuda_GpuMat_Allocator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_cuda_GpuMat_Allocator_methods[] =
{

    {NULL,          NULL}
};

// Converter (cuda_GpuMat_Allocator)

template<>
struct PyOpenCV_Converter< Ptr<cv::cuda::GpuMat::Allocator> >
{
    static PyObject* from(const Ptr<cv::cuda::GpuMat::Allocator>& r)
    {
        return pyopencv_cuda_GpuMat_Allocator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::cuda::GpuMat::Allocator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::cuda::GpuMat::Allocator> * dst_;
        if (pyopencv_cuda_GpuMat_Allocator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::cuda::GpuMat::Allocator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// cuda_HostMem (Generic)
//================================================================================

// GetSet (cuda_HostMem)


static PyObject* pyopencv_cuda_HostMem_get_step(pyopencv_cuda_HostMem_t* p, void *closure)
{
    return pyopencv_from(p->v->step);
}


// Methods (cuda_HostMem)

static int pyopencv_cv_cuda_cuda_HostMem_HostMem(pyopencv_cuda_HostMem_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    {
    PyObject* pyobj_alloc_type = NULL;
    HostMem_AllocType alloc_type=HostMem::AllocType::PAGE_LOCKED;

    const char* keywords[] = { "alloc_type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:HostMem", (char**)keywords, &pyobj_alloc_type) &&
        pyopencv_to(pyobj_alloc_type, alloc_type, ArgInfo("alloc_type", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::HostMem(alloc_type)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_alloc_type = NULL;
    HostMem_AllocType alloc_type=HostMem::AllocType::PAGE_LOCKED;

    const char* keywords[] = { "rows", "cols", "type", "alloc_type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iii|O:HostMem", (char**)keywords, &rows, &cols, &type, &pyobj_alloc_type) &&
        pyopencv_to(pyobj_alloc_type, alloc_type, ArgInfo("alloc_type", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::HostMem(rows, cols, type, alloc_type)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;
    int type=0;
    PyObject* pyobj_alloc_type = NULL;
    HostMem_AllocType alloc_type=HostMem::AllocType::PAGE_LOCKED;

    const char* keywords[] = { "size", "type", "alloc_type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:HostMem", (char**)keywords, &pyobj_size, &type, &pyobj_alloc_type) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) &&
        pyopencv_to(pyobj_alloc_type, alloc_type, ArgInfo("alloc_type", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::HostMem(size, type, alloc_type)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    Mat arr;
    PyObject* pyobj_alloc_type = NULL;
    HostMem_AllocType alloc_type=HostMem::AllocType::PAGE_LOCKED;

    const char* keywords[] = { "arr", "alloc_type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:HostMem", (char**)keywords, &pyobj_arr, &pyobj_alloc_type) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_alloc_type, alloc_type, ArgInfo("alloc_type", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::HostMem(arr, alloc_type)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    cuda::GpuMat arr;
    PyObject* pyobj_alloc_type = NULL;
    HostMem_AllocType alloc_type=HostMem::AllocType::PAGE_LOCKED;

    const char* keywords[] = { "arr", "alloc_type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:HostMem", (char**)keywords, &pyobj_arr, &pyobj_alloc_type) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_alloc_type, alloc_type, ArgInfo("alloc_type", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::HostMem(arr, alloc_type)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arr = NULL;
    UMat arr;
    PyObject* pyobj_alloc_type = NULL;
    HostMem_AllocType alloc_type=HostMem::AllocType::PAGE_LOCKED;

    const char* keywords[] = { "arr", "alloc_type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:HostMem", (char**)keywords, &pyobj_arr, &pyobj_alloc_type) &&
        pyopencv_to(pyobj_arr, arr, ArgInfo("arr", 0)) &&
        pyopencv_to(pyobj_alloc_type, alloc_type, ArgInfo("alloc_type", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::HostMem>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::HostMem(arr, alloc_type)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_channels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->channels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_clone(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    HostMem retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->clone());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_create(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int rows=0;
    int cols=0;
    int type=0;

    const char* keywords[] = { "rows", "cols", "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iii:cuda_HostMem.create", (char**)keywords, &rows, &cols, &type) )
    {
        ERRWRAP2(_self_->create(rows, cols, type));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_createMatHeader(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->createMatHeader());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_depth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->depth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_elemSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->elemSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_elemSize1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->elemSize1());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_isContinuous(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isContinuous());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_reshape(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int cn=0;
    int rows=0;
    HostMem retval;

    const char* keywords[] = { "cn", "rows", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|i:cuda_HostMem.reshape", (char**)keywords, &cn, &rows) )
    {
        ERRWRAP2(retval = _self_->reshape(cn, rows));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_size(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->size());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_step1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->step1());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_swap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    PyObject* pyobj_b = NULL;
    HostMem b;

    const char* keywords[] = { "b", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_HostMem.swap", (char**)keywords, &pyobj_b) &&
        pyopencv_to(pyobj_b, b, ArgInfo("b", 0)) )
    {
        ERRWRAP2(_self_->swap(b));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_HostMem_type(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::HostMem> * self1 = 0;
    if (!pyopencv_cuda_HostMem_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_HostMem' or its derivative)");
    Ptr<cv::cuda::HostMem> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->type());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (cuda_HostMem)

static PyGetSetDef pyopencv_cuda_HostMem_getseters[] =
{
    {(char*)"step", (getter)pyopencv_cuda_HostMem_get_step, NULL, (char*)"step", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_cuda_HostMem_methods[] =
{
    {"channels", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_channels, 0), "channels() -> retval\n."},
    {"clone", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_clone, 0), "clone() -> retval\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_create, 0), "create(rows, cols, type) -> None\n."},
    {"createMatHeader", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_createMatHeader, 0), "createMatHeader() -> retval\n."},
    {"depth", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_depth, 0), "depth() -> retval\n."},
    {"elemSize", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_elemSize, 0), "elemSize() -> retval\n."},
    {"elemSize1", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_elemSize1, 0), "elemSize1() -> retval\n."},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_empty, 0), "empty() -> retval\n."},
    {"isContinuous", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_isContinuous, 0), "isContinuous() -> retval\n.   @brief Maps CPU memory to GPU address space and creates the cuda::GpuMat header without reference counting\n.       for it.\n.   \n.       This can be done only if memory was allocated with the SHARED flag and if it is supported by the\n.       hardware. Laptops often share video and CPU memory, so address spaces can be mapped, which\n.       eliminates an extra copy."},
    {"reshape", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_reshape, 0), "reshape(cn[, rows]) -> retval\n."},
    {"size", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_size, 0), "size() -> retval\n."},
    {"step1", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_step1, 0), "step1() -> retval\n."},
    {"swap", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_swap, 0), "swap(b) -> None\n."},
    {"type", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_HostMem_type, 0), "type() -> retval\n."},

    {NULL,          NULL}
};

// Converter (cuda_HostMem)

template<>
struct PyOpenCV_Converter< Ptr<cv::cuda::HostMem> >
{
    static PyObject* from(const Ptr<cv::cuda::HostMem>& r)
    {
        return pyopencv_cuda_HostMem_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::cuda::HostMem>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::cuda::HostMem> * dst_;
        if (pyopencv_cuda_HostMem_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::cuda::HostMem> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// cuda_Stream (Generic)
//================================================================================

// GetSet (cuda_Stream)



// Methods (cuda_Stream)

static int pyopencv_cv_cuda_cuda_Stream_Stream(pyopencv_cuda_Stream_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::cuda::Stream>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::Stream()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_allocator = NULL;
    Ptr<GpuMat::Allocator> allocator;

    const char* keywords[] = { "allocator", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:Stream", (char**)keywords, &pyobj_allocator) &&
        pyopencv_to(pyobj_allocator, allocator, ArgInfo("allocator", 0)) )
    {
        new (&(self->v)) Ptr<cv::cuda::Stream>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::cuda::Stream(allocator)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_cuda_cuda_Stream_Null_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    Stream retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::cuda::Stream::Null());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_Stream_queryIfComplete(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::Stream> * self1 = 0;
    if (!pyopencv_cuda_Stream_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_Stream' or its derivative)");
    Ptr<cv::cuda::Stream> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->queryIfComplete());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_Stream_waitEvent(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::Stream> * self1 = 0;
    if (!pyopencv_cuda_Stream_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_Stream' or its derivative)");
    Ptr<cv::cuda::Stream> _self_ = *(self1);
    PyObject* pyobj_event = NULL;
    Event event;

    const char* keywords[] = { "event", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:cuda_Stream.waitEvent", (char**)keywords, &pyobj_event) &&
        pyopencv_to(pyobj_event, event, ArgInfo("event", 0)) )
    {
        ERRWRAP2(_self_->waitEvent(event));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_Stream_waitForCompletion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;


    Ptr<cv::cuda::Stream> * self1 = 0;
    if (!pyopencv_cuda_Stream_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'cuda_Stream' or its derivative)");
    Ptr<cv::cuda::Stream> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->waitForCompletion());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (cuda_Stream)

static PyGetSetDef pyopencv_cuda_Stream_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_cuda_Stream_methods[] =
{
    {"Null", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_Stream_Null_static, METH_STATIC), "Null() -> retval\n.   @brief Adds a callback to be called on the host after all currently enqueued items in the stream have\n.       completed.\n.   \n.       @note Callbacks must not make any CUDA API calls. Callbacks must not perform any synchronization\n.       that may depend on outstanding device work or other callbacks that are not mandated to run earlier.\n.       Callbacks without a mandated order (in independent streams) execute in undefined order and may be\n.       serialized."},
    {"queryIfComplete", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_Stream_queryIfComplete, 0), "queryIfComplete() -> retval\n.   @brief Returns true if the current stream queue is finished. Otherwise, it returns false."},
    {"waitEvent", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_Stream_waitEvent, 0), "waitEvent(event) -> None\n.   @brief Makes a compute stream wait on an event."},
    {"waitForCompletion", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_Stream_waitForCompletion, 0), "waitForCompletion() -> None\n.   @brief Blocks the current CPU thread until all operations in the stream are complete."},

    {NULL,          NULL}
};

// Converter (cuda_Stream)

template<>
struct PyOpenCV_Converter< Ptr<cv::cuda::Stream> >
{
    static PyObject* from(const Ptr<cv::cuda::Stream>& r)
    {
        return pyopencv_cuda_Stream_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::cuda::Stream>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::cuda::Stream> * dst_;
        if (pyopencv_cuda_Stream_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::cuda::Stream> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// cuda_TargetArchs (Generic)
//================================================================================

// GetSet (cuda_TargetArchs)



// Methods (cuda_TargetArchs)

static PyObject* pyopencv_cv_cuda_cuda_TargetArchs_has_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    int major=0;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_TargetArchs.has", (char**)keywords, &major, &minor) )
    {
        ERRWRAP2(retval = cv::cuda::TargetArchs::has(major, minor));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_TargetArchs_hasBin_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    int major=0;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_TargetArchs.hasBin", (char**)keywords, &major, &minor) )
    {
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasBin(major, minor));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_TargetArchs_hasEqualOrGreater_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    int major=0;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_TargetArchs.hasEqualOrGreater", (char**)keywords, &major, &minor) )
    {
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreater(major, minor));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_TargetArchs_hasEqualOrGreaterBin_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    int major=0;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_TargetArchs.hasEqualOrGreaterBin", (char**)keywords, &major, &minor) )
    {
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreaterBin(major, minor));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_TargetArchs_hasEqualOrGreaterPtx_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    int major=0;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_TargetArchs.hasEqualOrGreaterPtx", (char**)keywords, &major, &minor) )
    {
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreaterPtx(major, minor));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_TargetArchs_hasEqualOrLessPtx_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    int major=0;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_TargetArchs.hasEqualOrLessPtx", (char**)keywords, &major, &minor) )
    {
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrLessPtx(major, minor));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_cuda_cuda_TargetArchs_hasPtx_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::cuda;

    int major=0;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:cuda_TargetArchs.hasPtx", (char**)keywords, &major, &minor) )
    {
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasPtx(major, minor));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (cuda_TargetArchs)

static PyGetSetDef pyopencv_cuda_TargetArchs_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_cuda_TargetArchs_methods[] =
{
    {"has", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_TargetArchs_has_static, METH_STATIC), "has(major, minor) -> retval\n.   @brief There is a set of methods to check whether the module contains intermediate (PTX) or binary CUDA\n.       code for the given architecture(s):\n.   \n.       @param major Major compute capability version.\n.       @param minor Minor compute capability version."},
    {"hasBin", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_TargetArchs_hasBin_static, METH_STATIC), "hasBin(major, minor) -> retval\n."},
    {"hasEqualOrGreater", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_TargetArchs_hasEqualOrGreater_static, METH_STATIC), "hasEqualOrGreater(major, minor) -> retval\n."},
    {"hasEqualOrGreaterBin", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_TargetArchs_hasEqualOrGreaterBin_static, METH_STATIC), "hasEqualOrGreaterBin(major, minor) -> retval\n."},
    {"hasEqualOrGreaterPtx", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_TargetArchs_hasEqualOrGreaterPtx_static, METH_STATIC), "hasEqualOrGreaterPtx(major, minor) -> retval\n."},
    {"hasEqualOrLessPtx", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_TargetArchs_hasEqualOrLessPtx_static, METH_STATIC), "hasEqualOrLessPtx(major, minor) -> retval\n."},
    {"hasPtx", CV_PY_FN_WITH_KW_(pyopencv_cv_cuda_cuda_TargetArchs_hasPtx_static, METH_STATIC), "hasPtx(major, minor) -> retval\n."},

    {NULL,          NULL}
};

// Converter (cuda_TargetArchs)

template<>
struct PyOpenCV_Converter< Ptr<cv::cuda::TargetArchs> >
{
    static PyObject* from(const Ptr<cv::cuda::TargetArchs>& r)
    {
        return pyopencv_cuda_TargetArchs_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::cuda::TargetArchs>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::cuda::TargetArchs> * dst_;
        if (pyopencv_cuda_TargetArchs_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::cuda::TargetArchs> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_AffineBasedEstimator (Generic)
//================================================================================

// GetSet (detail_AffineBasedEstimator)



// Methods (detail_AffineBasedEstimator)

static int pyopencv_cv_detail_detail_AffineBasedEstimator_AffineBasedEstimator(pyopencv_detail_AffineBasedEstimator_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::detail::AffineBasedEstimator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::AffineBasedEstimator()));
        return 0;
    }

    return -1;
}



// Tables (detail_AffineBasedEstimator)

static PyGetSetDef pyopencv_detail_AffineBasedEstimator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_AffineBasedEstimator_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_AffineBasedEstimator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::AffineBasedEstimator> >
{
    static PyObject* from(const Ptr<cv::detail::AffineBasedEstimator>& r)
    {
        return pyopencv_detail_AffineBasedEstimator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::AffineBasedEstimator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::AffineBasedEstimator> * dst_;
        if (pyopencv_detail_AffineBasedEstimator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::AffineBasedEstimator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_AffineBestOf2NearestMatcher (Generic)
//================================================================================

// GetSet (detail_AffineBestOf2NearestMatcher)



// Methods (detail_AffineBestOf2NearestMatcher)

static int pyopencv_cv_detail_detail_AffineBestOf2NearestMatcher_AffineBestOf2NearestMatcher(pyopencv_detail_AffineBestOf2NearestMatcher_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    bool full_affine=false;
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;

    const char* keywords[] = { "full_affine", "try_use_gpu", "match_conf", "num_matches_thresh1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|bbfi:AffineBestOf2NearestMatcher", (char**)keywords, &full_affine, &try_use_gpu, &match_conf, &num_matches_thresh1) )
    {
        new (&(self->v)) Ptr<cv::detail::AffineBestOf2NearestMatcher>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::AffineBestOf2NearestMatcher(full_affine, try_use_gpu, match_conf, num_matches_thresh1)));
        return 0;
    }

    return -1;
}



// Tables (detail_AffineBestOf2NearestMatcher)

static PyGetSetDef pyopencv_detail_AffineBestOf2NearestMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_AffineBestOf2NearestMatcher_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_AffineBestOf2NearestMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::AffineBestOf2NearestMatcher> >
{
    static PyObject* from(const Ptr<cv::detail::AffineBestOf2NearestMatcher>& r)
    {
        return pyopencv_detail_AffineBestOf2NearestMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::AffineBestOf2NearestMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::AffineBestOf2NearestMatcher> * dst_;
        if (pyopencv_detail_AffineBestOf2NearestMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::AffineBestOf2NearestMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BestOf2NearestMatcher (Generic)
//================================================================================

// GetSet (detail_BestOf2NearestMatcher)



// Methods (detail_BestOf2NearestMatcher)

static int pyopencv_cv_detail_detail_BestOf2NearestMatcher_BestOf2NearestMatcher(pyopencv_detail_BestOf2NearestMatcher_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;

    const char* keywords[] = { "try_use_gpu", "match_conf", "num_matches_thresh1", "num_matches_thresh2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|bfii:BestOf2NearestMatcher", (char**)keywords, &try_use_gpu, &match_conf, &num_matches_thresh1, &num_matches_thresh2) )
    {
        new (&(self->v)) Ptr<cv::detail::BestOf2NearestMatcher>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BestOf2NearestMatcher(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_detail_detail_BestOf2NearestMatcher_collectGarbage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BestOf2NearestMatcher> * self1 = 0;
    if (!pyopencv_detail_BestOf2NearestMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BestOf2NearestMatcher' or its derivative)");
    Ptr<cv::detail::BestOf2NearestMatcher> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->collectGarbage());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BestOf2NearestMatcher_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;
    Ptr<BestOf2NearestMatcher> retval;

    const char* keywords[] = { "try_use_gpu", "match_conf", "num_matches_thresh1", "num_matches_thresh2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|bfii:detail_BestOf2NearestMatcher.create", (char**)keywords, &try_use_gpu, &match_conf, &num_matches_thresh1, &num_matches_thresh2) )
    {
        ERRWRAP2(retval = cv::detail::BestOf2NearestMatcher::create(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (detail_BestOf2NearestMatcher)

static PyGetSetDef pyopencv_detail_BestOf2NearestMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BestOf2NearestMatcher_methods[] =
{
    {"collectGarbage", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BestOf2NearestMatcher_collectGarbage, 0), "collectGarbage() -> None\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BestOf2NearestMatcher_create_static, METH_STATIC), "create([, try_use_gpu[, match_conf[, num_matches_thresh1[, num_matches_thresh2]]]]) -> retval\n."},

    {NULL,          NULL}
};

// Converter (detail_BestOf2NearestMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BestOf2NearestMatcher> >
{
    static PyObject* from(const Ptr<cv::detail::BestOf2NearestMatcher>& r)
    {
        return pyopencv_detail_BestOf2NearestMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BestOf2NearestMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BestOf2NearestMatcher> * dst_;
        if (pyopencv_detail_BestOf2NearestMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BestOf2NearestMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BestOf2NearestRangeMatcher (Generic)
//================================================================================

// GetSet (detail_BestOf2NearestRangeMatcher)



// Methods (detail_BestOf2NearestRangeMatcher)

static int pyopencv_cv_detail_detail_BestOf2NearestRangeMatcher_BestOf2NearestRangeMatcher(pyopencv_detail_BestOf2NearestRangeMatcher_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    int range_width=5;
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;

    const char* keywords[] = { "range_width", "try_use_gpu", "match_conf", "num_matches_thresh1", "num_matches_thresh2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ibfii:BestOf2NearestRangeMatcher", (char**)keywords, &range_width, &try_use_gpu, &match_conf, &num_matches_thresh1, &num_matches_thresh2) )
    {
        new (&(self->v)) Ptr<cv::detail::BestOf2NearestRangeMatcher>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BestOf2NearestRangeMatcher(range_width, try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2)));
        return 0;
    }

    return -1;
}



// Tables (detail_BestOf2NearestRangeMatcher)

static PyGetSetDef pyopencv_detail_BestOf2NearestRangeMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BestOf2NearestRangeMatcher_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_BestOf2NearestRangeMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BestOf2NearestRangeMatcher> >
{
    static PyObject* from(const Ptr<cv::detail::BestOf2NearestRangeMatcher>& r)
    {
        return pyopencv_detail_BestOf2NearestRangeMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BestOf2NearestRangeMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BestOf2NearestRangeMatcher> * dst_;
        if (pyopencv_detail_BestOf2NearestRangeMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BestOf2NearestRangeMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_Blender (Generic)
//================================================================================

// GetSet (detail_Blender)



// Methods (detail_Blender)

static PyObject* pyopencv_cv_detail_detail_Blender_blend(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::Blender> * self1 = 0;
    if (!pyopencv_detail_Blender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_Blender' or its derivative)");
    Ptr<cv::detail::Blender> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_dst_mask = NULL;
    Mat dst_mask;

    const char* keywords[] = { "dst", "dst_mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_Blender.blend", (char**)keywords, &pyobj_dst, &pyobj_dst_mask) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_dst_mask, dst_mask, ArgInfo("dst_mask", 1)) )
    {
        ERRWRAP2(_self_->blend(dst, dst_mask));
        return Py_BuildValue("(NN)", pyopencv_from(dst), pyopencv_from(dst_mask));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_dst_mask = NULL;
    UMat dst_mask;

    const char* keywords[] = { "dst", "dst_mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_Blender.blend", (char**)keywords, &pyobj_dst, &pyobj_dst_mask) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_dst_mask, dst_mask, ArgInfo("dst_mask", 1)) )
    {
        ERRWRAP2(_self_->blend(dst, dst_mask));
        return Py_BuildValue("(NN)", pyopencv_from(dst), pyopencv_from(dst_mask));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_Blender_createDefault_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    int type=0;
    bool try_gpu=false;
    Ptr<Blender> retval;

    const char* keywords[] = { "type", "try_gpu", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|b:detail_Blender.createDefault", (char**)keywords, &type, &try_gpu) )
    {
        ERRWRAP2(retval = cv::detail::Blender::createDefault(type, try_gpu));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_Blender_feed(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::Blender> * self1 = 0;
    if (!pyopencv_detail_Blender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_Blender' or its derivative)");
    Ptr<cv::detail::Blender> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_tl = NULL;
    Point tl;

    const char* keywords[] = { "img", "mask", "tl", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_Blender.feed", (char**)keywords, &pyobj_img, &pyobj_mask, &pyobj_tl) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_tl, tl, ArgInfo("tl", 0)) )
    {
        ERRWRAP2(_self_->feed(img, mask, tl));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    PyObject* pyobj_tl = NULL;
    Point tl;

    const char* keywords[] = { "img", "mask", "tl", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_Blender.feed", (char**)keywords, &pyobj_img, &pyobj_mask, &pyobj_tl) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_tl, tl, ArgInfo("tl", 0)) )
    {
        ERRWRAP2(_self_->feed(img, mask, tl));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_Blender_prepare(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::Blender> * self1 = 0;
    if (!pyopencv_detail_Blender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_Blender' or its derivative)");
    Ptr<cv::detail::Blender> _self_ = *(self1);
    {
    PyObject* pyobj_corners = NULL;
    vector_Point corners;
    PyObject* pyobj_sizes = NULL;
    vector_Size sizes;

    const char* keywords[] = { "corners", "sizes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_Blender.prepare", (char**)keywords, &pyobj_corners, &pyobj_sizes) &&
        pyopencv_to(pyobj_corners, corners, ArgInfo("corners", 0)) &&
        pyopencv_to(pyobj_sizes, sizes, ArgInfo("sizes", 0)) )
    {
        ERRWRAP2(_self_->prepare(corners, sizes));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst_roi = NULL;
    Rect dst_roi;

    const char* keywords[] = { "dst_roi", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_Blender.prepare", (char**)keywords, &pyobj_dst_roi) &&
        pyopencv_to(pyobj_dst_roi, dst_roi, ArgInfo("dst_roi", 0)) )
    {
        ERRWRAP2(_self_->prepare(dst_roi));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (detail_Blender)

static PyGetSetDef pyopencv_detail_Blender_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_Blender_methods[] =
{
    {"blend", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Blender_blend, 0), "blend(dst, dst_mask) -> dst, dst_mask\n.   @brief Blends and returns the final pano.\n.   \n.       @param dst Final pano\n.       @param dst_mask Final pano mask"},
    {"createDefault", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Blender_createDefault_static, METH_STATIC), "createDefault(type[, try_gpu]) -> retval\n."},
    {"feed", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Blender_feed, 0), "feed(img, mask, tl) -> None\n.   @brief Processes the image.\n.   \n.       @param img Source image\n.       @param mask Source image mask\n.       @param tl Source image top-left corners"},
    {"prepare", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Blender_prepare, 0), "prepare(corners, sizes) -> None\n.   @brief Prepares the blender for blending.\n.   \n.       @param corners Source images top-left corners\n.       @param sizes Source image sizes\n\n\n\nprepare(dst_roi) -> None\n.   @overload"},

    {NULL,          NULL}
};

// Converter (detail_Blender)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::Blender> >
{
    static PyObject* from(const Ptr<cv::detail::Blender>& r)
    {
        return pyopencv_detail_Blender_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::Blender>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::Blender> * dst_;
        if (pyopencv_detail_Blender_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::Blender> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BlocksChannelsCompensator (Generic)
//================================================================================

// GetSet (detail_BlocksChannelsCompensator)



// Methods (detail_BlocksChannelsCompensator)

static int pyopencv_cv_detail_detail_BlocksChannelsCompensator_BlocksChannelsCompensator(pyopencv_detail_BlocksChannelsCompensator_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    int bl_width=32;
    int bl_height=32;
    int nr_feeds=1;

    const char* keywords[] = { "bl_width", "bl_height", "nr_feeds", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iii:BlocksChannelsCompensator", (char**)keywords, &bl_width, &bl_height, &nr_feeds) )
    {
        new (&(self->v)) Ptr<cv::detail::BlocksChannelsCompensator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BlocksChannelsCompensator(bl_width, bl_height, nr_feeds)));
        return 0;
    }

    return -1;
}



// Tables (detail_BlocksChannelsCompensator)

static PyGetSetDef pyopencv_detail_BlocksChannelsCompensator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BlocksChannelsCompensator_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_BlocksChannelsCompensator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BlocksChannelsCompensator> >
{
    static PyObject* from(const Ptr<cv::detail::BlocksChannelsCompensator>& r)
    {
        return pyopencv_detail_BlocksChannelsCompensator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BlocksChannelsCompensator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BlocksChannelsCompensator> * dst_;
        if (pyopencv_detail_BlocksChannelsCompensator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BlocksChannelsCompensator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BlocksCompensator (Generic)
//================================================================================

// GetSet (detail_BlocksCompensator)



// Methods (detail_BlocksCompensator)

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_BlocksCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_BlocksCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_getBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBlockSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_getMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_BlocksCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_BlocksCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_getNrFeeds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNrFeeds());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_getNrGainsFilteringIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNrGainsFilteringIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_setBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    {
    int width=0;
    int height=0;

    const char* keywords[] = { "width", "height", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:detail_BlocksCompensator.setBlockSize", (char**)keywords, &width, &height) )
    {
        ERRWRAP2(_self_->setBlockSize(width, height));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_size = NULL;
    Size size;

    const char* keywords[] = { "size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_BlocksCompensator.setBlockSize", (char**)keywords, &pyobj_size) &&
        pyopencv_to(pyobj_size, size, ArgInfo("size", 0)) )
    {
        ERRWRAP2(_self_->setBlockSize(size));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_setMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_BlocksCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_BlocksCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_setNrFeeds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    int nr_feeds=0;

    const char* keywords[] = { "nr_feeds", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:detail_BlocksCompensator.setNrFeeds", (char**)keywords, &nr_feeds) )
    {
        ERRWRAP2(_self_->setNrFeeds(nr_feeds));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksCompensator_setNrGainsFilteringIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksCompensator' or its derivative)");
    Ptr<cv::detail::BlocksCompensator> _self_ = *(self1);
    int nr_iterations=0;

    const char* keywords[] = { "nr_iterations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:detail_BlocksCompensator.setNrGainsFilteringIterations", (char**)keywords, &nr_iterations) )
    {
        ERRWRAP2(_self_->setNrGainsFilteringIterations(nr_iterations));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (detail_BlocksCompensator)

static PyGetSetDef pyopencv_detail_BlocksCompensator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BlocksCompensator_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_apply, 0), "apply(index, corner, image, mask) -> image\n."},
    {"getBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_getBlockSize, 0), "getBlockSize() -> retval\n."},
    {"getMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_getMatGains, 0), "getMatGains([, umv]) -> umv\n."},
    {"getNrFeeds", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_getNrFeeds, 0), "getNrFeeds() -> retval\n."},
    {"getNrGainsFilteringIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_getNrGainsFilteringIterations, 0), "getNrGainsFilteringIterations() -> retval\n."},
    {"setBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_setBlockSize, 0), "setBlockSize(width, height) -> None\n.   \n\n\n\nsetBlockSize(size) -> None\n."},
    {"setMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_setMatGains, 0), "setMatGains(umv) -> None\n."},
    {"setNrFeeds", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_setNrFeeds, 0), "setNrFeeds(nr_feeds) -> None\n."},
    {"setNrGainsFilteringIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksCompensator_setNrGainsFilteringIterations, 0), "setNrGainsFilteringIterations(nr_iterations) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_BlocksCompensator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BlocksCompensator> >
{
    static PyObject* from(const Ptr<cv::detail::BlocksCompensator>& r)
    {
        return pyopencv_detail_BlocksCompensator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BlocksCompensator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BlocksCompensator> * dst_;
        if (pyopencv_detail_BlocksCompensator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BlocksCompensator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BlocksGainCompensator (Generic)
//================================================================================

// GetSet (detail_BlocksGainCompensator)



// Methods (detail_BlocksGainCompensator)

static int pyopencv_cv_detail_detail_BlocksGainCompensator_BlocksGainCompensator(pyopencv_detail_BlocksGainCompensator_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    {
    int bl_width=32;
    int bl_height=32;

    const char* keywords[] = { "bl_width", "bl_height", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ii:BlocksGainCompensator", (char**)keywords, &bl_width, &bl_height) )
    {
        new (&(self->v)) Ptr<cv::detail::BlocksGainCompensator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BlocksGainCompensator(bl_width, bl_height)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int bl_width=0;
    int bl_height=0;
    int nr_feeds=0;

    const char* keywords[] = { "bl_width", "bl_height", "nr_feeds", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iii:BlocksGainCompensator", (char**)keywords, &bl_width, &bl_height, &nr_feeds) )
    {
        new (&(self->v)) Ptr<cv::detail::BlocksGainCompensator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BlocksGainCompensator(bl_width, bl_height, nr_feeds)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_detail_detail_BlocksGainCompensator_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksGainCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksGainCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksGainCompensator' or its derivative)");
    Ptr<cv::detail::BlocksGainCompensator> _self_ = *(self1);
    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_BlocksGainCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_BlocksGainCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksGainCompensator_getMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksGainCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksGainCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksGainCompensator' or its derivative)");
    Ptr<cv::detail::BlocksGainCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_BlocksGainCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_BlocksGainCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BlocksGainCompensator_setMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BlocksGainCompensator> * self1 = 0;
    if (!pyopencv_detail_BlocksGainCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BlocksGainCompensator' or its derivative)");
    Ptr<cv::detail::BlocksGainCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_BlocksGainCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_BlocksGainCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (detail_BlocksGainCompensator)

static PyGetSetDef pyopencv_detail_BlocksGainCompensator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BlocksGainCompensator_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksGainCompensator_apply, 0), "apply(index, corner, image, mask) -> image\n."},
    {"getMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksGainCompensator_getMatGains, 0), "getMatGains([, umv]) -> umv\n."},
    {"setMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BlocksGainCompensator_setMatGains, 0), "setMatGains(umv) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_BlocksGainCompensator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BlocksGainCompensator> >
{
    static PyObject* from(const Ptr<cv::detail::BlocksGainCompensator>& r)
    {
        return pyopencv_detail_BlocksGainCompensator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BlocksGainCompensator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BlocksGainCompensator> * dst_;
        if (pyopencv_detail_BlocksGainCompensator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BlocksGainCompensator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterAffine (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterAffine)



// Methods (detail_BundleAdjusterAffine)

static int pyopencv_cv_detail_detail_BundleAdjusterAffine_BundleAdjusterAffine(pyopencv_detail_BundleAdjusterAffine_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::detail::BundleAdjusterAffine>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BundleAdjusterAffine()));
        return 0;
    }

    return -1;
}



// Tables (detail_BundleAdjusterAffine)

static PyGetSetDef pyopencv_detail_BundleAdjusterAffine_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BundleAdjusterAffine_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_BundleAdjusterAffine)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BundleAdjusterAffine> >
{
    static PyObject* from(const Ptr<cv::detail::BundleAdjusterAffine>& r)
    {
        return pyopencv_detail_BundleAdjusterAffine_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BundleAdjusterAffine>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BundleAdjusterAffine> * dst_;
        if (pyopencv_detail_BundleAdjusterAffine_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BundleAdjusterAffine> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterAffinePartial (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterAffinePartial)



// Methods (detail_BundleAdjusterAffinePartial)

static int pyopencv_cv_detail_detail_BundleAdjusterAffinePartial_BundleAdjusterAffinePartial(pyopencv_detail_BundleAdjusterAffinePartial_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::detail::BundleAdjusterAffinePartial>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BundleAdjusterAffinePartial()));
        return 0;
    }

    return -1;
}



// Tables (detail_BundleAdjusterAffinePartial)

static PyGetSetDef pyopencv_detail_BundleAdjusterAffinePartial_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BundleAdjusterAffinePartial_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_BundleAdjusterAffinePartial)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BundleAdjusterAffinePartial> >
{
    static PyObject* from(const Ptr<cv::detail::BundleAdjusterAffinePartial>& r)
    {
        return pyopencv_detail_BundleAdjusterAffinePartial_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BundleAdjusterAffinePartial>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BundleAdjusterAffinePartial> * dst_;
        if (pyopencv_detail_BundleAdjusterAffinePartial_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BundleAdjusterAffinePartial> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterBase (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterBase)



// Methods (detail_BundleAdjusterBase)

static PyObject* pyopencv_cv_detail_detail_BundleAdjusterBase_confThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!pyopencv_detail_BundleAdjusterBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BundleAdjusterBase' or its derivative)");
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->confThresh());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BundleAdjusterBase_refinementMask(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!pyopencv_detail_BundleAdjusterBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BundleAdjusterBase' or its derivative)");
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->refinementMask());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BundleAdjusterBase_setConfThresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!pyopencv_detail_BundleAdjusterBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BundleAdjusterBase' or its derivative)");
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    double conf_thresh=0;

    const char* keywords[] = { "conf_thresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:detail_BundleAdjusterBase.setConfThresh", (char**)keywords, &conf_thresh) )
    {
        ERRWRAP2(_self_->setConfThresh(conf_thresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BundleAdjusterBase_setRefinementMask(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!pyopencv_detail_BundleAdjusterBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BundleAdjusterBase' or its derivative)");
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    {
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_BundleAdjusterBase.setRefinementMask", (char**)keywords, &pyobj_mask) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->setRefinementMask(mask));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_BundleAdjusterBase.setRefinementMask", (char**)keywords, &pyobj_mask) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->setRefinementMask(mask));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BundleAdjusterBase_setTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!pyopencv_detail_BundleAdjusterBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BundleAdjusterBase' or its derivative)");
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    PyObject* pyobj_term_criteria = NULL;
    TermCriteria term_criteria;

    const char* keywords[] = { "term_criteria", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_BundleAdjusterBase.setTermCriteria", (char**)keywords, &pyobj_term_criteria) &&
        pyopencv_to(pyobj_term_criteria, term_criteria, ArgInfo("term_criteria", 0)) )
    {
        ERRWRAP2(_self_->setTermCriteria(term_criteria));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_BundleAdjusterBase_termCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::BundleAdjusterBase> * self1 = 0;
    if (!pyopencv_detail_BundleAdjusterBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_BundleAdjusterBase' or its derivative)");
    Ptr<cv::detail::BundleAdjusterBase> _self_ = *(self1);
    TermCriteria retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->termCriteria());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (detail_BundleAdjusterBase)

static PyGetSetDef pyopencv_detail_BundleAdjusterBase_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BundleAdjusterBase_methods[] =
{
    {"confThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BundleAdjusterBase_confThresh, 0), "confThresh() -> retval\n."},
    {"refinementMask", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BundleAdjusterBase_refinementMask, 0), "refinementMask() -> retval\n."},
    {"setConfThresh", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BundleAdjusterBase_setConfThresh, 0), "setConfThresh(conf_thresh) -> None\n."},
    {"setRefinementMask", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BundleAdjusterBase_setRefinementMask, 0), "setRefinementMask(mask) -> None\n."},
    {"setTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BundleAdjusterBase_setTermCriteria, 0), "setTermCriteria(term_criteria) -> None\n."},
    {"termCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_BundleAdjusterBase_termCriteria, 0), "termCriteria() -> retval\n."},

    {NULL,          NULL}
};

// Converter (detail_BundleAdjusterBase)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BundleAdjusterBase> >
{
    static PyObject* from(const Ptr<cv::detail::BundleAdjusterBase>& r)
    {
        return pyopencv_detail_BundleAdjusterBase_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BundleAdjusterBase>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BundleAdjusterBase> * dst_;
        if (pyopencv_detail_BundleAdjusterBase_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BundleAdjusterBase> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterRay (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterRay)



// Methods (detail_BundleAdjusterRay)

static int pyopencv_cv_detail_detail_BundleAdjusterRay_BundleAdjusterRay(pyopencv_detail_BundleAdjusterRay_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::detail::BundleAdjusterRay>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BundleAdjusterRay()));
        return 0;
    }

    return -1;
}



// Tables (detail_BundleAdjusterRay)

static PyGetSetDef pyopencv_detail_BundleAdjusterRay_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BundleAdjusterRay_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_BundleAdjusterRay)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BundleAdjusterRay> >
{
    static PyObject* from(const Ptr<cv::detail::BundleAdjusterRay>& r)
    {
        return pyopencv_detail_BundleAdjusterRay_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BundleAdjusterRay>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BundleAdjusterRay> * dst_;
        if (pyopencv_detail_BundleAdjusterRay_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BundleAdjusterRay> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_BundleAdjusterReproj (Generic)
//================================================================================

// GetSet (detail_BundleAdjusterReproj)



// Methods (detail_BundleAdjusterReproj)

static int pyopencv_cv_detail_detail_BundleAdjusterReproj_BundleAdjusterReproj(pyopencv_detail_BundleAdjusterReproj_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::detail::BundleAdjusterReproj>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::BundleAdjusterReproj()));
        return 0;
    }

    return -1;
}



// Tables (detail_BundleAdjusterReproj)

static PyGetSetDef pyopencv_detail_BundleAdjusterReproj_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_BundleAdjusterReproj_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_BundleAdjusterReproj)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::BundleAdjusterReproj> >
{
    static PyObject* from(const Ptr<cv::detail::BundleAdjusterReproj>& r)
    {
        return pyopencv_detail_BundleAdjusterReproj_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::BundleAdjusterReproj>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::BundleAdjusterReproj> * dst_;
        if (pyopencv_detail_BundleAdjusterReproj_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::BundleAdjusterReproj> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_CameraParams (Generic)
//================================================================================

// GetSet (detail_CameraParams)


static PyObject* pyopencv_detail_CameraParams_get_R(pyopencv_detail_CameraParams_t* p, void *closure)
{
    return pyopencv_from(p->v.R);
}

static int pyopencv_detail_CameraParams_set_R(pyopencv_detail_CameraParams_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the R attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.R) ? 0 : -1;
}

static PyObject* pyopencv_detail_CameraParams_get_aspect(pyopencv_detail_CameraParams_t* p, void *closure)
{
    return pyopencv_from(p->v.aspect);
}

static int pyopencv_detail_CameraParams_set_aspect(pyopencv_detail_CameraParams_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the aspect attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.aspect) ? 0 : -1;
}

static PyObject* pyopencv_detail_CameraParams_get_focal(pyopencv_detail_CameraParams_t* p, void *closure)
{
    return pyopencv_from(p->v.focal);
}

static int pyopencv_detail_CameraParams_set_focal(pyopencv_detail_CameraParams_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the focal attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.focal) ? 0 : -1;
}

static PyObject* pyopencv_detail_CameraParams_get_ppx(pyopencv_detail_CameraParams_t* p, void *closure)
{
    return pyopencv_from(p->v.ppx);
}

static int pyopencv_detail_CameraParams_set_ppx(pyopencv_detail_CameraParams_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the ppx attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.ppx) ? 0 : -1;
}

static PyObject* pyopencv_detail_CameraParams_get_ppy(pyopencv_detail_CameraParams_t* p, void *closure)
{
    return pyopencv_from(p->v.ppy);
}

static int pyopencv_detail_CameraParams_set_ppy(pyopencv_detail_CameraParams_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the ppy attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.ppy) ? 0 : -1;
}

static PyObject* pyopencv_detail_CameraParams_get_t(pyopencv_detail_CameraParams_t* p, void *closure)
{
    return pyopencv_from(p->v.t);
}

static int pyopencv_detail_CameraParams_set_t(pyopencv_detail_CameraParams_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the t attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.t) ? 0 : -1;
}


// Methods (detail_CameraParams)

static PyObject* pyopencv_cv_detail_detail_CameraParams_K(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    cv::detail::CameraParams * self1 = 0;
    if (!pyopencv_detail_CameraParams_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_CameraParams' or its derivative)");
    cv::detail::CameraParams* _self_ = (self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->K());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (detail_CameraParams)

static PyGetSetDef pyopencv_detail_CameraParams_getseters[] =
{
    {(char*)"R", (getter)pyopencv_detail_CameraParams_get_R, (setter)pyopencv_detail_CameraParams_set_R, (char*)"R", NULL},
    {(char*)"aspect", (getter)pyopencv_detail_CameraParams_get_aspect, (setter)pyopencv_detail_CameraParams_set_aspect, (char*)"aspect", NULL},
    {(char*)"focal", (getter)pyopencv_detail_CameraParams_get_focal, (setter)pyopencv_detail_CameraParams_set_focal, (char*)"focal", NULL},
    {(char*)"ppx", (getter)pyopencv_detail_CameraParams_get_ppx, (setter)pyopencv_detail_CameraParams_set_ppx, (char*)"ppx", NULL},
    {(char*)"ppy", (getter)pyopencv_detail_CameraParams_get_ppy, (setter)pyopencv_detail_CameraParams_set_ppy, (char*)"ppy", NULL},
    {(char*)"t", (getter)pyopencv_detail_CameraParams_get_t, (setter)pyopencv_detail_CameraParams_set_t, (char*)"t", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_CameraParams_methods[] =
{
    {"K", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_CameraParams_K, 0), "K() -> retval\n."},

    {NULL,          NULL}
};

// Converter (detail_CameraParams)

template<>
struct PyOpenCV_Converter< cv::detail::CameraParams >
{
    static PyObject* from(const cv::detail::CameraParams& r)
    {
        return pyopencv_detail_CameraParams_Instance(r);
    }
    static bool to(PyObject* src, cv::detail::CameraParams& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::detail::CameraParams * dst_;
        if (pyopencv_detail_CameraParams_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::detail::CameraParams for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_ChannelsCompensator (Generic)
//================================================================================

// GetSet (detail_ChannelsCompensator)



// Methods (detail_ChannelsCompensator)

static int pyopencv_cv_detail_detail_ChannelsCompensator_ChannelsCompensator(pyopencv_detail_ChannelsCompensator_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    int nr_feeds=1;

    const char* keywords[] = { "nr_feeds", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:ChannelsCompensator", (char**)keywords, &nr_feeds) )
    {
        new (&(self->v)) Ptr<cv::detail::ChannelsCompensator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::ChannelsCompensator(nr_feeds)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_detail_detail_ChannelsCompensator_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!pyopencv_detail_ChannelsCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ChannelsCompensator' or its derivative)");
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_ChannelsCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_ChannelsCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ChannelsCompensator_getMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!pyopencv_detail_ChannelsCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ChannelsCompensator' or its derivative)");
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_ChannelsCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_ChannelsCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ChannelsCompensator_getNrFeeds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!pyopencv_detail_ChannelsCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ChannelsCompensator' or its derivative)");
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNrFeeds());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ChannelsCompensator_setMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!pyopencv_detail_ChannelsCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ChannelsCompensator' or its derivative)");
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_ChannelsCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_ChannelsCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ChannelsCompensator_setNrFeeds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ChannelsCompensator> * self1 = 0;
    if (!pyopencv_detail_ChannelsCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ChannelsCompensator' or its derivative)");
    Ptr<cv::detail::ChannelsCompensator> _self_ = *(self1);
    int nr_feeds=0;

    const char* keywords[] = { "nr_feeds", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:detail_ChannelsCompensator.setNrFeeds", (char**)keywords, &nr_feeds) )
    {
        ERRWRAP2(_self_->setNrFeeds(nr_feeds));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (detail_ChannelsCompensator)

static PyGetSetDef pyopencv_detail_ChannelsCompensator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_ChannelsCompensator_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ChannelsCompensator_apply, 0), "apply(index, corner, image, mask) -> image\n."},
    {"getMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ChannelsCompensator_getMatGains, 0), "getMatGains([, umv]) -> umv\n."},
    {"getNrFeeds", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ChannelsCompensator_getNrFeeds, 0), "getNrFeeds() -> retval\n."},
    {"setMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ChannelsCompensator_setMatGains, 0), "setMatGains(umv) -> None\n."},
    {"setNrFeeds", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ChannelsCompensator_setNrFeeds, 0), "setNrFeeds(nr_feeds) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_ChannelsCompensator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::ChannelsCompensator> >
{
    static PyObject* from(const Ptr<cv::detail::ChannelsCompensator>& r)
    {
        return pyopencv_detail_ChannelsCompensator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::ChannelsCompensator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::ChannelsCompensator> * dst_;
        if (pyopencv_detail_ChannelsCompensator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::ChannelsCompensator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_DpSeamFinder (Generic)
//================================================================================

// GetSet (detail_DpSeamFinder)



// Methods (detail_DpSeamFinder)

static int pyopencv_cv_detail_detail_DpSeamFinder_DpSeamFinder(pyopencv_detail_DpSeamFinder_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    PyObject* pyobj_costFunc = NULL;
    String costFunc;

    const char* keywords[] = { "costFunc", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DpSeamFinder", (char**)keywords, &pyobj_costFunc) &&
        pyopencv_to(pyobj_costFunc, costFunc, ArgInfo("costFunc", 0)) )
    {
        new (&(self->v)) Ptr<cv::detail::DpSeamFinder>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::DpSeamFinder(costFunc)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_detail_detail_DpSeamFinder_setCostFunction(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::DpSeamFinder> * self1 = 0;
    if (!pyopencv_detail_DpSeamFinder_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_DpSeamFinder' or its derivative)");
    Ptr<cv::detail::DpSeamFinder> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    String val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_DpSeamFinder.setCostFunction", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCostFunction(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (detail_DpSeamFinder)

static PyGetSetDef pyopencv_detail_DpSeamFinder_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_DpSeamFinder_methods[] =
{
    {"setCostFunction", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_DpSeamFinder_setCostFunction, 0), "setCostFunction(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_DpSeamFinder)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::DpSeamFinder> >
{
    static PyObject* from(const Ptr<cv::detail::DpSeamFinder>& r)
    {
        return pyopencv_detail_DpSeamFinder_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::DpSeamFinder>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::DpSeamFinder> * dst_;
        if (pyopencv_detail_DpSeamFinder_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::DpSeamFinder> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_Estimator (Generic)
//================================================================================

// GetSet (detail_Estimator)



// Methods (detail_Estimator)

static PyObject* pyopencv_cv_detail_detail_Estimator_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::Estimator> * self1 = 0;
    if (!pyopencv_detail_Estimator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_Estimator' or its derivative)");
    Ptr<cv::detail::Estimator> _self_ = *(self1);
    PyObject* pyobj_features = NULL;
    vector_ImageFeatures features;
    PyObject* pyobj_pairwise_matches = NULL;
    vector_MatchesInfo pairwise_matches;
    PyObject* pyobj_cameras = NULL;
    vector_CameraParams cameras;
    bool retval;

    const char* keywords[] = { "features", "pairwise_matches", "cameras", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_Estimator.apply", (char**)keywords, &pyobj_features, &pyobj_pairwise_matches, &pyobj_cameras) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) &&
        pyopencv_to(pyobj_pairwise_matches, pairwise_matches, ArgInfo("pairwise_matches", 0)) &&
        pyopencv_to(pyobj_cameras, cameras, ArgInfo("cameras", 1)) )
    {
        ERRWRAP2(retval = _self_->operator ()(features, pairwise_matches, cameras));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(cameras));
    }

    return NULL;
}



// Tables (detail_Estimator)

static PyGetSetDef pyopencv_detail_Estimator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_Estimator_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Estimator_apply, 0), "apply(features, pairwise_matches, cameras) -> retval, cameras\n.   @brief Estimates camera parameters.\n.   \n.       @param features Features of images\n.       @param pairwise_matches Pairwise matches of images\n.       @param cameras Estimated camera parameters\n.       @return True in case of success, false otherwise"},

    {NULL,          NULL}
};

// Converter (detail_Estimator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::Estimator> >
{
    static PyObject* from(const Ptr<cv::detail::Estimator>& r)
    {
        return pyopencv_detail_Estimator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::Estimator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::Estimator> * dst_;
        if (pyopencv_detail_Estimator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::Estimator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_ExposureCompensator (Generic)
//================================================================================

// GetSet (detail_ExposureCompensator)



// Methods (detail_ExposureCompensator)

static PyObject* pyopencv_cv_detail_detail_ExposureCompensator_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_ExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ExposureCompensator' or its derivative)");
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_ExposureCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_ExposureCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ExposureCompensator_createDefault_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    int type=0;
    Ptr<ExposureCompensator> retval;

    const char* keywords[] = { "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:detail_ExposureCompensator.createDefault", (char**)keywords, &type) )
    {
        ERRWRAP2(retval = cv::detail::ExposureCompensator::createDefault(type));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ExposureCompensator_feed(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_ExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ExposureCompensator' or its derivative)");
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    PyObject* pyobj_corners = NULL;
    vector_Point corners;
    PyObject* pyobj_images = NULL;
    vector_UMat images;
    PyObject* pyobj_masks = NULL;
    vector_UMat masks;

    const char* keywords[] = { "corners", "images", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_ExposureCompensator.feed", (char**)keywords, &pyobj_corners, &pyobj_images, &pyobj_masks) &&
        pyopencv_to(pyobj_corners, corners, ArgInfo("corners", 0)) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->feed(corners, images, masks));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ExposureCompensator_getMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_ExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ExposureCompensator' or its derivative)");
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_arg1 = NULL;
    vector_Mat arg1;

    const char* keywords[] = { "arg1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_ExposureCompensator.getMatGains", (char**)keywords, &pyobj_arg1) &&
        pyopencv_to(pyobj_arg1, arg1, ArgInfo("arg1", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(arg1));
        return pyopencv_from(arg1);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arg1 = NULL;
    vector_Mat arg1;

    const char* keywords[] = { "arg1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_ExposureCompensator.getMatGains", (char**)keywords, &pyobj_arg1) &&
        pyopencv_to(pyobj_arg1, arg1, ArgInfo("arg1", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(arg1));
        return pyopencv_from(arg1);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ExposureCompensator_getUpdateGain(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_ExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ExposureCompensator' or its derivative)");
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUpdateGain());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ExposureCompensator_setMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_ExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ExposureCompensator' or its derivative)");
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_arg1 = NULL;
    vector_Mat arg1;

    const char* keywords[] = { "arg1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_ExposureCompensator.setMatGains", (char**)keywords, &pyobj_arg1) &&
        pyopencv_to(pyobj_arg1, arg1, ArgInfo("arg1", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(arg1));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_arg1 = NULL;
    vector_Mat arg1;

    const char* keywords[] = { "arg1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_ExposureCompensator.setMatGains", (char**)keywords, &pyobj_arg1) &&
        pyopencv_to(pyobj_arg1, arg1, ArgInfo("arg1", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(arg1));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_ExposureCompensator_setUpdateGain(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::ExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_ExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ExposureCompensator' or its derivative)");
    Ptr<cv::detail::ExposureCompensator> _self_ = *(self1);
    bool b=0;

    const char* keywords[] = { "b", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:detail_ExposureCompensator.setUpdateGain", (char**)keywords, &b) )
    {
        ERRWRAP2(_self_->setUpdateGain(b));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (detail_ExposureCompensator)

static PyGetSetDef pyopencv_detail_ExposureCompensator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_ExposureCompensator_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ExposureCompensator_apply, 0), "apply(index, corner, image, mask) -> image\n.   @brief Compensate exposure in the specified image.\n.   \n.       @param index Image index\n.       @param corner Image top-left corner\n.       @param image Image to process\n.       @param mask Image mask"},
    {"createDefault", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ExposureCompensator_createDefault_static, METH_STATIC), "createDefault(type) -> retval\n."},
    {"feed", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ExposureCompensator_feed, 0), "feed(corners, images, masks) -> None\n.   @param corners Source image top-left corners\n.       @param images Source images\n.       @param masks Image masks to update (second value in pair specifies the value which should be used\n.       to detect where image is)"},
    {"getMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ExposureCompensator_getMatGains, 0), "getMatGains([, arg1]) -> arg1\n."},
    {"getUpdateGain", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ExposureCompensator_getUpdateGain, 0), "getUpdateGain() -> retval\n."},
    {"setMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ExposureCompensator_setMatGains, 0), "setMatGains(arg1) -> None\n."},
    {"setUpdateGain", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ExposureCompensator_setUpdateGain, 0), "setUpdateGain(b) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_ExposureCompensator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::ExposureCompensator> >
{
    static PyObject* from(const Ptr<cv::detail::ExposureCompensator>& r)
    {
        return pyopencv_detail_ExposureCompensator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::ExposureCompensator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::ExposureCompensator> * dst_;
        if (pyopencv_detail_ExposureCompensator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::ExposureCompensator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_FeatherBlender (Generic)
//================================================================================

// GetSet (detail_FeatherBlender)



// Methods (detail_FeatherBlender)

static int pyopencv_cv_detail_detail_FeatherBlender_FeatherBlender(pyopencv_detail_FeatherBlender_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    float sharpness=0.02f;

    const char* keywords[] = { "sharpness", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|f:FeatherBlender", (char**)keywords, &sharpness) )
    {
        new (&(self->v)) Ptr<cv::detail::FeatherBlender>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::FeatherBlender(sharpness)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_detail_detail_FeatherBlender_blend(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!pyopencv_detail_FeatherBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeatherBlender' or its derivative)");
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_dst_mask = NULL;
    Mat dst_mask;

    const char* keywords[] = { "dst", "dst_mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_FeatherBlender.blend", (char**)keywords, &pyobj_dst, &pyobj_dst_mask) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_dst_mask, dst_mask, ArgInfo("dst_mask", 1)) )
    {
        ERRWRAP2(_self_->blend(dst, dst_mask));
        return Py_BuildValue("(NN)", pyopencv_from(dst), pyopencv_from(dst_mask));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_dst_mask = NULL;
    UMat dst_mask;

    const char* keywords[] = { "dst", "dst_mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_FeatherBlender.blend", (char**)keywords, &pyobj_dst, &pyobj_dst_mask) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_dst_mask, dst_mask, ArgInfo("dst_mask", 1)) )
    {
        ERRWRAP2(_self_->blend(dst, dst_mask));
        return Py_BuildValue("(NN)", pyopencv_from(dst), pyopencv_from(dst_mask));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_FeatherBlender_createWeightMaps(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!pyopencv_detail_FeatherBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeatherBlender' or its derivative)");
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    PyObject* pyobj_masks = NULL;
    vector_UMat masks;
    PyObject* pyobj_corners = NULL;
    vector_Point corners;
    PyObject* pyobj_weight_maps = NULL;
    vector_UMat weight_maps;
    Rect retval;

    const char* keywords[] = { "masks", "corners", "weight_maps", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_FeatherBlender.createWeightMaps", (char**)keywords, &pyobj_masks, &pyobj_corners, &pyobj_weight_maps) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) &&
        pyopencv_to(pyobj_corners, corners, ArgInfo("corners", 0)) &&
        pyopencv_to(pyobj_weight_maps, weight_maps, ArgInfo("weight_maps", 1)) )
    {
        ERRWRAP2(retval = _self_->createWeightMaps(masks, corners, weight_maps));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(weight_maps));
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_FeatherBlender_feed(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!pyopencv_detail_FeatherBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeatherBlender' or its derivative)");
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_tl = NULL;
    Point tl;

    const char* keywords[] = { "img", "mask", "tl", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_FeatherBlender.feed", (char**)keywords, &pyobj_img, &pyobj_mask, &pyobj_tl) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_tl, tl, ArgInfo("tl", 0)) )
    {
        ERRWRAP2(_self_->feed(img, mask, tl));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    PyObject* pyobj_tl = NULL;
    Point tl;

    const char* keywords[] = { "img", "mask", "tl", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_FeatherBlender.feed", (char**)keywords, &pyobj_img, &pyobj_mask, &pyobj_tl) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_tl, tl, ArgInfo("tl", 0)) )
    {
        ERRWRAP2(_self_->feed(img, mask, tl));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_FeatherBlender_prepare(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!pyopencv_detail_FeatherBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeatherBlender' or its derivative)");
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    PyObject* pyobj_dst_roi = NULL;
    Rect dst_roi;

    const char* keywords[] = { "dst_roi", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_FeatherBlender.prepare", (char**)keywords, &pyobj_dst_roi) &&
        pyopencv_to(pyobj_dst_roi, dst_roi, ArgInfo("dst_roi", 0)) )
    {
        ERRWRAP2(_self_->prepare(dst_roi));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_FeatherBlender_setSharpness(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!pyopencv_detail_FeatherBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeatherBlender' or its derivative)");
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:detail_FeatherBlender.setSharpness", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setSharpness(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_FeatherBlender_sharpness(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeatherBlender> * self1 = 0;
    if (!pyopencv_detail_FeatherBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeatherBlender' or its derivative)");
    Ptr<cv::detail::FeatherBlender> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->sharpness());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (detail_FeatherBlender)

static PyGetSetDef pyopencv_detail_FeatherBlender_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_FeatherBlender_methods[] =
{
    {"blend", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeatherBlender_blend, 0), "blend(dst, dst_mask) -> dst, dst_mask\n."},
    {"createWeightMaps", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeatherBlender_createWeightMaps, 0), "createWeightMaps(masks, corners, weight_maps) -> retval, weight_maps\n."},
    {"feed", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeatherBlender_feed, 0), "feed(img, mask, tl) -> None\n."},
    {"prepare", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeatherBlender_prepare, 0), "prepare(dst_roi) -> None\n."},
    {"setSharpness", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeatherBlender_setSharpness, 0), "setSharpness(val) -> None\n."},
    {"sharpness", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeatherBlender_sharpness, 0), "sharpness() -> retval\n."},

    {NULL,          NULL}
};

// Converter (detail_FeatherBlender)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::FeatherBlender> >
{
    static PyObject* from(const Ptr<cv::detail::FeatherBlender>& r)
    {
        return pyopencv_detail_FeatherBlender_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::FeatherBlender>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::FeatherBlender> * dst_;
        if (pyopencv_detail_FeatherBlender_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::FeatherBlender> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_FeaturesMatcher (Generic)
//================================================================================

// GetSet (detail_FeaturesMatcher)



// Methods (detail_FeaturesMatcher)

static PyObject* pyopencv_cv_detail_detail_FeaturesMatcher_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeaturesMatcher> * self1 = 0;
    if (!pyopencv_detail_FeaturesMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeaturesMatcher' or its derivative)");
    Ptr<cv::detail::FeaturesMatcher> _self_ = *(self1);
    PyObject* pyobj_features1 = NULL;
    ImageFeatures features1;
    PyObject* pyobj_features2 = NULL;
    ImageFeatures features2;
    MatchesInfo matches_info;

    const char* keywords[] = { "features1", "features2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_FeaturesMatcher.apply", (char**)keywords, &pyobj_features1, &pyobj_features2) &&
        pyopencv_to(pyobj_features1, features1, ArgInfo("features1", 0)) &&
        pyopencv_to(pyobj_features2, features2, ArgInfo("features2", 0)) )
    {
        ERRWRAP2(_self_->operator ()(features1, features2, matches_info));
        return pyopencv_from(matches_info);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_FeaturesMatcher_apply2(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeaturesMatcher> * self1 = 0;
    if (!pyopencv_detail_FeaturesMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeaturesMatcher' or its derivative)");
    Ptr<cv::detail::FeaturesMatcher> _self_ = *(self1);
    PyObject* pyobj_features = NULL;
    vector_ImageFeatures features;
    vector_MatchesInfo pairwise_matches;
    PyObject* pyobj_mask = NULL;
    UMat mask=cv::UMat();

    const char* keywords[] = { "features", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:detail_FeaturesMatcher.apply2", (char**)keywords, &pyobj_features, &pyobj_mask) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->operator ()(features, pairwise_matches, mask));
        return pyopencv_from(pairwise_matches);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_FeaturesMatcher_collectGarbage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeaturesMatcher> * self1 = 0;
    if (!pyopencv_detail_FeaturesMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeaturesMatcher' or its derivative)");
    Ptr<cv::detail::FeaturesMatcher> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->collectGarbage());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_FeaturesMatcher_isThreadSafe(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::FeaturesMatcher> * self1 = 0;
    if (!pyopencv_detail_FeaturesMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_FeaturesMatcher' or its derivative)");
    Ptr<cv::detail::FeaturesMatcher> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isThreadSafe());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (detail_FeaturesMatcher)

static PyGetSetDef pyopencv_detail_FeaturesMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_FeaturesMatcher_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeaturesMatcher_apply, 0), "apply(features1, features2) -> matches_info\n.   @overload\n.       @param features1 First image features\n.       @param features2 Second image features\n.       @param matches_info Found matches"},
    {"apply2", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeaturesMatcher_apply2, 0), "apply2(features[, mask]) -> pairwise_matches\n.   @brief Performs images matching.\n.   \n.       @param features Features of the source images\n.       @param pairwise_matches Found pairwise matches\n.       @param mask Mask indicating which image pairs must be matched\n.   \n.       The function is parallelized with the TBB library.\n.   \n.       @sa detail::MatchesInfo"},
    {"collectGarbage", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeaturesMatcher_collectGarbage, 0), "collectGarbage() -> None\n.   @brief Frees unused memory allocated before if there is any."},
    {"isThreadSafe", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_FeaturesMatcher_isThreadSafe, 0), "isThreadSafe() -> retval\n.   @return True, if it's possible to use the same matcher instance in parallel, false otherwise"},

    {NULL,          NULL}
};

// Converter (detail_FeaturesMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::FeaturesMatcher> >
{
    static PyObject* from(const Ptr<cv::detail::FeaturesMatcher>& r)
    {
        return pyopencv_detail_FeaturesMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::FeaturesMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::FeaturesMatcher> * dst_;
        if (pyopencv_detail_FeaturesMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::FeaturesMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_GainCompensator (Generic)
//================================================================================

// GetSet (detail_GainCompensator)



// Methods (detail_GainCompensator)

static int pyopencv_cv_detail_detail_GainCompensator_GainCompensator(pyopencv_detail_GainCompensator_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::detail::GainCompensator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::GainCompensator()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int nr_feeds=0;

    const char* keywords[] = { "nr_feeds", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:GainCompensator", (char**)keywords, &nr_feeds) )
    {
        new (&(self->v)) Ptr<cv::detail::GainCompensator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::GainCompensator(nr_feeds)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_detail_detail_GainCompensator_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!pyopencv_detail_GainCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_GainCompensator' or its derivative)");
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_GainCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    int index=0;
    PyObject* pyobj_corner = NULL;
    Point corner;
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "index", "corner", "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_GainCompensator.apply", (char**)keywords, &index, &pyobj_corner, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_corner, corner, ArgInfo("corner", 0)) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->apply(index, corner, image, mask));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_GainCompensator_getMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!pyopencv_detail_GainCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_GainCompensator' or its derivative)");
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_GainCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_GainCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_GainCompensator_getNrFeeds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!pyopencv_detail_GainCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_GainCompensator' or its derivative)");
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNrFeeds());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_GainCompensator_setMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!pyopencv_detail_GainCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_GainCompensator' or its derivative)");
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_GainCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_GainCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_GainCompensator_setNrFeeds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::GainCompensator> * self1 = 0;
    if (!pyopencv_detail_GainCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_GainCompensator' or its derivative)");
    Ptr<cv::detail::GainCompensator> _self_ = *(self1);
    int nr_feeds=0;

    const char* keywords[] = { "nr_feeds", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:detail_GainCompensator.setNrFeeds", (char**)keywords, &nr_feeds) )
    {
        ERRWRAP2(_self_->setNrFeeds(nr_feeds));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (detail_GainCompensator)

static PyGetSetDef pyopencv_detail_GainCompensator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_GainCompensator_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_GainCompensator_apply, 0), "apply(index, corner, image, mask) -> image\n."},
    {"getMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_GainCompensator_getMatGains, 0), "getMatGains([, umv]) -> umv\n."},
    {"getNrFeeds", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_GainCompensator_getNrFeeds, 0), "getNrFeeds() -> retval\n."},
    {"setMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_GainCompensator_setMatGains, 0), "setMatGains(umv) -> None\n."},
    {"setNrFeeds", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_GainCompensator_setNrFeeds, 0), "setNrFeeds(nr_feeds) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_GainCompensator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::GainCompensator> >
{
    static PyObject* from(const Ptr<cv::detail::GainCompensator>& r)
    {
        return pyopencv_detail_GainCompensator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::GainCompensator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::GainCompensator> * dst_;
        if (pyopencv_detail_GainCompensator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::GainCompensator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_GraphCutSeamFinder (Generic)
//================================================================================

// GetSet (detail_GraphCutSeamFinder)



// Methods (detail_GraphCutSeamFinder)

static int pyopencv_cv_detail_detail_GraphCutSeamFinder_GraphCutSeamFinder(pyopencv_detail_GraphCutSeamFinder_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    PyObject* pyobj_cost_type = NULL;
    String cost_type;
    float terminal_cost=10000.f;
    float bad_region_penalty=1000.f;

    const char* keywords[] = { "cost_type", "terminal_cost", "bad_region_penalty", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|ff:GraphCutSeamFinder", (char**)keywords, &pyobj_cost_type, &terminal_cost, &bad_region_penalty) &&
        pyopencv_to(pyobj_cost_type, cost_type, ArgInfo("cost_type", 0)) )
    {
        new (&(self->v)) Ptr<cv::detail::GraphCutSeamFinder>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::GraphCutSeamFinder(cost_type, terminal_cost, bad_region_penalty)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_detail_detail_GraphCutSeamFinder_find(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::GraphCutSeamFinder> * self1 = 0;
    if (!pyopencv_detail_GraphCutSeamFinder_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_GraphCutSeamFinder' or its derivative)");
    Ptr<cv::detail::GraphCutSeamFinder> _self_ = *(self1);
    PyObject* pyobj_src = NULL;
    vector_UMat src;
    PyObject* pyobj_corners = NULL;
    vector_Point corners;
    PyObject* pyobj_masks = NULL;
    vector_UMat masks;

    const char* keywords[] = { "src", "corners", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_GraphCutSeamFinder.find", (char**)keywords, &pyobj_src, &pyobj_corners, &pyobj_masks) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_corners, corners, ArgInfo("corners", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->find(src, corners, masks));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (detail_GraphCutSeamFinder)

static PyGetSetDef pyopencv_detail_GraphCutSeamFinder_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_GraphCutSeamFinder_methods[] =
{
    {"find", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_GraphCutSeamFinder_find, 0), "find(src, corners, masks) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_GraphCutSeamFinder)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::GraphCutSeamFinder> >
{
    static PyObject* from(const Ptr<cv::detail::GraphCutSeamFinder>& r)
    {
        return pyopencv_detail_GraphCutSeamFinder_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::GraphCutSeamFinder>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::GraphCutSeamFinder> * dst_;
        if (pyopencv_detail_GraphCutSeamFinder_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::GraphCutSeamFinder> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_HomographyBasedEstimator (Generic)
//================================================================================

// GetSet (detail_HomographyBasedEstimator)



// Methods (detail_HomographyBasedEstimator)

static int pyopencv_cv_detail_detail_HomographyBasedEstimator_HomographyBasedEstimator(pyopencv_detail_HomographyBasedEstimator_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    bool is_focals_estimated=false;

    const char* keywords[] = { "is_focals_estimated", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|b:HomographyBasedEstimator", (char**)keywords, &is_focals_estimated) )
    {
        new (&(self->v)) Ptr<cv::detail::HomographyBasedEstimator>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::HomographyBasedEstimator(is_focals_estimated)));
        return 0;
    }

    return -1;
}



// Tables (detail_HomographyBasedEstimator)

static PyGetSetDef pyopencv_detail_HomographyBasedEstimator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_HomographyBasedEstimator_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_HomographyBasedEstimator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::HomographyBasedEstimator> >
{
    static PyObject* from(const Ptr<cv::detail::HomographyBasedEstimator>& r)
    {
        return pyopencv_detail_HomographyBasedEstimator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::HomographyBasedEstimator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::HomographyBasedEstimator> * dst_;
        if (pyopencv_detail_HomographyBasedEstimator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::HomographyBasedEstimator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_ImageFeatures (Generic)
//================================================================================

// GetSet (detail_ImageFeatures)


static PyObject* pyopencv_detail_ImageFeatures_get_descriptors(pyopencv_detail_ImageFeatures_t* p, void *closure)
{
    return pyopencv_from(p->v.descriptors);
}

static int pyopencv_detail_ImageFeatures_set_descriptors(pyopencv_detail_ImageFeatures_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the descriptors attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.descriptors) ? 0 : -1;
}

static PyObject* pyopencv_detail_ImageFeatures_get_img_idx(pyopencv_detail_ImageFeatures_t* p, void *closure)
{
    return pyopencv_from(p->v.img_idx);
}

static int pyopencv_detail_ImageFeatures_set_img_idx(pyopencv_detail_ImageFeatures_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the img_idx attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.img_idx) ? 0 : -1;
}

static PyObject* pyopencv_detail_ImageFeatures_get_img_size(pyopencv_detail_ImageFeatures_t* p, void *closure)
{
    return pyopencv_from(p->v.img_size);
}

static int pyopencv_detail_ImageFeatures_set_img_size(pyopencv_detail_ImageFeatures_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the img_size attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.img_size) ? 0 : -1;
}


// Methods (detail_ImageFeatures)

static PyObject* pyopencv_cv_detail_detail_ImageFeatures_getKeypoints(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    cv::detail::ImageFeatures * self1 = 0;
    if (!pyopencv_detail_ImageFeatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_ImageFeatures' or its derivative)");
    cv::detail::ImageFeatures* _self_ = (self1);
    std::vector<KeyPoint> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getKeypoints());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (detail_ImageFeatures)

static PyGetSetDef pyopencv_detail_ImageFeatures_getseters[] =
{
    {(char*)"descriptors", (getter)pyopencv_detail_ImageFeatures_get_descriptors, (setter)pyopencv_detail_ImageFeatures_set_descriptors, (char*)"descriptors", NULL},
    {(char*)"img_idx", (getter)pyopencv_detail_ImageFeatures_get_img_idx, (setter)pyopencv_detail_ImageFeatures_set_img_idx, (char*)"img_idx", NULL},
    {(char*)"img_size", (getter)pyopencv_detail_ImageFeatures_get_img_size, (setter)pyopencv_detail_ImageFeatures_set_img_size, (char*)"img_size", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_ImageFeatures_methods[] =
{
    {"getKeypoints", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_ImageFeatures_getKeypoints, 0), "getKeypoints() -> retval\n."},

    {NULL,          NULL}
};

// Converter (detail_ImageFeatures)

template<>
struct PyOpenCV_Converter< cv::detail::ImageFeatures >
{
    static PyObject* from(const cv::detail::ImageFeatures& r)
    {
        return pyopencv_detail_ImageFeatures_Instance(r);
    }
    static bool to(PyObject* src, cv::detail::ImageFeatures& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::detail::ImageFeatures * dst_;
        if (pyopencv_detail_ImageFeatures_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::detail::ImageFeatures for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_MatchesInfo (Generic)
//================================================================================

// GetSet (detail_MatchesInfo)


static PyObject* pyopencv_detail_MatchesInfo_get_H(pyopencv_detail_MatchesInfo_t* p, void *closure)
{
    return pyopencv_from(p->v.H);
}

static int pyopencv_detail_MatchesInfo_set_H(pyopencv_detail_MatchesInfo_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the H attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.H) ? 0 : -1;
}

static PyObject* pyopencv_detail_MatchesInfo_get_confidence(pyopencv_detail_MatchesInfo_t* p, void *closure)
{
    return pyopencv_from(p->v.confidence);
}

static int pyopencv_detail_MatchesInfo_set_confidence(pyopencv_detail_MatchesInfo_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the confidence attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.confidence) ? 0 : -1;
}

static PyObject* pyopencv_detail_MatchesInfo_get_dst_img_idx(pyopencv_detail_MatchesInfo_t* p, void *closure)
{
    return pyopencv_from(p->v.dst_img_idx);
}

static int pyopencv_detail_MatchesInfo_set_dst_img_idx(pyopencv_detail_MatchesInfo_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the dst_img_idx attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.dst_img_idx) ? 0 : -1;
}

static PyObject* pyopencv_detail_MatchesInfo_get_num_inliers(pyopencv_detail_MatchesInfo_t* p, void *closure)
{
    return pyopencv_from(p->v.num_inliers);
}

static int pyopencv_detail_MatchesInfo_set_num_inliers(pyopencv_detail_MatchesInfo_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the num_inliers attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.num_inliers) ? 0 : -1;
}

static PyObject* pyopencv_detail_MatchesInfo_get_src_img_idx(pyopencv_detail_MatchesInfo_t* p, void *closure)
{
    return pyopencv_from(p->v.src_img_idx);
}

static int pyopencv_detail_MatchesInfo_set_src_img_idx(pyopencv_detail_MatchesInfo_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the src_img_idx attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.src_img_idx) ? 0 : -1;
}


// Methods (detail_MatchesInfo)

static PyObject* pyopencv_cv_detail_detail_MatchesInfo_getInliers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    cv::detail::MatchesInfo * self1 = 0;
    if (!pyopencv_detail_MatchesInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_MatchesInfo' or its derivative)");
    cv::detail::MatchesInfo* _self_ = (self1);
    std::vector<uchar> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInliers());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_MatchesInfo_getMatches(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    cv::detail::MatchesInfo * self1 = 0;
    if (!pyopencv_detail_MatchesInfo_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_MatchesInfo' or its derivative)");
    cv::detail::MatchesInfo* _self_ = (self1);
    std::vector<DMatch> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMatches());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (detail_MatchesInfo)

static PyGetSetDef pyopencv_detail_MatchesInfo_getseters[] =
{
    {(char*)"H", (getter)pyopencv_detail_MatchesInfo_get_H, (setter)pyopencv_detail_MatchesInfo_set_H, (char*)"H", NULL},
    {(char*)"confidence", (getter)pyopencv_detail_MatchesInfo_get_confidence, (setter)pyopencv_detail_MatchesInfo_set_confidence, (char*)"confidence", NULL},
    {(char*)"dst_img_idx", (getter)pyopencv_detail_MatchesInfo_get_dst_img_idx, (setter)pyopencv_detail_MatchesInfo_set_dst_img_idx, (char*)"dst_img_idx", NULL},
    {(char*)"num_inliers", (getter)pyopencv_detail_MatchesInfo_get_num_inliers, (setter)pyopencv_detail_MatchesInfo_set_num_inliers, (char*)"num_inliers", NULL},
    {(char*)"src_img_idx", (getter)pyopencv_detail_MatchesInfo_get_src_img_idx, (setter)pyopencv_detail_MatchesInfo_set_src_img_idx, (char*)"src_img_idx", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_MatchesInfo_methods[] =
{
    {"getInliers", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_MatchesInfo_getInliers, 0), "getInliers() -> retval\n."},
    {"getMatches", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_MatchesInfo_getMatches, 0), "getMatches() -> retval\n."},

    {NULL,          NULL}
};

// Converter (detail_MatchesInfo)

template<>
struct PyOpenCV_Converter< cv::detail::MatchesInfo >
{
    static PyObject* from(const cv::detail::MatchesInfo& r)
    {
        return pyopencv_detail_MatchesInfo_Instance(r);
    }
    static bool to(PyObject* src, cv::detail::MatchesInfo& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::detail::MatchesInfo * dst_;
        if (pyopencv_detail_MatchesInfo_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::detail::MatchesInfo for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_MultiBandBlender (Generic)
//================================================================================

// GetSet (detail_MultiBandBlender)



// Methods (detail_MultiBandBlender)

static int pyopencv_cv_detail_detail_MultiBandBlender_MultiBandBlender(pyopencv_detail_MultiBandBlender_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    int try_gpu=false;
    int num_bands=5;
    int weight_type=CV_32F;

    const char* keywords[] = { "try_gpu", "num_bands", "weight_type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iii:MultiBandBlender", (char**)keywords, &try_gpu, &num_bands, &weight_type) )
    {
        new (&(self->v)) Ptr<cv::detail::MultiBandBlender>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::MultiBandBlender(try_gpu, num_bands, weight_type)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_detail_detail_MultiBandBlender_blend(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!pyopencv_detail_MultiBandBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_MultiBandBlender' or its derivative)");
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_dst_mask = NULL;
    Mat dst_mask;

    const char* keywords[] = { "dst", "dst_mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_MultiBandBlender.blend", (char**)keywords, &pyobj_dst, &pyobj_dst_mask) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_dst_mask, dst_mask, ArgInfo("dst_mask", 1)) )
    {
        ERRWRAP2(_self_->blend(dst, dst_mask));
        return Py_BuildValue("(NN)", pyopencv_from(dst), pyopencv_from(dst_mask));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_dst_mask = NULL;
    UMat dst_mask;

    const char* keywords[] = { "dst", "dst_mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_MultiBandBlender.blend", (char**)keywords, &pyobj_dst, &pyobj_dst_mask) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_dst_mask, dst_mask, ArgInfo("dst_mask", 1)) )
    {
        ERRWRAP2(_self_->blend(dst, dst_mask));
        return Py_BuildValue("(NN)", pyopencv_from(dst), pyopencv_from(dst_mask));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_MultiBandBlender_feed(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!pyopencv_detail_MultiBandBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_MultiBandBlender' or its derivative)");
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_tl = NULL;
    Point tl;

    const char* keywords[] = { "img", "mask", "tl", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_MultiBandBlender.feed", (char**)keywords, &pyobj_img, &pyobj_mask, &pyobj_tl) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_tl, tl, ArgInfo("tl", 0)) )
    {
        ERRWRAP2(_self_->feed(img, mask, tl));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    PyObject* pyobj_tl = NULL;
    Point tl;

    const char* keywords[] = { "img", "mask", "tl", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_MultiBandBlender.feed", (char**)keywords, &pyobj_img, &pyobj_mask, &pyobj_tl) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_tl, tl, ArgInfo("tl", 0)) )
    {
        ERRWRAP2(_self_->feed(img, mask, tl));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_MultiBandBlender_numBands(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!pyopencv_detail_MultiBandBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_MultiBandBlender' or its derivative)");
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->numBands());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_MultiBandBlender_prepare(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!pyopencv_detail_MultiBandBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_MultiBandBlender' or its derivative)");
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);
    PyObject* pyobj_dst_roi = NULL;
    Rect dst_roi;

    const char* keywords[] = { "dst_roi", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_MultiBandBlender.prepare", (char**)keywords, &pyobj_dst_roi) &&
        pyopencv_to(pyobj_dst_roi, dst_roi, ArgInfo("dst_roi", 0)) )
    {
        ERRWRAP2(_self_->prepare(dst_roi));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_MultiBandBlender_setNumBands(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::MultiBandBlender> * self1 = 0;
    if (!pyopencv_detail_MultiBandBlender_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_MultiBandBlender' or its derivative)");
    Ptr<cv::detail::MultiBandBlender> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:detail_MultiBandBlender.setNumBands", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setNumBands(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (detail_MultiBandBlender)

static PyGetSetDef pyopencv_detail_MultiBandBlender_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_MultiBandBlender_methods[] =
{
    {"blend", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_MultiBandBlender_blend, 0), "blend(dst, dst_mask) -> dst, dst_mask\n."},
    {"feed", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_MultiBandBlender_feed, 0), "feed(img, mask, tl) -> None\n."},
    {"numBands", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_MultiBandBlender_numBands, 0), "numBands() -> retval\n."},
    {"prepare", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_MultiBandBlender_prepare, 0), "prepare(dst_roi) -> None\n."},
    {"setNumBands", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_MultiBandBlender_setNumBands, 0), "setNumBands(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_MultiBandBlender)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::MultiBandBlender> >
{
    static PyObject* from(const Ptr<cv::detail::MultiBandBlender>& r)
    {
        return pyopencv_detail_MultiBandBlender_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::MultiBandBlender>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::MultiBandBlender> * dst_;
        if (pyopencv_detail_MultiBandBlender_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::MultiBandBlender> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_NoBundleAdjuster (Generic)
//================================================================================

// GetSet (detail_NoBundleAdjuster)



// Methods (detail_NoBundleAdjuster)

static int pyopencv_cv_detail_detail_NoBundleAdjuster_NoBundleAdjuster(pyopencv_detail_NoBundleAdjuster_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::detail::NoBundleAdjuster>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::detail::NoBundleAdjuster()));
        return 0;
    }

    return -1;
}



// Tables (detail_NoBundleAdjuster)

static PyGetSetDef pyopencv_detail_NoBundleAdjuster_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_NoBundleAdjuster_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_NoBundleAdjuster)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::NoBundleAdjuster> >
{
    static PyObject* from(const Ptr<cv::detail::NoBundleAdjuster>& r)
    {
        return pyopencv_detail_NoBundleAdjuster_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::NoBundleAdjuster>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::NoBundleAdjuster> * dst_;
        if (pyopencv_detail_NoBundleAdjuster_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::NoBundleAdjuster> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_NoExposureCompensator (Generic)
//================================================================================

// GetSet (detail_NoExposureCompensator)



// Methods (detail_NoExposureCompensator)

static PyObject* pyopencv_cv_detail_detail_NoExposureCompensator_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::NoExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_NoExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_NoExposureCompensator' or its derivative)");
    Ptr<cv::detail::NoExposureCompensator> _self_ = *(self1);
    {
    int arg1=0;
    PyObject* pyobj_arg2 = NULL;
    Point arg2;
    PyObject* pyobj_arg3 = NULL;
    Mat arg3;
    PyObject* pyobj_arg4 = NULL;
    Mat arg4;

    const char* keywords[] = { "arg1", "arg2", "arg3", "arg4", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_NoExposureCompensator.apply", (char**)keywords, &arg1, &pyobj_arg2, &pyobj_arg3, &pyobj_arg4) &&
        pyopencv_to(pyobj_arg2, arg2, ArgInfo("arg2", 0)) &&
        pyopencv_to(pyobj_arg3, arg3, ArgInfo("arg3", 1)) &&
        pyopencv_to(pyobj_arg4, arg4, ArgInfo("arg4", 0)) )
    {
        ERRWRAP2(_self_->apply(arg1, arg2, arg3, arg4));
        return pyopencv_from(arg3);
    }
    }
    PyErr_Clear();

    {
    int arg1=0;
    PyObject* pyobj_arg2 = NULL;
    Point arg2;
    PyObject* pyobj_arg3 = NULL;
    UMat arg3;
    PyObject* pyobj_arg4 = NULL;
    UMat arg4;

    const char* keywords[] = { "arg1", "arg2", "arg3", "arg4", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOOO:detail_NoExposureCompensator.apply", (char**)keywords, &arg1, &pyobj_arg2, &pyobj_arg3, &pyobj_arg4) &&
        pyopencv_to(pyobj_arg2, arg2, ArgInfo("arg2", 0)) &&
        pyopencv_to(pyobj_arg3, arg3, ArgInfo("arg3", 1)) &&
        pyopencv_to(pyobj_arg4, arg4, ArgInfo("arg4", 0)) )
    {
        ERRWRAP2(_self_->apply(arg1, arg2, arg3, arg4));
        return pyopencv_from(arg3);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_NoExposureCompensator_getMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::NoExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_NoExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_NoExposureCompensator' or its derivative)");
    Ptr<cv::detail::NoExposureCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_NoExposureCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:detail_NoExposureCompensator.getMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 1)) )
    {
        ERRWRAP2(_self_->getMatGains(umv));
        return pyopencv_from(umv);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_NoExposureCompensator_setMatGains(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::NoExposureCompensator> * self1 = 0;
    if (!pyopencv_detail_NoExposureCompensator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_NoExposureCompensator' or its derivative)");
    Ptr<cv::detail::NoExposureCompensator> _self_ = *(self1);
    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_NoExposureCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_umv = NULL;
    vector_Mat umv;

    const char* keywords[] = { "umv", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:detail_NoExposureCompensator.setMatGains", (char**)keywords, &pyobj_umv) &&
        pyopencv_to(pyobj_umv, umv, ArgInfo("umv", 0)) )
    {
        ERRWRAP2(_self_->setMatGains(umv));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (detail_NoExposureCompensator)

static PyGetSetDef pyopencv_detail_NoExposureCompensator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_NoExposureCompensator_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_NoExposureCompensator_apply, 0), "apply(arg1, arg2, arg3, arg4) -> arg3\n."},
    {"getMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_NoExposureCompensator_getMatGains, 0), "getMatGains([, umv]) -> umv\n."},
    {"setMatGains", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_NoExposureCompensator_setMatGains, 0), "setMatGains(umv) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_NoExposureCompensator)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::NoExposureCompensator> >
{
    static PyObject* from(const Ptr<cv::detail::NoExposureCompensator>& r)
    {
        return pyopencv_detail_NoExposureCompensator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::NoExposureCompensator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::NoExposureCompensator> * dst_;
        if (pyopencv_detail_NoExposureCompensator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::NoExposureCompensator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_NoSeamFinder (Generic)
//================================================================================

// GetSet (detail_NoSeamFinder)



// Methods (detail_NoSeamFinder)

static PyObject* pyopencv_cv_detail_detail_NoSeamFinder_find(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::NoSeamFinder> * self1 = 0;
    if (!pyopencv_detail_NoSeamFinder_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_NoSeamFinder' or its derivative)");
    Ptr<cv::detail::NoSeamFinder> _self_ = *(self1);
    PyObject* pyobj_arg1 = NULL;
    vector_UMat arg1;
    PyObject* pyobj_arg2 = NULL;
    vector_Point arg2;
    PyObject* pyobj_arg3 = NULL;
    vector_UMat arg3;

    const char* keywords[] = { "arg1", "arg2", "arg3", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_NoSeamFinder.find", (char**)keywords, &pyobj_arg1, &pyobj_arg2, &pyobj_arg3) &&
        pyopencv_to(pyobj_arg1, arg1, ArgInfo("arg1", 0)) &&
        pyopencv_to(pyobj_arg2, arg2, ArgInfo("arg2", 0)) &&
        pyopencv_to(pyobj_arg3, arg3, ArgInfo("arg3", 1)) )
    {
        ERRWRAP2(_self_->find(arg1, arg2, arg3));
        return pyopencv_from(arg3);
    }

    return NULL;
}



// Tables (detail_NoSeamFinder)

static PyGetSetDef pyopencv_detail_NoSeamFinder_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_NoSeamFinder_methods[] =
{
    {"find", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_NoSeamFinder_find, 0), "find(arg1, arg2, arg3) -> arg3\n."},

    {NULL,          NULL}
};

// Converter (detail_NoSeamFinder)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::NoSeamFinder> >
{
    static PyObject* from(const Ptr<cv::detail::NoSeamFinder>& r)
    {
        return pyopencv_detail_NoSeamFinder_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::NoSeamFinder>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::NoSeamFinder> * dst_;
        if (pyopencv_detail_NoSeamFinder_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::NoSeamFinder> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_PairwiseSeamFinder (Generic)
//================================================================================

// GetSet (detail_PairwiseSeamFinder)



// Methods (detail_PairwiseSeamFinder)

static PyObject* pyopencv_cv_detail_detail_PairwiseSeamFinder_find(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::PairwiseSeamFinder> * self1 = 0;
    if (!pyopencv_detail_PairwiseSeamFinder_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_PairwiseSeamFinder' or its derivative)");
    Ptr<cv::detail::PairwiseSeamFinder> _self_ = *(self1);
    PyObject* pyobj_src = NULL;
    vector_UMat src;
    PyObject* pyobj_corners = NULL;
    vector_Point corners;
    PyObject* pyobj_masks = NULL;
    vector_UMat masks;

    const char* keywords[] = { "src", "corners", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_PairwiseSeamFinder.find", (char**)keywords, &pyobj_src, &pyobj_corners, &pyobj_masks) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_corners, corners, ArgInfo("corners", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 1)) )
    {
        ERRWRAP2(_self_->find(src, corners, masks));
        return pyopencv_from(masks);
    }

    return NULL;
}



// Tables (detail_PairwiseSeamFinder)

static PyGetSetDef pyopencv_detail_PairwiseSeamFinder_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_PairwiseSeamFinder_methods[] =
{
    {"find", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_PairwiseSeamFinder_find, 0), "find(src, corners, masks) -> masks\n."},

    {NULL,          NULL}
};

// Converter (detail_PairwiseSeamFinder)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::PairwiseSeamFinder> >
{
    static PyObject* from(const Ptr<cv::detail::PairwiseSeamFinder>& r)
    {
        return pyopencv_detail_PairwiseSeamFinder_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::PairwiseSeamFinder>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::PairwiseSeamFinder> * dst_;
        if (pyopencv_detail_PairwiseSeamFinder_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::PairwiseSeamFinder> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_ProjectorBase (Generic)
//================================================================================

// GetSet (detail_ProjectorBase)



// Methods (detail_ProjectorBase)



// Tables (detail_ProjectorBase)

static PyGetSetDef pyopencv_detail_ProjectorBase_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_ProjectorBase_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_ProjectorBase)

template<>
struct PyOpenCV_Converter< cv::detail::ProjectorBase >
{
    static PyObject* from(const cv::detail::ProjectorBase& r)
    {
        return pyopencv_detail_ProjectorBase_Instance(r);
    }
    static bool to(PyObject* src, cv::detail::ProjectorBase& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::detail::ProjectorBase * dst_;
        if (pyopencv_detail_ProjectorBase_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::detail::ProjectorBase for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_SeamFinder (Generic)
//================================================================================

// GetSet (detail_SeamFinder)



// Methods (detail_SeamFinder)

static PyObject* pyopencv_cv_detail_detail_SeamFinder_createDefault_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    int type=0;
    Ptr<SeamFinder> retval;

    const char* keywords[] = { "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:detail_SeamFinder.createDefault", (char**)keywords, &type) )
    {
        ERRWRAP2(retval = cv::detail::SeamFinder::createDefault(type));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_SeamFinder_find(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::SeamFinder> * self1 = 0;
    if (!pyopencv_detail_SeamFinder_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_SeamFinder' or its derivative)");
    Ptr<cv::detail::SeamFinder> _self_ = *(self1);
    PyObject* pyobj_src = NULL;
    vector_UMat src;
    PyObject* pyobj_corners = NULL;
    vector_Point corners;
    PyObject* pyobj_masks = NULL;
    vector_UMat masks;

    const char* keywords[] = { "src", "corners", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_SeamFinder.find", (char**)keywords, &pyobj_src, &pyobj_corners, &pyobj_masks) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_corners, corners, ArgInfo("corners", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 1)) )
    {
        ERRWRAP2(_self_->find(src, corners, masks));
        return pyopencv_from(masks);
    }

    return NULL;
}



// Tables (detail_SeamFinder)

static PyGetSetDef pyopencv_detail_SeamFinder_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_SeamFinder_methods[] =
{
    {"createDefault", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_SeamFinder_createDefault_static, METH_STATIC), "createDefault(type) -> retval\n."},
    {"find", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_SeamFinder_find, 0), "find(src, corners, masks) -> masks\n.   @brief Estimates seams.\n.   \n.       @param src Source images\n.       @param corners Source image top-left corners\n.       @param masks Source image masks to update"},

    {NULL,          NULL}
};

// Converter (detail_SeamFinder)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::SeamFinder> >
{
    static PyObject* from(const Ptr<cv::detail::SeamFinder>& r)
    {
        return pyopencv_detail_SeamFinder_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::SeamFinder>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::SeamFinder> * dst_;
        if (pyopencv_detail_SeamFinder_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::SeamFinder> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_SphericalProjector (Generic)
//================================================================================

// GetSet (detail_SphericalProjector)



// Methods (detail_SphericalProjector)

static PyObject* pyopencv_cv_detail_detail_SphericalProjector_mapBackward(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    cv::detail::SphericalProjector * self1 = 0;
    if (!pyopencv_detail_SphericalProjector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_SphericalProjector' or its derivative)");
    cv::detail::SphericalProjector* _self_ = (self1);
    float u=0.f;
    float v=0.f;
    float x=0.f;
    float y=0.f;

    const char* keywords[] = { "u", "v", "x", "y", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ffff:detail_SphericalProjector.mapBackward", (char**)keywords, &u, &v, &x, &y) )
    {
        ERRWRAP2(_self_->mapBackward(u, v, x, y));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_SphericalProjector_mapForward(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    cv::detail::SphericalProjector * self1 = 0;
    if (!pyopencv_detail_SphericalProjector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_SphericalProjector' or its derivative)");
    cv::detail::SphericalProjector* _self_ = (self1);
    float x=0.f;
    float y=0.f;
    float u=0.f;
    float v=0.f;

    const char* keywords[] = { "x", "y", "u", "v", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ffff:detail_SphericalProjector.mapForward", (char**)keywords, &x, &y, &u, &v) )
    {
        ERRWRAP2(_self_->mapForward(x, y, u, v));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (detail_SphericalProjector)

static PyGetSetDef pyopencv_detail_SphericalProjector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_SphericalProjector_methods[] =
{
    {"mapBackward", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_SphericalProjector_mapBackward, 0), "mapBackward(u, v, x, y) -> None\n."},
    {"mapForward", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_SphericalProjector_mapForward, 0), "mapForward(x, y, u, v) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_SphericalProjector)

template<>
struct PyOpenCV_Converter< cv::detail::SphericalProjector >
{
    static PyObject* from(const cv::detail::SphericalProjector& r)
    {
        return pyopencv_detail_SphericalProjector_Instance(r);
    }
    static bool to(PyObject* src, cv::detail::SphericalProjector& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::detail::SphericalProjector * dst_;
        if (pyopencv_detail_SphericalProjector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::detail::SphericalProjector for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_Timelapser (Generic)
//================================================================================

// GetSet (detail_Timelapser)



// Methods (detail_Timelapser)

static PyObject* pyopencv_cv_detail_detail_Timelapser_createDefault_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;

    int type=0;
    Ptr<Timelapser> retval;

    const char* keywords[] = { "type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:detail_Timelapser.createDefault", (char**)keywords, &type) )
    {
        ERRWRAP2(retval = cv::detail::Timelapser::createDefault(type));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_Timelapser_getDst(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::Timelapser> * self1 = 0;
    if (!pyopencv_detail_Timelapser_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_Timelapser' or its derivative)");
    Ptr<cv::detail::Timelapser> _self_ = *(self1);
    UMat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDst());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_Timelapser_initialize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::Timelapser> * self1 = 0;
    if (!pyopencv_detail_Timelapser_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_Timelapser' or its derivative)");
    Ptr<cv::detail::Timelapser> _self_ = *(self1);
    PyObject* pyobj_corners = NULL;
    vector_Point corners;
    PyObject* pyobj_sizes = NULL;
    vector_Size sizes;

    const char* keywords[] = { "corners", "sizes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:detail_Timelapser.initialize", (char**)keywords, &pyobj_corners, &pyobj_sizes) &&
        pyopencv_to(pyobj_corners, corners, ArgInfo("corners", 0)) &&
        pyopencv_to(pyobj_sizes, sizes, ArgInfo("sizes", 0)) )
    {
        ERRWRAP2(_self_->initialize(corners, sizes));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_detail_detail_Timelapser_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::Timelapser> * self1 = 0;
    if (!pyopencv_detail_Timelapser_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_Timelapser' or its derivative)");
    Ptr<cv::detail::Timelapser> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_tl = NULL;
    Point tl;

    const char* keywords[] = { "img", "mask", "tl", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_Timelapser.process", (char**)keywords, &pyobj_img, &pyobj_mask, &pyobj_tl) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_tl, tl, ArgInfo("tl", 0)) )
    {
        ERRWRAP2(_self_->process(img, mask, tl));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    PyObject* pyobj_tl = NULL;
    Point tl;

    const char* keywords[] = { "img", "mask", "tl", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_Timelapser.process", (char**)keywords, &pyobj_img, &pyobj_mask, &pyobj_tl) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_tl, tl, ArgInfo("tl", 0)) )
    {
        ERRWRAP2(_self_->process(img, mask, tl));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (detail_Timelapser)

static PyGetSetDef pyopencv_detail_Timelapser_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_Timelapser_methods[] =
{
    {"createDefault", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Timelapser_createDefault_static, METH_STATIC), "createDefault(type) -> retval\n."},
    {"getDst", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Timelapser_getDst, 0), "getDst() -> retval\n."},
    {"initialize", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Timelapser_initialize, 0), "initialize(corners, sizes) -> None\n."},
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_Timelapser_process, 0), "process(img, mask, tl) -> None\n."},

    {NULL,          NULL}
};

// Converter (detail_Timelapser)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::Timelapser> >
{
    static PyObject* from(const Ptr<cv::detail::Timelapser>& r)
    {
        return pyopencv_detail_Timelapser_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::Timelapser>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::Timelapser> * dst_;
        if (pyopencv_detail_Timelapser_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::Timelapser> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_TimelapserCrop (Generic)
//================================================================================

// GetSet (detail_TimelapserCrop)



// Methods (detail_TimelapserCrop)



// Tables (detail_TimelapserCrop)

static PyGetSetDef pyopencv_detail_TimelapserCrop_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_TimelapserCrop_methods[] =
{

    {NULL,          NULL}
};

// Converter (detail_TimelapserCrop)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::TimelapserCrop> >
{
    static PyObject* from(const Ptr<cv::detail::TimelapserCrop>& r)
    {
        return pyopencv_detail_TimelapserCrop_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::TimelapserCrop>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::TimelapserCrop> * dst_;
        if (pyopencv_detail_TimelapserCrop_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::TimelapserCrop> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// detail_VoronoiSeamFinder (Generic)
//================================================================================

// GetSet (detail_VoronoiSeamFinder)



// Methods (detail_VoronoiSeamFinder)

static PyObject* pyopencv_cv_detail_detail_VoronoiSeamFinder_find(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::detail;


    Ptr<cv::detail::VoronoiSeamFinder> * self1 = 0;
    if (!pyopencv_detail_VoronoiSeamFinder_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'detail_VoronoiSeamFinder' or its derivative)");
    Ptr<cv::detail::VoronoiSeamFinder> _self_ = *(self1);
    PyObject* pyobj_src = NULL;
    vector_UMat src;
    PyObject* pyobj_corners = NULL;
    vector_Point corners;
    PyObject* pyobj_masks = NULL;
    vector_UMat masks;

    const char* keywords[] = { "src", "corners", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:detail_VoronoiSeamFinder.find", (char**)keywords, &pyobj_src, &pyobj_corners, &pyobj_masks) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_corners, corners, ArgInfo("corners", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 1)) )
    {
        ERRWRAP2(_self_->find(src, corners, masks));
        return pyopencv_from(masks);
    }

    return NULL;
}



// Tables (detail_VoronoiSeamFinder)

static PyGetSetDef pyopencv_detail_VoronoiSeamFinder_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_detail_VoronoiSeamFinder_methods[] =
{
    {"find", CV_PY_FN_WITH_KW_(pyopencv_cv_detail_detail_VoronoiSeamFinder_find, 0), "find(src, corners, masks) -> masks\n."},

    {NULL,          NULL}
};

// Converter (detail_VoronoiSeamFinder)

template<>
struct PyOpenCV_Converter< Ptr<cv::detail::VoronoiSeamFinder> >
{
    static PyObject* from(const Ptr<cv::detail::VoronoiSeamFinder>& r)
    {
        return pyopencv_detail_VoronoiSeamFinder_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::detail::VoronoiSeamFinder>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::detail::VoronoiSeamFinder> * dst_;
        if (pyopencv_detail_VoronoiSeamFinder_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::detail::VoronoiSeamFinder> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// dnn_DictValue (Generic)
//================================================================================

// GetSet (dnn_DictValue)



// Methods (dnn_DictValue)

static int pyopencv_cv_dnn_dnn_DictValue_DictValue(pyopencv_dnn_DictValue_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;

    {
    int i=0;

    const char* keywords[] = { "i", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:DictValue", (char**)keywords, &i) )
    {
        new (&(self->v)) Ptr<cv::dnn::DictValue>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::dnn::DictValue(i)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    double p=0;

    const char* keywords[] = { "p", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:DictValue", (char**)keywords, &p) )
    {
        new (&(self->v)) Ptr<cv::dnn::DictValue>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::dnn::DictValue(p)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_s = NULL;
    String s;

    const char* keywords[] = { "s", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:DictValue", (char**)keywords, &pyobj_s) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) )
    {
        new (&(self->v)) Ptr<cv::dnn::DictValue>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::dnn::DictValue(s)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_dnn_dnn_DictValue_getIntValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!pyopencv_dnn_DictValue_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_DictValue' or its derivative)");
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    int idx=-1;
    int retval;

    const char* keywords[] = { "idx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:dnn_DictValue.getIntValue", (char**)keywords, &idx) )
    {
        ERRWRAP2(retval = _self_->getIntValue(idx));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_DictValue_getRealValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!pyopencv_dnn_DictValue_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_DictValue' or its derivative)");
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    int idx=-1;
    double retval;

    const char* keywords[] = { "idx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:dnn_DictValue.getRealValue", (char**)keywords, &idx) )
    {
        ERRWRAP2(retval = _self_->getRealValue(idx));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_DictValue_getStringValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!pyopencv_dnn_DictValue_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_DictValue' or its derivative)");
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    int idx=-1;
    String retval;

    const char* keywords[] = { "idx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:dnn_DictValue.getStringValue", (char**)keywords, &idx) )
    {
        ERRWRAP2(retval = _self_->getStringValue(idx));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_DictValue_isInt(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!pyopencv_dnn_DictValue_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_DictValue' or its derivative)");
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isInt());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_DictValue_isReal(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!pyopencv_dnn_DictValue_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_DictValue' or its derivative)");
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isReal());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_DictValue_isString(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::DictValue> * self1 = 0;
    if (!pyopencv_dnn_DictValue_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_DictValue' or its derivative)");
    Ptr<cv::dnn::DictValue> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isString());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (dnn_DictValue)

static PyGetSetDef pyopencv_dnn_DictValue_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_dnn_DictValue_methods[] =
{
    {"getIntValue", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_DictValue_getIntValue, 0), "getIntValue([, idx]) -> retval\n."},
    {"getRealValue", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_DictValue_getRealValue, 0), "getRealValue([, idx]) -> retval\n."},
    {"getStringValue", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_DictValue_getStringValue, 0), "getStringValue([, idx]) -> retval\n."},
    {"isInt", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_DictValue_isInt, 0), "isInt() -> retval\n."},
    {"isReal", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_DictValue_isReal, 0), "isReal() -> retval\n."},
    {"isString", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_DictValue_isString, 0), "isString() -> retval\n."},

    {NULL,          NULL}
};

// Converter (dnn_DictValue)

template<>
struct PyOpenCV_Converter< Ptr<cv::dnn::DictValue> >
{
    static PyObject* from(const Ptr<cv::dnn::DictValue>& r)
    {
        return pyopencv_dnn_DictValue_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::dnn::DictValue>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::dnn::DictValue> * dst_;
        if (pyopencv_dnn_DictValue_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::dnn::DictValue> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// dnn_Layer (Generic)
//================================================================================

// GetSet (dnn_Layer)


static PyObject* pyopencv_dnn_Layer_get_blobs(pyopencv_dnn_Layer_t* p, void *closure)
{
    cv::dnn::Layer* _self_ = dynamic_cast<cv::dnn::Layer*>(p->v.get());
    if (!_self_)
        return failmsgp("Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    return pyopencv_from(_self_->blobs);
}

static int pyopencv_dnn_Layer_set_blobs(pyopencv_dnn_Layer_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the blobs attribute");
        return -1;
    }
    cv::dnn::Layer* _self_ = dynamic_cast<cv::dnn::Layer*>(p->v.get());
    if (!_self_)
    {
        failmsgp("Incorrect type of object (must be 'dnn_Layer' or its derivative)");
        return -1;
    }
    return pyopencv_to(value, _self_->blobs) ? 0 : -1;
}

static PyObject* pyopencv_dnn_Layer_get_name(pyopencv_dnn_Layer_t* p, void *closure)
{
    cv::dnn::Layer* _self_ = dynamic_cast<cv::dnn::Layer*>(p->v.get());
    if (!_self_)
        return failmsgp("Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    return pyopencv_from(_self_->name);
}

static PyObject* pyopencv_dnn_Layer_get_preferableTarget(pyopencv_dnn_Layer_t* p, void *closure)
{
    cv::dnn::Layer* _self_ = dynamic_cast<cv::dnn::Layer*>(p->v.get());
    if (!_self_)
        return failmsgp("Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    return pyopencv_from(_self_->preferableTarget);
}

static PyObject* pyopencv_dnn_Layer_get_type(pyopencv_dnn_Layer_t* p, void *closure)
{
    cv::dnn::Layer* _self_ = dynamic_cast<cv::dnn::Layer*>(p->v.get());
    if (!_self_)
        return failmsgp("Incorrect type of object (must be 'dnn_Layer' or its derivative)");
    return pyopencv_from(_self_->type);
}


// Methods (dnn_Layer)

static PyObject* pyopencv_cv_dnn_dnn_Layer_finalize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!pyopencv_dnn_Layer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Layer' or its derivative)");
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    {
    PyObject* pyobj_inputs = NULL;
    vector_Mat inputs;
    PyObject* pyobj_outputs = NULL;
    vector_Mat outputs;

    const char* keywords[] = { "inputs", "outputs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:dnn_Layer.finalize", (char**)keywords, &pyobj_inputs, &pyobj_outputs) &&
        pyopencv_to(pyobj_inputs, inputs, ArgInfo("inputs", 0)) &&
        pyopencv_to(pyobj_outputs, outputs, ArgInfo("outputs", 1)) )
    {
        ERRWRAP2(_self_->finalize(inputs, outputs));
        return pyopencv_from(outputs);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputs = NULL;
    vector_Mat inputs;
    PyObject* pyobj_outputs = NULL;
    vector_Mat outputs;

    const char* keywords[] = { "inputs", "outputs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:dnn_Layer.finalize", (char**)keywords, &pyobj_inputs, &pyobj_outputs) &&
        pyopencv_to(pyobj_inputs, inputs, ArgInfo("inputs", 0)) &&
        pyopencv_to(pyobj_outputs, outputs, ArgInfo("outputs", 1)) )
    {
        ERRWRAP2(_self_->finalize(inputs, outputs));
        return pyopencv_from(outputs);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Layer_outputNameToIndex(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!pyopencv_dnn_Layer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Layer' or its derivative)");
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    PyObject* pyobj_outputName = NULL;
    String outputName;
    int retval;

    const char* keywords[] = { "outputName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Layer.outputNameToIndex", (char**)keywords, &pyobj_outputName) &&
        pyopencv_to(pyobj_outputName, outputName, ArgInfo("outputName", 0)) )
    {
        ERRWRAP2(retval = _self_->outputNameToIndex(outputName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Layer_run(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    Ptr<cv::dnn::Layer> * self1 = 0;
    if (!pyopencv_dnn_Layer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Layer' or its derivative)");
    Ptr<cv::dnn::Layer> _self_ = *(self1);
    {
    PyObject* pyobj_inputs = NULL;
    vector_Mat inputs;
    PyObject* pyobj_outputs = NULL;
    vector_Mat outputs;
    PyObject* pyobj_internals = NULL;
    vector_Mat internals;

    const char* keywords[] = { "inputs", "internals", "outputs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:dnn_Layer.run", (char**)keywords, &pyobj_inputs, &pyobj_internals, &pyobj_outputs) &&
        pyopencv_to(pyobj_inputs, inputs, ArgInfo("inputs", 0)) &&
        pyopencv_to(pyobj_outputs, outputs, ArgInfo("outputs", 1)) &&
        pyopencv_to(pyobj_internals, internals, ArgInfo("internals", 1)) )
    {
        ERRWRAP2(_self_->run(inputs, outputs, internals));
        return Py_BuildValue("(NN)", pyopencv_from(outputs), pyopencv_from(internals));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputs = NULL;
    vector_Mat inputs;
    PyObject* pyobj_outputs = NULL;
    vector_Mat outputs;
    PyObject* pyobj_internals = NULL;
    vector_Mat internals;

    const char* keywords[] = { "inputs", "internals", "outputs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:dnn_Layer.run", (char**)keywords, &pyobj_inputs, &pyobj_internals, &pyobj_outputs) &&
        pyopencv_to(pyobj_inputs, inputs, ArgInfo("inputs", 0)) &&
        pyopencv_to(pyobj_outputs, outputs, ArgInfo("outputs", 1)) &&
        pyopencv_to(pyobj_internals, internals, ArgInfo("internals", 1)) )
    {
        ERRWRAP2(_self_->run(inputs, outputs, internals));
        return Py_BuildValue("(NN)", pyopencv_from(outputs), pyopencv_from(internals));
    }
    }

    return NULL;
}



// Tables (dnn_Layer)

static PyGetSetDef pyopencv_dnn_Layer_getseters[] =
{
    {(char*)"blobs", (getter)pyopencv_dnn_Layer_get_blobs, (setter)pyopencv_dnn_Layer_set_blobs, (char*)"blobs", NULL},
    {(char*)"name", (getter)pyopencv_dnn_Layer_get_name, NULL, (char*)"name", NULL},
    {(char*)"preferableTarget", (getter)pyopencv_dnn_Layer_get_preferableTarget, NULL, (char*)"preferableTarget", NULL},
    {(char*)"type", (getter)pyopencv_dnn_Layer_get_type, NULL, (char*)"type", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_dnn_Layer_methods[] =
{
    {"finalize", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Layer_finalize, 0), "finalize(inputs[, outputs]) -> outputs\n.   @brief Computes and sets internal parameters according to inputs, outputs and blobs.\n.            *  @param[in]  inputs  vector of already allocated input blobs\n.            *  @param[out] outputs vector of already allocated output blobs\n.            *\n.            * If this method is called after network has allocated all memory for input and output blobs\n.            * and before inferencing."},
    {"outputNameToIndex", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Layer_outputNameToIndex, 0), "outputNameToIndex(outputName) -> retval\n.   @brief Returns index of output blob in output array.\n.            *  @see inputNameToIndex()"},
    {"run", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Layer_run, 0), "run(inputs, internals[, outputs]) -> outputs, internals\n.   @brief Allocates layer and computes output.\n.            *  @deprecated This method will be removed in the future release."},

    {NULL,          NULL}
};

// Converter (dnn_Layer)

template<>
struct PyOpenCV_Converter< Ptr<cv::dnn::Layer> >
{
    static PyObject* from(const Ptr<cv::dnn::Layer>& r)
    {
        return pyopencv_dnn_Layer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::dnn::Layer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::dnn::Layer> * dst_;
        if (pyopencv_dnn_Layer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::dnn::Layer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// dnn_Net (Generic)
//================================================================================

// GetSet (dnn_Net)



// Methods (dnn_Net)

static int pyopencv_cv_dnn_dnn_Net_Net(pyopencv_dnn_Net_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::dnn::Net());
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_connect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_outPin = NULL;
    String outPin;
    PyObject* pyobj_inpPin = NULL;
    String inpPin;

    const char* keywords[] = { "outPin", "inpPin", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:dnn_Net.connect", (char**)keywords, &pyobj_outPin, &pyobj_inpPin) &&
        pyopencv_to(pyobj_outPin, outPin, ArgInfo("outPin", 0)) &&
        pyopencv_to(pyobj_inpPin, inpPin, ArgInfo("inpPin", 0)) )
    {
        ERRWRAP2(_self_->connect(outPin, inpPin));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_dump(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->dump());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_dumpToFile(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_path = NULL;
    String path;

    const char* keywords[] = { "path", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.dumpToFile", (char**)keywords, &pyobj_path) &&
        pyopencv_to(pyobj_path, path, ArgInfo("path", 0)) )
    {
        ERRWRAP2(_self_->dumpToFile(path));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_enableFusion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    bool fusion=0;

    const char* keywords[] = { "fusion", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:dnn_Net.enableFusion", (char**)keywords, &fusion) )
    {
        ERRWRAP2(_self_->enableFusion(fusion));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_forward(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    {
    PyObject* pyobj_outputName = NULL;
    String outputName;
    Mat retval;

    const char* keywords[] = { "outputName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:dnn_Net.forward", (char**)keywords, &pyobj_outputName) &&
        pyopencv_to(pyobj_outputName, outputName, ArgInfo("outputName", 0)) )
    {
        ERRWRAP2(retval = _self_->forward(outputName));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_outputBlobs = NULL;
    vector_Mat outputBlobs;
    PyObject* pyobj_outputName = NULL;
    String outputName;

    const char* keywords[] = { "outputBlobs", "outputName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:dnn_Net.forward", (char**)keywords, &pyobj_outputBlobs, &pyobj_outputName) &&
        pyopencv_to(pyobj_outputBlobs, outputBlobs, ArgInfo("outputBlobs", 1)) &&
        pyopencv_to(pyobj_outputName, outputName, ArgInfo("outputName", 0)) )
    {
        ERRWRAP2(_self_->forward(outputBlobs, outputName));
        return pyopencv_from(outputBlobs);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_outputBlobs = NULL;
    vector_Mat outputBlobs;
    PyObject* pyobj_outputName = NULL;
    String outputName;

    const char* keywords[] = { "outputBlobs", "outputName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:dnn_Net.forward", (char**)keywords, &pyobj_outputBlobs, &pyobj_outputName) &&
        pyopencv_to(pyobj_outputBlobs, outputBlobs, ArgInfo("outputBlobs", 1)) &&
        pyopencv_to(pyobj_outputName, outputName, ArgInfo("outputName", 0)) )
    {
        ERRWRAP2(_self_->forward(outputBlobs, outputName));
        return pyopencv_from(outputBlobs);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_outputBlobs = NULL;
    vector_Mat outputBlobs;
    PyObject* pyobj_outBlobNames = NULL;
    vector_String outBlobNames;

    const char* keywords[] = { "outBlobNames", "outputBlobs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:dnn_Net.forward", (char**)keywords, &pyobj_outBlobNames, &pyobj_outputBlobs) &&
        pyopencv_to(pyobj_outputBlobs, outputBlobs, ArgInfo("outputBlobs", 1)) &&
        pyopencv_to(pyobj_outBlobNames, outBlobNames, ArgInfo("outBlobNames", 0)) )
    {
        ERRWRAP2(_self_->forward(outputBlobs, outBlobNames));
        return pyopencv_from(outputBlobs);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_outputBlobs = NULL;
    vector_Mat outputBlobs;
    PyObject* pyobj_outBlobNames = NULL;
    vector_String outBlobNames;

    const char* keywords[] = { "outBlobNames", "outputBlobs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:dnn_Net.forward", (char**)keywords, &pyobj_outBlobNames, &pyobj_outputBlobs) &&
        pyopencv_to(pyobj_outputBlobs, outputBlobs, ArgInfo("outputBlobs", 1)) &&
        pyopencv_to(pyobj_outBlobNames, outBlobNames, ArgInfo("outBlobNames", 0)) )
    {
        ERRWRAP2(_self_->forward(outputBlobs, outBlobNames));
        return pyopencv_from(outputBlobs);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_forwardAndRetrieve(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    vector_vector_Mat outputBlobs;
    PyObject* pyobj_outBlobNames = NULL;
    vector_String outBlobNames;

    const char* keywords[] = { "outBlobNames", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.forwardAndRetrieve", (char**)keywords, &pyobj_outBlobNames) &&
        pyopencv_to(pyobj_outBlobNames, outBlobNames, ArgInfo("outBlobNames", 0)) )
    {
        ERRWRAP2(_self_->forward(outputBlobs, outBlobNames));
        return pyopencv_from(outputBlobs);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_forwardAsync(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_outputName = NULL;
    String outputName;
    AsyncArray retval;

    const char* keywords[] = { "outputName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:dnn_Net.forwardAsync", (char**)keywords, &pyobj_outputName) &&
        pyopencv_to(pyobj_outputName, outputName, ArgInfo("outputName", 0)) )
    {
        ERRWRAP2(retval = _self_->forwardAsync(outputName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getFLOPS(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    {
    PyObject* pyobj_netInputShapes = NULL;
    vector_MatShape netInputShapes;
    int64 retval;

    const char* keywords[] = { "netInputShapes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.getFLOPS", (char**)keywords, &pyobj_netInputShapes) &&
        pyopencv_to(pyobj_netInputShapes, netInputShapes, ArgInfo("netInputShapes", 0)) )
    {
        ERRWRAP2(retval = _self_->getFLOPS(netInputShapes));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_netInputShape = NULL;
    MatShape netInputShape;
    int64 retval;

    const char* keywords[] = { "netInputShape", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.getFLOPS", (char**)keywords, &pyobj_netInputShape) &&
        pyopencv_to(pyobj_netInputShape, netInputShape, ArgInfo("netInputShape", 0)) )
    {
        ERRWRAP2(retval = _self_->getFLOPS(netInputShape));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    int layerId=0;
    PyObject* pyobj_netInputShapes = NULL;
    vector_MatShape netInputShapes;
    int64 retval;

    const char* keywords[] = { "layerId", "netInputShapes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO:dnn_Net.getFLOPS", (char**)keywords, &layerId, &pyobj_netInputShapes) &&
        pyopencv_to(pyobj_netInputShapes, netInputShapes, ArgInfo("netInputShapes", 0)) )
    {
        ERRWRAP2(retval = _self_->getFLOPS(layerId, netInputShapes));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    int layerId=0;
    PyObject* pyobj_netInputShape = NULL;
    MatShape netInputShape;
    int64 retval;

    const char* keywords[] = { "layerId", "netInputShape", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO:dnn_Net.getFLOPS", (char**)keywords, &layerId, &pyobj_netInputShape) &&
        pyopencv_to(pyobj_netInputShape, netInputShape, ArgInfo("netInputShape", 0)) )
    {
        ERRWRAP2(retval = _self_->getFLOPS(layerId, netInputShape));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getLayer(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_layerId = NULL;
    LayerId layerId;
    Ptr<Layer> retval;

    const char* keywords[] = { "layerId", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.getLayer", (char**)keywords, &pyobj_layerId) &&
        pyopencv_to(pyobj_layerId, layerId, ArgInfo("layerId", 0)) )
    {
        ERRWRAP2(retval = _self_->getLayer(layerId));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getLayerId(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_layer = NULL;
    String layer;
    int retval;

    const char* keywords[] = { "layer", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.getLayerId", (char**)keywords, &pyobj_layer) &&
        pyopencv_to(pyobj_layer, layer, ArgInfo("layer", 0)) )
    {
        ERRWRAP2(retval = _self_->getLayerId(layer));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getLayerNames(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    std::vector<String> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLayerNames());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getLayerTypes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    vector_String layersTypes;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->getLayerTypes(layersTypes));
        return pyopencv_from(layersTypes);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getLayersCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_layerType = NULL;
    String layerType;
    int retval;

    const char* keywords[] = { "layerType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.getLayersCount", (char**)keywords, &pyobj_layerType) &&
        pyopencv_to(pyobj_layerType, layerType, ArgInfo("layerType", 0)) )
    {
        ERRWRAP2(retval = _self_->getLayersCount(layerType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getLayersShapes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    {
    PyObject* pyobj_netInputShapes = NULL;
    vector_MatShape netInputShapes;
    vector_int layersIds;
    vector_vector_MatShape inLayersShapes;
    vector_vector_MatShape outLayersShapes;

    const char* keywords[] = { "netInputShapes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.getLayersShapes", (char**)keywords, &pyobj_netInputShapes) &&
        pyopencv_to(pyobj_netInputShapes, netInputShapes, ArgInfo("netInputShapes", 0)) )
    {
        ERRWRAP2(_self_->getLayersShapes(netInputShapes, layersIds, inLayersShapes, outLayersShapes));
        return Py_BuildValue("(NNN)", pyopencv_from(layersIds), pyopencv_from(inLayersShapes), pyopencv_from(outLayersShapes));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_netInputShape = NULL;
    MatShape netInputShape;
    vector_int layersIds;
    vector_vector_MatShape inLayersShapes;
    vector_vector_MatShape outLayersShapes;

    const char* keywords[] = { "netInputShape", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.getLayersShapes", (char**)keywords, &pyobj_netInputShape) &&
        pyopencv_to(pyobj_netInputShape, netInputShape, ArgInfo("netInputShape", 0)) )
    {
        ERRWRAP2(_self_->getLayersShapes(netInputShape, layersIds, inLayersShapes, outLayersShapes));
        return Py_BuildValue("(NNN)", pyopencv_from(layersIds), pyopencv_from(inLayersShapes), pyopencv_from(outLayersShapes));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getMemoryConsumption(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    {
    PyObject* pyobj_netInputShape = NULL;
    MatShape netInputShape;
    size_t weights;
    size_t blobs;

    const char* keywords[] = { "netInputShape", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.getMemoryConsumption", (char**)keywords, &pyobj_netInputShape) &&
        pyopencv_to(pyobj_netInputShape, netInputShape, ArgInfo("netInputShape", 0)) )
    {
        ERRWRAP2(_self_->getMemoryConsumption(netInputShape, weights, blobs));
        return Py_BuildValue("(NN)", pyopencv_from(weights), pyopencv_from(blobs));
    }
    }
    PyErr_Clear();

    {
    int layerId=0;
    PyObject* pyobj_netInputShapes = NULL;
    vector_MatShape netInputShapes;
    size_t weights;
    size_t blobs;

    const char* keywords[] = { "layerId", "netInputShapes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO:dnn_Net.getMemoryConsumption", (char**)keywords, &layerId, &pyobj_netInputShapes) &&
        pyopencv_to(pyobj_netInputShapes, netInputShapes, ArgInfo("netInputShapes", 0)) )
    {
        ERRWRAP2(_self_->getMemoryConsumption(layerId, netInputShapes, weights, blobs));
        return Py_BuildValue("(NN)", pyopencv_from(weights), pyopencv_from(blobs));
    }
    }
    PyErr_Clear();

    {
    int layerId=0;
    PyObject* pyobj_netInputShape = NULL;
    MatShape netInputShape;
    size_t weights;
    size_t blobs;

    const char* keywords[] = { "layerId", "netInputShape", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO:dnn_Net.getMemoryConsumption", (char**)keywords, &layerId, &pyobj_netInputShape) &&
        pyopencv_to(pyobj_netInputShape, netInputShape, ArgInfo("netInputShape", 0)) )
    {
        ERRWRAP2(_self_->getMemoryConsumption(layerId, netInputShape, weights, blobs));
        return Py_BuildValue("(NN)", pyopencv_from(weights), pyopencv_from(blobs));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getParam(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_layer = NULL;
    LayerId layer;
    int numParam=0;
    Mat retval;

    const char* keywords[] = { "layer", "numParam", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:dnn_Net.getParam", (char**)keywords, &pyobj_layer, &numParam) &&
        pyopencv_to(pyobj_layer, layer, ArgInfo("layer", 0)) )
    {
        ERRWRAP2(retval = _self_->getParam(layer, numParam));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getPerfProfile(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    vector_double timings;
    int64 retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPerfProfile(timings));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(timings));
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getUnconnectedOutLayers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    std::vector<int> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUnconnectedOutLayers());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_getUnconnectedOutLayersNames(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    std::vector<String> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUnconnectedOutLayersNames());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_readFromModelOptimizer_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;

    PyObject* pyobj_xml = NULL;
    String xml;
    PyObject* pyobj_bin = NULL;
    String bin;
    Net retval;

    const char* keywords[] = { "xml", "bin", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:dnn_Net.readFromModelOptimizer", (char**)keywords, &pyobj_xml, &pyobj_bin) &&
        pyopencv_to(pyobj_xml, xml, ArgInfo("xml", 0)) &&
        pyopencv_to(pyobj_bin, bin, ArgInfo("bin", 0)) )
    {
        ERRWRAP2(retval = cv::dnn::Net::readFromModelOptimizer(xml, bin));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_setHalideScheduler(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_scheduler = NULL;
    String scheduler;

    const char* keywords[] = { "scheduler", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.setHalideScheduler", (char**)keywords, &pyobj_scheduler) &&
        pyopencv_to(pyobj_scheduler, scheduler, ArgInfo("scheduler", 0)) )
    {
        ERRWRAP2(_self_->setHalideScheduler(scheduler));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_setInput(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    {
    PyObject* pyobj_blob = NULL;
    Mat blob;
    PyObject* pyobj_name = NULL;
    String name="";
    double scalefactor=1.0;
    PyObject* pyobj_mean = NULL;
    Scalar mean;

    const char* keywords[] = { "blob", "name", "scalefactor", "mean", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OdO:dnn_Net.setInput", (char**)keywords, &pyobj_blob, &pyobj_name, &scalefactor, &pyobj_mean) &&
        pyopencv_to(pyobj_blob, blob, ArgInfo("blob", 0)) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) &&
        pyopencv_to(pyobj_mean, mean, ArgInfo("mean", 0)) )
    {
        ERRWRAP2(_self_->setInput(blob, name, scalefactor, mean));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_blob = NULL;
    UMat blob;
    PyObject* pyobj_name = NULL;
    String name="";
    double scalefactor=1.0;
    PyObject* pyobj_mean = NULL;
    Scalar mean;

    const char* keywords[] = { "blob", "name", "scalefactor", "mean", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OdO:dnn_Net.setInput", (char**)keywords, &pyobj_blob, &pyobj_name, &scalefactor, &pyobj_mean) &&
        pyopencv_to(pyobj_blob, blob, ArgInfo("blob", 0)) &&
        pyopencv_to(pyobj_name, name, ArgInfo("name", 0)) &&
        pyopencv_to(pyobj_mean, mean, ArgInfo("mean", 0)) )
    {
        ERRWRAP2(_self_->setInput(blob, name, scalefactor, mean));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_setInputsNames(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    PyObject* pyobj_inputBlobNames = NULL;
    vector_String inputBlobNames;

    const char* keywords[] = { "inputBlobNames", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:dnn_Net.setInputsNames", (char**)keywords, &pyobj_inputBlobNames) &&
        pyopencv_to(pyobj_inputBlobNames, inputBlobNames, ArgInfo("inputBlobNames", 0)) )
    {
        ERRWRAP2(_self_->setInputsNames(inputBlobNames));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_setParam(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    {
    PyObject* pyobj_layer = NULL;
    LayerId layer;
    int numParam=0;
    PyObject* pyobj_blob = NULL;
    Mat blob;

    const char* keywords[] = { "layer", "numParam", "blob", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO:dnn_Net.setParam", (char**)keywords, &pyobj_layer, &numParam, &pyobj_blob) &&
        pyopencv_to(pyobj_layer, layer, ArgInfo("layer", 0)) &&
        pyopencv_to(pyobj_blob, blob, ArgInfo("blob", 0)) )
    {
        ERRWRAP2(_self_->setParam(layer, numParam, blob));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_layer = NULL;
    LayerId layer;
    int numParam=0;
    PyObject* pyobj_blob = NULL;
    Mat blob;

    const char* keywords[] = { "layer", "numParam", "blob", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO:dnn_Net.setParam", (char**)keywords, &pyobj_layer, &numParam, &pyobj_blob) &&
        pyopencv_to(pyobj_layer, layer, ArgInfo("layer", 0)) &&
        pyopencv_to(pyobj_blob, blob, ArgInfo("blob", 0)) )
    {
        ERRWRAP2(_self_->setParam(layer, numParam, blob));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_setPreferableBackend(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    int backendId=0;

    const char* keywords[] = { "backendId", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:dnn_Net.setPreferableBackend", (char**)keywords, &backendId) )
    {
        ERRWRAP2(_self_->setPreferableBackend(backendId));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_dnn_dnn_Net_setPreferableTarget(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::dnn;


    cv::dnn::Net * self1 = 0;
    if (!pyopencv_dnn_Net_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'dnn_Net' or its derivative)");
    cv::dnn::Net* _self_ = (self1);
    int targetId=0;

    const char* keywords[] = { "targetId", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:dnn_Net.setPreferableTarget", (char**)keywords, &targetId) )
    {
        ERRWRAP2(_self_->setPreferableTarget(targetId));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (dnn_Net)

static PyGetSetDef pyopencv_dnn_Net_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_dnn_Net_methods[] =
{
    {"connect", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_connect, 0), "connect(outPin, inpPin) -> None\n.   @brief Connects output of the first layer to input of the second layer.\n.            *  @param outPin descriptor of the first layer output.\n.            *  @param inpPin descriptor of the second layer input.\n.            *\n.            * Descriptors have the following template <DFN>&lt;layer_name&gt;[.input_number]</DFN>:\n.            * - the first part of the template <DFN>layer_name</DFN> is sting name of the added layer.\n.            *   If this part is empty then the network input pseudo layer will be used;\n.            * - the second optional part of the template <DFN>input_number</DFN>\n.            *   is either number of the layer input, either label one.\n.            *   If this part is omitted then the first layer input will be used.\n.            *\n.            *  @see setNetInputs(), Layer::inputNameToIndex(), Layer::outputNameToIndex()"},
    {"dump", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_dump, 0), "dump() -> retval\n.   @brief Dump net to String\n.            *  @returns String with structure, hyperparameters, backend, target and fusion\n.            *  Call method after setInput(). To see correct backend, target and fusion run after forward()."},
    {"dumpToFile", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_dumpToFile, 0), "dumpToFile(path) -> None\n.   @brief Dump net structure, hyperparameters, backend, target and fusion to dot file\n.            *  @param path   path to output file with .dot extension\n.            *  @see dump()"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_empty, 0), "empty() -> retval\n.   Returns true if there are no layers in the network."},
    {"enableFusion", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_enableFusion, 0), "enableFusion(fusion) -> None\n.   @brief Enables or disables layer fusion in the network.\n.            * @param fusion true to enable the fusion, false to disable. The fusion is enabled by default."},
    {"forward", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_forward, 0), "forward([, outputName]) -> retval\n.   @brief Runs forward pass to compute output of layer with name @p outputName.\n.            *  @param outputName name for layer which output is needed to get\n.            *  @return blob for first output of specified layer.\n.            *  @details By default runs forward pass for the whole network.\n\n\n\nforward([, outputBlobs[, outputName]]) -> outputBlobs\n.   @brief Runs forward pass to compute output of layer with name @p outputName.\n.            *  @param outputBlobs contains all output blobs for specified layer.\n.            *  @param outputName name for layer which output is needed to get\n.            *  @details If @p outputName is empty, runs forward pass for the whole network.\n\n\n\nforward(outBlobNames[, outputBlobs]) -> outputBlobs\n.   @brief Runs forward pass to compute outputs of layers listed in @p outBlobNames.\n.            *  @param outputBlobs contains blobs for first outputs of specified layers.\n.            *  @param outBlobNames names for layers which outputs are needed to get"},
    {"forwardAndRetrieve", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_forwardAndRetrieve, 0), "forwardAndRetrieve(outBlobNames) -> outputBlobs\n.   @brief Runs forward pass to compute outputs of layers listed in @p outBlobNames.\n.            *  @param outputBlobs contains all output blobs for each layer specified in @p outBlobNames.\n.            *  @param outBlobNames names for layers which outputs are needed to get"},
    {"forwardAsync", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_forwardAsync, 0), "forwardAsync([, outputName]) -> retval\n.   @brief Runs forward pass to compute output of layer with name @p outputName.\n.            *  @param outputName name for layer which output is needed to get\n.            *  @details By default runs forward pass for the whole network.\n.            *\n.            *  This is an asynchronous version of forward(const String&).\n.            *  dnn::DNN_BACKEND_INFERENCE_ENGINE backend is required."},
    {"getFLOPS", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getFLOPS, 0), "getFLOPS(netInputShapes) -> retval\n.   @brief Computes FLOP for whole loaded model with specified input shapes.\n.            * @param netInputShapes vector of shapes for all net inputs.\n.            * @returns computed FLOP.\n\n\n\ngetFLOPS(netInputShape) -> retval\n.   @overload\n\n\n\ngetFLOPS(layerId, netInputShapes) -> retval\n.   @overload\n\n\n\ngetFLOPS(layerId, netInputShape) -> retval\n.   @overload"},
    {"getLayer", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getLayer, 0), "getLayer(layerId) -> retval\n.   @brief Returns pointer to layer with specified id or name which the network use."},
    {"getLayerId", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getLayerId, 0), "getLayerId(layer) -> retval\n.   @brief Converts string name of the layer to the integer identifier.\n.            *  @returns id of the layer, or -1 if the layer wasn't found."},
    {"getLayerNames", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getLayerNames, 0), "getLayerNames() -> retval\n."},
    {"getLayerTypes", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getLayerTypes, 0), "getLayerTypes() -> layersTypes\n.   @brief Returns list of types for layer used in model.\n.            * @param layersTypes output parameter for returning types."},
    {"getLayersCount", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getLayersCount, 0), "getLayersCount(layerType) -> retval\n.   @brief Returns count of layers of specified type.\n.            * @param layerType type.\n.            * @returns count of layers"},
    {"getLayersShapes", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getLayersShapes, 0), "getLayersShapes(netInputShapes) -> layersIds, inLayersShapes, outLayersShapes\n.   @brief Returns input and output shapes for all layers in loaded model;\n.            *  preliminary inferencing isn't necessary.\n.            *  @param netInputShapes shapes for all input blobs in net input layer.\n.            *  @param layersIds output parameter for layer IDs.\n.            *  @param inLayersShapes output parameter for input layers shapes;\n.            * order is the same as in layersIds\n.            *  @param outLayersShapes output parameter for output layers shapes;\n.            * order is the same as in layersIds\n\n\n\ngetLayersShapes(netInputShape) -> layersIds, inLayersShapes, outLayersShapes\n.   @overload"},
    {"getMemoryConsumption", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getMemoryConsumption, 0), "getMemoryConsumption(netInputShape) -> weights, blobs\n.   @overload\n\n\n\ngetMemoryConsumption(layerId, netInputShapes) -> weights, blobs\n.   @overload\n\n\n\ngetMemoryConsumption(layerId, netInputShape) -> weights, blobs\n.   @overload"},
    {"getParam", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getParam, 0), "getParam(layer[, numParam]) -> retval\n.   @brief Returns parameter blob of the layer.\n.            *  @param layer name or id of the layer.\n.            *  @param numParam index of the layer parameter in the Layer::blobs array.\n.            *  @see Layer::blobs"},
    {"getPerfProfile", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getPerfProfile, 0), "getPerfProfile() -> retval, timings\n.   @brief Returns overall time for inference and timings (in ticks) for layers.\n.            * Indexes in returned vector correspond to layers ids. Some layers can be fused with others,\n.            * in this case zero ticks count will be return for that skipped layers.\n.            * @param timings vector for tick timings for all layers.\n.            * @return overall ticks for model inference."},
    {"getUnconnectedOutLayers", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getUnconnectedOutLayers, 0), "getUnconnectedOutLayers() -> retval\n.   @brief Returns indexes of layers with unconnected outputs."},
    {"getUnconnectedOutLayersNames", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_getUnconnectedOutLayersNames, 0), "getUnconnectedOutLayersNames() -> retval\n.   @brief Returns names of layers with unconnected outputs."},
    {"readFromModelOptimizer", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_readFromModelOptimizer_static, METH_STATIC), "readFromModelOptimizer(xml, bin) -> retval\n.   @brief Create a network from Intel's Model Optimizer intermediate representation.\n.            *  @param[in] xml XML configuration file with network's topology.\n.            *  @param[in] bin Binary file with trained weights.\n.            *  Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine\n.            *  backend."},
    {"setHalideScheduler", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_setHalideScheduler, 0), "setHalideScheduler(scheduler) -> None\n.   * @brief Compile Halide layers.\n.            * @param[in] scheduler Path to YAML file with scheduling directives.\n.            * @see setPreferableBackend\n.            *\n.            * Schedule layers that support Halide backend. Then compile them for\n.            * specific target. For layers that not represented in scheduling file\n.            * or if no manual scheduling used at all, automatic scheduling will be applied."},
    {"setInput", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_setInput, 0), "setInput(blob[, name[, scalefactor[, mean]]]) -> None\n.   @brief Sets the new input value for the network\n.            *  @param blob        A new blob. Should have CV_32F or CV_8U depth.\n.            *  @param name        A name of input layer.\n.            *  @param scalefactor An optional normalization scale.\n.            *  @param mean        An optional mean subtraction values.\n.            *  @see connect(String, String) to know format of the descriptor.\n.            *\n.            *  If scale or mean values are specified, a final input blob is computed\n.            *  as:\n.            * \\f[input(n,c,h,w) = scalefactor \\times (blob(n,c,h,w) - mean_c)\\f]"},
    {"setInputsNames", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_setInputsNames, 0), "setInputsNames(inputBlobNames) -> None\n.   @brief Sets outputs names of the network input pseudo layer.\n.            *\n.            * Each net always has special own the network input pseudo layer with id=0.\n.            * This layer stores the user blobs only and don't make any computations.\n.            * In fact, this layer provides the only way to pass user data into the network.\n.            * As any other layer, this layer can label its outputs and this function provides an easy way to do this."},
    {"setParam", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_setParam, 0), "setParam(layer, numParam, blob) -> None\n.   @brief Sets the new value for the learned param of the layer.\n.            *  @param layer name or id of the layer.\n.            *  @param numParam index of the layer parameter in the Layer::blobs array.\n.            *  @param blob the new value.\n.            *  @see Layer::blobs\n.            *  @note If shape of the new blob differs from the previous shape,\n.            *  then the following forward pass may fail."},
    {"setPreferableBackend", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_setPreferableBackend, 0), "setPreferableBackend(backendId) -> None\n.   * @brief Ask network to use specific computation backend where it supported.\n.            * @param[in] backendId backend identifier.\n.            * @see Backend\n.            *\n.            * If OpenCV is compiled with Intel's Inference Engine library, DNN_BACKEND_DEFAULT\n.            * means DNN_BACKEND_INFERENCE_ENGINE. Otherwise it equals to DNN_BACKEND_OPENCV."},
    {"setPreferableTarget", CV_PY_FN_WITH_KW_(pyopencv_cv_dnn_dnn_Net_setPreferableTarget, 0), "setPreferableTarget(targetId) -> None\n.   * @brief Ask network to make computations on specific target device.\n.            * @param[in] targetId target identifier.\n.            * @see Target\n.            *\n.            * List of supported combinations backend / target:\n.            * |                        | DNN_BACKEND_OPENCV | DNN_BACKEND_INFERENCE_ENGINE | DNN_BACKEND_HALIDE |\n.            * |------------------------|--------------------|------------------------------|--------------------|\n.            * | DNN_TARGET_CPU         |                  + |                            + |                  + |\n.            * | DNN_TARGET_OPENCL      |                  + |                            + |                  + |\n.            * | DNN_TARGET_OPENCL_FP16 |                  + |                            + |                    |\n.            * | DNN_TARGET_MYRIAD      |                    |                            + |                    |\n.            * | DNN_TARGET_FPGA        |                    |                            + |                    |"},

    {NULL,          NULL}
};

// Converter (dnn_Net)

template<>
struct PyOpenCV_Converter< cv::dnn::Net >
{
    static PyObject* from(const cv::dnn::Net& r)
    {
        return pyopencv_dnn_Net_Instance(r);
    }
    static bool to(PyObject* src, cv::dnn::Net& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::dnn::Net * dst_;
        if (pyopencv_dnn_Net_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::dnn::Net for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// dpm_DPMDetector (Generic)
//================================================================================

// GetSet (dpm_DPMDetector)



// Methods (dpm_DPMDetector)



// Tables (dpm_DPMDetector)

static PyGetSetDef pyopencv_dpm_DPMDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_dpm_DPMDetector_methods[] =
{

    {NULL,          NULL}
};

// Converter (dpm_DPMDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::dpm::DPMDetector> >
{
    static PyObject* from(const Ptr<cv::dpm::DPMDetector>& r)
    {
        return pyopencv_dpm_DPMDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::dpm::DPMDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::dpm::DPMDetector> * dst_;
        if (pyopencv_dpm_DPMDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::dpm::DPMDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// dpm_DPMDetector_ObjectDetection (Generic)
//================================================================================

// GetSet (dpm_DPMDetector_ObjectDetection)



// Methods (dpm_DPMDetector_ObjectDetection)



// Tables (dpm_DPMDetector_ObjectDetection)

static PyGetSetDef pyopencv_dpm_DPMDetector_ObjectDetection_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_dpm_DPMDetector_ObjectDetection_methods[] =
{

    {NULL,          NULL}
};

// Converter (dpm_DPMDetector_ObjectDetection)

template<>
struct PyOpenCV_Converter< Ptr<cv::dpm::DPMDetector::ObjectDetection> >
{
    static PyObject* from(const Ptr<cv::dpm::DPMDetector::ObjectDetection>& r)
    {
        return pyopencv_dpm_DPMDetector_ObjectDetection_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::dpm::DPMDetector::ObjectDetection>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::dpm::DPMDetector::ObjectDetection> * dst_;
        if (pyopencv_dpm_DPMDetector_ObjectDetection_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::dpm::DPMDetector::ObjectDetection> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_BIF (Generic)
//================================================================================

// GetSet (face_BIF)



// Methods (face_BIF)

static PyObject* pyopencv_cv_face_face_BIF_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BIF> * self1 = 0;
    if (!pyopencv_face_BIF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BIF' or its derivative)");
    Ptr<cv::face::BIF> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_features = NULL;
    Mat features;

    const char* keywords[] = { "image", "features", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:face_BIF.compute", (char**)keywords, &pyobj_image, &pyobj_features) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 1)) )
    {
        ERRWRAP2(_self_->compute(image, features));
        return pyopencv_from(features);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_features = NULL;
    UMat features;

    const char* keywords[] = { "image", "features", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:face_BIF.compute", (char**)keywords, &pyobj_image, &pyobj_features) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 1)) )
    {
        ERRWRAP2(_self_->compute(image, features));
        return pyopencv_from(features);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BIF_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;

    int num_bands=8;
    int num_rotations=12;
    Ptr<BIF> retval;

    const char* keywords[] = { "num_bands", "num_rotations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ii:face_BIF.create", (char**)keywords, &num_bands, &num_rotations) )
    {
        ERRWRAP2(retval = cv::face::BIF::create(num_bands, num_rotations));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BIF_getNumBands(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BIF> * self1 = 0;
    if (!pyopencv_face_BIF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BIF' or its derivative)");
    Ptr<cv::face::BIF> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumBands());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BIF_getNumRotations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BIF> * self1 = 0;
    if (!pyopencv_face_BIF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BIF' or its derivative)");
    Ptr<cv::face::BIF> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumRotations());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (face_BIF)

static PyGetSetDef pyopencv_face_BIF_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_BIF_methods[] =
{
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BIF_compute, 0), "compute(image[, features]) -> features\n.   Computes features sby input image.\n.        *  @param image Input image (CV_32FC1).\n.        *  @param features Feature vector (CV_32FC1)."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BIF_create_static, METH_STATIC), "create([, num_bands[, num_rotations]]) -> retval\n.   * @param num_bands The number of filter bands (<=8) used for computing BIF.\n.        * @param num_rotations The number of image rotations for computing BIF.\n.        * @returns Object for computing BIF."},
    {"getNumBands", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BIF_getNumBands, 0), "getNumBands() -> retval\n.   @returns The number of filter bands used for computing BIF."},
    {"getNumRotations", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BIF_getNumRotations, 0), "getNumRotations() -> retval\n.   @returns The number of image rotations."},

    {NULL,          NULL}
};

// Converter (face_BIF)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::BIF> >
{
    static PyObject* from(const Ptr<cv::face::BIF>& r)
    {
        return pyopencv_face_BIF_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::BIF>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::BIF> * dst_;
        if (pyopencv_face_BIF_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::BIF> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_BasicFaceRecognizer (Generic)
//================================================================================

// GetSet (face_BasicFaceRecognizer)



// Methods (face_BasicFaceRecognizer)

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_getEigenValues(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEigenValues());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_getEigenVectors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEigenVectors());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_getLabels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLabels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_getMean(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMean());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_getNumComponents(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumComponents());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_getProjections(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    std::vector<cv::Mat> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getProjections());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_setNumComponents(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:face_BasicFaceRecognizer.setNumComponents", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setNumComponents(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_BasicFaceRecognizer_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::BasicFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_BasicFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_BasicFaceRecognizer' or its derivative)");
    Ptr<cv::face::BasicFaceRecognizer> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:face_BasicFaceRecognizer.setThreshold", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setThreshold(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (face_BasicFaceRecognizer)

static PyGetSetDef pyopencv_face_BasicFaceRecognizer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_BasicFaceRecognizer_methods[] =
{
    {"getEigenValues", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_getEigenValues, 0), "getEigenValues() -> retval\n."},
    {"getEigenVectors", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_getEigenVectors, 0), "getEigenVectors() -> retval\n."},
    {"getLabels", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_getLabels, 0), "getLabels() -> retval\n."},
    {"getMean", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_getMean, 0), "getMean() -> retval\n."},
    {"getNumComponents", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_getNumComponents, 0), "getNumComponents() -> retval\n.   @see setNumComponents"},
    {"getProjections", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_getProjections, 0), "getProjections() -> retval\n."},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_getThreshold, 0), "getThreshold() -> retval\n.   @see setThreshold"},
    {"setNumComponents", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_setNumComponents, 0), "setNumComponents(val) -> None\n.   @copybrief getNumComponents @see getNumComponents"},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_BasicFaceRecognizer_setThreshold, 0), "setThreshold(val) -> None\n.   @copybrief getThreshold @see getThreshold"},

    {NULL,          NULL}
};

// Converter (face_BasicFaceRecognizer)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::BasicFaceRecognizer> >
{
    static PyObject* from(const Ptr<cv::face::BasicFaceRecognizer>& r)
    {
        return pyopencv_face_BasicFaceRecognizer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::BasicFaceRecognizer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::BasicFaceRecognizer> * dst_;
        if (pyopencv_face_BasicFaceRecognizer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::BasicFaceRecognizer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_EigenFaceRecognizer (Generic)
//================================================================================

// GetSet (face_EigenFaceRecognizer)



// Methods (face_EigenFaceRecognizer)

static PyObject* pyopencv_cv_face_face_EigenFaceRecognizer_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;

    int num_components=0;
    double threshold=DBL_MAX;
    Ptr<EigenFaceRecognizer> retval;

    const char* keywords[] = { "num_components", "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|id:face_EigenFaceRecognizer.create", (char**)keywords, &num_components, &threshold) )
    {
        ERRWRAP2(retval = cv::face::EigenFaceRecognizer::create(num_components, threshold));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (face_EigenFaceRecognizer)

static PyGetSetDef pyopencv_face_EigenFaceRecognizer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_EigenFaceRecognizer_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_EigenFaceRecognizer_create_static, METH_STATIC), "create([, num_components[, threshold]]) -> retval\n.   @param num_components The number of components (read: Eigenfaces) kept for this Principal\n.       Component Analysis. As a hint: There's no rule how many components (read: Eigenfaces) should be\n.       kept for good reconstruction capabilities. It is based on your input data, so experiment with the\n.       number. Keeping 80 components should almost always be sufficient.\n.       @param threshold The threshold applied in the prediction.\n.   \n.       ### Notes:\n.   \n.       -   Training and prediction must be done on grayscale images, use cvtColor to convert between the\n.           color spaces.\n.       -   **THE EIGENFACES METHOD MAKES THE ASSUMPTION, THAT THE TRAINING AND TEST IMAGES ARE OF EQUAL\n.           SIZE.** (caps-lock, because I got so many mails asking for this). You have to make sure your\n.           input data has the correct shape, else a meaningful exception is thrown. Use resize to resize\n.           the images.\n.       -   This model does not support updating.\n.   \n.       ### Model internal data:\n.   \n.       -   num_components see EigenFaceRecognizer::create.\n.       -   threshold see EigenFaceRecognizer::create.\n.       -   eigenvalues The eigenvalues for this Principal Component Analysis (ordered descending).\n.       -   eigenvectors The eigenvectors for this Principal Component Analysis (ordered by their\n.           eigenvalue).\n.       -   mean The sample mean calculated from the training data.\n.       -   projections The projections of the training data.\n.       -   labels The threshold applied in the prediction. If the distance to the nearest neighbor is\n.           larger than the threshold, this method returns -1."},

    {NULL,          NULL}
};

// Converter (face_EigenFaceRecognizer)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::EigenFaceRecognizer> >
{
    static PyObject* from(const Ptr<cv::face::EigenFaceRecognizer>& r)
    {
        return pyopencv_face_EigenFaceRecognizer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::EigenFaceRecognizer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::EigenFaceRecognizer> * dst_;
        if (pyopencv_face_EigenFaceRecognizer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::EigenFaceRecognizer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_FaceRecognizer (Generic)
//================================================================================

// GetSet (face_FaceRecognizer)



// Methods (face_FaceRecognizer)

static PyObject* pyopencv_cv_face_face_FaceRecognizer_getLabelInfo(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    int label=0;
    String retval;

    const char* keywords[] = { "label", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:face_FaceRecognizer.getLabelInfo", (char**)keywords, &label) )
    {
        ERRWRAP2(retval = _self_->getLabelInfo(label));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_getLabelsByString(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    PyObject* pyobj_str = NULL;
    String str;
    std::vector<int> retval;

    const char* keywords[] = { "str", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_FaceRecognizer.getLabelsByString", (char**)keywords, &pyobj_str) &&
        pyopencv_to(pyobj_str, str, ArgInfo("str", 0)) )
    {
        ERRWRAP2(retval = _self_->getLabelsByString(str));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_predict(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    int label;
    double confidence;

    const char* keywords[] = { "src", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_FaceRecognizer.predict", (char**)keywords, &pyobj_src) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) )
    {
        ERRWRAP2(_self_->predict(src, label, confidence));
        return Py_BuildValue("(NN)", pyopencv_from(label), pyopencv_from(confidence));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    int label;
    double confidence;

    const char* keywords[] = { "src", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_FaceRecognizer.predict", (char**)keywords, &pyobj_src) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) )
    {
        ERRWRAP2(_self_->predict(src, label, confidence));
        return Py_BuildValue("(NN)", pyopencv_from(label), pyopencv_from(confidence));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_predict_collect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_collector = NULL;
    Ptr<PredictCollector> collector;

    const char* keywords[] = { "src", "collector", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:face_FaceRecognizer.predict_collect", (char**)keywords, &pyobj_src, &pyobj_collector) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_collector, collector, ArgInfo("collector", 0)) )
    {
        ERRWRAP2(_self_->predict(src, collector));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_collector = NULL;
    Ptr<PredictCollector> collector;

    const char* keywords[] = { "src", "collector", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:face_FaceRecognizer.predict_collect", (char**)keywords, &pyobj_src, &pyobj_collector) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_collector, collector, ArgInfo("collector", 0)) )
    {
        ERRWRAP2(_self_->predict(src, collector));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_predict_label(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    int retval;

    const char* keywords[] = { "src", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_FaceRecognizer.predict_label", (char**)keywords, &pyobj_src) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) )
    {
        ERRWRAP2(retval = _self_->predict(src));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    int retval;

    const char* keywords[] = { "src", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_FaceRecognizer.predict_label", (char**)keywords, &pyobj_src) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) )
    {
        ERRWRAP2(retval = _self_->predict(src));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    PyObject* pyobj_filename = NULL;
    String filename;

    const char* keywords[] = { "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_FaceRecognizer.read", (char**)keywords, &pyobj_filename) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        ERRWRAP2(_self_->read(filename));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_setLabelInfo(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    int label=0;
    PyObject* pyobj_strInfo = NULL;
    String strInfo;

    const char* keywords[] = { "label", "strInfo", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO:face_FaceRecognizer.setLabelInfo", (char**)keywords, &label, &pyobj_strInfo) &&
        pyopencv_to(pyobj_strInfo, strInfo, ArgInfo("strInfo", 0)) )
    {
        ERRWRAP2(_self_->setLabelInfo(label, strInfo));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_train(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_labels = NULL;
    Mat labels;

    const char* keywords[] = { "src", "labels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:face_FaceRecognizer.train", (char**)keywords, &pyobj_src, &pyobj_labels) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 0)) )
    {
        ERRWRAP2(_self_->train(src, labels));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_labels = NULL;
    UMat labels;

    const char* keywords[] = { "src", "labels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:face_FaceRecognizer.train", (char**)keywords, &pyobj_src, &pyobj_labels) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 0)) )
    {
        ERRWRAP2(_self_->train(src, labels));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_update(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_labels = NULL;
    Mat labels;

    const char* keywords[] = { "src", "labels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:face_FaceRecognizer.update", (char**)keywords, &pyobj_src, &pyobj_labels) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 0)) )
    {
        ERRWRAP2(_self_->update(src, labels));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    vector_Mat src;
    PyObject* pyobj_labels = NULL;
    UMat labels;

    const char* keywords[] = { "src", "labels", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:face_FaceRecognizer.update", (char**)keywords, &pyobj_src, &pyobj_labels) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 0)) )
    {
        ERRWRAP2(_self_->update(src, labels));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_FaceRecognizer_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::FaceRecognizer> * self1 = 0;
    if (!pyopencv_face_FaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_FaceRecognizer' or its derivative)");
    Ptr<cv::face::FaceRecognizer> _self_ = *(self1);
    PyObject* pyobj_filename = NULL;
    String filename;

    const char* keywords[] = { "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_FaceRecognizer.write", (char**)keywords, &pyobj_filename) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        ERRWRAP2(_self_->write(filename));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (face_FaceRecognizer)

static PyGetSetDef pyopencv_face_FaceRecognizer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_FaceRecognizer_methods[] =
{
    {"getLabelInfo", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_getLabelInfo, 0), "getLabelInfo(label) -> retval\n.   @brief Gets string information by label.\n.   \n.       If an unknown label id is provided or there is no label information associated with the specified\n.       label id the method returns an empty string."},
    {"getLabelsByString", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_getLabelsByString, 0), "getLabelsByString(str) -> retval\n.   @brief Gets vector of labels by string.\n.   \n.       The function searches for the labels containing the specified sub-string in the associated string\n.       info."},
    {"predict", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_predict, 0), "predict(src) -> label, confidence\n.   @brief Predicts a label and associated confidence (e.g. distance) for a given input image.\n.   \n.       @param src Sample image to get a prediction from.\n.       @param label The predicted label for the given image.\n.       @param confidence Associated confidence (e.g. distance) for the predicted label.\n.   \n.       The suffix const means that prediction does not affect the internal model state, so the method can\n.       be safely called from within different threads.\n.   \n.       The following example shows how to get a prediction from a trained model:\n.   \n.       @code\n.       using namespace cv;\n.       // Do your initialization here (create the cv::FaceRecognizer model) ...\n.       // ...\n.       // Read in a sample image:\n.       Mat img = imread(\"person1/3.jpg\", IMREAD_GRAYSCALE);\n.       // And get a prediction from the cv::FaceRecognizer:\n.       int predicted = model->predict(img);\n.       @endcode\n.   \n.       Or to get a prediction and the associated confidence (e.g. distance):\n.   \n.       @code\n.       using namespace cv;\n.       // Do your initialization here (create the cv::FaceRecognizer model) ...\n.       // ...\n.       Mat img = imread(\"person1/3.jpg\", IMREAD_GRAYSCALE);\n.       // Some variables for the predicted label and associated confidence (e.g. distance):\n.       int predicted_label = -1;\n.       double predicted_confidence = 0.0;\n.       // Get the prediction and associated confidence from the model\n.       model->predict(img, predicted_label, predicted_confidence);\n.       @endcode"},
    {"predict_collect", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_predict_collect, 0), "predict_collect(src, collector) -> None\n.   @brief - if implemented - send all result of prediction to collector that can be used for somehow custom result handling\n.       @param src Sample image to get a prediction from.\n.       @param collector User-defined collector object that accepts all results\n.   \n.       To implement this method u just have to do same internal cycle as in predict(InputArray src, CV_OUT int &label, CV_OUT double &confidence) but\n.       not try to get \"best@ result, just resend it to caller side with given collector"},
    {"predict_label", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_predict_label, 0), "predict_label(src) -> retval\n.   @overload"},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_read, 0), "read(filename) -> None\n.   @brief Loads a FaceRecognizer and its model state.\n.   \n.       Loads a persisted model and state from a given XML or YAML file . Every FaceRecognizer has to\n.       overwrite FaceRecognizer::load(FileStorage& fs) to enable loading the model state.\n.       FaceRecognizer::load(FileStorage& fs) in turn gets called by\n.       FaceRecognizer::load(const String& filename), to ease saving a model."},
    {"setLabelInfo", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_setLabelInfo, 0), "setLabelInfo(label, strInfo) -> None\n.   @brief Sets string info for the specified model's label.\n.   \n.       The string info is replaced by the provided value if it was set before for the specified label."},
    {"train", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_train, 0), "train(src, labels) -> None\n.   @brief Trains a FaceRecognizer with given data and associated labels.\n.   \n.       @param src The training images, that means the faces you want to learn. The data has to be\n.       given as a vector\\<Mat\\>.\n.       @param labels The labels corresponding to the images have to be given either as a vector\\<int\\>\n.       or a Mat of type CV_32SC1.\n.   \n.       The following source code snippet shows you how to learn a Fisherfaces model on a given set of\n.       images. The images are read with imread and pushed into a std::vector\\<Mat\\>. The labels of each\n.       image are stored within a std::vector\\<int\\> (you could also use a Mat of type CV_32SC1). Think of\n.       the label as the subject (the person) this image belongs to, so same subjects (persons) should have\n.       the same label. For the available FaceRecognizer you don't have to pay any attention to the order of\n.       the labels, just make sure same persons have the same label:\n.   \n.       @code\n.       // holds images and labels\n.       vector<Mat> images;\n.       vector<int> labels;\n.       // using Mat of type CV_32SC1\n.       // Mat labels(number_of_samples, 1, CV_32SC1);\n.       // images for first person\n.       images.push_back(imread(\"person0/0.jpg\", IMREAD_GRAYSCALE)); labels.push_back(0);\n.       images.push_back(imread(\"person0/1.jpg\", IMREAD_GRAYSCALE)); labels.push_back(0);\n.       images.push_back(imread(\"person0/2.jpg\", IMREAD_GRAYSCALE)); labels.push_back(0);\n.       // images for second person\n.       images.push_back(imread(\"person1/0.jpg\", IMREAD_GRAYSCALE)); labels.push_back(1);\n.       images.push_back(imread(\"person1/1.jpg\", IMREAD_GRAYSCALE)); labels.push_back(1);\n.       images.push_back(imread(\"person1/2.jpg\", IMREAD_GRAYSCALE)); labels.push_back(1);\n.       @endcode\n.   \n.       Now that you have read some images, we can create a new FaceRecognizer. In this example I'll create\n.       a Fisherfaces model and decide to keep all of the possible Fisherfaces:\n.   \n.       @code\n.       // Create a new Fisherfaces model and retain all available Fisherfaces,\n.       // this is the most common usage of this specific FaceRecognizer:\n.       //\n.       Ptr<FaceRecognizer> model =  FisherFaceRecognizer::create();\n.       @endcode\n.   \n.       And finally train it on the given dataset (the face images and labels):\n.   \n.       @code\n.       // This is the common interface to train all of the available cv::FaceRecognizer\n.       // implementations:\n.       //\n.       model->train(images, labels);\n.       @endcode"},
    {"update", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_update, 0), "update(src, labels) -> None\n.   @brief Updates a FaceRecognizer with given data and associated labels.\n.   \n.       @param src The training images, that means the faces you want to learn. The data has to be given\n.       as a vector\\<Mat\\>.\n.       @param labels The labels corresponding to the images have to be given either as a vector\\<int\\> or\n.       a Mat of type CV_32SC1.\n.   \n.       This method updates a (probably trained) FaceRecognizer, but only if the algorithm supports it. The\n.       Local Binary Patterns Histograms (LBPH) recognizer (see createLBPHFaceRecognizer) can be updated.\n.       For the Eigenfaces and Fisherfaces method, this is algorithmically not possible and you have to\n.       re-estimate the model with FaceRecognizer::train. In any case, a call to train empties the existing\n.       model and learns a new model, while update does not delete any model data.\n.   \n.       @code\n.       // Create a new LBPH model (it can be updated) and use the default parameters,\n.       // this is the most common usage of this specific FaceRecognizer:\n.       //\n.       Ptr<FaceRecognizer> model =  LBPHFaceRecognizer::create();\n.       // This is the common interface to train all of the available cv::FaceRecognizer\n.       // implementations:\n.       //\n.       model->train(images, labels);\n.       // Some containers to hold new image:\n.       vector<Mat> newImages;\n.       vector<int> newLabels;\n.       // You should add some images to the containers:\n.       //\n.       // ...\n.       //\n.       // Now updating the model is as easy as calling:\n.       model->update(newImages,newLabels);\n.       // This will preserve the old model data and extend the existing model\n.       // with the new features extracted from newImages!\n.       @endcode\n.   \n.       Calling update on an Eigenfaces model (see EigenFaceRecognizer::create), which doesn't support\n.       updating, will throw an error similar to:\n.   \n.       @code\n.       OpenCV Error: The function/feature is not implemented (This FaceRecognizer (FaceRecognizer.Eigenfaces) does not support updating, you have to use FaceRecognizer::train to update it.) in update, file /home/philipp/git/opencv/modules/contrib/src/facerec.cpp, line 305\n.       terminate called after throwing an instance of 'cv::Exception'\n.       @endcode\n.   \n.       @note The FaceRecognizer does not store your training images, because this would be very\n.       memory intense and it's not the responsibility of te FaceRecognizer to do so. The caller is\n.       responsible for maintaining the dataset, he want to work with."},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FaceRecognizer_write, 0), "write(filename) -> None\n.   @brief Saves a FaceRecognizer and its model state.\n.   \n.       Saves this model to a given filename, either as XML or YAML.\n.       @param filename The filename to store this FaceRecognizer to (either XML/YAML).\n.   \n.       Every FaceRecognizer overwrites FaceRecognizer::save(FileStorage& fs) to save the internal model\n.       state. FaceRecognizer::save(const String& filename) saves the state of a model to the given\n.       filename.\n.   \n.       The suffix const means that prediction does not affect the internal model state, so the method can\n.       be safely called from within different threads."},

    {NULL,          NULL}
};

// Converter (face_FaceRecognizer)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::FaceRecognizer> >
{
    static PyObject* from(const Ptr<cv::face::FaceRecognizer>& r)
    {
        return pyopencv_face_FaceRecognizer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::FaceRecognizer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::FaceRecognizer> * dst_;
        if (pyopencv_face_FaceRecognizer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::FaceRecognizer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_Facemark (Generic)
//================================================================================

// GetSet (face_Facemark)



// Methods (face_Facemark)

static PyObject* pyopencv_cv_face_face_Facemark_fit(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::Facemark> * self1 = 0;
    if (!pyopencv_face_Facemark_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_Facemark' or its derivative)");
    Ptr<cv::face::Facemark> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_faces = NULL;
    Mat faces;
    PyObject* pyobj_landmarks = NULL;
    vector_Mat landmarks;
    bool retval;

    const char* keywords[] = { "image", "faces", "landmarks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:face_Facemark.fit", (char**)keywords, &pyobj_image, &pyobj_faces, &pyobj_landmarks) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_faces, faces, ArgInfo("faces", 0)) &&
        pyopencv_to(pyobj_landmarks, landmarks, ArgInfo("landmarks", 1)) )
    {
        ERRWRAP2(retval = _self_->fit(image, faces, landmarks));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(landmarks));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_faces = NULL;
    UMat faces;
    PyObject* pyobj_landmarks = NULL;
    vector_Mat landmarks;
    bool retval;

    const char* keywords[] = { "image", "faces", "landmarks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:face_Facemark.fit", (char**)keywords, &pyobj_image, &pyobj_faces, &pyobj_landmarks) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_faces, faces, ArgInfo("faces", 0)) &&
        pyopencv_to(pyobj_landmarks, landmarks, ArgInfo("landmarks", 1)) )
    {
        ERRWRAP2(retval = _self_->fit(image, faces, landmarks));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(landmarks));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_Facemark_loadModel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::Facemark> * self1 = 0;
    if (!pyopencv_face_Facemark_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_Facemark' or its derivative)");
    Ptr<cv::face::Facemark> _self_ = *(self1);
    PyObject* pyobj_model = NULL;
    String model;

    const char* keywords[] = { "model", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_Facemark.loadModel", (char**)keywords, &pyobj_model) &&
        pyopencv_to(pyobj_model, model, ArgInfo("model", 0)) )
    {
        ERRWRAP2(_self_->loadModel(model));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (face_Facemark)

static PyGetSetDef pyopencv_face_Facemark_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_Facemark_methods[] =
{
    {"fit", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_Facemark_fit, 0), "fit(image, faces[, landmarks]) -> retval, landmarks\n.   @brief Detect facial landmarks from an image.\n.       @param image Input image.\n.       @param faces Output of the function which represent region of interest of the detected faces.\n.       Each face is stored in cv::Rect container.\n.       @param landmarks The detected landmark points for each faces.\n.   \n.       <B>Example of usage</B>\n.       @code\n.       Mat image = imread(\"image.jpg\");\n.       std::vector<Rect> faces;\n.       std::vector<std::vector<Point2f> > landmarks;\n.       facemark->fit(image, faces, landmarks);\n.       @endcode"},
    {"loadModel", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_Facemark_loadModel, 0), "loadModel(model) -> None\n.   @brief A function to load the trained model before the fitting process.\n.       @param model A string represent the filename of a trained model.\n.   \n.       <B>Example of usage</B>\n.       @code\n.       facemark->loadModel(\"../data/lbf.model\");\n.       @endcode"},

    {NULL,          NULL}
};

// Converter (face_Facemark)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::Facemark> >
{
    static PyObject* from(const Ptr<cv::face::Facemark>& r)
    {
        return pyopencv_face_Facemark_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::Facemark>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::Facemark> * dst_;
        if (pyopencv_face_Facemark_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::Facemark> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_FacemarkAAM (Generic)
//================================================================================

// GetSet (face_FacemarkAAM)



// Methods (face_FacemarkAAM)



// Tables (face_FacemarkAAM)

static PyGetSetDef pyopencv_face_FacemarkAAM_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_FacemarkAAM_methods[] =
{

    {NULL,          NULL}
};

// Converter (face_FacemarkAAM)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::FacemarkAAM> >
{
    static PyObject* from(const Ptr<cv::face::FacemarkAAM>& r)
    {
        return pyopencv_face_FacemarkAAM_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::FacemarkAAM>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::FacemarkAAM> * dst_;
        if (pyopencv_face_FacemarkAAM_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::FacemarkAAM> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_FacemarkKazemi (Generic)
//================================================================================

// GetSet (face_FacemarkKazemi)



// Methods (face_FacemarkKazemi)



// Tables (face_FacemarkKazemi)

static PyGetSetDef pyopencv_face_FacemarkKazemi_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_FacemarkKazemi_methods[] =
{

    {NULL,          NULL}
};

// Converter (face_FacemarkKazemi)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::FacemarkKazemi> >
{
    static PyObject* from(const Ptr<cv::face::FacemarkKazemi>& r)
    {
        return pyopencv_face_FacemarkKazemi_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::FacemarkKazemi>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::FacemarkKazemi> * dst_;
        if (pyopencv_face_FacemarkKazemi_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::FacemarkKazemi> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_FacemarkLBF (Generic)
//================================================================================

// GetSet (face_FacemarkLBF)



// Methods (face_FacemarkLBF)



// Tables (face_FacemarkLBF)

static PyGetSetDef pyopencv_face_FacemarkLBF_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_FacemarkLBF_methods[] =
{

    {NULL,          NULL}
};

// Converter (face_FacemarkLBF)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::FacemarkLBF> >
{
    static PyObject* from(const Ptr<cv::face::FacemarkLBF>& r)
    {
        return pyopencv_face_FacemarkLBF_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::FacemarkLBF>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::FacemarkLBF> * dst_;
        if (pyopencv_face_FacemarkLBF_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::FacemarkLBF> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_FacemarkTrain (Generic)
//================================================================================

// GetSet (face_FacemarkTrain)



// Methods (face_FacemarkTrain)



// Tables (face_FacemarkTrain)

static PyGetSetDef pyopencv_face_FacemarkTrain_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_FacemarkTrain_methods[] =
{

    {NULL,          NULL}
};

// Converter (face_FacemarkTrain)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::FacemarkTrain> >
{
    static PyObject* from(const Ptr<cv::face::FacemarkTrain>& r)
    {
        return pyopencv_face_FacemarkTrain_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::FacemarkTrain>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::FacemarkTrain> * dst_;
        if (pyopencv_face_FacemarkTrain_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::FacemarkTrain> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_FisherFaceRecognizer (Generic)
//================================================================================

// GetSet (face_FisherFaceRecognizer)



// Methods (face_FisherFaceRecognizer)

static PyObject* pyopencv_cv_face_face_FisherFaceRecognizer_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;

    int num_components=0;
    double threshold=DBL_MAX;
    Ptr<FisherFaceRecognizer> retval;

    const char* keywords[] = { "num_components", "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|id:face_FisherFaceRecognizer.create", (char**)keywords, &num_components, &threshold) )
    {
        ERRWRAP2(retval = cv::face::FisherFaceRecognizer::create(num_components, threshold));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (face_FisherFaceRecognizer)

static PyGetSetDef pyopencv_face_FisherFaceRecognizer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_FisherFaceRecognizer_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_FisherFaceRecognizer_create_static, METH_STATIC), "create([, num_components[, threshold]]) -> retval\n.   @param num_components The number of components (read: Fisherfaces) kept for this Linear\n.       Discriminant Analysis with the Fisherfaces criterion. It's useful to keep all components, that\n.       means the number of your classes c (read: subjects, persons you want to recognize). If you leave\n.       this at the default (0) or set it to a value less-equal 0 or greater (c-1), it will be set to the\n.       correct number (c-1) automatically.\n.       @param threshold The threshold applied in the prediction. If the distance to the nearest neighbor\n.       is larger than the threshold, this method returns -1.\n.   \n.       ### Notes:\n.   \n.       -   Training and prediction must be done on grayscale images, use cvtColor to convert between the\n.           color spaces.\n.       -   **THE FISHERFACES METHOD MAKES THE ASSUMPTION, THAT THE TRAINING AND TEST IMAGES ARE OF EQUAL\n.           SIZE.** (caps-lock, because I got so many mails asking for this). You have to make sure your\n.           input data has the correct shape, else a meaningful exception is thrown. Use resize to resize\n.           the images.\n.       -   This model does not support updating.\n.   \n.       ### Model internal data:\n.   \n.       -   num_components see FisherFaceRecognizer::create.\n.       -   threshold see FisherFaceRecognizer::create.\n.       -   eigenvalues The eigenvalues for this Linear Discriminant Analysis (ordered descending).\n.       -   eigenvectors The eigenvectors for this Linear Discriminant Analysis (ordered by their\n.           eigenvalue).\n.       -   mean The sample mean calculated from the training data.\n.       -   projections The projections of the training data.\n.       -   labels The labels corresponding to the projections."},

    {NULL,          NULL}
};

// Converter (face_FisherFaceRecognizer)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::FisherFaceRecognizer> >
{
    static PyObject* from(const Ptr<cv::face::FisherFaceRecognizer>& r)
    {
        return pyopencv_face_FisherFaceRecognizer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::FisherFaceRecognizer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::FisherFaceRecognizer> * dst_;
        if (pyopencv_face_FisherFaceRecognizer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::FisherFaceRecognizer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_LBPHFaceRecognizer (Generic)
//================================================================================

// GetSet (face_LBPHFaceRecognizer)



// Methods (face_LBPHFaceRecognizer)

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;

    int radius=1;
    int neighbors=8;
    int grid_x=8;
    int grid_y=8;
    double threshold=DBL_MAX;
    Ptr<LBPHFaceRecognizer> retval;

    const char* keywords[] = { "radius", "neighbors", "grid_x", "grid_y", "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iiiid:face_LBPHFaceRecognizer.create", (char**)keywords, &radius, &neighbors, &grid_x, &grid_y, &threshold) )
    {
        ERRWRAP2(retval = cv::face::LBPHFaceRecognizer::create(radius, neighbors, grid_x, grid_y, threshold));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_getGridX(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGridX());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_getGridY(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGridY());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_getHistograms(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    std::vector<cv::Mat> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getHistograms());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_getLabels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLabels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_getNeighbors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNeighbors());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_getRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRadius());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_setGridX(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:face_LBPHFaceRecognizer.setGridX", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setGridX(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_setGridY(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:face_LBPHFaceRecognizer.setGridY", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setGridY(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_setNeighbors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:face_LBPHFaceRecognizer.setNeighbors", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setNeighbors(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_setRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:face_LBPHFaceRecognizer.setRadius", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRadius(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_LBPHFaceRecognizer_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::LBPHFaceRecognizer> * self1 = 0;
    if (!pyopencv_face_LBPHFaceRecognizer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_LBPHFaceRecognizer' or its derivative)");
    Ptr<cv::face::LBPHFaceRecognizer> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:face_LBPHFaceRecognizer.setThreshold", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setThreshold(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (face_LBPHFaceRecognizer)

static PyGetSetDef pyopencv_face_LBPHFaceRecognizer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_LBPHFaceRecognizer_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_create_static, METH_STATIC), "create([, radius[, neighbors[, grid_x[, grid_y[, threshold]]]]]) -> retval\n.   @param radius The radius used for building the Circular Local Binary Pattern. The greater the\n.       radius, the smoother the image but more spatial information you can get.\n.       @param neighbors The number of sample points to build a Circular Local Binary Pattern from. An\n.       appropriate value is to use `8` sample points. Keep in mind: the more sample points you include,\n.       the higher the computational cost.\n.       @param grid_x The number of cells in the horizontal direction, 8 is a common value used in\n.       publications. The more cells, the finer the grid, the higher the dimensionality of the resulting\n.       feature vector.\n.       @param grid_y The number of cells in the vertical direction, 8 is a common value used in\n.       publications. The more cells, the finer the grid, the higher the dimensionality of the resulting\n.       feature vector.\n.       @param threshold The threshold applied in the prediction. If the distance to the nearest neighbor\n.       is larger than the threshold, this method returns -1.\n.   \n.       ### Notes:\n.   \n.       -   The Circular Local Binary Patterns (used in training and prediction) expect the data given as\n.           grayscale images, use cvtColor to convert between the color spaces.\n.       -   This model supports updating.\n.   \n.       ### Model internal data:\n.   \n.       -   radius see LBPHFaceRecognizer::create.\n.       -   neighbors see LBPHFaceRecognizer::create.\n.       -   grid_x see LLBPHFaceRecognizer::create.\n.       -   grid_y see LBPHFaceRecognizer::create.\n.       -   threshold see LBPHFaceRecognizer::create.\n.       -   histograms Local Binary Patterns Histograms calculated from the given training data (empty if\n.           none was given).\n.       -   labels Labels corresponding to the calculated Local Binary Patterns Histograms."},
    {"getGridX", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_getGridX, 0), "getGridX() -> retval\n.   @see setGridX"},
    {"getGridY", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_getGridY, 0), "getGridY() -> retval\n.   @see setGridY"},
    {"getHistograms", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_getHistograms, 0), "getHistograms() -> retval\n."},
    {"getLabels", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_getLabels, 0), "getLabels() -> retval\n."},
    {"getNeighbors", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_getNeighbors, 0), "getNeighbors() -> retval\n.   @see setNeighbors"},
    {"getRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_getRadius, 0), "getRadius() -> retval\n.   @see setRadius"},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_getThreshold, 0), "getThreshold() -> retval\n.   @see setThreshold"},
    {"setGridX", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_setGridX, 0), "setGridX(val) -> None\n.   @copybrief getGridX @see getGridX"},
    {"setGridY", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_setGridY, 0), "setGridY(val) -> None\n.   @copybrief getGridY @see getGridY"},
    {"setNeighbors", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_setNeighbors, 0), "setNeighbors(val) -> None\n.   @copybrief getNeighbors @see getNeighbors"},
    {"setRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_setRadius, 0), "setRadius(val) -> None\n.   @copybrief getRadius @see getRadius"},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_LBPHFaceRecognizer_setThreshold, 0), "setThreshold(val) -> None\n.   @copybrief getThreshold @see getThreshold"},

    {NULL,          NULL}
};

// Converter (face_LBPHFaceRecognizer)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::LBPHFaceRecognizer> >
{
    static PyObject* from(const Ptr<cv::face::LBPHFaceRecognizer>& r)
    {
        return pyopencv_face_LBPHFaceRecognizer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::LBPHFaceRecognizer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::LBPHFaceRecognizer> * dst_;
        if (pyopencv_face_LBPHFaceRecognizer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::LBPHFaceRecognizer> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_MACE (Generic)
//================================================================================

// GetSet (face_MACE)



// Methods (face_MACE)

static PyObject* pyopencv_cv_face_face_MACE_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;

    int IMGSIZE=64;
    cv::Ptr<MACE> retval;

    const char* keywords[] = { "IMGSIZE", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:face_MACE.create", (char**)keywords, &IMGSIZE) )
    {
        ERRWRAP2(retval = cv::face::MACE::create(IMGSIZE));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_MACE_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;

    PyObject* pyobj_filename = NULL;
    String filename;
    PyObject* pyobj_objname = NULL;
    String objname;
    cv::Ptr<MACE> retval;

    const char* keywords[] = { "filename", "objname", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:face_MACE.load", (char**)keywords, &pyobj_filename, &pyobj_objname) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_objname, objname, ArgInfo("objname", 0)) )
    {
        ERRWRAP2(retval = cv::face::MACE::load(filename, objname));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_MACE_salt(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::MACE> * self1 = 0;
    if (!pyopencv_face_MACE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_MACE' or its derivative)");
    Ptr<cv::face::MACE> _self_ = *(self1);
    PyObject* pyobj_passphrase = NULL;
    String passphrase;

    const char* keywords[] = { "passphrase", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_MACE.salt", (char**)keywords, &pyobj_passphrase) &&
        pyopencv_to(pyobj_passphrase, passphrase, ArgInfo("passphrase", 0)) )
    {
        ERRWRAP2(_self_->salt(passphrase));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_MACE_same(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::MACE> * self1 = 0;
    if (!pyopencv_face_MACE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_MACE' or its derivative)");
    Ptr<cv::face::MACE> _self_ = *(self1);
    {
    PyObject* pyobj_query = NULL;
    Mat query;
    bool retval;

    const char* keywords[] = { "query", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_MACE.same", (char**)keywords, &pyobj_query) &&
        pyopencv_to(pyobj_query, query, ArgInfo("query", 0)) )
    {
        ERRWRAP2(retval = _self_->same(query));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_query = NULL;
    UMat query;
    bool retval;

    const char* keywords[] = { "query", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_MACE.same", (char**)keywords, &pyobj_query) &&
        pyopencv_to(pyobj_query, query, ArgInfo("query", 0)) )
    {
        ERRWRAP2(retval = _self_->same(query));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_MACE_train(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::MACE> * self1 = 0;
    if (!pyopencv_face_MACE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_MACE' or its derivative)");
    Ptr<cv::face::MACE> _self_ = *(self1);
    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;

    const char* keywords[] = { "images", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_MACE.train", (char**)keywords, &pyobj_images) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) )
    {
        ERRWRAP2(_self_->train(images));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;

    const char* keywords[] = { "images", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:face_MACE.train", (char**)keywords, &pyobj_images) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) )
    {
        ERRWRAP2(_self_->train(images));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (face_MACE)

static PyGetSetDef pyopencv_face_MACE_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_MACE_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_MACE_create_static, METH_STATIC), "create([, IMGSIZE]) -> retval\n.   @brief constructor\n.       @param IMGSIZE  images will get resized to this (should be an even number)"},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_MACE_load_static, METH_STATIC), "load(filename[, objname]) -> retval\n.   @brief constructor\n.       @param filename  build a new MACE instance from a pre-serialized FileStorage\n.       @param objname (optional) top-level node in the FileStorage"},
    {"salt", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_MACE_salt, 0), "salt(passphrase) -> None\n.   @brief optionally encrypt images with random convolution\n.       @param passphrase a crc64 random seed will get generated from this"},
    {"same", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_MACE_same, 0), "same(query) -> retval\n.   @brief correlate query img and threshold to min class value\n.       @param query  a Mat with query image"},
    {"train", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_MACE_train, 0), "train(images) -> None\n.   @brief train it on positive features\n.          compute the mace filter: `h = D(-1) * X * (X(+) * D(-1) * X)(-1) * C`\n.          also calculate a minimal threshold for this class, the smallest self-similarity from the train images\n.       @param images  a vector<Mat> with the train images"},

    {NULL,          NULL}
};

// Converter (face_MACE)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::MACE> >
{
    static PyObject* from(const Ptr<cv::face::MACE>& r)
    {
        return pyopencv_face_MACE_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::MACE>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::MACE> * dst_;
        if (pyopencv_face_MACE_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::MACE> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_PredictCollector (Generic)
//================================================================================

// GetSet (face_PredictCollector)



// Methods (face_PredictCollector)



// Tables (face_PredictCollector)

static PyGetSetDef pyopencv_face_PredictCollector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_PredictCollector_methods[] =
{

    {NULL,          NULL}
};

// Converter (face_PredictCollector)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::PredictCollector> >
{
    static PyObject* from(const Ptr<cv::face::PredictCollector>& r)
    {
        return pyopencv_face_PredictCollector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::PredictCollector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::PredictCollector> * dst_;
        if (pyopencv_face_PredictCollector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::PredictCollector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// face_StandardCollector (Generic)
//================================================================================

// GetSet (face_StandardCollector)



// Methods (face_StandardCollector)

static PyObject* pyopencv_cv_face_face_StandardCollector_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;

    double threshold=DBL_MAX;
    Ptr<StandardCollector> retval;

    const char* keywords[] = { "threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|d:face_StandardCollector.create", (char**)keywords, &threshold) )
    {
        ERRWRAP2(retval = cv::face::StandardCollector::create(threshold));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_StandardCollector_getMinDist(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::StandardCollector> * self1 = 0;
    if (!pyopencv_face_StandardCollector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_StandardCollector' or its derivative)");
    Ptr<cv::face::StandardCollector> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinDist());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_StandardCollector_getMinLabel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::StandardCollector> * self1 = 0;
    if (!pyopencv_face_StandardCollector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_StandardCollector' or its derivative)");
    Ptr<cv::face::StandardCollector> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinLabel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_face_face_StandardCollector_getResults(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::face;


    Ptr<cv::face::StandardCollector> * self1 = 0;
    if (!pyopencv_face_StandardCollector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'face_StandardCollector' or its derivative)");
    Ptr<cv::face::StandardCollector> _self_ = *(self1);
    bool sorted=false;
    std::vector< std::pair<int, double> > retval;

    const char* keywords[] = { "sorted", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|b:face_StandardCollector.getResults", (char**)keywords, &sorted) )
    {
        ERRWRAP2(retval = _self_->getResults(sorted));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (face_StandardCollector)

static PyGetSetDef pyopencv_face_StandardCollector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_face_StandardCollector_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_StandardCollector_create_static, METH_STATIC), "create([, threshold]) -> retval\n.   @brief Static constructor\n.       @param threshold set threshold"},
    {"getMinDist", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_StandardCollector_getMinDist, 0), "getMinDist() -> retval\n.   @brief Returns minimal distance value"},
    {"getMinLabel", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_StandardCollector_getMinLabel, 0), "getMinLabel() -> retval\n.   @brief Returns label with minimal distance"},
    {"getResults", CV_PY_FN_WITH_KW_(pyopencv_cv_face_face_StandardCollector_getResults, 0), "getResults([, sorted]) -> retval\n.   @brief Return results as vector\n.       @param sorted If set, results will be sorted by distance\n.       Each values is a pair of label and distance."},

    {NULL,          NULL}
};

// Converter (face_StandardCollector)

template<>
struct PyOpenCV_Converter< Ptr<cv::face::StandardCollector> >
{
    static PyObject* from(const Ptr<cv::face::StandardCollector>& r)
    {
        return pyopencv_face_StandardCollector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::face::StandardCollector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::face::StandardCollector> * dst_;
        if (pyopencv_face_StandardCollector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::face::StandardCollector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// flann_Index (Generic)
//================================================================================

// GetSet (flann_Index)



// Methods (flann_Index)

static int pyopencv_cv_flann_flann_Index_Index(pyopencv_flann_Index_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::flann::Index>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::flann::Index()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_features = NULL;
    Mat features;
    PyObject* pyobj_params = NULL;
    IndexParams params;
    PyObject* pyobj_distType = NULL;
    cvflann_flann_distance_t distType=cvflann::FLANN_DIST_L2;

    const char* keywords[] = { "features", "params", "distType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:Index", (char**)keywords, &pyobj_features, &pyobj_params, &pyobj_distType) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) &&
        pyopencv_to(pyobj_distType, distType, ArgInfo("distType", 0)) )
    {
        new (&(self->v)) Ptr<cv::flann::Index>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::flann::Index(features, params, distType)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_features = NULL;
    UMat features;
    PyObject* pyobj_params = NULL;
    IndexParams params;
    PyObject* pyobj_distType = NULL;
    cvflann_flann_distance_t distType=cvflann::FLANN_DIST_L2;

    const char* keywords[] = { "features", "params", "distType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:Index", (char**)keywords, &pyobj_features, &pyobj_params, &pyobj_distType) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) &&
        pyopencv_to(pyobj_distType, distType, ArgInfo("distType", 0)) )
    {
        new (&(self->v)) Ptr<cv::flann::Index>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::flann::Index(features, params, distType)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_flann_flann_Index_build(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;


    Ptr<cv::flann::Index> * self1 = 0;
    if (!pyopencv_flann_Index_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'flann_Index' or its derivative)");
    Ptr<cv::flann::Index> _self_ = *(self1);
    {
    PyObject* pyobj_features = NULL;
    Mat features;
    PyObject* pyobj_params = NULL;
    IndexParams params;
    PyObject* pyobj_distType = NULL;
    cvflann_flann_distance_t distType=cvflann::FLANN_DIST_L2;

    const char* keywords[] = { "features", "params", "distType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:flann_Index.build", (char**)keywords, &pyobj_features, &pyobj_params, &pyobj_distType) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) &&
        pyopencv_to(pyobj_distType, distType, ArgInfo("distType", 0)) )
    {
        ERRWRAP2(_self_->build(features, params, distType));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_features = NULL;
    UMat features;
    PyObject* pyobj_params = NULL;
    IndexParams params;
    PyObject* pyobj_distType = NULL;
    cvflann_flann_distance_t distType=cvflann::FLANN_DIST_L2;

    const char* keywords[] = { "features", "params", "distType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:flann_Index.build", (char**)keywords, &pyobj_features, &pyobj_params, &pyobj_distType) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) &&
        pyopencv_to(pyobj_distType, distType, ArgInfo("distType", 0)) )
    {
        ERRWRAP2(_self_->build(features, params, distType));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_flann_flann_Index_getAlgorithm(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;


    Ptr<cv::flann::Index> * self1 = 0;
    if (!pyopencv_flann_Index_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'flann_Index' or its derivative)");
    Ptr<cv::flann::Index> _self_ = *(self1);
    cvflann::flann_algorithm_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAlgorithm());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_flann_flann_Index_getDistance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;


    Ptr<cv::flann::Index> * self1 = 0;
    if (!pyopencv_flann_Index_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'flann_Index' or its derivative)");
    Ptr<cv::flann::Index> _self_ = *(self1);
    cvflann::flann_distance_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDistance());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_flann_flann_Index_knnSearch(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;


    Ptr<cv::flann::Index> * self1 = 0;
    if (!pyopencv_flann_Index_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'flann_Index' or its derivative)");
    Ptr<cv::flann::Index> _self_ = *(self1);
    {
    PyObject* pyobj_query = NULL;
    Mat query;
    PyObject* pyobj_indices = NULL;
    Mat indices;
    PyObject* pyobj_dists = NULL;
    Mat dists;
    int knn=0;
    PyObject* pyobj_params = NULL;
    SearchParams params;

    const char* keywords[] = { "query", "knn", "indices", "dists", "params", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|OOO:flann_Index.knnSearch", (char**)keywords, &pyobj_query, &knn, &pyobj_indices, &pyobj_dists, &pyobj_params) &&
        pyopencv_to(pyobj_query, query, ArgInfo("query", 0)) &&
        pyopencv_to(pyobj_indices, indices, ArgInfo("indices", 1)) &&
        pyopencv_to(pyobj_dists, dists, ArgInfo("dists", 1)) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) )
    {
        ERRWRAP2(_self_->knnSearch(query, indices, dists, knn, params));
        return Py_BuildValue("(NN)", pyopencv_from(indices), pyopencv_from(dists));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_query = NULL;
    UMat query;
    PyObject* pyobj_indices = NULL;
    UMat indices;
    PyObject* pyobj_dists = NULL;
    UMat dists;
    int knn=0;
    PyObject* pyobj_params = NULL;
    SearchParams params;

    const char* keywords[] = { "query", "knn", "indices", "dists", "params", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|OOO:flann_Index.knnSearch", (char**)keywords, &pyobj_query, &knn, &pyobj_indices, &pyobj_dists, &pyobj_params) &&
        pyopencv_to(pyobj_query, query, ArgInfo("query", 0)) &&
        pyopencv_to(pyobj_indices, indices, ArgInfo("indices", 1)) &&
        pyopencv_to(pyobj_dists, dists, ArgInfo("dists", 1)) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) )
    {
        ERRWRAP2(_self_->knnSearch(query, indices, dists, knn, params));
        return Py_BuildValue("(NN)", pyopencv_from(indices), pyopencv_from(dists));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_flann_flann_Index_load(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;


    Ptr<cv::flann::Index> * self1 = 0;
    if (!pyopencv_flann_Index_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'flann_Index' or its derivative)");
    Ptr<cv::flann::Index> _self_ = *(self1);
    {
    PyObject* pyobj_features = NULL;
    Mat features;
    PyObject* pyobj_filename = NULL;
    String filename;
    bool retval;

    const char* keywords[] = { "features", "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:flann_Index.load", (char**)keywords, &pyobj_features, &pyobj_filename) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        ERRWRAP2(retval = _self_->load(features, filename));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_features = NULL;
    UMat features;
    PyObject* pyobj_filename = NULL;
    String filename;
    bool retval;

    const char* keywords[] = { "features", "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:flann_Index.load", (char**)keywords, &pyobj_features, &pyobj_filename) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        ERRWRAP2(retval = _self_->load(features, filename));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_flann_flann_Index_radiusSearch(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;


    Ptr<cv::flann::Index> * self1 = 0;
    if (!pyopencv_flann_Index_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'flann_Index' or its derivative)");
    Ptr<cv::flann::Index> _self_ = *(self1);
    {
    PyObject* pyobj_query = NULL;
    Mat query;
    PyObject* pyobj_indices = NULL;
    Mat indices;
    PyObject* pyobj_dists = NULL;
    Mat dists;
    double radius=0;
    int maxResults=0;
    PyObject* pyobj_params = NULL;
    SearchParams params;
    int retval;

    const char* keywords[] = { "query", "radius", "maxResults", "indices", "dists", "params", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Odi|OOO:flann_Index.radiusSearch", (char**)keywords, &pyobj_query, &radius, &maxResults, &pyobj_indices, &pyobj_dists, &pyobj_params) &&
        pyopencv_to(pyobj_query, query, ArgInfo("query", 0)) &&
        pyopencv_to(pyobj_indices, indices, ArgInfo("indices", 1)) &&
        pyopencv_to(pyobj_dists, dists, ArgInfo("dists", 1)) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) )
    {
        ERRWRAP2(retval = _self_->radiusSearch(query, indices, dists, radius, maxResults, params));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(indices), pyopencv_from(dists));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_query = NULL;
    UMat query;
    PyObject* pyobj_indices = NULL;
    UMat indices;
    PyObject* pyobj_dists = NULL;
    UMat dists;
    double radius=0;
    int maxResults=0;
    PyObject* pyobj_params = NULL;
    SearchParams params;
    int retval;

    const char* keywords[] = { "query", "radius", "maxResults", "indices", "dists", "params", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Odi|OOO:flann_Index.radiusSearch", (char**)keywords, &pyobj_query, &radius, &maxResults, &pyobj_indices, &pyobj_dists, &pyobj_params) &&
        pyopencv_to(pyobj_query, query, ArgInfo("query", 0)) &&
        pyopencv_to(pyobj_indices, indices, ArgInfo("indices", 1)) &&
        pyopencv_to(pyobj_dists, dists, ArgInfo("dists", 1)) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) )
    {
        ERRWRAP2(retval = _self_->radiusSearch(query, indices, dists, radius, maxResults, params));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(indices), pyopencv_from(dists));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_flann_flann_Index_release(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;


    Ptr<cv::flann::Index> * self1 = 0;
    if (!pyopencv_flann_Index_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'flann_Index' or its derivative)");
    Ptr<cv::flann::Index> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->release());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_flann_flann_Index_save(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::flann;


    Ptr<cv::flann::Index> * self1 = 0;
    if (!pyopencv_flann_Index_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'flann_Index' or its derivative)");
    Ptr<cv::flann::Index> _self_ = *(self1);
    PyObject* pyobj_filename = NULL;
    String filename;

    const char* keywords[] = { "filename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:flann_Index.save", (char**)keywords, &pyobj_filename) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) )
    {
        ERRWRAP2(_self_->save(filename));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (flann_Index)

static PyGetSetDef pyopencv_flann_Index_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_flann_Index_methods[] =
{
    {"build", CV_PY_FN_WITH_KW_(pyopencv_cv_flann_flann_Index_build, 0), "build(features, params[, distType]) -> None\n."},
    {"getAlgorithm", CV_PY_FN_WITH_KW_(pyopencv_cv_flann_flann_Index_getAlgorithm, 0), "getAlgorithm() -> retval\n."},
    {"getDistance", CV_PY_FN_WITH_KW_(pyopencv_cv_flann_flann_Index_getDistance, 0), "getDistance() -> retval\n."},
    {"knnSearch", CV_PY_FN_WITH_KW_(pyopencv_cv_flann_flann_Index_knnSearch, 0), "knnSearch(query, knn[, indices[, dists[, params]]]) -> indices, dists\n."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_flann_flann_Index_load, 0), "load(features, filename) -> retval\n."},
    {"radiusSearch", CV_PY_FN_WITH_KW_(pyopencv_cv_flann_flann_Index_radiusSearch, 0), "radiusSearch(query, radius, maxResults[, indices[, dists[, params]]]) -> retval, indices, dists\n."},
    {"release", CV_PY_FN_WITH_KW_(pyopencv_cv_flann_flann_Index_release, 0), "release() -> None\n."},
    {"save", CV_PY_FN_WITH_KW_(pyopencv_cv_flann_flann_Index_save, 0), "save(filename) -> None\n."},

    {NULL,          NULL}
};

// Converter (flann_Index)

template<>
struct PyOpenCV_Converter< Ptr<cv::flann::Index> >
{
    static PyObject* from(const Ptr<cv::flann::Index>& r)
    {
        return pyopencv_flann_Index_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::flann::Index>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::flann::Index> * dst_;
        if (pyopencv_flann_Index_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::flann::Index> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// freetype_FreeType2 (Generic)
//================================================================================

// GetSet (freetype_FreeType2)



// Methods (freetype_FreeType2)

static PyObject* pyopencv_cv_freetype_freetype_FreeType2_getTextSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::freetype;


    Ptr<cv::freetype::FreeType2> * self1 = 0;
    if (!pyopencv_freetype_FreeType2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'freetype_FreeType2' or its derivative)");
    Ptr<cv::freetype::FreeType2> _self_ = *(self1);
    PyObject* pyobj_text = NULL;
    String text;
    int fontHeight=0;
    int thickness=0;
    int baseLine;
    Size retval;

    const char* keywords[] = { "text", "fontHeight", "thickness", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oii:freetype_FreeType2.getTextSize", (char**)keywords, &pyobj_text, &fontHeight, &thickness) &&
        pyopencv_to(pyobj_text, text, ArgInfo("text", 0)) )
    {
        ERRWRAP2(retval = _self_->getTextSize(text, fontHeight, thickness, &baseLine));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(baseLine));
    }

    return NULL;
}

static PyObject* pyopencv_cv_freetype_freetype_FreeType2_loadFontData(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::freetype;


    Ptr<cv::freetype::FreeType2> * self1 = 0;
    if (!pyopencv_freetype_FreeType2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'freetype_FreeType2' or its derivative)");
    Ptr<cv::freetype::FreeType2> _self_ = *(self1);
    PyObject* pyobj_fontFileName = NULL;
    String fontFileName;
    int id=0;

    const char* keywords[] = { "fontFileName", "id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:freetype_FreeType2.loadFontData", (char**)keywords, &pyobj_fontFileName, &id) &&
        pyopencv_to(pyobj_fontFileName, fontFileName, ArgInfo("fontFileName", 0)) )
    {
        ERRWRAP2(_self_->loadFontData(fontFileName, id));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_freetype_freetype_FreeType2_putText(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::freetype;


    Ptr<cv::freetype::FreeType2> * self1 = 0;
    if (!pyopencv_freetype_FreeType2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'freetype_FreeType2' or its derivative)");
    Ptr<cv::freetype::FreeType2> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_text = NULL;
    String text;
    PyObject* pyobj_org = NULL;
    Point org;
    int fontHeight=0;
    PyObject* pyobj_color = NULL;
    Scalar color;
    int thickness=0;
    int line_type=0;
    bool bottomLeftOrigin=0;

    const char* keywords[] = { "img", "text", "org", "fontHeight", "color", "thickness", "line_type", "bottomLeftOrigin", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOiOiib:freetype_FreeType2.putText", (char**)keywords, &pyobj_img, &pyobj_text, &pyobj_org, &fontHeight, &pyobj_color, &thickness, &line_type, &bottomLeftOrigin) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 1)) &&
        pyopencv_to(pyobj_text, text, ArgInfo("text", 0)) &&
        pyopencv_to(pyobj_org, org, ArgInfo("org", 0)) &&
        pyopencv_to(pyobj_color, color, ArgInfo("color", 0)) )
    {
        ERRWRAP2(_self_->putText(img, text, org, fontHeight, color, thickness, line_type, bottomLeftOrigin));
        return pyopencv_from(img);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_text = NULL;
    String text;
    PyObject* pyobj_org = NULL;
    Point org;
    int fontHeight=0;
    PyObject* pyobj_color = NULL;
    Scalar color;
    int thickness=0;
    int line_type=0;
    bool bottomLeftOrigin=0;

    const char* keywords[] = { "img", "text", "org", "fontHeight", "color", "thickness", "line_type", "bottomLeftOrigin", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOiOiib:freetype_FreeType2.putText", (char**)keywords, &pyobj_img, &pyobj_text, &pyobj_org, &fontHeight, &pyobj_color, &thickness, &line_type, &bottomLeftOrigin) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 1)) &&
        pyopencv_to(pyobj_text, text, ArgInfo("text", 0)) &&
        pyopencv_to(pyobj_org, org, ArgInfo("org", 0)) &&
        pyopencv_to(pyobj_color, color, ArgInfo("color", 0)) )
    {
        ERRWRAP2(_self_->putText(img, text, org, fontHeight, color, thickness, line_type, bottomLeftOrigin));
        return pyopencv_from(img);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_freetype_freetype_FreeType2_setSplitNumber(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::freetype;


    Ptr<cv::freetype::FreeType2> * self1 = 0;
    if (!pyopencv_freetype_FreeType2_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'freetype_FreeType2' or its derivative)");
    Ptr<cv::freetype::FreeType2> _self_ = *(self1);
    int num=0;

    const char* keywords[] = { "num", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:freetype_FreeType2.setSplitNumber", (char**)keywords, &num) )
    {
        ERRWRAP2(_self_->setSplitNumber(num));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (freetype_FreeType2)

static PyGetSetDef pyopencv_freetype_FreeType2_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_freetype_FreeType2_methods[] =
{
    {"getTextSize", CV_PY_FN_WITH_KW_(pyopencv_cv_freetype_freetype_FreeType2_getTextSize, 0), "getTextSize(text, fontHeight, thickness) -> retval, baseLine\n.   @brief Calculates the width and height of a text string.\n.   \n.   The function getTextSize calculates and returns the approximate size of a box that contains the specified text.\n.   That is, the following code renders some text, the tight box surrounding it, and the baseline: :\n.   @code\n.       String text = \"Funny text inside the box\";\n.       int fontHeight = 60;\n.       int thickness = -1;\n.       int linestyle = 8;\n.   \n.       Mat img(600, 800, CV_8UC3, Scalar::all(0));\n.   \n.       int baseline=0;\n.   \n.       cv::Ptr<cv::freetype::FreeType2> ft2;\n.       ft2 = cv::freetype::createFreeType2();\n.       ft2->loadFontData( \"./mplus-1p-regular.ttf\", 0 );\n.   \n.       Size textSize = ft2->getTextSize(text,\n.                                        fontHeight,\n.                                        thickness,\n.                                        &baseline);\n.   \n.       if(thickness > 0){\n.           baseline += thickness;\n.       }\n.   \n.       // center the text\n.       Point textOrg((img.cols - textSize.width) / 2,\n.                     (img.rows + textSize.height) / 2);\n.   \n.       // draw the box\n.       rectangle(img, textOrg + Point(0, baseline),\n.                 textOrg + Point(textSize.width, -textSize.height),\n.                 Scalar(0,255,0),1,8);\n.   \n.       // ... and the baseline first\n.       line(img, textOrg + Point(0, thickness),\n.            textOrg + Point(textSize.width, thickness),\n.            Scalar(0, 0, 255),1,8);\n.   \n.       // then put the text itself\n.       ft2->putText(img, text, textOrg, fontHeight,\n.                    Scalar::all(255), thickness, linestyle, true );\n.   @endcode\n.   \n.   @param text Input text string.\n.   @param fontHeight Drawing font size by pixel unit.\n.   @param thickness Thickness of lines used to render the text. See putText for details.\n.   @param[out] baseLine y-coordinate of the baseline relative to the bottom-most text\n.   point.\n.   @return The size of a box that contains the specified text.\n.   \n.   @see cv::putText"},
    {"loadFontData", CV_PY_FN_WITH_KW_(pyopencv_cv_freetype_freetype_FreeType2_loadFontData, 0), "loadFontData(fontFileName, id) -> None\n.   @brief Load font data.\n.   \n.   The function loadFontData loads font data.\n.   \n.   @param fontFileName FontFile Name\n.   @param id face_index to select a font faces in a single file."},
    {"putText", CV_PY_FN_WITH_KW_(pyopencv_cv_freetype_freetype_FreeType2_putText, 0), "putText(img, text, org, fontHeight, color, thickness, line_type, bottomLeftOrigin) -> img\n.   @brief Draws a text string.\n.   \n.   The function putText renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by \"Tofu\" or non-drawn.\n.   \n.   @param img Image.\n.   @param text Text string to be drawn.\n.   @param org Bottom-left/Top-left corner of the text string in the image.\n.   @param fontHeight Drawing font size by pixel unit.\n.   @param color Text color.\n.   @param thickness Thickness of the lines used to draw a text when negative, the glyph is filled. Otherwise, the glyph is drawn with this thickness.\n.   @param line_type Line type. See the line for details.\n.   @param bottomLeftOrigin When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner."},
    {"setSplitNumber", CV_PY_FN_WITH_KW_(pyopencv_cv_freetype_freetype_FreeType2_setSplitNumber, 0), "setSplitNumber(num) -> None\n.   @brief Set Split Number from Bezier-curve to line\n.   \n.   The function setSplitNumber set the number of split points from bezier-curve to line.\n.   If you want to draw large glyph, large is better.\n.   If you want to draw small glyph, small is better.\n.   \n.   @param num number of split points from bezier-curve to line"},

    {NULL,          NULL}
};

// Converter (freetype_FreeType2)

template<>
struct PyOpenCV_Converter< Ptr<cv::freetype::FreeType2> >
{
    static PyObject* from(const Ptr<cv::freetype::FreeType2>& r)
    {
        return pyopencv_freetype_FreeType2_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::freetype::FreeType2>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::freetype::FreeType2> * dst_;
        if (pyopencv_freetype_FreeType2_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::freetype::FreeType2> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// hdf_HDF5 (Generic)
//================================================================================

// GetSet (hdf_HDF5)



// Methods (hdf_HDF5)

static PyObject* pyopencv_cv_hdf_hdf_HDF5_atdelete(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:hdf_HDF5.atdelete", (char**)keywords, &pyobj_atlabel) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atdelete(atlabel));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_atexists(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    PyObject* pyobj_atlabel = NULL;
    String atlabel;
    bool retval;

    const char* keywords[] = { "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:hdf_HDF5.atexists", (char**)keywords, &pyobj_atlabel) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(retval = _self_->atexists(atlabel));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_atread(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    {
    int value=0;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "value", "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO:hdf_HDF5.atread", (char**)keywords, &value, &pyobj_atlabel) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atread(&value, atlabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    double value=0;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "value", "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "dO:hdf_HDF5.atread", (char**)keywords, &value, &pyobj_atlabel) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atread(&value, atlabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_value = NULL;
    String value;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "value", "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:hdf_HDF5.atread", (char**)keywords, &pyobj_value, &pyobj_atlabel) &&
        pyopencv_to(pyobj_value, value, ArgInfo("value", 0)) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atread(&value, atlabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_value = NULL;
    Mat value;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "atlabel", "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:hdf_HDF5.atread", (char**)keywords, &pyobj_atlabel, &pyobj_value) &&
        pyopencv_to(pyobj_value, value, ArgInfo("value", 1)) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atread(value, atlabel));
        return pyopencv_from(value);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_value = NULL;
    UMat value;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "atlabel", "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:hdf_HDF5.atread", (char**)keywords, &pyobj_atlabel, &pyobj_value) &&
        pyopencv_to(pyobj_value, value, ArgInfo("value", 1)) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atread(value, atlabel));
        return pyopencv_from(value);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_atwrite(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    {
    int value=0;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "value", "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iO:hdf_HDF5.atwrite", (char**)keywords, &value, &pyobj_atlabel) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atwrite(value, atlabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    double value=0;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "value", "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "dO:hdf_HDF5.atwrite", (char**)keywords, &value, &pyobj_atlabel) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atwrite(value, atlabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_value = NULL;
    String value;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "value", "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:hdf_HDF5.atwrite", (char**)keywords, &pyobj_value, &pyobj_atlabel) &&
        pyopencv_to(pyobj_value, value, ArgInfo("value", 0)) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atwrite(value, atlabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_value = NULL;
    Mat value;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "value", "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:hdf_HDF5.atwrite", (char**)keywords, &pyobj_value, &pyobj_atlabel) &&
        pyopencv_to(pyobj_value, value, ArgInfo("value", 0)) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atwrite(value, atlabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_value = NULL;
    UMat value;
    PyObject* pyobj_atlabel = NULL;
    String atlabel;

    const char* keywords[] = { "value", "atlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:hdf_HDF5.atwrite", (char**)keywords, &pyobj_value, &pyobj_atlabel) &&
        pyopencv_to(pyobj_value, value, ArgInfo("value", 0)) &&
        pyopencv_to(pyobj_atlabel, atlabel, ArgInfo("atlabel", 0)) )
    {
        ERRWRAP2(_self_->atwrite(value, atlabel));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_close(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->close());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_dscreate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;

    const char* keywords[] = { "rows", "cols", "type", "dslabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiO:hdf_HDF5.dscreate", (char**)keywords, &rows, &cols, &type, &pyobj_dslabel) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dscreate(rows, cols, type, dslabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int compresslevel=0;

    const char* keywords[] = { "rows", "cols", "type", "dslabel", "compresslevel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiOi:hdf_HDF5.dscreate", (char**)keywords, &rows, &cols, &type, &pyobj_dslabel, &compresslevel) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dscreate(rows, cols, type, dslabel, compresslevel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int compresslevel=0;
    PyObject* pyobj_dims_chunks = NULL;
    vector_int dims_chunks;

    const char* keywords[] = { "rows", "cols", "type", "dslabel", "compresslevel", "dims_chunks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiOiO:hdf_HDF5.dscreate", (char**)keywords, &rows, &cols, &type, &pyobj_dslabel, &compresslevel, &pyobj_dims_chunks) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) &&
        pyopencv_to(pyobj_dims_chunks, dims_chunks, ArgInfo("dims_chunks", 0)) )
    {
        ERRWRAP2(_self_->dscreate(rows, cols, type, dslabel, compresslevel, dims_chunks));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int type=0;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int compresslevel=0;
    int dims_chunks=0;

    const char* keywords[] = { "rows", "cols", "type", "dslabel", "compresslevel", "dims_chunks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiOii:hdf_HDF5.dscreate", (char**)keywords, &rows, &cols, &type, &pyobj_dslabel, &compresslevel, &dims_chunks) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dscreate(rows, cols, type, dslabel, compresslevel, &dims_chunks));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    int n_dims=0;
    int sizes=0;
    int type=0;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;

    const char* keywords[] = { "n_dims", "sizes", "type", "dslabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiO:hdf_HDF5.dscreate", (char**)keywords, &n_dims, &sizes, &type, &pyobj_dslabel) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dscreate(n_dims, &sizes, type, dslabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    int n_dims=0;
    int sizes=0;
    int type=0;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int compresslevel=0;

    const char* keywords[] = { "n_dims", "sizes", "type", "dslabel", "compresslevel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiOi:hdf_HDF5.dscreate", (char**)keywords, &n_dims, &sizes, &type, &pyobj_dslabel, &compresslevel) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dscreate(n_dims, &sizes, type, dslabel, compresslevel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_sizes = NULL;
    vector_int sizes;
    int type=0;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int compresslevel=HDF5::H5_NONE;
    PyObject* pyobj_dims_chunks = NULL;
    vector_int dims_chunks=vector<int>();

    const char* keywords[] = { "sizes", "type", "dslabel", "compresslevel", "dims_chunks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO|iO:hdf_HDF5.dscreate", (char**)keywords, &pyobj_sizes, &type, &pyobj_dslabel, &compresslevel, &pyobj_dims_chunks) &&
        pyopencv_to(pyobj_sizes, sizes, ArgInfo("sizes", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) &&
        pyopencv_to(pyobj_dims_chunks, dims_chunks, ArgInfo("dims_chunks", 0)) )
    {
        ERRWRAP2(_self_->dscreate(sizes, type, dslabel, compresslevel, dims_chunks));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    int n_dims=0;
    int sizes=0;
    int type=0;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int compresslevel=0;
    int dims_chunks=0;

    const char* keywords[] = { "n_dims", "sizes", "type", "dslabel", "compresslevel", "dims_chunks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiOii:hdf_HDF5.dscreate", (char**)keywords, &n_dims, &sizes, &type, &pyobj_dslabel, &compresslevel, &dims_chunks) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dscreate(n_dims, &sizes, type, dslabel, compresslevel, &dims_chunks));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_dsgetsize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_flag=HDF5::H5_GETDIMS;
    vector<int> retval;

    const char* keywords[] = { "dslabel", "dims_flag", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:hdf_HDF5.dsgetsize", (char**)keywords, &pyobj_dslabel, &dims_flag) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(retval = _self_->dsgetsize(dslabel, dims_flag));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_dsgettype(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int retval;

    const char* keywords[] = { "dslabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:hdf_HDF5.dsgettype", (char**)keywords, &pyobj_dslabel) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(retval = _self_->dsgettype(dslabel));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_dsinsert(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;

    const char* keywords[] = { "Array", "dslabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:hdf_HDF5.dsinsert", (char**)keywords, &pyobj_Array, &pyobj_dslabel) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsinsert(Array, dslabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;

    const char* keywords[] = { "Array", "dslabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:hdf_HDF5.dsinsert", (char**)keywords, &pyobj_Array, &pyobj_dslabel) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsinsert(Array, dslabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;

    const char* keywords[] = { "Array", "dslabel", "dims_offset", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi:hdf_HDF5.dsinsert", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &dims_offset) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsinsert(Array, dslabel, &dims_offset));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;

    const char* keywords[] = { "Array", "dslabel", "dims_offset", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi:hdf_HDF5.dsinsert", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &dims_offset) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsinsert(Array, dslabel, &dims_offset));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    PyObject* pyobj_dims_offset = NULL;
    vector_int dims_offset;
    PyObject* pyobj_dims_counts = NULL;
    vector_int dims_counts=vector<int>();

    const char* keywords[] = { "Array", "dslabel", "dims_offset", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:hdf_HDF5.dsinsert", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &pyobj_dims_offset, &pyobj_dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) &&
        pyopencv_to(pyobj_dims_offset, dims_offset, ArgInfo("dims_offset", 0)) &&
        pyopencv_to(pyobj_dims_counts, dims_counts, ArgInfo("dims_counts", 0)) )
    {
        ERRWRAP2(_self_->dsinsert(Array, dslabel, dims_offset, dims_counts));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    PyObject* pyobj_dims_offset = NULL;
    vector_int dims_offset;
    PyObject* pyobj_dims_counts = NULL;
    vector_int dims_counts=vector<int>();

    const char* keywords[] = { "Array", "dslabel", "dims_offset", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:hdf_HDF5.dsinsert", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &pyobj_dims_offset, &pyobj_dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) &&
        pyopencv_to(pyobj_dims_offset, dims_offset, ArgInfo("dims_offset", 0)) &&
        pyopencv_to(pyobj_dims_counts, dims_counts, ArgInfo("dims_counts", 0)) )
    {
        ERRWRAP2(_self_->dsinsert(Array, dslabel, dims_offset, dims_counts));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;
    int dims_counts=0;

    const char* keywords[] = { "Array", "dslabel", "dims_offset", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOii:hdf_HDF5.dsinsert", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &dims_offset, &dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsinsert(Array, dslabel, &dims_offset, &dims_counts));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;
    int dims_counts=0;

    const char* keywords[] = { "Array", "dslabel", "dims_offset", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOii:hdf_HDF5.dsinsert", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &dims_offset, &dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsinsert(Array, dslabel, &dims_offset, &dims_counts));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_dsread(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;

    const char* keywords[] = { "dslabel", "Array", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:hdf_HDF5.dsread", (char**)keywords, &pyobj_dslabel, &pyobj_Array) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 1)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsread(Array, dslabel));
        return pyopencv_from(Array);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;

    const char* keywords[] = { "dslabel", "Array", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:hdf_HDF5.dsread", (char**)keywords, &pyobj_dslabel, &pyobj_Array) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 1)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsread(Array, dslabel));
        return pyopencv_from(Array);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;

    const char* keywords[] = { "dslabel", "dims_offset", "Array", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:hdf_HDF5.dsread", (char**)keywords, &pyobj_dslabel, &dims_offset, &pyobj_Array) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 1)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsread(Array, dslabel, &dims_offset));
        return pyopencv_from(Array);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;

    const char* keywords[] = { "dslabel", "dims_offset", "Array", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:hdf_HDF5.dsread", (char**)keywords, &pyobj_dslabel, &dims_offset, &pyobj_Array) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 1)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsread(Array, dslabel, &dims_offset));
        return pyopencv_from(Array);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    PyObject* pyobj_dims_offset = NULL;
    vector_int dims_offset;
    PyObject* pyobj_dims_counts = NULL;
    vector_int dims_counts=vector<int>();

    const char* keywords[] = { "dslabel", "dims_offset", "Array", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:hdf_HDF5.dsread", (char**)keywords, &pyobj_dslabel, &pyobj_dims_offset, &pyobj_Array, &pyobj_dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 1)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) &&
        pyopencv_to(pyobj_dims_offset, dims_offset, ArgInfo("dims_offset", 0)) &&
        pyopencv_to(pyobj_dims_counts, dims_counts, ArgInfo("dims_counts", 0)) )
    {
        ERRWRAP2(_self_->dsread(Array, dslabel, dims_offset, dims_counts));
        return pyopencv_from(Array);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    PyObject* pyobj_dims_offset = NULL;
    vector_int dims_offset;
    PyObject* pyobj_dims_counts = NULL;
    vector_int dims_counts=vector<int>();

    const char* keywords[] = { "dslabel", "dims_offset", "Array", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:hdf_HDF5.dsread", (char**)keywords, &pyobj_dslabel, &pyobj_dims_offset, &pyobj_Array, &pyobj_dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 1)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) &&
        pyopencv_to(pyobj_dims_offset, dims_offset, ArgInfo("dims_offset", 0)) &&
        pyopencv_to(pyobj_dims_counts, dims_counts, ArgInfo("dims_counts", 0)) )
    {
        ERRWRAP2(_self_->dsread(Array, dslabel, dims_offset, dims_counts));
        return pyopencv_from(Array);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;
    int dims_counts=0;

    const char* keywords[] = { "dslabel", "dims_offset", "dims_counts", "Array", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oii|O:hdf_HDF5.dsread", (char**)keywords, &pyobj_dslabel, &dims_offset, &dims_counts, &pyobj_Array) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 1)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsread(Array, dslabel, &dims_offset, &dims_counts));
        return pyopencv_from(Array);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;
    int dims_counts=0;

    const char* keywords[] = { "dslabel", "dims_offset", "dims_counts", "Array", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oii|O:hdf_HDF5.dsread", (char**)keywords, &pyobj_dslabel, &dims_offset, &dims_counts, &pyobj_Array) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 1)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dsread(Array, dslabel, &dims_offset, &dims_counts));
        return pyopencv_from(Array);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_dswrite(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;

    const char* keywords[] = { "Array", "dslabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:hdf_HDF5.dswrite", (char**)keywords, &pyobj_Array, &pyobj_dslabel) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dswrite(Array, dslabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;

    const char* keywords[] = { "Array", "dslabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:hdf_HDF5.dswrite", (char**)keywords, &pyobj_Array, &pyobj_dslabel) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dswrite(Array, dslabel));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;

    const char* keywords[] = { "Array", "dslabel", "dims_offset", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi:hdf_HDF5.dswrite", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &dims_offset) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dswrite(Array, dslabel, &dims_offset));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;

    const char* keywords[] = { "Array", "dslabel", "dims_offset", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi:hdf_HDF5.dswrite", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &dims_offset) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dswrite(Array, dslabel, &dims_offset));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    PyObject* pyobj_dims_offset = NULL;
    vector_int dims_offset;
    PyObject* pyobj_dims_counts = NULL;
    vector_int dims_counts=vector<int>();

    const char* keywords[] = { "Array", "dslabel", "dims_offset", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:hdf_HDF5.dswrite", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &pyobj_dims_offset, &pyobj_dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) &&
        pyopencv_to(pyobj_dims_offset, dims_offset, ArgInfo("dims_offset", 0)) &&
        pyopencv_to(pyobj_dims_counts, dims_counts, ArgInfo("dims_counts", 0)) )
    {
        ERRWRAP2(_self_->dswrite(Array, dslabel, dims_offset, dims_counts));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    PyObject* pyobj_dims_offset = NULL;
    vector_int dims_offset;
    PyObject* pyobj_dims_counts = NULL;
    vector_int dims_counts=vector<int>();

    const char* keywords[] = { "Array", "dslabel", "dims_offset", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:hdf_HDF5.dswrite", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &pyobj_dims_offset, &pyobj_dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) &&
        pyopencv_to(pyobj_dims_offset, dims_offset, ArgInfo("dims_offset", 0)) &&
        pyopencv_to(pyobj_dims_counts, dims_counts, ArgInfo("dims_counts", 0)) )
    {
        ERRWRAP2(_self_->dswrite(Array, dslabel, dims_offset, dims_counts));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    Mat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;
    int dims_counts=0;

    const char* keywords[] = { "Array", "dslabel", "dims_offset", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOii:hdf_HDF5.dswrite", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &dims_offset, &dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dswrite(Array, dslabel, &dims_offset, &dims_counts));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Array = NULL;
    UMat Array;
    PyObject* pyobj_dslabel = NULL;
    String dslabel;
    int dims_offset=0;
    int dims_counts=0;

    const char* keywords[] = { "Array", "dslabel", "dims_offset", "dims_counts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOii:hdf_HDF5.dswrite", (char**)keywords, &pyobj_Array, &pyobj_dslabel, &dims_offset, &dims_counts) &&
        pyopencv_to(pyobj_Array, Array, ArgInfo("Array", 0)) &&
        pyopencv_to(pyobj_dslabel, dslabel, ArgInfo("dslabel", 0)) )
    {
        ERRWRAP2(_self_->dswrite(Array, dslabel, &dims_offset, &dims_counts));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_grcreate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    PyObject* pyobj_grlabel = NULL;
    String grlabel;

    const char* keywords[] = { "grlabel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:hdf_HDF5.grcreate", (char**)keywords, &pyobj_grlabel) &&
        pyopencv_to(pyobj_grlabel, grlabel, ArgInfo("grlabel", 0)) )
    {
        ERRWRAP2(_self_->grcreate(grlabel));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_hlexists(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    PyObject* pyobj_label = NULL;
    String label;
    bool retval;

    const char* keywords[] = { "label", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:hdf_HDF5.hlexists", (char**)keywords, &pyobj_label) &&
        pyopencv_to(pyobj_label, label, ArgInfo("label", 0)) )
    {
        ERRWRAP2(retval = _self_->hlexists(label));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hdf_hdf_HDF5_kpgetsize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hdf;


    Ptr<cv::hdf::HDF5> * self1 = 0;
    if (!pyopencv_hdf_HDF5_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hdf_HDF5' or its derivative)");
    Ptr<cv::hdf::HDF5> _self_ = *(self1);
    PyObject* pyobj_kplabel = NULL;
    String kplabel;
    int dims_flag=HDF5::H5_GETDIMS;
    int retval;

    const char* keywords[] = { "kplabel", "dims_flag", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:hdf_HDF5.kpgetsize", (char**)keywords, &pyobj_kplabel, &dims_flag) &&
        pyopencv_to(pyobj_kplabel, kplabel, ArgInfo("kplabel", 0)) )
    {
        ERRWRAP2(retval = _self_->kpgetsize(kplabel, dims_flag));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (hdf_HDF5)

static PyGetSetDef pyopencv_hdf_HDF5_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_hdf_HDF5_methods[] =
{
    {"atdelete", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_atdelete, 0), "atdelete(atlabel) -> None\n.   * Delete an attribute from the root group.\n.        *\n.        * @param atlabel the attribute to be deleted.\n.        *\n.        * @note CV_Error() is called if the given attribute does not exist. Use atexists()\n.        * to check whether it exists or not beforehand.\n.        *\n.        * @sa atexists, atwrite, atread"},
    {"atexists", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_atexists, 0), "atexists(atlabel) -> retval\n.   * Check whether a given attribute exits or not in the root group.\n.        *\n.        * @param atlabel the attribute name to be checked.\n.        * @return true if the attribute exists, false otherwise.\n.        *\n.        * @sa atdelete, atwrite, atread"},
    {"atread", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_atread, 0), "atread(value, atlabel) -> None\n.   * Read an attribute from the root group.\n.        *\n.        * @param value address where the attribute is read into\n.        * @param atlabel attribute name\n.        *\n.        * The following example demonstrates how to read an attribute of type cv::String:\n.        *\n.        *  @snippet samples/read_write_attributes.cpp snippets_read_str\n.        *\n.        * @note The attribute MUST exist, otherwise CV_Error() is called. Use atexists()\n.        * to check if it exists beforehand.\n.        *\n.        * @sa atexists, atdelete, atwrite\n\n\n\natread(atlabel[, value]) -> value\n.   * Read an attribute from the root group.\n.        *\n.        * @param value attribute value. Currently, only n-d continuous multi-channel arrays are supported.\n.        * @param atlabel attribute name.\n.        *\n.        * @note The attribute MUST exist, otherwise CV_Error() is called. Use atexists()\n.        * to check if it exists beforehand.\n.        *\n.        * @sa atexists, atdelete, atwrite"},
    {"atwrite", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_atwrite, 0), "atwrite(value, atlabel) -> None\n.   * Write an attribute inside the root group.\n.        *\n.        * @param value attribute value.\n.        * @param atlabel attribute name.\n.        *\n.        * The following example demonstrates how to write an attribute of type cv::String:\n.        *\n.        *  @snippet samples/read_write_attributes.cpp snippets_write_str\n.        *\n.        * @note CV_Error() is called if the given attribute already exists. Use atexists()\n.        * to check whether it exists or not beforehand. And use atdelete() to delete\n.        * it if it already exists.\n.        *\n.        * @sa atexists, atdelete, atread"},
    {"close", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_close, 0), "close() -> None\n.   @brief Close and release hdf5 object."},
    {"dscreate", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_dscreate, 0), "dscreate(rows, cols, type, dslabel) -> None\n.   @overload\n\n\n\ndscreate(rows, cols, type, dslabel, compresslevel) -> None\n.   @overload\n\n\n\ndscreate(rows, cols, type, dslabel, compresslevel, dims_chunks) -> None\n.   @overload\n\n\n\ndscreate(n_dims, sizes, type, dslabel) -> None\n.   \n\n\n\ndscreate(n_dims, sizes, type, dslabel, compresslevel) -> None\n.   \n\n\n\ndscreate(sizes, type, dslabel[, compresslevel[, dims_chunks]]) -> None\n.   \n\n\n\ndscreate(n_dims, sizes, type, dslabel, compresslevel, dims_chunks) -> None\n.   @brief Create and allocate storage for n-dimensional dataset, single or multichannel type.\n.       @param n_dims declare number of dimensions\n.       @param sizes array containing sizes for each dimensions\n.       @param type type to be used, e.g., CV_8UC3, CV_32FC1, etc.\n.       @param dslabel specify the hdf5 dataset label. Existing dataset label will cause an error.\n.       @param compresslevel specify the compression level 0-9 to be used, H5_NONE is the default value and means no compression.\n.                            The value 0 also means no compression.\n.                            A value 9 indicating the best compression ration. Note\n.                            that a higher compression level indicates a higher computational cost. It relies\n.                            on GNU gzip for compression.\n.       @param dims_chunks each array member specifies chunking sizes to be used for block I/O,\n.              by default NULL means none at all.\n.       @note If the dataset already exists, an exception will be thrown. Existence of the dataset can be checked\n.       using hlexists().\n.   \n.       - See example below that creates a 6 dimensional storage space:\n.       @code{.cpp}\n.         // open / autocreate hdf5 file\n.         cv::Ptr<cv::hdf::HDF5> h5io = cv::hdf::open( \"mytest.h5\" );\n.         // create space for 6 dimensional CV_64FC2 matrix\n.         if ( ! h5io->hlexists( \"nddata\" ) )\n.           int n_dims = 5;\n.           int dsdims[n_dims] = { 100, 100, 20, 10, 5, 5 };\n.           h5io->dscreate( n_dims, sizes, CV_64FC2, \"nddata\" );\n.         else\n.           printf(\"DS already created, skipping\\n\" );\n.         // release\n.         h5io->close();\n.       @endcode\n.   \n.       @note Activating compression requires internal chunking. Chunking can significantly improve access\n.       speed both at read and write time, especially for windowed access logic that shifts offset inside dataset.\n.       If no custom chunking is specified, the default one will be invoked by the size of **whole** dataset\n.       as single big chunk of data.\n.   \n.       - See example of level 0 compression (shallow) using chunking against the first\n.       dimension, thus storage will consists of 100 chunks of data:\n.       @code{.cpp}\n.         // open / autocreate hdf5 file\n.         cv::Ptr<cv::hdf::HDF5> h5io = cv::hdf::open( \"mytest.h5\" );\n.         // create space for 6 dimensional CV_64FC2 matrix\n.         if ( ! h5io->hlexists( \"nddata\" ) )\n.           int n_dims = 5;\n.           int dsdims[n_dims] = { 100, 100, 20, 10, 5, 5 };\n.           int chunks[n_dims] = {   1, 100, 20, 10, 5, 5 };\n.           h5io->dscreate( n_dims, dsdims, CV_64FC2, \"nddata\", 0, chunks );\n.         else\n.           printf(\"DS already created, skipping\\n\" );\n.         // release\n.         h5io->close();\n.       @endcode\n.   \n.       @note A value of H5_UNLIMITED inside the **sizes** array means **unlimited** data on that dimension, thus it is\n.       possible to expand anytime such dataset on those unlimited directions. Presence of H5_UNLIMITED on any dimension\n.       **requires** to define custom chunking. No default chunking will be defined in unlimited scenario since the default size\n.       on that dimension will be zero, and will grow once dataset is written. Writing into dataset that has H5_UNLIMITED on\n.       some of its dimension requires dsinsert() instead of dswrite() that allows growth on unlimited dimension instead of\n.       dswrite() that allows to write only in predefined data space.\n.   \n.       - Example below shows a 3 dimensional dataset using no compression with all unlimited sizes and one unit chunking:\n.       @code{.cpp}\n.         // open / autocreate hdf5 file\n.         cv::Ptr<cv::hdf::HDF5> h5io = cv::hdf::open( \"mytest.h5\" );\n.         int n_dims = 3;\n.         int chunks[n_dims] = { 1, 1, 1 };\n.         int dsdims[n_dims] = { cv::hdf::HDF5::H5_UNLIMITED, cv::hdf::HDF5::H5_UNLIMITED, cv::hdf::HDF5::H5_UNLIMITED };\n.         h5io->dscreate( n_dims, dsdims, CV_64FC2, \"nddata\", cv::hdf::HDF5::H5_NONE, chunks );\n.         // release\n.         h5io->close();\n.       @endcode"},
    {"dsgetsize", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_dsgetsize, 0), "dsgetsize(dslabel[, dims_flag]) -> retval\n.   @brief Fetch dataset sizes\n.       @param dslabel specify the hdf5 dataset label to be measured.\n.       @param dims_flag will fetch dataset dimensions on H5_GETDIMS, dataset maximum dimensions on H5_GETMAXDIMS,\n.                        and chunk sizes on H5_GETCHUNKDIMS.\n.   \n.       Returns vector object containing sizes of dataset on each dimensions.\n.   \n.       @note Resulting vector size will match the amount of dataset dimensions. By default H5_GETDIMS will return\n.       actual dataset dimensions. Using H5_GETMAXDIM flag will get maximum allowed dimension which normally match\n.       actual dataset dimension but can hold H5_UNLIMITED value if dataset was prepared in **unlimited** mode on\n.       some of its dimension. It can be useful to check existing dataset dimensions before overwrite it as whole or subset.\n.       Trying to write with oversized source data into dataset target will thrown exception. The H5_GETCHUNKDIMS will\n.       return the dimension of chunk if dataset was created with chunking options otherwise returned vector size\n.       will be zero."},
    {"dsgettype", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_dsgettype, 0), "dsgettype(dslabel) -> retval\n.   @brief Fetch dataset type\n.       @param dslabel specify the hdf5 dataset label to be checked.\n.   \n.       Returns the stored matrix type. This is an identifier compatible with the CvMat type system,\n.       like e.g. CV_16SC5 (16-bit signed 5-channel array), and so on.\n.   \n.       @note Result can be parsed with CV_MAT_CN() to obtain amount of channels and CV_MAT_DEPTH() to obtain native cvdata type.\n.       It is thread safe."},
    {"dsinsert", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_dsinsert, 0), "dsinsert(Array, dslabel) -> None\n.   \n\n\n\ndsinsert(Array, dslabel, dims_offset) -> None\n.   \n\n\n\ndsinsert(Array, dslabel, dims_offset[, dims_counts]) -> None\n.   \n\n\n\ndsinsert(Array, dslabel, dims_offset, dims_counts) -> None\n.   @brief Insert or overwrite a Mat object into specified dataset and auto expand dataset size if **unlimited** property allows.\n.       @param Array specify Mat data array to be written.\n.       @param dslabel specify the target hdf5 dataset label.\n.       @param dims_offset each array member specify the offset location\n.              over dataset's each dimensions from where InputArray will be (over)written into dataset.\n.       @param dims_counts each array member specify the amount of data over dataset's\n.              each dimensions from InputArray that will be written into dataset.\n.   \n.       Writes Mat object into targeted dataset and **autoexpand** dataset dimension if allowed.\n.   \n.       @note Unlike dswrite(), datasets are **not** created **automatically**. Only Mat is supported and it must be **continuous**.\n.       If dsinsert() happens over outer regions of dataset dimensions and on that dimension of dataset is in **unlimited** mode then\n.       dataset is expanded, otherwise exception is thrown. To create datasets with **unlimited** property on specific or more\n.       dimensions see dscreate() and the optional H5_UNLIMITED flag at creation time. It is not thread safe over same dataset\n.       but multiple datasets can be merged inside a single hdf5 file.\n.   \n.       - Example below creates **unlimited** rows x 100 cols and expands rows 5 times with dsinsert() using single 100x100 CV_64FC2\n.       over the dataset. Final size will have 5x100 rows and 100 cols, reflecting H matrix five times over row's span. Chunks size is\n.       100x100 just optimized against the H matrix size having compression disabled. If routine is called multiple times dataset will be\n.       just overwritten:\n.       @code{.cpp}\n.         // dual channel hilbert matrix\n.         cv::Mat H(50, 100, CV_64FC2);\n.         for(int i = 0; i < H.rows; i++)\n.           for(int j = 0; j < H.cols; j++)\n.           {\n.               H.at<cv::Vec2d>(i,j)[0] =  1./(i+j+1);\n.               H.at<cv::Vec2d>(i,j)[1] = -1./(i+j+1);\n.               count++;\n.           }\n.         // open / autocreate hdf5 file\n.         cv::Ptr<cv::hdf::HDF5> h5io = cv::hdf::open( \"mytest.h5\" );\n.         // optimise dataset by chunks\n.         int chunks[2] = { 100, 100 };\n.         // create Unlimited x 100 CV_64FC2 space\n.         h5io->dscreate( cv::hdf::HDF5::H5_UNLIMITED, 100, CV_64FC2, \"hilbert\", cv::hdf::HDF5::H5_NONE, chunks );\n.         // write into first half\n.         int offset[2] = { 0, 0 };\n.         for ( int t = 0; t < 5; t++ )\n.         {\n.           offset[0] += 100 * t;\n.           h5io->dsinsert( H, \"hilbert\", offset );\n.         }\n.         // release\n.         h5io->close();\n.       @endcode"},
    {"dsread", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_dsread, 0), "dsread(dslabel[, Array]) -> Array\n.   \n\n\n\ndsread(dslabel, dims_offset[, Array]) -> Array\n.   \n\n\n\ndsread(dslabel, dims_offset[, Array[, dims_counts]]) -> Array\n.   \n\n\n\ndsread(dslabel, dims_offset, dims_counts[, Array]) -> Array\n.   @brief Read specific dataset from hdf5 file into Mat object.\n.       @param Array Mat container where data reads will be returned.\n.       @param dslabel specify the source hdf5 dataset label.\n.       @param dims_offset each array member specify the offset location over\n.              each dimensions from where dataset starts to read into OutputArray.\n.       @param dims_counts each array member specify the amount over dataset's each\n.              dimensions of dataset to read into OutputArray.\n.   \n.       Reads out Mat object reflecting the stored dataset.\n.   \n.       @note If hdf5 file does not exist an exception will be thrown. Use hlexists() to check dataset presence.\n.       It is thread safe.\n.   \n.       - Example below reads a dataset:\n.       @code{.cpp}\n.         // open hdf5 file\n.         cv::Ptr<cv::hdf::HDF5> h5io = cv::hdf::open( \"mytest.h5\" );\n.         // blank Mat container\n.         cv::Mat H;\n.         // read hibert dataset\n.         h5io->read( H, \"hilbert\" );\n.         // release\n.         h5io->close();\n.       @endcode\n.   \n.       - Example below perform read of 3x5 submatrix from second row and third element.\n.       @code{.cpp}\n.         // open hdf5 file\n.         cv::Ptr<cv::hdf::HDF5> h5io = cv::hdf::open( \"mytest.h5\" );\n.         // blank Mat container\n.         cv::Mat H;\n.         int offset[2] = { 1, 2 };\n.         int counts[2] = { 3, 5 };\n.         // read hibert dataset\n.         h5io->read( H, \"hilbert\", offset, counts );\n.         // release\n.         h5io->close();\n.       @endcode"},
    {"dswrite", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_dswrite, 0), "dswrite(Array, dslabel) -> None\n.   \n\n\n\ndswrite(Array, dslabel, dims_offset) -> None\n.   \n\n\n\ndswrite(Array, dslabel, dims_offset[, dims_counts]) -> None\n.   \n\n\n\ndswrite(Array, dslabel, dims_offset, dims_counts) -> None\n.   @brief Write or overwrite a Mat object into specified dataset of hdf5 file.\n.       @param Array specify Mat data array to be written.\n.       @param dslabel specify the target hdf5 dataset label.\n.       @param dims_offset each array member specify the offset location\n.              over dataset's each dimensions from where InputArray will be (over)written into dataset.\n.       @param dims_counts each array member specifies the amount of data over dataset's\n.              each dimensions from InputArray that will be written into dataset.\n.   \n.       Writes Mat object into targeted dataset.\n.   \n.       @note If dataset is not created and does not exist it will be created **automatically**. Only Mat is supported and\n.       it must be **continuous**. It is thread safe but it is recommended that writes to happen over separate non-overlapping\n.       regions. Multiple datasets can be written inside a single hdf5 file.\n.   \n.       - Example below writes a 100x100 CV_64FC2 matrix into a dataset. No dataset pre-creation required. If routine\n.       is called multiple times dataset will be just overwritten:\n.       @code{.cpp}\n.         // dual channel hilbert matrix\n.         cv::Mat H(100, 100, CV_64FC2);\n.         for(int i = 0; i < H.rows; i++)\n.           for(int j = 0; j < H.cols; j++)\n.           {\n.               H.at<cv::Vec2d>(i,j)[0] =  1./(i+j+1);\n.               H.at<cv::Vec2d>(i,j)[1] = -1./(i+j+1);\n.               count++;\n.           }\n.         // open / autocreate hdf5 file\n.         cv::Ptr<cv::hdf::HDF5> h5io = cv::hdf::open( \"mytest.h5\" );\n.         // write / overwrite dataset\n.         h5io->dswrite( H, \"hilbert\" );\n.         // release\n.         h5io->close();\n.       @endcode\n.   \n.       - Example below writes a smaller 50x100 matrix into 100x100 compressed space optimised by two 50x100 chunks.\n.       Matrix is written twice into first half (0->50) and second half (50->100) of data space using offset.\n.       @code{.cpp}\n.         // dual channel hilbert matrix\n.         cv::Mat H(50, 100, CV_64FC2);\n.         for(int i = 0; i < H.rows; i++)\n.           for(int j = 0; j < H.cols; j++)\n.           {\n.               H.at<cv::Vec2d>(i,j)[0] =  1./(i+j+1);\n.               H.at<cv::Vec2d>(i,j)[1] = -1./(i+j+1);\n.               count++;\n.           }\n.         // open / autocreate hdf5 file\n.         cv::Ptr<cv::hdf::HDF5> h5io = cv::hdf::open( \"mytest.h5\" );\n.         // optimise dataset by two chunks\n.         int chunks[2] = { 50, 100 };\n.         // create 100x100 CV_64FC2 compressed space\n.         h5io->dscreate( 100, 100, CV_64FC2, \"hilbert\", 9, chunks );\n.         // write into first half\n.         int offset1[2] = { 0, 0 };\n.         h5io->dswrite( H, \"hilbert\", offset1 );\n.         // write into second half\n.         int offset2[2] = { 50, 0 };\n.         h5io->dswrite( H, \"hilbert\", offset2 );\n.         // release\n.         h5io->close();\n.       @endcode"},
    {"grcreate", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_grcreate, 0), "grcreate(grlabel) -> None\n.   @brief Create a group.\n.       @param grlabel specify the hdf5 group label.\n.   \n.       Create a hdf5 group with default properties. The group is closed automatically after creation.\n.   \n.       @note Groups are useful for better organising multiple datasets. It is possible to create subgroups within any group.\n.       Existence of a particular group can be checked using hlexists(). In case of subgroups, a label would be e.g: 'Group1/SubGroup1'\n.       where SubGroup1 is within the root group Group1. Before creating a subgroup, its parent group MUST be created.\n.   \n.       - In this example, Group1 will have one subgroup called SubGroup1:\n.   \n.        @snippet samples/create_groups.cpp create_group\n.   \n.        The corresponding result visualized using the HDFView tool is\n.   \n.        ![Visualization of groups using the HDFView tool](pics/create_groups.png)\n.   \n.       @note When a dataset is created with dscreate() or kpcreate(), it can be created within a group by specifying the\n.       full path within the label. In our example, it would be: 'Group1/SubGroup1/MyDataSet'. It is not thread safe."},
    {"hlexists", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_hlexists, 0), "hlexists(label) -> retval\n.   @brief Check if label exists or not.\n.       @param label specify the hdf5 dataset label.\n.   \n.       Returns **true** if dataset exists, and **false** otherwise.\n.   \n.       @note Checks if dataset, group or other object type (hdf5 link) exists under the label name. It is thread safe."},
    {"kpgetsize", CV_PY_FN_WITH_KW_(pyopencv_cv_hdf_hdf_HDF5_kpgetsize, 0), "kpgetsize(kplabel[, dims_flag]) -> retval\n.   @brief Fetch keypoint dataset size\n.       @param kplabel specify the hdf5 dataset label to be measured.\n.       @param dims_flag will fetch dataset dimensions on H5_GETDIMS, and dataset maximum dimensions on H5_GETMAXDIMS.\n.   \n.       Returns size of keypoints dataset.\n.   \n.       @note Resulting size will match the amount of keypoints. By default H5_GETDIMS will return actual dataset dimension.\n.       Using H5_GETMAXDIM flag will get maximum allowed dimension which normally match actual dataset dimension but can hold\n.       H5_UNLIMITED value if dataset was prepared in **unlimited** mode. It can be useful to check existing dataset dimension\n.       before overwrite it as whole or subset. Trying to write with oversized source data into dataset target will thrown\n.       exception. The H5_GETCHUNKDIMS will return the dimension of chunk if dataset was created with chunking options otherwise\n.       returned vector size will be zero."},

    {NULL,          NULL}
};

// Converter (hdf_HDF5)

template<>
struct PyOpenCV_Converter< Ptr<cv::hdf::HDF5> >
{
    static PyObject* from(const Ptr<cv::hdf::HDF5>& r)
    {
        return pyopencv_hdf_HDF5_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::hdf::HDF5>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::hdf::HDF5> * dst_;
        if (pyopencv_hdf_HDF5_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::hdf::HDF5> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// hfs_HfsSegment (Generic)
//================================================================================

// GetSet (hfs_HfsSegment)



// Methods (hfs_HfsSegment)

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;

    int height=0;
    int width=0;
    float segEgbThresholdI=0.08f;
    int minRegionSizeI=100;
    float segEgbThresholdII=0.28f;
    int minRegionSizeII=200;
    float spatialWeight=0.6f;
    int slicSpixelSize=8;
    int numSlicIter=5;
    Ptr<HfsSegment> retval;

    const char* keywords[] = { "height", "width", "segEgbThresholdI", "minRegionSizeI", "segEgbThresholdII", "minRegionSizeII", "spatialWeight", "slicSpixelSize", "numSlicIter", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii|fififii:hfs_HfsSegment.create", (char**)keywords, &height, &width, &segEgbThresholdI, &minRegionSizeI, &segEgbThresholdII, &minRegionSizeII, &spatialWeight, &slicSpixelSize, &numSlicIter) )
    {
        ERRWRAP2(retval = cv::hfs::HfsSegment::create(height, width, segEgbThresholdI, minRegionSizeI, segEgbThresholdII, minRegionSizeII, spatialWeight, slicSpixelSize, numSlicIter));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_getMinRegionSizeI(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinRegionSizeI());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_getMinRegionSizeII(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinRegionSizeII());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_getNumSlicIter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumSlicIter());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_getSegEgbThresholdI(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSegEgbThresholdI());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_getSegEgbThresholdII(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSegEgbThresholdII());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_getSlicSpixelSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSlicSpixelSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_getSpatialWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSpatialWeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_performSegmentCpu(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    bool ifDraw=true;
    Mat retval;

    const char* keywords[] = { "src", "ifDraw", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|b:hfs_HfsSegment.performSegmentCpu", (char**)keywords, &pyobj_src, &ifDraw) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) )
    {
        ERRWRAP2(retval = _self_->performSegmentCpu(src, ifDraw));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    bool ifDraw=true;
    Mat retval;

    const char* keywords[] = { "src", "ifDraw", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|b:hfs_HfsSegment.performSegmentCpu", (char**)keywords, &pyobj_src, &ifDraw) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) )
    {
        ERRWRAP2(retval = _self_->performSegmentCpu(src, ifDraw));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_performSegmentGpu(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    bool ifDraw=true;
    Mat retval;

    const char* keywords[] = { "src", "ifDraw", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|b:hfs_HfsSegment.performSegmentGpu", (char**)keywords, &pyobj_src, &ifDraw) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) )
    {
        ERRWRAP2(retval = _self_->performSegmentGpu(src, ifDraw));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    bool ifDraw=true;
    Mat retval;

    const char* keywords[] = { "src", "ifDraw", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|b:hfs_HfsSegment.performSegmentGpu", (char**)keywords, &pyobj_src, &ifDraw) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) )
    {
        ERRWRAP2(retval = _self_->performSegmentGpu(src, ifDraw));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_setMinRegionSizeI(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    int n=0;

    const char* keywords[] = { "n", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:hfs_HfsSegment.setMinRegionSizeI", (char**)keywords, &n) )
    {
        ERRWRAP2(_self_->setMinRegionSizeI(n));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_setMinRegionSizeII(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    int n=0;

    const char* keywords[] = { "n", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:hfs_HfsSegment.setMinRegionSizeII", (char**)keywords, &n) )
    {
        ERRWRAP2(_self_->setMinRegionSizeII(n));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_setNumSlicIter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    int n=0;

    const char* keywords[] = { "n", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:hfs_HfsSegment.setNumSlicIter", (char**)keywords, &n) )
    {
        ERRWRAP2(_self_->setNumSlicIter(n));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_setSegEgbThresholdI(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    float c=0.f;

    const char* keywords[] = { "c", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:hfs_HfsSegment.setSegEgbThresholdI", (char**)keywords, &c) )
    {
        ERRWRAP2(_self_->setSegEgbThresholdI(c));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_setSegEgbThresholdII(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    float c=0.f;

    const char* keywords[] = { "c", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:hfs_HfsSegment.setSegEgbThresholdII", (char**)keywords, &c) )
    {
        ERRWRAP2(_self_->setSegEgbThresholdII(c));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_setSlicSpixelSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    int n=0;

    const char* keywords[] = { "n", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:hfs_HfsSegment.setSlicSpixelSize", (char**)keywords, &n) )
    {
        ERRWRAP2(_self_->setSlicSpixelSize(n));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_hfs_hfs_HfsSegment_setSpatialWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::hfs;


    Ptr<cv::hfs::HfsSegment> * self1 = 0;
    if (!pyopencv_hfs_HfsSegment_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'hfs_HfsSegment' or its derivative)");
    Ptr<cv::hfs::HfsSegment> _self_ = *(self1);
    float w=0.f;

    const char* keywords[] = { "w", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:hfs_HfsSegment.setSpatialWeight", (char**)keywords, &w) )
    {
        ERRWRAP2(_self_->setSpatialWeight(w));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (hfs_HfsSegment)

static PyGetSetDef pyopencv_hfs_HfsSegment_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_hfs_HfsSegment_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_create_static, METH_STATIC), "create(height, width[, segEgbThresholdI[, minRegionSizeI[, segEgbThresholdII[, minRegionSizeII[, spatialWeight[, slicSpixelSize[, numSlicIter]]]]]]]) -> retval\n.   @brief: create a hfs object\n.   * @param height: the height of the input image\n.   * @param width: the width of the input image\n.   * @param segEgbThresholdI: parameter segEgbThresholdI\n.   * @param minRegionSizeI: parameter minRegionSizeI\n.   * @param segEgbThresholdII: parameter segEgbThresholdII\n.   * @param minRegionSizeII: parameter minRegionSizeII\n.   * @param spatialWeight: parameter spatialWeight\n.   * @param slicSpixelSize: parameter slicSpixelSize\n.   * @param numSlicIter: parameter numSlicIter"},
    {"getMinRegionSizeI", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_getMinRegionSizeI, 0), "getMinRegionSizeI() -> retval\n."},
    {"getMinRegionSizeII", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_getMinRegionSizeII, 0), "getMinRegionSizeII() -> retval\n."},
    {"getNumSlicIter", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_getNumSlicIter, 0), "getNumSlicIter() -> retval\n."},
    {"getSegEgbThresholdI", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_getSegEgbThresholdI, 0), "getSegEgbThresholdI() -> retval\n."},
    {"getSegEgbThresholdII", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_getSegEgbThresholdII, 0), "getSegEgbThresholdII() -> retval\n."},
    {"getSlicSpixelSize", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_getSlicSpixelSize, 0), "getSlicSpixelSize() -> retval\n."},
    {"getSpatialWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_getSpatialWeight, 0), "getSpatialWeight() -> retval\n."},
    {"performSegmentCpu", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_performSegmentCpu, 0), "performSegmentCpu(src[, ifDraw]) -> retval\n.   @brief do segmentation with cpu\n.   * This method is only implemented for reference.\n.   * It is highly NOT recommanded to use it."},
    {"performSegmentGpu", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_performSegmentGpu, 0), "performSegmentGpu(src[, ifDraw]) -> retval\n.   @brief do segmentation gpu\n.   * @param src: the input image\n.   * @param ifDraw: if draw the image in the returned Mat. if this parameter is false,\n.   * then the content of the returned Mat is a matrix of index, describing the region\n.   * each pixel belongs to. And it's data type is CV_16U. If this parameter is true,\n.   * then the returned Mat is a segmented picture, and color of each region is the\n.   * average color of all pixels in that region. And it's data type is the same as\n.   * the input image"},
    {"setMinRegionSizeI", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_setMinRegionSizeI, 0), "setMinRegionSizeI(n) -> None\n.   @brief: set and get the parameter minRegionSizeI.\n.   * This parameter is used in the second stage\n.   * mentioned above. After the EGB segmentation, regions that have fewer\n.   * pixels then this parameter will be merged into it's adjacent region."},
    {"setMinRegionSizeII", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_setMinRegionSizeII, 0), "setMinRegionSizeII(n) -> None\n.   @brief: set and get the parameter minRegionSizeII.\n.   * This parameter is used in the third stage\n.   * mentioned above. It serves the same purpose as minRegionSizeI"},
    {"setNumSlicIter", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_setNumSlicIter, 0), "setNumSlicIter(n) -> None\n.   @brief: set and get the parameter numSlicIter.\n.   * This parameter is used in the first stage. It\n.   * describes how many iteration to perform when executing SLIC."},
    {"setSegEgbThresholdI", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_setSegEgbThresholdI, 0), "setSegEgbThresholdI(c) -> None\n.   @brief: set and get the parameter segEgbThresholdI.\n.   * This parameter is used in the second stage mentioned above.\n.   * It is a constant used to threshold weights of the edge when merging\n.   * adjacent nodes when applying EGB algorithm. The segmentation result\n.   * tends to have more regions remained if this value is large and vice versa."},
    {"setSegEgbThresholdII", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_setSegEgbThresholdII, 0), "setSegEgbThresholdII(c) -> None\n.   @brief: set and get the parameter segEgbThresholdII.\n.   * This parameter is used in the third stage\n.   * mentioned above. It serves the same purpose as segEgbThresholdI.\n.   * The segmentation result tends to have more regions remained if\n.   * this value is large and vice versa."},
    {"setSlicSpixelSize", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_setSlicSpixelSize, 0), "setSlicSpixelSize(n) -> None\n.   @brief: set and get the parameter slicSpixelSize.\n.   * This parameter is used in the first stage mentioned\n.   * above(the SLIC stage). It describes the size of each\n.   * superpixel when initializing SLIC. Every superpixel\n.   * approximately has \\f$slicSpixelSize \\times slicSpixelSize\\f$\n.   * pixels in the begining."},
    {"setSpatialWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_hfs_hfs_HfsSegment_setSpatialWeight, 0), "setSpatialWeight(w) -> None\n.   @brief: set and get the parameter spatialWeight.\n.   * This parameter is used in the first stage\n.   * mentioned above(the SLIC stage). It describes how important is the role\n.   * of position when calculating the distance between each pixel and it's\n.   * center. The exact formula to calculate the distance is\n.   * \\f$colorDistance + spatialWeight \\times spatialDistance\\f$.\n.   * The segmentation result tends to have more local consistency\n.   * if this value is larger."},

    {NULL,          NULL}
};

// Converter (hfs_HfsSegment)

template<>
struct PyOpenCV_Converter< Ptr<cv::hfs::HfsSegment> >
{
    static PyObject* from(const Ptr<cv::hfs::HfsSegment>& r)
    {
        return pyopencv_hfs_HfsSegment_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::hfs::HfsSegment>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::hfs::HfsSegment> * dst_;
        if (pyopencv_hfs_HfsSegment_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::hfs::HfsSegment> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// img_hash_AverageHash (Generic)
//================================================================================

// GetSet (img_hash_AverageHash)



// Methods (img_hash_AverageHash)

static PyObject* pyopencv_cv_img_hash_img_hash_AverageHash_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;

    Ptr<AverageHash> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::img_hash::AverageHash::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (img_hash_AverageHash)

static PyGetSetDef pyopencv_img_hash_AverageHash_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_img_hash_AverageHash_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_AverageHash_create_static, METH_STATIC), "create() -> retval\n."},

    {NULL,          NULL}
};

// Converter (img_hash_AverageHash)

template<>
struct PyOpenCV_Converter< Ptr<cv::img_hash::AverageHash> >
{
    static PyObject* from(const Ptr<cv::img_hash::AverageHash>& r)
    {
        return pyopencv_img_hash_AverageHash_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::img_hash::AverageHash>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::img_hash::AverageHash> * dst_;
        if (pyopencv_img_hash_AverageHash_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::img_hash::AverageHash> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// img_hash_BlockMeanHash (Generic)
//================================================================================

// GetSet (img_hash_BlockMeanHash)



// Methods (img_hash_BlockMeanHash)

static PyObject* pyopencv_cv_img_hash_img_hash_BlockMeanHash_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;

    int mode=BLOCK_MEAN_HASH_MODE_0;
    Ptr<BlockMeanHash> retval;

    const char* keywords[] = { "mode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:img_hash_BlockMeanHash.create", (char**)keywords, &mode) )
    {
        ERRWRAP2(retval = cv::img_hash::BlockMeanHash::create(mode));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_BlockMeanHash_getMean(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::BlockMeanHash> * self1 = 0;
    if (!pyopencv_img_hash_BlockMeanHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_BlockMeanHash' or its derivative)");
    Ptr<cv::img_hash::BlockMeanHash> _self_ = *(self1);
    std::vector<double> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMean());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_BlockMeanHash_setMode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::BlockMeanHash> * self1 = 0;
    if (!pyopencv_img_hash_BlockMeanHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_BlockMeanHash' or its derivative)");
    Ptr<cv::img_hash::BlockMeanHash> _self_ = *(self1);
    int mode=0;

    const char* keywords[] = { "mode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:img_hash_BlockMeanHash.setMode", (char**)keywords, &mode) )
    {
        ERRWRAP2(_self_->setMode(mode));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (img_hash_BlockMeanHash)

static PyGetSetDef pyopencv_img_hash_BlockMeanHash_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_img_hash_BlockMeanHash_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_BlockMeanHash_create_static, METH_STATIC), "create([, mode]) -> retval\n."},
    {"getMean", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_BlockMeanHash_getMean, 0), "getMean() -> retval\n."},
    {"setMode", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_BlockMeanHash_setMode, 0), "setMode(mode) -> None\n.   @brief Create BlockMeanHash object\n.           @param mode the mode"},

    {NULL,          NULL}
};

// Converter (img_hash_BlockMeanHash)

template<>
struct PyOpenCV_Converter< Ptr<cv::img_hash::BlockMeanHash> >
{
    static PyObject* from(const Ptr<cv::img_hash::BlockMeanHash>& r)
    {
        return pyopencv_img_hash_BlockMeanHash_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::img_hash::BlockMeanHash>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::img_hash::BlockMeanHash> * dst_;
        if (pyopencv_img_hash_BlockMeanHash_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::img_hash::BlockMeanHash> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// img_hash_ColorMomentHash (Generic)
//================================================================================

// GetSet (img_hash_ColorMomentHash)



// Methods (img_hash_ColorMomentHash)

static PyObject* pyopencv_cv_img_hash_img_hash_ColorMomentHash_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;

    Ptr<ColorMomentHash> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::img_hash::ColorMomentHash::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (img_hash_ColorMomentHash)

static PyGetSetDef pyopencv_img_hash_ColorMomentHash_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_img_hash_ColorMomentHash_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_ColorMomentHash_create_static, METH_STATIC), "create() -> retval\n."},

    {NULL,          NULL}
};

// Converter (img_hash_ColorMomentHash)

template<>
struct PyOpenCV_Converter< Ptr<cv::img_hash::ColorMomentHash> >
{
    static PyObject* from(const Ptr<cv::img_hash::ColorMomentHash>& r)
    {
        return pyopencv_img_hash_ColorMomentHash_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::img_hash::ColorMomentHash>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::img_hash::ColorMomentHash> * dst_;
        if (pyopencv_img_hash_ColorMomentHash_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::img_hash::ColorMomentHash> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// img_hash_ImgHashBase (Generic)
//================================================================================

// GetSet (img_hash_ImgHashBase)



// Methods (img_hash_ImgHashBase)

static PyObject* pyopencv_cv_img_hash_img_hash_ImgHashBase_compare(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::ImgHashBase> * self1 = 0;
    if (!pyopencv_img_hash_ImgHashBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_ImgHashBase' or its derivative)");
    Ptr<cv::img_hash::ImgHashBase> _self_ = *(self1);
    {
    PyObject* pyobj_hashOne = NULL;
    Mat hashOne;
    PyObject* pyobj_hashTwo = NULL;
    Mat hashTwo;
    double retval;

    const char* keywords[] = { "hashOne", "hashTwo", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:img_hash_ImgHashBase.compare", (char**)keywords, &pyobj_hashOne, &pyobj_hashTwo) &&
        pyopencv_to(pyobj_hashOne, hashOne, ArgInfo("hashOne", 0)) &&
        pyopencv_to(pyobj_hashTwo, hashTwo, ArgInfo("hashTwo", 0)) )
    {
        ERRWRAP2(retval = _self_->compare(hashOne, hashTwo));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_hashOne = NULL;
    UMat hashOne;
    PyObject* pyobj_hashTwo = NULL;
    UMat hashTwo;
    double retval;

    const char* keywords[] = { "hashOne", "hashTwo", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:img_hash_ImgHashBase.compare", (char**)keywords, &pyobj_hashOne, &pyobj_hashTwo) &&
        pyopencv_to(pyobj_hashOne, hashOne, ArgInfo("hashOne", 0)) &&
        pyopencv_to(pyobj_hashTwo, hashTwo, ArgInfo("hashTwo", 0)) )
    {
        ERRWRAP2(retval = _self_->compare(hashOne, hashTwo));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_ImgHashBase_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::ImgHashBase> * self1 = 0;
    if (!pyopencv_img_hash_ImgHashBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_ImgHashBase' or its derivative)");
    Ptr<cv::img_hash::ImgHashBase> _self_ = *(self1);
    {
    PyObject* pyobj_inputArr = NULL;
    Mat inputArr;
    PyObject* pyobj_outputArr = NULL;
    Mat outputArr;

    const char* keywords[] = { "inputArr", "outputArr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:img_hash_ImgHashBase.compute", (char**)keywords, &pyobj_inputArr, &pyobj_outputArr) &&
        pyopencv_to(pyobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        pyopencv_to(pyobj_outputArr, outputArr, ArgInfo("outputArr", 1)) )
    {
        ERRWRAP2(_self_->compute(inputArr, outputArr));
        return pyopencv_from(outputArr);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputArr = NULL;
    UMat inputArr;
    PyObject* pyobj_outputArr = NULL;
    UMat outputArr;

    const char* keywords[] = { "inputArr", "outputArr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:img_hash_ImgHashBase.compute", (char**)keywords, &pyobj_inputArr, &pyobj_outputArr) &&
        pyopencv_to(pyobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        pyopencv_to(pyobj_outputArr, outputArr, ArgInfo("outputArr", 1)) )
    {
        ERRWRAP2(_self_->compute(inputArr, outputArr));
        return pyopencv_from(outputArr);
    }
    }

    return NULL;
}



// Tables (img_hash_ImgHashBase)

static PyGetSetDef pyopencv_img_hash_ImgHashBase_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_img_hash_ImgHashBase_methods[] =
{
    {"compare", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_ImgHashBase_compare, 0), "compare(hashOne, hashTwo) -> retval\n.   @brief Compare the hash value between inOne and inTwo\n.           @param hashOne Hash value one\n.           @param hashTwo Hash value two\n.           @return value indicate similarity between inOne and inTwo, the meaning\n.           of the value vary from algorithms to algorithms"},
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_ImgHashBase_compute, 0), "compute(inputArr[, outputArr]) -> outputArr\n.   @brief Computes hash of the input image\n.           @param inputArr input image want to compute hash value\n.           @param outputArr hash of the image"},

    {NULL,          NULL}
};

// Converter (img_hash_ImgHashBase)

template<>
struct PyOpenCV_Converter< Ptr<cv::img_hash::ImgHashBase> >
{
    static PyObject* from(const Ptr<cv::img_hash::ImgHashBase>& r)
    {
        return pyopencv_img_hash_ImgHashBase_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::img_hash::ImgHashBase>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::img_hash::ImgHashBase> * dst_;
        if (pyopencv_img_hash_ImgHashBase_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::img_hash::ImgHashBase> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// img_hash_MarrHildrethHash (Generic)
//================================================================================

// GetSet (img_hash_MarrHildrethHash)



// Methods (img_hash_MarrHildrethHash)

static PyObject* pyopencv_cv_img_hash_img_hash_MarrHildrethHash_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;

    float alpha=2.0f;
    float scale=1.0f;
    Ptr<MarrHildrethHash> retval;

    const char* keywords[] = { "alpha", "scale", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ff:img_hash_MarrHildrethHash.create", (char**)keywords, &alpha, &scale) )
    {
        ERRWRAP2(retval = cv::img_hash::MarrHildrethHash::create(alpha, scale));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_MarrHildrethHash_getAlpha(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::MarrHildrethHash> * self1 = 0;
    if (!pyopencv_img_hash_MarrHildrethHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_MarrHildrethHash' or its derivative)");
    Ptr<cv::img_hash::MarrHildrethHash> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAlpha());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_MarrHildrethHash_getScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::MarrHildrethHash> * self1 = 0;
    if (!pyopencv_img_hash_MarrHildrethHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_MarrHildrethHash' or its derivative)");
    Ptr<cv::img_hash::MarrHildrethHash> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_MarrHildrethHash_setKernelParam(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::MarrHildrethHash> * self1 = 0;
    if (!pyopencv_img_hash_MarrHildrethHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_MarrHildrethHash' or its derivative)");
    Ptr<cv::img_hash::MarrHildrethHash> _self_ = *(self1);
    float alpha=0.f;
    float scale=0.f;

    const char* keywords[] = { "alpha", "scale", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ff:img_hash_MarrHildrethHash.setKernelParam", (char**)keywords, &alpha, &scale) )
    {
        ERRWRAP2(_self_->setKernelParam(alpha, scale));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (img_hash_MarrHildrethHash)

static PyGetSetDef pyopencv_img_hash_MarrHildrethHash_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_img_hash_MarrHildrethHash_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_MarrHildrethHash_create_static, METH_STATIC), "create([, alpha[, scale]]) -> retval\n.   @param alpha int scale factor for marr wavelet (default=2).\n.           @param scale int level of scale factor (default = 1)"},
    {"getAlpha", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_MarrHildrethHash_getAlpha, 0), "getAlpha() -> retval\n.   * @brief self explain"},
    {"getScale", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_MarrHildrethHash_getScale, 0), "getScale() -> retval\n.   * @brief self explain"},
    {"setKernelParam", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_MarrHildrethHash_setKernelParam, 0), "setKernelParam(alpha, scale) -> None\n.   @brief Set Mh kernel parameters\n.           @param alpha int scale factor for marr wavelet (default=2).\n.           @param scale int level of scale factor (default = 1)"},

    {NULL,          NULL}
};

// Converter (img_hash_MarrHildrethHash)

template<>
struct PyOpenCV_Converter< Ptr<cv::img_hash::MarrHildrethHash> >
{
    static PyObject* from(const Ptr<cv::img_hash::MarrHildrethHash>& r)
    {
        return pyopencv_img_hash_MarrHildrethHash_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::img_hash::MarrHildrethHash>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::img_hash::MarrHildrethHash> * dst_;
        if (pyopencv_img_hash_MarrHildrethHash_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::img_hash::MarrHildrethHash> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// img_hash_PHash (Generic)
//================================================================================

// GetSet (img_hash_PHash)



// Methods (img_hash_PHash)

static PyObject* pyopencv_cv_img_hash_img_hash_PHash_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;

    Ptr<PHash> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::img_hash::PHash::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (img_hash_PHash)

static PyGetSetDef pyopencv_img_hash_PHash_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_img_hash_PHash_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_PHash_create_static, METH_STATIC), "create() -> retval\n."},

    {NULL,          NULL}
};

// Converter (img_hash_PHash)

template<>
struct PyOpenCV_Converter< Ptr<cv::img_hash::PHash> >
{
    static PyObject* from(const Ptr<cv::img_hash::PHash>& r)
    {
        return pyopencv_img_hash_PHash_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::img_hash::PHash>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::img_hash::PHash> * dst_;
        if (pyopencv_img_hash_PHash_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::img_hash::PHash> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// img_hash_RadialVarianceHash (Generic)
//================================================================================

// GetSet (img_hash_RadialVarianceHash)



// Methods (img_hash_RadialVarianceHash)

static PyObject* pyopencv_cv_img_hash_img_hash_RadialVarianceHash_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;

    double sigma=1;
    int numOfAngleLine=180;
    Ptr<RadialVarianceHash> retval;

    const char* keywords[] = { "sigma", "numOfAngleLine", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|di:img_hash_RadialVarianceHash.create", (char**)keywords, &sigma, &numOfAngleLine) )
    {
        ERRWRAP2(retval = cv::img_hash::RadialVarianceHash::create(sigma, numOfAngleLine));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_RadialVarianceHash_getNumOfAngleLine(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::RadialVarianceHash> * self1 = 0;
    if (!pyopencv_img_hash_RadialVarianceHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_RadialVarianceHash' or its derivative)");
    Ptr<cv::img_hash::RadialVarianceHash> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumOfAngleLine());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_RadialVarianceHash_getSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::RadialVarianceHash> * self1 = 0;
    if (!pyopencv_img_hash_RadialVarianceHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_RadialVarianceHash' or its derivative)");
    Ptr<cv::img_hash::RadialVarianceHash> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_RadialVarianceHash_setNumOfAngleLine(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::RadialVarianceHash> * self1 = 0;
    if (!pyopencv_img_hash_RadialVarianceHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_RadialVarianceHash' or its derivative)");
    Ptr<cv::img_hash::RadialVarianceHash> _self_ = *(self1);
    int value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:img_hash_RadialVarianceHash.setNumOfAngleLine", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setNumOfAngleLine(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_img_hash_img_hash_RadialVarianceHash_setSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::img_hash;


    Ptr<cv::img_hash::RadialVarianceHash> * self1 = 0;
    if (!pyopencv_img_hash_RadialVarianceHash_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'img_hash_RadialVarianceHash' or its derivative)");
    Ptr<cv::img_hash::RadialVarianceHash> _self_ = *(self1);
    double value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:img_hash_RadialVarianceHash.setSigma", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setSigma(value));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (img_hash_RadialVarianceHash)

static PyGetSetDef pyopencv_img_hash_RadialVarianceHash_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_img_hash_RadialVarianceHash_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_RadialVarianceHash_create_static, METH_STATIC), "create([, sigma[, numOfAngleLine]]) -> retval\n."},
    {"getNumOfAngleLine", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_RadialVarianceHash_getNumOfAngleLine, 0), "getNumOfAngleLine() -> retval\n."},
    {"getSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_RadialVarianceHash_getSigma, 0), "getSigma() -> retval\n."},
    {"setNumOfAngleLine", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_RadialVarianceHash_setNumOfAngleLine, 0), "setNumOfAngleLine(value) -> None\n."},
    {"setSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_img_hash_img_hash_RadialVarianceHash_setSigma, 0), "setSigma(value) -> None\n."},

    {NULL,          NULL}
};

// Converter (img_hash_RadialVarianceHash)

template<>
struct PyOpenCV_Converter< Ptr<cv::img_hash::RadialVarianceHash> >
{
    static PyObject* from(const Ptr<cv::img_hash::RadialVarianceHash>& r)
    {
        return pyopencv_img_hash_RadialVarianceHash_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::img_hash::RadialVarianceHash>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::img_hash::RadialVarianceHash> * dst_;
        if (pyopencv_img_hash_RadialVarianceHash_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::img_hash::RadialVarianceHash> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// kinfu_KinFu (Generic)
//================================================================================

// GetSet (kinfu_KinFu)



// Methods (kinfu_KinFu)

static PyObject* pyopencv_cv_kinfu_kinfu_KinFu_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;

    PyObject* pyobj__params = NULL;
    Ptr<Params> _params;
    Ptr<KinFu> retval;

    const char* keywords[] = { "_params", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:kinfu_KinFu.create", (char**)keywords, &pyobj__params) &&
        pyopencv_to(pyobj__params, _params, ArgInfo("_params", 0)) )
    {
        ERRWRAP2(retval = cv::kinfu::KinFu::create(_params));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_kinfu_kinfu_KinFu_getCloud(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;


    Ptr<cv::kinfu::KinFu> * self1 = 0;
    if (!pyopencv_kinfu_KinFu_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'kinfu_KinFu' or its derivative)");
    Ptr<cv::kinfu::KinFu> _self_ = *(self1);
    {
    PyObject* pyobj_points = NULL;
    Mat points;
    PyObject* pyobj_normals = NULL;
    Mat normals;

    const char* keywords[] = { "points", "normals", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:kinfu_KinFu.getCloud", (char**)keywords, &pyobj_points, &pyobj_normals) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 1)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 1)) )
    {
        ERRWRAP2(_self_->getCloud(points, normals));
        return Py_BuildValue("(NN)", pyopencv_from(points), pyopencv_from(normals));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points = NULL;
    UMat points;
    PyObject* pyobj_normals = NULL;
    UMat normals;

    const char* keywords[] = { "points", "normals", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:kinfu_KinFu.getCloud", (char**)keywords, &pyobj_points, &pyobj_normals) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 1)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 1)) )
    {
        ERRWRAP2(_self_->getCloud(points, normals));
        return Py_BuildValue("(NN)", pyopencv_from(points), pyopencv_from(normals));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_kinfu_kinfu_KinFu_getNormals(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;


    Ptr<cv::kinfu::KinFu> * self1 = 0;
    if (!pyopencv_kinfu_KinFu_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'kinfu_KinFu' or its derivative)");
    Ptr<cv::kinfu::KinFu> _self_ = *(self1);
    {
    PyObject* pyobj_points = NULL;
    Mat points;
    PyObject* pyobj_normals = NULL;
    Mat normals;

    const char* keywords[] = { "points", "normals", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:kinfu_KinFu.getNormals", (char**)keywords, &pyobj_points, &pyobj_normals) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 1)) )
    {
        ERRWRAP2(_self_->getNormals(points, normals));
        return pyopencv_from(normals);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points = NULL;
    UMat points;
    PyObject* pyobj_normals = NULL;
    UMat normals;

    const char* keywords[] = { "points", "normals", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:kinfu_KinFu.getNormals", (char**)keywords, &pyobj_points, &pyobj_normals) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 1)) )
    {
        ERRWRAP2(_self_->getNormals(points, normals));
        return pyopencv_from(normals);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_kinfu_kinfu_KinFu_getPoints(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;


    Ptr<cv::kinfu::KinFu> * self1 = 0;
    if (!pyopencv_kinfu_KinFu_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'kinfu_KinFu' or its derivative)");
    Ptr<cv::kinfu::KinFu> _self_ = *(self1);
    {
    PyObject* pyobj_points = NULL;
    Mat points;

    const char* keywords[] = { "points", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:kinfu_KinFu.getPoints", (char**)keywords, &pyobj_points) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 1)) )
    {
        ERRWRAP2(_self_->getPoints(points));
        return pyopencv_from(points);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points = NULL;
    UMat points;

    const char* keywords[] = { "points", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:kinfu_KinFu.getPoints", (char**)keywords, &pyobj_points) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 1)) )
    {
        ERRWRAP2(_self_->getPoints(points));
        return pyopencv_from(points);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_kinfu_kinfu_KinFu_render(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;


    Ptr<cv::kinfu::KinFu> * self1 = 0;
    if (!pyopencv_kinfu_KinFu_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'kinfu_KinFu' or its derivative)");
    Ptr<cv::kinfu::KinFu> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_cameraPose = NULL;
    Matx44f cameraPose=Matx44f::eye();

    const char* keywords[] = { "image", "cameraPose", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:kinfu_KinFu.render", (char**)keywords, &pyobj_image, &pyobj_cameraPose) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_cameraPose, cameraPose, ArgInfo("cameraPose", 0)) )
    {
        ERRWRAP2(_self_->render(image, cameraPose));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_cameraPose = NULL;
    Matx44f cameraPose=Matx44f::eye();

    const char* keywords[] = { "image", "cameraPose", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OO:kinfu_KinFu.render", (char**)keywords, &pyobj_image, &pyobj_cameraPose) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) &&
        pyopencv_to(pyobj_cameraPose, cameraPose, ArgInfo("cameraPose", 0)) )
    {
        ERRWRAP2(_self_->render(image, cameraPose));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_kinfu_kinfu_KinFu_reset(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;


    Ptr<cv::kinfu::KinFu> * self1 = 0;
    if (!pyopencv_kinfu_KinFu_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'kinfu_KinFu' or its derivative)");
    Ptr<cv::kinfu::KinFu> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->reset());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_kinfu_kinfu_KinFu_update(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;


    Ptr<cv::kinfu::KinFu> * self1 = 0;
    if (!pyopencv_kinfu_KinFu_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'kinfu_KinFu' or its derivative)");
    Ptr<cv::kinfu::KinFu> _self_ = *(self1);
    {
    PyObject* pyobj_depth = NULL;
    Mat depth;
    bool retval;

    const char* keywords[] = { "depth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:kinfu_KinFu.update", (char**)keywords, &pyobj_depth) &&
        pyopencv_to(pyobj_depth, depth, ArgInfo("depth", 0)) )
    {
        ERRWRAP2(retval = _self_->update(depth));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_depth = NULL;
    UMat depth;
    bool retval;

    const char* keywords[] = { "depth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:kinfu_KinFu.update", (char**)keywords, &pyobj_depth) &&
        pyopencv_to(pyobj_depth, depth, ArgInfo("depth", 0)) )
    {
        ERRWRAP2(retval = _self_->update(depth));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (kinfu_KinFu)

static PyGetSetDef pyopencv_kinfu_KinFu_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_kinfu_KinFu_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_KinFu_create_static, METH_STATIC), "create(_params) -> retval\n."},
    {"getCloud", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_KinFu_getCloud, 0), "getCloud([, points[, normals]]) -> points, normals\n.   @brief Gets points and normals of current 3d mesh\n.   \n.         The order of normals corresponds to order of points.\n.         The order of points is undefined.\n.   \n.           @param points vector of points which are 4-float vectors\n.           @param normals vector of normals which are 4-float vectors"},
    {"getNormals", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_KinFu_getNormals, 0), "getNormals(points[, normals]) -> normals\n.   @brief Calculates normals for given points\n.           @param points input vector of points which are 4-float vectors\n.           @param normals output vector of corresponding normals which are 4-float vectors"},
    {"getPoints", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_KinFu_getPoints, 0), "getPoints([, points]) -> points\n.   @brief Gets points of current 3d mesh\n.   \n.        The order of points is undefined.\n.   \n.           @param points vector of points which are 4-float vectors"},
    {"render", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_KinFu_render, 0), "render([, image[, cameraPose]]) -> image\n.   @brief Renders a volume into an image\n.   \n.         Renders a 0-surface of TSDF using Phong shading into a CV_8UC4 Mat.\n.         Light pose is fixed in KinFu params.\n.   \n.           @param image resulting image\n.           @param cameraPose pose of camera to render from. If empty then render from current pose\n.           which is a last frame camera pose."},
    {"reset", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_KinFu_reset, 0), "reset() -> None\n.   @brief Resets the algorithm\n.   \n.       Clears current model and resets a pose."},
    {"update", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_KinFu_update, 0), "update(depth) -> retval\n.   @brief Process next depth frame\n.   \n.         Integrates depth into voxel space with respect to its ICP-calculated pose.\n.         Input image is converted to CV_32F internally if has another type.\n.   \n.       @param depth one-channel image which size and depth scale is described in algorithm's parameters\n.       @return true if succeded to align new frame with current scene, false if opposite"},

    {NULL,          NULL}
};

// Converter (kinfu_KinFu)

template<>
struct PyOpenCV_Converter< Ptr<cv::kinfu::KinFu> >
{
    static PyObject* from(const Ptr<cv::kinfu::KinFu>& r)
    {
        return pyopencv_kinfu_KinFu_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::kinfu::KinFu>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::kinfu::KinFu> * dst_;
        if (pyopencv_kinfu_KinFu_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::kinfu::KinFu> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// kinfu_Params (Generic)
//================================================================================

// GetSet (kinfu_Params)


static PyObject* pyopencv_kinfu_Params_get_bilateral_kernel_size(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->bilateral_kernel_size);
}

static int pyopencv_kinfu_Params_set_bilateral_kernel_size(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the bilateral_kernel_size attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->bilateral_kernel_size) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_bilateral_sigma_depth(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->bilateral_sigma_depth);
}

static int pyopencv_kinfu_Params_set_bilateral_sigma_depth(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the bilateral_sigma_depth attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->bilateral_sigma_depth) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_bilateral_sigma_spatial(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->bilateral_sigma_spatial);
}

static int pyopencv_kinfu_Params_set_bilateral_sigma_spatial(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the bilateral_sigma_spatial attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->bilateral_sigma_spatial) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_depthFactor(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->depthFactor);
}

static int pyopencv_kinfu_Params_set_depthFactor(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the depthFactor attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->depthFactor) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_frameSize(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->frameSize);
}

static int pyopencv_kinfu_Params_set_frameSize(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the frameSize attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->frameSize) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_icpAngleThresh(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->icpAngleThresh);
}

static int pyopencv_kinfu_Params_set_icpAngleThresh(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the icpAngleThresh attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->icpAngleThresh) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_icpDistThresh(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->icpDistThresh);
}

static int pyopencv_kinfu_Params_set_icpDistThresh(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the icpDistThresh attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->icpDistThresh) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_icpIterations(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->icpIterations);
}

static PyObject* pyopencv_kinfu_Params_get_intr(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->intr);
}

static PyObject* pyopencv_kinfu_Params_get_lightPose(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->lightPose);
}

static PyObject* pyopencv_kinfu_Params_get_pyramidLevels(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramidLevels);
}

static int pyopencv_kinfu_Params_set_pyramidLevels(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the pyramidLevels attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->pyramidLevels) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_raycast_step_factor(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->raycast_step_factor);
}

static int pyopencv_kinfu_Params_set_raycast_step_factor(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the raycast_step_factor attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->raycast_step_factor) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_truncateThreshold(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->truncateThreshold);
}

static int pyopencv_kinfu_Params_set_truncateThreshold(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the truncateThreshold attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->truncateThreshold) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_tsdf_max_weight(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->tsdf_max_weight);
}

static int pyopencv_kinfu_Params_set_tsdf_max_weight(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the tsdf_max_weight attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->tsdf_max_weight) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_tsdf_min_camera_movement(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->tsdf_min_camera_movement);
}

static int pyopencv_kinfu_Params_set_tsdf_min_camera_movement(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the tsdf_min_camera_movement attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->tsdf_min_camera_movement) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_tsdf_trunc_dist(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->tsdf_trunc_dist);
}

static int pyopencv_kinfu_Params_set_tsdf_trunc_dist(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the tsdf_trunc_dist attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->tsdf_trunc_dist) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_volumeDims(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->volumeDims);
}

static int pyopencv_kinfu_Params_set_volumeDims(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the volumeDims attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->volumeDims) ? 0 : -1;
}

static PyObject* pyopencv_kinfu_Params_get_voxelSize(pyopencv_kinfu_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->voxelSize);
}

static int pyopencv_kinfu_Params_set_voxelSize(pyopencv_kinfu_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the voxelSize attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->voxelSize) ? 0 : -1;
}


// Methods (kinfu_Params)

static PyObject* pyopencv_cv_kinfu_kinfu_Params_coarseParams_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;

    Ptr<Params> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::kinfu::Params::coarseParams());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_kinfu_kinfu_Params_defaultParams_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::kinfu;

    Ptr<Params> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::kinfu::Params::defaultParams());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (kinfu_Params)

static PyGetSetDef pyopencv_kinfu_Params_getseters[] =
{
    {(char*)"bilateral_kernel_size", (getter)pyopencv_kinfu_Params_get_bilateral_kernel_size, (setter)pyopencv_kinfu_Params_set_bilateral_kernel_size, (char*)"bilateral_kernel_size", NULL},
    {(char*)"bilateral_sigma_depth", (getter)pyopencv_kinfu_Params_get_bilateral_sigma_depth, (setter)pyopencv_kinfu_Params_set_bilateral_sigma_depth, (char*)"bilateral_sigma_depth", NULL},
    {(char*)"bilateral_sigma_spatial", (getter)pyopencv_kinfu_Params_get_bilateral_sigma_spatial, (setter)pyopencv_kinfu_Params_set_bilateral_sigma_spatial, (char*)"bilateral_sigma_spatial", NULL},
    {(char*)"depthFactor", (getter)pyopencv_kinfu_Params_get_depthFactor, (setter)pyopencv_kinfu_Params_set_depthFactor, (char*)"depthFactor", NULL},
    {(char*)"frameSize", (getter)pyopencv_kinfu_Params_get_frameSize, (setter)pyopencv_kinfu_Params_set_frameSize, (char*)"frameSize", NULL},
    {(char*)"icpAngleThresh", (getter)pyopencv_kinfu_Params_get_icpAngleThresh, (setter)pyopencv_kinfu_Params_set_icpAngleThresh, (char*)"icpAngleThresh", NULL},
    {(char*)"icpDistThresh", (getter)pyopencv_kinfu_Params_get_icpDistThresh, (setter)pyopencv_kinfu_Params_set_icpDistThresh, (char*)"icpDistThresh", NULL},
    {(char*)"icpIterations", (getter)pyopencv_kinfu_Params_get_icpIterations, NULL, (char*)"icpIterations", NULL},
    {(char*)"intr", (getter)pyopencv_kinfu_Params_get_intr, NULL, (char*)"intr", NULL},
    {(char*)"lightPose", (getter)pyopencv_kinfu_Params_get_lightPose, NULL, (char*)"lightPose", NULL},
    {(char*)"pyramidLevels", (getter)pyopencv_kinfu_Params_get_pyramidLevels, (setter)pyopencv_kinfu_Params_set_pyramidLevels, (char*)"pyramidLevels", NULL},
    {(char*)"raycast_step_factor", (getter)pyopencv_kinfu_Params_get_raycast_step_factor, (setter)pyopencv_kinfu_Params_set_raycast_step_factor, (char*)"raycast_step_factor", NULL},
    {(char*)"truncateThreshold", (getter)pyopencv_kinfu_Params_get_truncateThreshold, (setter)pyopencv_kinfu_Params_set_truncateThreshold, (char*)"truncateThreshold", NULL},
    {(char*)"tsdf_max_weight", (getter)pyopencv_kinfu_Params_get_tsdf_max_weight, (setter)pyopencv_kinfu_Params_set_tsdf_max_weight, (char*)"tsdf_max_weight", NULL},
    {(char*)"tsdf_min_camera_movement", (getter)pyopencv_kinfu_Params_get_tsdf_min_camera_movement, (setter)pyopencv_kinfu_Params_set_tsdf_min_camera_movement, (char*)"tsdf_min_camera_movement", NULL},
    {(char*)"tsdf_trunc_dist", (getter)pyopencv_kinfu_Params_get_tsdf_trunc_dist, (setter)pyopencv_kinfu_Params_set_tsdf_trunc_dist, (char*)"tsdf_trunc_dist", NULL},
    {(char*)"volumeDims", (getter)pyopencv_kinfu_Params_get_volumeDims, (setter)pyopencv_kinfu_Params_set_volumeDims, (char*)"volumeDims", NULL},
    {(char*)"voxelSize", (getter)pyopencv_kinfu_Params_get_voxelSize, (setter)pyopencv_kinfu_Params_set_voxelSize, (char*)"voxelSize", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_kinfu_Params_methods[] =
{
    {"coarseParams", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_Params_coarseParams_static, METH_STATIC), "coarseParams() -> retval\n.   @brief Coarse parameters\n.       A set of parameters which provides better speed, can fail to match frames\n.       in case of rapid sensor motion."},
    {"defaultParams", CV_PY_FN_WITH_KW_(pyopencv_cv_kinfu_kinfu_Params_defaultParams_static, METH_STATIC), "defaultParams() -> retval\n.   @brief Default parameters\n.       A set of parameters which provides better model quality, can be very slow."},

    {NULL,          NULL}
};

// Converter (kinfu_Params)

template<>
struct PyOpenCV_Converter< Ptr<cv::kinfu::Params> >
{
    static PyObject* from(const Ptr<cv::kinfu::Params>& r)
    {
        return pyopencv_kinfu_Params_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::kinfu::Params>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::kinfu::Params> * dst_;
        if (pyopencv_kinfu_Params_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::kinfu::Params> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// line_descriptor_BinaryDescriptor (Generic)
//================================================================================

// GetSet (line_descriptor_BinaryDescriptor)



// Methods (line_descriptor_BinaryDescriptor)

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptor> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptor' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptor> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_keylines = NULL;
    vector_KeyLine keylines;
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;
    bool returnFloatDescr=false;

    const char* keywords[] = { "image", "keylines", "descriptors", "returnFloatDescr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Ob:line_descriptor_BinaryDescriptor.compute", (char**)keywords, &pyobj_image, &pyobj_keylines, &pyobj_descriptors, &returnFloatDescr) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_keylines, keylines, ArgInfo("keylines", 1)) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 1)) )
    {
        ERRWRAP2(_self_->compute(image, keylines, descriptors, returnFloatDescr));
        return Py_BuildValue("(NN)", pyopencv_from(keylines), pyopencv_from(descriptors));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_keylines = NULL;
    vector_KeyLine keylines;
    PyObject* pyobj_descriptors = NULL;
    Mat descriptors;
    bool returnFloatDescr=false;

    const char* keywords[] = { "image", "keylines", "descriptors", "returnFloatDescr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Ob:line_descriptor_BinaryDescriptor.compute", (char**)keywords, &pyobj_image, &pyobj_keylines, &pyobj_descriptors, &returnFloatDescr) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_keylines, keylines, ArgInfo("keylines", 1)) &&
        pyopencv_to(pyobj_descriptors, descriptors, ArgInfo("descriptors", 1)) )
    {
        ERRWRAP2(_self_->compute(image, keylines, descriptors, returnFloatDescr));
        return Py_BuildValue("(NN)", pyopencv_from(keylines), pyopencv_from(descriptors));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_createBinaryDescriptor_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;

    Ptr<BinaryDescriptor> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::line_descriptor::BinaryDescriptor::createBinaryDescriptor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptor> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptor' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptor> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_KeyLine keypoints;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:line_descriptor_BinaryDescriptor.detect", (char**)keywords, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->detect(image, keypoints, mask));
        return pyopencv_from(keypoints);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_KeyLine keypoints;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "image", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:line_descriptor_BinaryDescriptor.detect", (char**)keywords, &pyobj_image, &pyobj_mask) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->detect(image, keypoints, mask));
        return pyopencv_from(keypoints);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_getNumOfOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptor> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptor' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumOfOctaves());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_getReductionRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptor> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptor' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getReductionRatio());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_getWidthOfBand(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptor> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptor' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptor> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWidthOfBand());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_setNumOfOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptor> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptor' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptor> _self_ = *(self1);
    int octaves=0;

    const char* keywords[] = { "octaves", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:line_descriptor_BinaryDescriptor.setNumOfOctaves", (char**)keywords, &octaves) )
    {
        ERRWRAP2(_self_->setNumOfOctaves(octaves));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_setReductionRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptor> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptor' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptor> _self_ = *(self1);
    int rRatio=0;

    const char* keywords[] = { "rRatio", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:line_descriptor_BinaryDescriptor.setReductionRatio", (char**)keywords, &rRatio) )
    {
        ERRWRAP2(_self_->setReductionRatio(rRatio));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_setWidthOfBand(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptor> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptor_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptor' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptor> _self_ = *(self1);
    int width=0;

    const char* keywords[] = { "width", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:line_descriptor_BinaryDescriptor.setWidthOfBand", (char**)keywords, &width) )
    {
        ERRWRAP2(_self_->setWidthOfBand(width));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (line_descriptor_BinaryDescriptor)

static PyGetSetDef pyopencv_line_descriptor_BinaryDescriptor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_line_descriptor_BinaryDescriptor_methods[] =
{
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_compute, 0), "compute(image, keylines[, descriptors[, returnFloatDescr]]) -> keylines, descriptors\n.   @brief Requires descriptors computation\n.   \n.       @param image input image\n.       @param keylines vector containing lines for which descriptors must be computed\n.       @param descriptors\n.       @param returnFloatDescr flag (when set to true, original non-binary descriptors are returned)"},
    {"createBinaryDescriptor", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_createBinaryDescriptor_static, METH_STATIC), "createBinaryDescriptor() -> retval\n.   @brief Create a BinaryDescriptor object with default parameters (or with the ones provided)\n.     and return a smart pointer to it"},
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_detect, 0), "detect(image[, mask]) -> keypoints\n.   @brief Requires line detection\n.   \n.       @param image input image\n.       @param keypoints vector that will store extracted lines for one or more images\n.       @param mask mask matrix to detect only KeyLines of interest"},
    {"getNumOfOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_getNumOfOctaves, 0), "getNumOfOctaves() -> retval\n.   @brief Get current number of octaves"},
    {"getReductionRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_getReductionRatio, 0), "getReductionRatio() -> retval\n.   @brief Get current reduction ratio (used in Gaussian pyramids)"},
    {"getWidthOfBand", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_getWidthOfBand, 0), "getWidthOfBand() -> retval\n.   @brief Get current width of bands"},
    {"setNumOfOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_setNumOfOctaves, 0), "setNumOfOctaves(octaves) -> None\n.   @brief Set number of octaves\n.       @param octaves number of octaves"},
    {"setReductionRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_setReductionRatio, 0), "setReductionRatio(rRatio) -> None\n.   @brief Set reduction ratio (used in Gaussian pyramids)\n.       @param rRatio reduction ratio"},
    {"setWidthOfBand", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptor_setWidthOfBand, 0), "setWidthOfBand(width) -> None\n.   @brief Set width of bands\n.       @param width width of bands"},

    {NULL,          NULL}
};

// Converter (line_descriptor_BinaryDescriptor)

template<>
struct PyOpenCV_Converter< Ptr<cv::line_descriptor::BinaryDescriptor> >
{
    static PyObject* from(const Ptr<cv::line_descriptor::BinaryDescriptor>& r)
    {
        return pyopencv_line_descriptor_BinaryDescriptor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::line_descriptor::BinaryDescriptor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::line_descriptor::BinaryDescriptor> * dst_;
        if (pyopencv_line_descriptor_BinaryDescriptor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::line_descriptor::BinaryDescriptor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// line_descriptor_BinaryDescriptorMatcher (Generic)
//================================================================================

// GetSet (line_descriptor_BinaryDescriptorMatcher)



// Methods (line_descriptor_BinaryDescriptorMatcher)

static int pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_BinaryDescriptorMatcher(pyopencv_line_descriptor_BinaryDescriptorMatcher_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::line_descriptor::BinaryDescriptorMatcher>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::line_descriptor::BinaryDescriptorMatcher()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_knnMatch(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptorMatcher> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptorMatcher' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|Ob:line_descriptor_BinaryDescriptorMatcher.knnMatch", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &k, &pyobj_mask, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    Mat trainDescriptors;
    vector_vector_DMatch matches;
    int k=0;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "k", "mask", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|Ob:line_descriptor_BinaryDescriptorMatcher.knnMatch", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &k, &pyobj_mask, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult));
        return pyopencv_from(matches);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_knnMatchQuery(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptorMatcher> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptorMatcher' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_matches = NULL;
    vector_vector_DMatch matches;
    int k=0;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks=std::vector<Mat>();
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "matches", "k", "masks", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|Ob:line_descriptor_BinaryDescriptorMatcher.knnMatchQuery", (char**)keywords, &pyobj_queryDescriptors, &pyobj_matches, &k, &pyobj_masks, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_matches, matches, ArgInfo("matches", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->knnMatch(queryDescriptors, matches, k, masks, compactResult));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_matches = NULL;
    vector_vector_DMatch matches;
    int k=0;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks=std::vector<Mat>();
    bool compactResult=false;

    const char* keywords[] = { "queryDescriptors", "matches", "k", "masks", "compactResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|Ob:line_descriptor_BinaryDescriptorMatcher.knnMatchQuery", (char**)keywords, &pyobj_queryDescriptors, &pyobj_matches, &k, &pyobj_masks, &compactResult) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_matches, matches, ArgInfo("matches", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->knnMatch(queryDescriptors, matches, k, masks, compactResult));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_match(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptorMatcher> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptorMatcher' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    Mat trainDescriptors;
    vector_DMatch matches;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:line_descriptor_BinaryDescriptorMatcher.match", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &pyobj_mask) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->match(queryDescriptors, trainDescriptors, matches, mask));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    PyObject* pyobj_trainDescriptors = NULL;
    Mat trainDescriptors;
    vector_DMatch matches;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "queryDescriptors", "trainDescriptors", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:line_descriptor_BinaryDescriptorMatcher.match", (char**)keywords, &pyobj_queryDescriptors, &pyobj_trainDescriptors, &pyobj_mask) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_trainDescriptors, trainDescriptors, ArgInfo("trainDescriptors", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->match(queryDescriptors, trainDescriptors, matches, mask));
        return pyopencv_from(matches);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_matchQuery(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::BinaryDescriptorMatcher> * self1 = 0;
    if (!pyopencv_line_descriptor_BinaryDescriptorMatcher_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_BinaryDescriptorMatcher' or its derivative)");
    Ptr<cv::line_descriptor::BinaryDescriptorMatcher> _self_ = *(self1);
    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    vector_DMatch matches;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks=std::vector<Mat>();

    const char* keywords[] = { "queryDescriptors", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:line_descriptor_BinaryDescriptorMatcher.matchQuery", (char**)keywords, &pyobj_queryDescriptors, &pyobj_masks) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->match(queryDescriptors, matches, masks));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_queryDescriptors = NULL;
    Mat queryDescriptors;
    vector_DMatch matches;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks=std::vector<Mat>();

    const char* keywords[] = { "queryDescriptors", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:line_descriptor_BinaryDescriptorMatcher.matchQuery", (char**)keywords, &pyobj_queryDescriptors, &pyobj_masks) &&
        pyopencv_to(pyobj_queryDescriptors, queryDescriptors, ArgInfo("queryDescriptors", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->match(queryDescriptors, matches, masks));
        return pyopencv_from(matches);
    }
    }

    return NULL;
}



// Tables (line_descriptor_BinaryDescriptorMatcher)

static PyGetSetDef pyopencv_line_descriptor_BinaryDescriptorMatcher_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_line_descriptor_BinaryDescriptorMatcher_methods[] =
{
    {"knnMatch", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_knnMatch, 0), "knnMatch(queryDescriptors, trainDescriptors, k[, mask[, compactResult]]) -> matches\n.   @brief For every input query descriptor, retrieve the best *k* matching ones from a dataset provided from\n.   user or from the one internal to class\n.   \n.   @param queryDescriptors query descriptors\n.   @param trainDescriptors dataset of descriptors furnished by user\n.   @param matches vector to host retrieved matches\n.   @param k number of the closest descriptors to be returned for every input query\n.   @param mask mask to select which input descriptors must be matched to ones in dataset\n.   @param compactResult flag to obtain a compact result (if true, a vector that doesn't contain any\n.   matches for a given query is not inserted in final result)"},
    {"knnMatchQuery", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_knnMatchQuery, 0), "knnMatchQuery(queryDescriptors, matches, k[, masks[, compactResult]]) -> None\n.   @overload\n.   @param queryDescriptors query descriptors\n.   @param matches vector to host retrieved matches\n.   @param k number of the closest descriptors to be returned for every input query\n.   @param masks vector of masks to select which input descriptors must be matched to ones in dataset\n.   (the *i*-th mask in vector indicates whether each input query can be matched with descriptors in\n.   dataset relative to *i*-th image)\n.   @param compactResult flag to obtain a compact result (if true, a vector that doesn't contain any\n.   matches for a given query is not inserted in final result)"},
    {"match", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_match, 0), "match(queryDescriptors, trainDescriptors[, mask]) -> matches\n.   @brief For every input query descriptor, retrieve the best matching one from a dataset provided from user\n.   or from the one internal to class\n.   \n.   @param queryDescriptors query descriptors\n.   @param trainDescriptors dataset of descriptors furnished by user\n.   @param matches vector to host retrieved matches\n.   @param mask mask to select which input descriptors must be matched to one in dataset"},
    {"matchQuery", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_BinaryDescriptorMatcher_matchQuery, 0), "matchQuery(queryDescriptors[, masks]) -> matches\n.   @overload\n.   @param queryDescriptors query descriptors\n.   @param matches vector to host retrieved matches\n.   @param masks vector of masks to select which input descriptors must be matched to one in dataset\n.   (the *i*-th mask in vector indicates whether each input query can be matched with descriptors in\n.   dataset relative to *i*-th image)"},

    {NULL,          NULL}
};

// Converter (line_descriptor_BinaryDescriptorMatcher)

template<>
struct PyOpenCV_Converter< Ptr<cv::line_descriptor::BinaryDescriptorMatcher> >
{
    static PyObject* from(const Ptr<cv::line_descriptor::BinaryDescriptorMatcher>& r)
    {
        return pyopencv_line_descriptor_BinaryDescriptorMatcher_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::line_descriptor::BinaryDescriptorMatcher>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::line_descriptor::BinaryDescriptorMatcher> * dst_;
        if (pyopencv_line_descriptor_BinaryDescriptorMatcher_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::line_descriptor::BinaryDescriptorMatcher> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// line_descriptor_DrawLinesMatchesFlags (Generic)
//================================================================================

// GetSet (line_descriptor_DrawLinesMatchesFlags)



// Methods (line_descriptor_DrawLinesMatchesFlags)



// Tables (line_descriptor_DrawLinesMatchesFlags)

static PyGetSetDef pyopencv_line_descriptor_DrawLinesMatchesFlags_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_line_descriptor_DrawLinesMatchesFlags_methods[] =
{

    {NULL,          NULL}
};

// Converter (line_descriptor_DrawLinesMatchesFlags)

template<>
struct PyOpenCV_Converter< cv::line_descriptor::DrawLinesMatchesFlags >
{
    static PyObject* from(const cv::line_descriptor::DrawLinesMatchesFlags& r)
    {
        return pyopencv_line_descriptor_DrawLinesMatchesFlags_Instance(r);
    }
    static bool to(PyObject* src, cv::line_descriptor::DrawLinesMatchesFlags& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::line_descriptor::DrawLinesMatchesFlags * dst_;
        if (pyopencv_line_descriptor_DrawLinesMatchesFlags_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::line_descriptor::DrawLinesMatchesFlags for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// line_descriptor_KeyLine (Generic)
//================================================================================

// GetSet (line_descriptor_KeyLine)


static PyObject* pyopencv_line_descriptor_KeyLine_get_angle(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.angle);
}

static int pyopencv_line_descriptor_KeyLine_set_angle(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the angle attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.angle) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_class_id(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.class_id);
}

static int pyopencv_line_descriptor_KeyLine_set_class_id(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the class_id attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.class_id) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_ePointInOctaveX(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.ePointInOctaveX);
}

static int pyopencv_line_descriptor_KeyLine_set_ePointInOctaveX(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the ePointInOctaveX attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.ePointInOctaveX) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_ePointInOctaveY(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.ePointInOctaveY);
}

static int pyopencv_line_descriptor_KeyLine_set_ePointInOctaveY(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the ePointInOctaveY attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.ePointInOctaveY) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_endPointX(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.endPointX);
}

static int pyopencv_line_descriptor_KeyLine_set_endPointX(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the endPointX attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.endPointX) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_endPointY(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.endPointY);
}

static int pyopencv_line_descriptor_KeyLine_set_endPointY(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the endPointY attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.endPointY) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_lineLength(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.lineLength);
}

static int pyopencv_line_descriptor_KeyLine_set_lineLength(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the lineLength attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.lineLength) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_numOfPixels(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.numOfPixels);
}

static int pyopencv_line_descriptor_KeyLine_set_numOfPixels(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the numOfPixels attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.numOfPixels) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_octave(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.octave);
}

static int pyopencv_line_descriptor_KeyLine_set_octave(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the octave attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.octave) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_pt(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.pt);
}

static int pyopencv_line_descriptor_KeyLine_set_pt(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the pt attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.pt) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_response(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.response);
}

static int pyopencv_line_descriptor_KeyLine_set_response(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the response attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.response) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_sPointInOctaveX(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.sPointInOctaveX);
}

static int pyopencv_line_descriptor_KeyLine_set_sPointInOctaveX(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the sPointInOctaveX attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.sPointInOctaveX) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_sPointInOctaveY(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.sPointInOctaveY);
}

static int pyopencv_line_descriptor_KeyLine_set_sPointInOctaveY(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the sPointInOctaveY attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.sPointInOctaveY) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_size(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.size);
}

static int pyopencv_line_descriptor_KeyLine_set_size(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the size attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.size) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_startPointX(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.startPointX);
}

static int pyopencv_line_descriptor_KeyLine_set_startPointX(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the startPointX attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.startPointX) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_KeyLine_get_startPointY(pyopencv_line_descriptor_KeyLine_t* p, void *closure)
{
    return pyopencv_from(p->v.startPointY);
}

static int pyopencv_line_descriptor_KeyLine_set_startPointY(pyopencv_line_descriptor_KeyLine_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the startPointY attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.startPointY) ? 0 : -1;
}


// Methods (line_descriptor_KeyLine)

static int pyopencv_cv_line_descriptor_line_descriptor_KeyLine_KeyLine(pyopencv_line_descriptor_KeyLine_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::line_descriptor::KeyLine());
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_KeyLine_getEndPoint(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    cv::line_descriptor::KeyLine * self1 = 0;
    if (!pyopencv_line_descriptor_KeyLine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_KeyLine' or its derivative)");
    cv::line_descriptor::KeyLine* _self_ = (self1);
    Point2f retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEndPoint());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_KeyLine_getEndPointInOctave(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    cv::line_descriptor::KeyLine * self1 = 0;
    if (!pyopencv_line_descriptor_KeyLine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_KeyLine' or its derivative)");
    cv::line_descriptor::KeyLine* _self_ = (self1);
    Point2f retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEndPointInOctave());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_KeyLine_getStartPoint(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    cv::line_descriptor::KeyLine * self1 = 0;
    if (!pyopencv_line_descriptor_KeyLine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_KeyLine' or its derivative)");
    cv::line_descriptor::KeyLine* _self_ = (self1);
    Point2f retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getStartPoint());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_KeyLine_getStartPointInOctave(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    cv::line_descriptor::KeyLine * self1 = 0;
    if (!pyopencv_line_descriptor_KeyLine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_KeyLine' or its derivative)");
    cv::line_descriptor::KeyLine* _self_ = (self1);
    Point2f retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getStartPointInOctave());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (line_descriptor_KeyLine)

static PyGetSetDef pyopencv_line_descriptor_KeyLine_getseters[] =
{
    {(char*)"angle", (getter)pyopencv_line_descriptor_KeyLine_get_angle, (setter)pyopencv_line_descriptor_KeyLine_set_angle, (char*)"angle", NULL},
    {(char*)"class_id", (getter)pyopencv_line_descriptor_KeyLine_get_class_id, (setter)pyopencv_line_descriptor_KeyLine_set_class_id, (char*)"class_id", NULL},
    {(char*)"ePointInOctaveX", (getter)pyopencv_line_descriptor_KeyLine_get_ePointInOctaveX, (setter)pyopencv_line_descriptor_KeyLine_set_ePointInOctaveX, (char*)"ePointInOctaveX", NULL},
    {(char*)"ePointInOctaveY", (getter)pyopencv_line_descriptor_KeyLine_get_ePointInOctaveY, (setter)pyopencv_line_descriptor_KeyLine_set_ePointInOctaveY, (char*)"ePointInOctaveY", NULL},
    {(char*)"endPointX", (getter)pyopencv_line_descriptor_KeyLine_get_endPointX, (setter)pyopencv_line_descriptor_KeyLine_set_endPointX, (char*)"endPointX", NULL},
    {(char*)"endPointY", (getter)pyopencv_line_descriptor_KeyLine_get_endPointY, (setter)pyopencv_line_descriptor_KeyLine_set_endPointY, (char*)"endPointY", NULL},
    {(char*)"lineLength", (getter)pyopencv_line_descriptor_KeyLine_get_lineLength, (setter)pyopencv_line_descriptor_KeyLine_set_lineLength, (char*)"lineLength", NULL},
    {(char*)"numOfPixels", (getter)pyopencv_line_descriptor_KeyLine_get_numOfPixels, (setter)pyopencv_line_descriptor_KeyLine_set_numOfPixels, (char*)"numOfPixels", NULL},
    {(char*)"octave", (getter)pyopencv_line_descriptor_KeyLine_get_octave, (setter)pyopencv_line_descriptor_KeyLine_set_octave, (char*)"octave", NULL},
    {(char*)"pt", (getter)pyopencv_line_descriptor_KeyLine_get_pt, (setter)pyopencv_line_descriptor_KeyLine_set_pt, (char*)"pt", NULL},
    {(char*)"response", (getter)pyopencv_line_descriptor_KeyLine_get_response, (setter)pyopencv_line_descriptor_KeyLine_set_response, (char*)"response", NULL},
    {(char*)"sPointInOctaveX", (getter)pyopencv_line_descriptor_KeyLine_get_sPointInOctaveX, (setter)pyopencv_line_descriptor_KeyLine_set_sPointInOctaveX, (char*)"sPointInOctaveX", NULL},
    {(char*)"sPointInOctaveY", (getter)pyopencv_line_descriptor_KeyLine_get_sPointInOctaveY, (setter)pyopencv_line_descriptor_KeyLine_set_sPointInOctaveY, (char*)"sPointInOctaveY", NULL},
    {(char*)"size", (getter)pyopencv_line_descriptor_KeyLine_get_size, (setter)pyopencv_line_descriptor_KeyLine_set_size, (char*)"size", NULL},
    {(char*)"startPointX", (getter)pyopencv_line_descriptor_KeyLine_get_startPointX, (setter)pyopencv_line_descriptor_KeyLine_set_startPointX, (char*)"startPointX", NULL},
    {(char*)"startPointY", (getter)pyopencv_line_descriptor_KeyLine_get_startPointY, (setter)pyopencv_line_descriptor_KeyLine_set_startPointY, (char*)"startPointY", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_line_descriptor_KeyLine_methods[] =
{
    {"getEndPoint", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_KeyLine_getEndPoint, 0), "getEndPoint() -> retval\n.   Returns the end point of the line in the original image"},
    {"getEndPointInOctave", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_KeyLine_getEndPointInOctave, 0), "getEndPointInOctave() -> retval\n.   Returns the end point of the line in the octave it was extracted from"},
    {"getStartPoint", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_KeyLine_getStartPoint, 0), "getStartPoint() -> retval\n.   Returns the start point of the line in the original image"},
    {"getStartPointInOctave", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_KeyLine_getStartPointInOctave, 0), "getStartPointInOctave() -> retval\n.   Returns the start point of the line in the octave it was extracted from"},

    {NULL,          NULL}
};

// Converter (line_descriptor_KeyLine)

template<>
struct PyOpenCV_Converter< cv::line_descriptor::KeyLine >
{
    static PyObject* from(const cv::line_descriptor::KeyLine& r)
    {
        return pyopencv_line_descriptor_KeyLine_Instance(r);
    }
    static bool to(PyObject* src, cv::line_descriptor::KeyLine& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::line_descriptor::KeyLine * dst_;
        if (pyopencv_line_descriptor_KeyLine_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::line_descriptor::KeyLine for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// line_descriptor_LSDDetector (Generic)
//================================================================================

// GetSet (line_descriptor_LSDDetector)



// Methods (line_descriptor_LSDDetector)

static int pyopencv_cv_line_descriptor_line_descriptor_LSDDetector_LSDDetectorWithParams(pyopencv_line_descriptor_LSDDetector_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;

    PyObject* pyobj__params = NULL;
    LSDParam _params;

    const char* keywords[] = { "_params", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:LSDDetectorWithParams", (char**)keywords, &pyobj__params) &&
        pyopencv_to(pyobj__params, _params, ArgInfo("_params", 0)) )
    {
        new (&(self->v)) Ptr<cv::line_descriptor::LSDDetector>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::line_descriptor::LSDDetector(_params)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_LSDDetector_createLSDDetector_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;

    Ptr<LSDDetector> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::line_descriptor::LSDDetector::createLSDDetector());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_LSDDetector_createLSDDetectorWithParams_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;

    PyObject* pyobj_params = NULL;
    LSDParam params;
    Ptr<LSDDetector> retval;

    const char* keywords[] = { "params", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:line_descriptor_LSDDetector.createLSDDetectorWithParams", (char**)keywords, &pyobj_params) &&
        pyopencv_to(pyobj_params, params, ArgInfo("params", 0)) )
    {
        ERRWRAP2(retval = cv::line_descriptor::LSDDetector::createLSDDetector(params));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_line_descriptor_line_descriptor_LSDDetector_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    Ptr<cv::line_descriptor::LSDDetector> * self1 = 0;
    if (!pyopencv_line_descriptor_LSDDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'line_descriptor_LSDDetector' or its derivative)");
    Ptr<cv::line_descriptor::LSDDetector> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_KeyLine keypoints;
    int scale=0;
    int numOctaves=0;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "image", "scale", "numOctaves", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oii|O:line_descriptor_LSDDetector.detect", (char**)keywords, &pyobj_image, &scale, &numOctaves, &pyobj_mask) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->detect(image, keypoints, scale, numOctaves, mask));
        return pyopencv_from(keypoints);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    vector_KeyLine keypoints;
    int scale=0;
    int numOctaves=0;
    PyObject* pyobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "image", "scale", "numOctaves", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oii|O:line_descriptor_LSDDetector.detect", (char**)keywords, &pyobj_image, &scale, &numOctaves, &pyobj_mask) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(_self_->detect(image, keypoints, scale, numOctaves, mask));
        return pyopencv_from(keypoints);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_keylines = NULL;
    vector_vector_KeyLine keylines;
    int scale=0;
    int numOctaves=0;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks=std::vector<Mat>();

    const char* keywords[] = { "images", "keylines", "scale", "numOctaves", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOii|O:line_descriptor_LSDDetector.detect", (char**)keywords, &pyobj_images, &pyobj_keylines, &scale, &numOctaves, &pyobj_masks) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_keylines, keylines, ArgInfo("keylines", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->detect(images, keylines, scale, numOctaves, masks));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_keylines = NULL;
    vector_vector_KeyLine keylines;
    int scale=0;
    int numOctaves=0;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks=std::vector<Mat>();

    const char* keywords[] = { "images", "keylines", "scale", "numOctaves", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOii|O:line_descriptor_LSDDetector.detect", (char**)keywords, &pyobj_images, &pyobj_keylines, &scale, &numOctaves, &pyobj_masks) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_keylines, keylines, ArgInfo("keylines", 0)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->detect(images, keylines, scale, numOctaves, masks));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (line_descriptor_LSDDetector)

static PyGetSetDef pyopencv_line_descriptor_LSDDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_line_descriptor_LSDDetector_methods[] =
{
    {"createLSDDetector", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_LSDDetector_createLSDDetector_static, METH_STATIC), "createLSDDetector() -> retval\n.   @brief Creates ad LSDDetector object, using smart pointers."},
    {"createLSDDetectorWithParams", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_LSDDetector_createLSDDetectorWithParams_static, METH_STATIC), "createLSDDetectorWithParams(params) -> retval\n."},
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_line_descriptor_line_descriptor_LSDDetector_detect, 0), "detect(image, scale, numOctaves[, mask]) -> keypoints\n.   @brief Detect lines inside an image.\n.   \n.   @param image input image\n.   @param keypoints vector that will store extracted lines for one or more images\n.   @param scale scale factor used in pyramids generation\n.   @param numOctaves number of octaves inside pyramid\n.   @param mask mask matrix to detect only KeyLines of interest\n\n\n\ndetect(images, keylines, scale, numOctaves[, masks]) -> None\n.   @overload\n.   @param images input images\n.   @param keylines set of vectors that will store extracted lines for one or more images\n.   @param scale scale factor used in pyramids generation\n.   @param numOctaves number of octaves inside pyramid\n.   @param masks vector of mask matrices to detect only KeyLines of interest from each input image"},

    {NULL,          NULL}
};

// Converter (line_descriptor_LSDDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::line_descriptor::LSDDetector> >
{
    static PyObject* from(const Ptr<cv::line_descriptor::LSDDetector>& r)
    {
        return pyopencv_line_descriptor_LSDDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::line_descriptor::LSDDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::line_descriptor::LSDDetector> * dst_;
        if (pyopencv_line_descriptor_LSDDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::line_descriptor::LSDDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// line_descriptor_LSDParam (Generic)
//================================================================================

// GetSet (line_descriptor_LSDParam)


static PyObject* pyopencv_line_descriptor_LSDParam_get_ang_th(pyopencv_line_descriptor_LSDParam_t* p, void *closure)
{
    return pyopencv_from(p->v.ang_th);
}

static int pyopencv_line_descriptor_LSDParam_set_ang_th(pyopencv_line_descriptor_LSDParam_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the ang_th attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.ang_th) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_LSDParam_get_density_th(pyopencv_line_descriptor_LSDParam_t* p, void *closure)
{
    return pyopencv_from(p->v.density_th);
}

static int pyopencv_line_descriptor_LSDParam_set_density_th(pyopencv_line_descriptor_LSDParam_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the density_th attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.density_th) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_LSDParam_get_log_eps(pyopencv_line_descriptor_LSDParam_t* p, void *closure)
{
    return pyopencv_from(p->v.log_eps);
}

static int pyopencv_line_descriptor_LSDParam_set_log_eps(pyopencv_line_descriptor_LSDParam_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the log_eps attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.log_eps) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_LSDParam_get_n_bins(pyopencv_line_descriptor_LSDParam_t* p, void *closure)
{
    return pyopencv_from(p->v.n_bins);
}

static int pyopencv_line_descriptor_LSDParam_set_n_bins(pyopencv_line_descriptor_LSDParam_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the n_bins attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.n_bins) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_LSDParam_get_quant(pyopencv_line_descriptor_LSDParam_t* p, void *closure)
{
    return pyopencv_from(p->v.quant);
}

static int pyopencv_line_descriptor_LSDParam_set_quant(pyopencv_line_descriptor_LSDParam_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the quant attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.quant) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_LSDParam_get_scale(pyopencv_line_descriptor_LSDParam_t* p, void *closure)
{
    return pyopencv_from(p->v.scale);
}

static int pyopencv_line_descriptor_LSDParam_set_scale(pyopencv_line_descriptor_LSDParam_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the scale attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.scale) ? 0 : -1;
}

static PyObject* pyopencv_line_descriptor_LSDParam_get_sigma_scale(pyopencv_line_descriptor_LSDParam_t* p, void *closure)
{
    return pyopencv_from(p->v.sigma_scale);
}

static int pyopencv_line_descriptor_LSDParam_set_sigma_scale(pyopencv_line_descriptor_LSDParam_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the sigma_scale attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.sigma_scale) ? 0 : -1;
}


// Methods (line_descriptor_LSDParam)

static int pyopencv_cv_line_descriptor_line_descriptor_LSDParam_LSDParam(pyopencv_line_descriptor_LSDParam_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::line_descriptor;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::line_descriptor::LSDParam());
        return 0;
    }

    return -1;
}



// Tables (line_descriptor_LSDParam)

static PyGetSetDef pyopencv_line_descriptor_LSDParam_getseters[] =
{
    {(char*)"ang_th", (getter)pyopencv_line_descriptor_LSDParam_get_ang_th, (setter)pyopencv_line_descriptor_LSDParam_set_ang_th, (char*)"ang_th", NULL},
    {(char*)"density_th", (getter)pyopencv_line_descriptor_LSDParam_get_density_th, (setter)pyopencv_line_descriptor_LSDParam_set_density_th, (char*)"density_th", NULL},
    {(char*)"log_eps", (getter)pyopencv_line_descriptor_LSDParam_get_log_eps, (setter)pyopencv_line_descriptor_LSDParam_set_log_eps, (char*)"log_eps", NULL},
    {(char*)"n_bins", (getter)pyopencv_line_descriptor_LSDParam_get_n_bins, (setter)pyopencv_line_descriptor_LSDParam_set_n_bins, (char*)"n_bins", NULL},
    {(char*)"quant", (getter)pyopencv_line_descriptor_LSDParam_get_quant, (setter)pyopencv_line_descriptor_LSDParam_set_quant, (char*)"quant", NULL},
    {(char*)"scale", (getter)pyopencv_line_descriptor_LSDParam_get_scale, (setter)pyopencv_line_descriptor_LSDParam_set_scale, (char*)"scale", NULL},
    {(char*)"sigma_scale", (getter)pyopencv_line_descriptor_LSDParam_get_sigma_scale, (setter)pyopencv_line_descriptor_LSDParam_set_sigma_scale, (char*)"sigma_scale", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_line_descriptor_LSDParam_methods[] =
{

    {NULL,          NULL}
};

// Converter (line_descriptor_LSDParam)

template<>
struct PyOpenCV_Converter< cv::line_descriptor::LSDParam >
{
    static PyObject* from(const cv::line_descriptor::LSDParam& r)
    {
        return pyopencv_line_descriptor_LSDParam_Instance(r);
    }
    static bool to(PyObject* src, cv::line_descriptor::LSDParam& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::line_descriptor::LSDParam * dst_;
        if (pyopencv_line_descriptor_LSDParam_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::line_descriptor::LSDParam for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// linemod_ColorGradient (Generic)
//================================================================================

// GetSet (linemod_ColorGradient)


static PyObject* pyopencv_linemod_ColorGradient_get_num_features(pyopencv_linemod_ColorGradient_t* p, void *closure)
{
    return pyopencv_from(p->v->num_features);
}

static PyObject* pyopencv_linemod_ColorGradient_get_strong_threshold(pyopencv_linemod_ColorGradient_t* p, void *closure)
{
    return pyopencv_from(p->v->strong_threshold);
}

static PyObject* pyopencv_linemod_ColorGradient_get_weak_threshold(pyopencv_linemod_ColorGradient_t* p, void *closure)
{
    return pyopencv_from(p->v->weak_threshold);
}


// Methods (linemod_ColorGradient)

static PyObject* pyopencv_cv_linemod_linemod_ColorGradient_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;

    float weak_threshold=0.f;
    size_t num_features=0;
    float strong_threshold=0.f;
    Ptr<ColorGradient> retval;

    const char* keywords[] = { "weak_threshold", "num_features", "strong_threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "fIf:linemod_ColorGradient.create", (char**)keywords, &weak_threshold, &num_features, &strong_threshold) )
    {
        ERRWRAP2(retval = cv::linemod::ColorGradient::create(weak_threshold, num_features, strong_threshold));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (linemod_ColorGradient)

static PyGetSetDef pyopencv_linemod_ColorGradient_getseters[] =
{
    {(char*)"num_features", (getter)pyopencv_linemod_ColorGradient_get_num_features, NULL, (char*)"num_features", NULL},
    {(char*)"strong_threshold", (getter)pyopencv_linemod_ColorGradient_get_strong_threshold, NULL, (char*)"strong_threshold", NULL},
    {(char*)"weak_threshold", (getter)pyopencv_linemod_ColorGradient_get_weak_threshold, NULL, (char*)"weak_threshold", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_linemod_ColorGradient_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_ColorGradient_create_static, METH_STATIC), "create(weak_threshold, num_features, strong_threshold) -> retval\n.   * \\brief Constructor.\n.      *\n.      * \\param weak_threshold   When quantizing, discard gradients with magnitude less than this.\n.      * \\param num_features     How many features a template must contain.\n.      * \\param strong_threshold Consider as candidate features only gradients whose norms are\n.      *                         larger than this."},

    {NULL,          NULL}
};

// Converter (linemod_ColorGradient)

template<>
struct PyOpenCV_Converter< Ptr<cv::linemod::ColorGradient> >
{
    static PyObject* from(const Ptr<cv::linemod::ColorGradient>& r)
    {
        return pyopencv_linemod_ColorGradient_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::linemod::ColorGradient>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::linemod::ColorGradient> * dst_;
        if (pyopencv_linemod_ColorGradient_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::linemod::ColorGradient> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// linemod_DepthNormal (Generic)
//================================================================================

// GetSet (linemod_DepthNormal)


static PyObject* pyopencv_linemod_DepthNormal_get_difference_threshold(pyopencv_linemod_DepthNormal_t* p, void *closure)
{
    return pyopencv_from(p->v->difference_threshold);
}

static PyObject* pyopencv_linemod_DepthNormal_get_distance_threshold(pyopencv_linemod_DepthNormal_t* p, void *closure)
{
    return pyopencv_from(p->v->distance_threshold);
}

static PyObject* pyopencv_linemod_DepthNormal_get_extract_threshold(pyopencv_linemod_DepthNormal_t* p, void *closure)
{
    return pyopencv_from(p->v->extract_threshold);
}

static PyObject* pyopencv_linemod_DepthNormal_get_num_features(pyopencv_linemod_DepthNormal_t* p, void *closure)
{
    return pyopencv_from(p->v->num_features);
}


// Methods (linemod_DepthNormal)

static PyObject* pyopencv_cv_linemod_linemod_DepthNormal_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;

    int distance_threshold=0;
    int difference_threshold=0;
    size_t num_features=0;
    int extract_threshold=0;
    Ptr<DepthNormal> retval;

    const char* keywords[] = { "distance_threshold", "difference_threshold", "num_features", "extract_threshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiIi:linemod_DepthNormal.create", (char**)keywords, &distance_threshold, &difference_threshold, &num_features, &extract_threshold) )
    {
        ERRWRAP2(retval = cv::linemod::DepthNormal::create(distance_threshold, difference_threshold, num_features, extract_threshold));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (linemod_DepthNormal)

static PyGetSetDef pyopencv_linemod_DepthNormal_getseters[] =
{
    {(char*)"difference_threshold", (getter)pyopencv_linemod_DepthNormal_get_difference_threshold, NULL, (char*)"difference_threshold", NULL},
    {(char*)"distance_threshold", (getter)pyopencv_linemod_DepthNormal_get_distance_threshold, NULL, (char*)"distance_threshold", NULL},
    {(char*)"extract_threshold", (getter)pyopencv_linemod_DepthNormal_get_extract_threshold, NULL, (char*)"extract_threshold", NULL},
    {(char*)"num_features", (getter)pyopencv_linemod_DepthNormal_get_num_features, NULL, (char*)"num_features", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_linemod_DepthNormal_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_DepthNormal_create_static, METH_STATIC), "create(distance_threshold, difference_threshold, num_features, extract_threshold) -> retval\n.   * \\brief Constructor.\n.      *\n.      * \\param distance_threshold   Ignore pixels beyond this distance.\n.      * \\param difference_threshold When computing normals, ignore contributions of pixels whose\n.      *                             depth difference with the central pixel is above this threshold.\n.      * \\param num_features         How many features a template must contain.\n.      * \\param extract_threshold    Consider as candidate feature only if there are no differing\n.      *                             orientations within a distance of extract_threshold."},

    {NULL,          NULL}
};

// Converter (linemod_DepthNormal)

template<>
struct PyOpenCV_Converter< Ptr<cv::linemod::DepthNormal> >
{
    static PyObject* from(const Ptr<cv::linemod::DepthNormal>& r)
    {
        return pyopencv_linemod_DepthNormal_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::linemod::DepthNormal>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::linemod::DepthNormal> * dst_;
        if (pyopencv_linemod_DepthNormal_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::linemod::DepthNormal> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// linemod_Detector (Generic)
//================================================================================

// GetSet (linemod_Detector)



// Methods (linemod_Detector)

static int pyopencv_cv_linemod_linemod_Detector_Detector(pyopencv_linemod_Detector_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::linemod::Detector>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::linemod::Detector()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_modalities = NULL;
    vector_Ptr_Modality modalities;
    PyObject* pyobj_T_pyramid = NULL;
    vector_int T_pyramid;

    const char* keywords[] = { "modalities", "T_pyramid", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:Detector", (char**)keywords, &pyobj_modalities, &pyobj_T_pyramid) &&
        pyopencv_to(pyobj_modalities, modalities, ArgInfo("modalities", 0)) &&
        pyopencv_to(pyobj_T_pyramid, T_pyramid, ArgInfo("T_pyramid", 0)) )
    {
        new (&(self->v)) Ptr<cv::linemod::Detector>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::linemod::Detector(modalities, T_pyramid)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_addSyntheticTemplate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    PyObject* pyobj_templates = NULL;
    vector_Template templates;
    PyObject* pyobj_class_id = NULL;
    String class_id;
    int retval;

    const char* keywords[] = { "templates", "class_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:linemod_Detector.addSyntheticTemplate", (char**)keywords, &pyobj_templates, &pyobj_class_id) &&
        pyopencv_to(pyobj_templates, templates, ArgInfo("templates", 0)) &&
        pyopencv_to(pyobj_class_id, class_id, ArgInfo("class_id", 0)) )
    {
        ERRWRAP2(retval = _self_->addSyntheticTemplate(templates, class_id));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_addTemplate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    {
    PyObject* pyobj_sources = NULL;
    vector_Mat sources;
    PyObject* pyobj_class_id = NULL;
    String class_id;
    PyObject* pyobj_object_mask = NULL;
    Mat object_mask;
    Rect bounding_box;
    int retval;

    const char* keywords[] = { "sources", "class_id", "object_mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:linemod_Detector.addTemplate", (char**)keywords, &pyobj_sources, &pyobj_class_id, &pyobj_object_mask) &&
        pyopencv_to(pyobj_sources, sources, ArgInfo("sources", 0)) &&
        pyopencv_to(pyobj_class_id, class_id, ArgInfo("class_id", 0)) &&
        pyopencv_to(pyobj_object_mask, object_mask, ArgInfo("object_mask", 0)) )
    {
        ERRWRAP2(retval = _self_->addTemplate(sources, class_id, object_mask, &bounding_box));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(bounding_box));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_sources = NULL;
    vector_Mat sources;
    PyObject* pyobj_class_id = NULL;
    String class_id;
    PyObject* pyobj_object_mask = NULL;
    Mat object_mask;
    Rect bounding_box;
    int retval;

    const char* keywords[] = { "sources", "class_id", "object_mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:linemod_Detector.addTemplate", (char**)keywords, &pyobj_sources, &pyobj_class_id, &pyobj_object_mask) &&
        pyopencv_to(pyobj_sources, sources, ArgInfo("sources", 0)) &&
        pyopencv_to(pyobj_class_id, class_id, ArgInfo("class_id", 0)) &&
        pyopencv_to(pyobj_object_mask, object_mask, ArgInfo("object_mask", 0)) )
    {
        ERRWRAP2(retval = _self_->addTemplate(sources, class_id, object_mask, &bounding_box));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(bounding_box));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_classIds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    std::vector<String> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->classIds());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_getModalities(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    std::vector< Ptr<Modality> > retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getModalities());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_getT(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    int pyramid_level=0;
    int retval;

    const char* keywords[] = { "pyramid_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:linemod_Detector.getT", (char**)keywords, &pyramid_level) )
    {
        ERRWRAP2(retval = _self_->getT(pyramid_level));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_getTemplates(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    PyObject* pyobj_class_id = NULL;
    String class_id;
    int template_id=0;
    std::vector<Template> retval;

    const char* keywords[] = { "class_id", "template_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:linemod_Detector.getTemplates", (char**)keywords, &pyobj_class_id, &template_id) &&
        pyopencv_to(pyobj_class_id, class_id, ArgInfo("class_id", 0)) )
    {
        ERRWRAP2(retval = _self_->getTemplates(class_id, template_id));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_match(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    {
    PyObject* pyobj_sources = NULL;
    vector_Mat sources;
    float threshold=0.f;
    vector_Match matches;
    PyObject* pyobj_class_ids = NULL;
    vector_String class_ids=std::vector<String>();
    PyObject* pyobj_quantized_images = NULL;
    vector_Mat quantized_images;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks=std::vector<Mat>();

    const char* keywords[] = { "sources", "threshold", "class_ids", "quantized_images", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Of|OOO:linemod_Detector.match", (char**)keywords, &pyobj_sources, &threshold, &pyobj_class_ids, &pyobj_quantized_images, &pyobj_masks) &&
        pyopencv_to(pyobj_sources, sources, ArgInfo("sources", 0)) &&
        pyopencv_to(pyobj_class_ids, class_ids, ArgInfo("class_ids", 0)) &&
        pyopencv_to(pyobj_quantized_images, quantized_images, ArgInfo("quantized_images", 1)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->match(sources, threshold, matches, class_ids, quantized_images, masks));
        return Py_BuildValue("(NN)", pyopencv_from(matches), pyopencv_from(quantized_images));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_sources = NULL;
    vector_Mat sources;
    float threshold=0.f;
    vector_Match matches;
    PyObject* pyobj_class_ids = NULL;
    vector_String class_ids=std::vector<String>();
    PyObject* pyobj_quantized_images = NULL;
    vector_Mat quantized_images;
    PyObject* pyobj_masks = NULL;
    vector_Mat masks=std::vector<Mat>();

    const char* keywords[] = { "sources", "threshold", "class_ids", "quantized_images", "masks", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Of|OOO:linemod_Detector.match", (char**)keywords, &pyobj_sources, &threshold, &pyobj_class_ids, &pyobj_quantized_images, &pyobj_masks) &&
        pyopencv_to(pyobj_sources, sources, ArgInfo("sources", 0)) &&
        pyopencv_to(pyobj_class_ids, class_ids, ArgInfo("class_ids", 0)) &&
        pyopencv_to(pyobj_quantized_images, quantized_images, ArgInfo("quantized_images", 1)) &&
        pyopencv_to(pyobj_masks, masks, ArgInfo("masks", 0)) )
    {
        ERRWRAP2(_self_->match(sources, threshold, matches, class_ids, quantized_images, masks));
        return Py_BuildValue("(NN)", pyopencv_from(matches), pyopencv_from(quantized_images));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_numClasses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->numClasses());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_numTemplates(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    {
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->numTemplates());
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_class_id = NULL;
    String class_id;
    int retval;

    const char* keywords[] = { "class_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:linemod_Detector.numTemplates", (char**)keywords, &pyobj_class_id) &&
        pyopencv_to(pyobj_class_id, class_id, ArgInfo("class_id", 0)) )
    {
        ERRWRAP2(retval = _self_->numTemplates(class_id));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_pyramidLevels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->pyramidLevels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    PyObject* pyobj_fn = NULL;
    FileNode fn;

    const char* keywords[] = { "fn", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:linemod_Detector.read", (char**)keywords, &pyobj_fn) &&
        pyopencv_to(pyobj_fn, fn, ArgInfo("fn", 0)) )
    {
        ERRWRAP2(_self_->read(fn));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_readClasses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    PyObject* pyobj_class_ids = NULL;
    vector_String class_ids;
    PyObject* pyobj_format = NULL;
    String format="templates_%s.yml.gz";

    const char* keywords[] = { "class_ids", "format", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:linemod_Detector.readClasses", (char**)keywords, &pyobj_class_ids, &pyobj_format) &&
        pyopencv_to(pyobj_class_ids, class_ids, ArgInfo("class_ids", 0)) &&
        pyopencv_to(pyobj_format, format, ArgInfo("format", 0)) )
    {
        ERRWRAP2(_self_->readClasses(class_ids, format));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Detector_writeClasses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Detector> * self1 = 0;
    if (!pyopencv_linemod_Detector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Detector' or its derivative)");
    Ptr<cv::linemod::Detector> _self_ = *(self1);
    PyObject* pyobj_format = NULL;
    String format="templates_%s.yml.gz";

    const char* keywords[] = { "format", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:linemod_Detector.writeClasses", (char**)keywords, &pyobj_format) &&
        pyopencv_to(pyobj_format, format, ArgInfo("format", 0)) )
    {
        ERRWRAP2(_self_->writeClasses(format));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (linemod_Detector)

static PyGetSetDef pyopencv_linemod_Detector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_linemod_Detector_methods[] =
{
    {"addSyntheticTemplate", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_addSyntheticTemplate, 0), "addSyntheticTemplate(templates, class_id) -> retval\n.   * \\brief Add a new object template computed by external means."},
    {"addTemplate", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_addTemplate, 0), "addTemplate(sources, class_id, object_mask) -> retval, bounding_box\n.   * \\brief Add new object template.\n.      *\n.      * \\param      sources      Source images, one for each modality.\n.      * \\param      class_id     Object class ID.\n.      * \\param      object_mask  Mask separating object from background.\n.      * \\param[out] bounding_box Optionally return bounding box of the extracted features.\n.      *\n.      * \\return Template ID, or -1 if failed to extract a valid template."},
    {"classIds", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_classIds, 0), "classIds() -> retval\n."},
    {"getModalities", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_getModalities, 0), "getModalities() -> retval\n.   * \\brief Get the modalities used by this detector.\n.      *\n.      * You are not permitted to add/remove modalities, but you may dynamic_cast them to\n.      * tweak parameters."},
    {"getT", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_getT, 0), "getT(pyramid_level) -> retval\n.   * \\brief Get sampling step T at pyramid_level."},
    {"getTemplates", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_getTemplates, 0), "getTemplates(class_id, template_id) -> retval\n.   * \\brief Get the template pyramid identified by template_id.\n.      *\n.      * For example, with 2 modalities (Gradient, Normal) and two pyramid levels\n.      * (L0, L1), the order is (GradientL0, NormalL0, GradientL1, NormalL1)."},
    {"match", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_match, 0), "match(sources, threshold[, class_ids[, quantized_images[, masks]]]) -> matches, quantized_images\n.   * \\brief Detect objects by template matching.\n.      *\n.      * Matches globally at the lowest pyramid level, then refines locally stepping up the pyramid.\n.      *\n.      * \\param      sources   Source images, one for each modality.\n.      * \\param      threshold Similarity threshold, a percentage between 0 and 100.\n.      * \\param[out] matches   Template matches, sorted by similarity score.\n.      * \\param      class_ids If non-empty, only search for the desired object classes.\n.      * \\param[out] quantized_images Optionally return vector<Mat> of quantized images.\n.      * \\param      masks     The masks for consideration during matching. The masks should be CV_8UC1\n.      *                       where 255 represents a valid pixel.  If non-empty, the vector must be\n.      *                       the same size as sources.  Each element must be\n.      *                       empty or the same size as its corresponding source."},
    {"numClasses", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_numClasses, 0), "numClasses() -> retval\n."},
    {"numTemplates", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_numTemplates, 0), "numTemplates() -> retval\n.   \n\n\n\nnumTemplates(class_id) -> retval\n."},
    {"pyramidLevels", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_pyramidLevels, 0), "pyramidLevels() -> retval\n.   * \\brief Get number of pyramid levels used by this detector."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_read, 0), "read(fn) -> None\n."},
    {"readClasses", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_readClasses, 0), "readClasses(class_ids[, format]) -> None\n."},
    {"writeClasses", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Detector_writeClasses, 0), "writeClasses([, format]) -> None\n."},

    {NULL,          NULL}
};

// Converter (linemod_Detector)

template<>
struct PyOpenCV_Converter< Ptr<cv::linemod::Detector> >
{
    static PyObject* from(const Ptr<cv::linemod::Detector>& r)
    {
        return pyopencv_linemod_Detector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::linemod::Detector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::linemod::Detector> * dst_;
        if (pyopencv_linemod_Detector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::linemod::Detector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// linemod_Feature (Generic)
//================================================================================

// GetSet (linemod_Feature)


static PyObject* pyopencv_linemod_Feature_get_label(pyopencv_linemod_Feature_t* p, void *closure)
{
    return pyopencv_from(p->v.label);
}

static int pyopencv_linemod_Feature_set_label(pyopencv_linemod_Feature_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the label attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.label) ? 0 : -1;
}

static PyObject* pyopencv_linemod_Feature_get_x(pyopencv_linemod_Feature_t* p, void *closure)
{
    return pyopencv_from(p->v.x);
}

static int pyopencv_linemod_Feature_set_x(pyopencv_linemod_Feature_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the x attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.x) ? 0 : -1;
}

static PyObject* pyopencv_linemod_Feature_get_y(pyopencv_linemod_Feature_t* p, void *closure)
{
    return pyopencv_from(p->v.y);
}

static int pyopencv_linemod_Feature_set_y(pyopencv_linemod_Feature_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the y attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.y) ? 0 : -1;
}


// Methods (linemod_Feature)

static int pyopencv_cv_linemod_linemod_Feature_Feature(pyopencv_linemod_Feature_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::linemod::Feature());
        return 0;
    }
    }
    PyErr_Clear();

    {
    int x=0;
    int y=0;
    int label=0;

    const char* keywords[] = { "x", "y", "label", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iii:Feature", (char**)keywords, &x, &y, &label) )
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::linemod::Feature(x, y, label));
        return 0;
    }
    }

    return -1;
}



// Tables (linemod_Feature)

static PyGetSetDef pyopencv_linemod_Feature_getseters[] =
{
    {(char*)"label", (getter)pyopencv_linemod_Feature_get_label, (setter)pyopencv_linemod_Feature_set_label, (char*)"label", NULL},
    {(char*)"x", (getter)pyopencv_linemod_Feature_get_x, (setter)pyopencv_linemod_Feature_set_x, (char*)"x", NULL},
    {(char*)"y", (getter)pyopencv_linemod_Feature_get_y, (setter)pyopencv_linemod_Feature_set_y, (char*)"y", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_linemod_Feature_methods[] =
{

    {NULL,          NULL}
};

// Converter (linemod_Feature)

template<>
struct PyOpenCV_Converter< cv::linemod::Feature >
{
    static PyObject* from(const cv::linemod::Feature& r)
    {
        return pyopencv_linemod_Feature_Instance(r);
    }
    static bool to(PyObject* src, cv::linemod::Feature& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::linemod::Feature * dst_;
        if (pyopencv_linemod_Feature_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::linemod::Feature for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// linemod_Match (Generic)
//================================================================================

// GetSet (linemod_Match)


static PyObject* pyopencv_linemod_Match_get_class_id(pyopencv_linemod_Match_t* p, void *closure)
{
    return pyopencv_from(p->v.class_id);
}

static int pyopencv_linemod_Match_set_class_id(pyopencv_linemod_Match_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the class_id attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.class_id) ? 0 : -1;
}

static PyObject* pyopencv_linemod_Match_get_similarity(pyopencv_linemod_Match_t* p, void *closure)
{
    return pyopencv_from(p->v.similarity);
}

static int pyopencv_linemod_Match_set_similarity(pyopencv_linemod_Match_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the similarity attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.similarity) ? 0 : -1;
}

static PyObject* pyopencv_linemod_Match_get_template_id(pyopencv_linemod_Match_t* p, void *closure)
{
    return pyopencv_from(p->v.template_id);
}

static int pyopencv_linemod_Match_set_template_id(pyopencv_linemod_Match_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the template_id attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.template_id) ? 0 : -1;
}

static PyObject* pyopencv_linemod_Match_get_x(pyopencv_linemod_Match_t* p, void *closure)
{
    return pyopencv_from(p->v.x);
}

static int pyopencv_linemod_Match_set_x(pyopencv_linemod_Match_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the x attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.x) ? 0 : -1;
}

static PyObject* pyopencv_linemod_Match_get_y(pyopencv_linemod_Match_t* p, void *closure)
{
    return pyopencv_from(p->v.y);
}

static int pyopencv_linemod_Match_set_y(pyopencv_linemod_Match_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the y attribute");
        return -1;
    }
    return pyopencv_to(value, p->v.y) ? 0 : -1;
}


// Methods (linemod_Match)

static int pyopencv_cv_linemod_linemod_Match_Match(pyopencv_linemod_Match_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::linemod::Match());
        return 0;
    }
    }
    PyErr_Clear();

    {
    int x=0;
    int y=0;
    float similarity=0.f;
    PyObject* pyobj_class_id = NULL;
    String class_id;
    int template_id=0;

    const char* keywords[] = { "x", "y", "similarity", "class_id", "template_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iifOi:Match", (char**)keywords, &x, &y, &similarity, &pyobj_class_id, &template_id) &&
        pyopencv_to(pyobj_class_id, class_id, ArgInfo("class_id", 0)) )
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::linemod::Match(x, y, similarity, class_id, template_id));
        return 0;
    }
    }

    return -1;
}



// Tables (linemod_Match)

static PyGetSetDef pyopencv_linemod_Match_getseters[] =
{
    {(char*)"class_id", (getter)pyopencv_linemod_Match_get_class_id, (setter)pyopencv_linemod_Match_set_class_id, (char*)"class_id", NULL},
    {(char*)"similarity", (getter)pyopencv_linemod_Match_get_similarity, (setter)pyopencv_linemod_Match_set_similarity, (char*)"similarity", NULL},
    {(char*)"template_id", (getter)pyopencv_linemod_Match_get_template_id, (setter)pyopencv_linemod_Match_set_template_id, (char*)"template_id", NULL},
    {(char*)"x", (getter)pyopencv_linemod_Match_get_x, (setter)pyopencv_linemod_Match_set_x, (char*)"x", NULL},
    {(char*)"y", (getter)pyopencv_linemod_Match_get_y, (setter)pyopencv_linemod_Match_set_y, (char*)"y", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_linemod_Match_methods[] =
{

    {NULL,          NULL}
};

// Converter (linemod_Match)

template<>
struct PyOpenCV_Converter< cv::linemod::Match >
{
    static PyObject* from(const cv::linemod::Match& r)
    {
        return pyopencv_linemod_Match_Instance(r);
    }
    static bool to(PyObject* src, cv::linemod::Match& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::linemod::Match * dst_;
        if (pyopencv_linemod_Match_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::linemod::Match for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// linemod_Modality (Generic)
//================================================================================

// GetSet (linemod_Modality)



// Methods (linemod_Modality)

static PyObject* pyopencv_cv_linemod_linemod_Modality_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;

    {
    PyObject* pyobj_modality_type = NULL;
    String modality_type;
    Ptr<Modality> retval;

    const char* keywords[] = { "modality_type", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:linemod_Modality.create", (char**)keywords, &pyobj_modality_type) &&
        pyopencv_to(pyobj_modality_type, modality_type, ArgInfo("modality_type", 0)) )
    {
        ERRWRAP2(retval = cv::linemod::Modality::create(modality_type));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_fn = NULL;
    FileNode fn;
    Ptr<Modality> retval;

    const char* keywords[] = { "fn", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:linemod_Modality.create", (char**)keywords, &pyobj_fn) &&
        pyopencv_to(pyobj_fn, fn, ArgInfo("fn", 0)) )
    {
        ERRWRAP2(retval = cv::linemod::Modality::create(fn));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Modality_name(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Modality> * self1 = 0;
    if (!pyopencv_linemod_Modality_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Modality' or its derivative)");
    Ptr<cv::linemod::Modality> _self_ = *(self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->name());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Modality_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Modality> * self1 = 0;
    if (!pyopencv_linemod_Modality_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Modality' or its derivative)");
    Ptr<cv::linemod::Modality> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    Ptr<QuantizedPyramid> retval;

    const char* keywords[] = { "src", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:linemod_Modality.process", (char**)keywords, &pyobj_src, &pyobj_mask) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->process(src, mask));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    Ptr<QuantizedPyramid> retval;

    const char* keywords[] = { "src", "mask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:linemod_Modality.process", (char**)keywords, &pyobj_src, &pyobj_mask) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->process(src, mask));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_Modality_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::Modality> * self1 = 0;
    if (!pyopencv_linemod_Modality_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_Modality' or its derivative)");
    Ptr<cv::linemod::Modality> _self_ = *(self1);
    PyObject* pyobj_fn = NULL;
    FileNode fn;

    const char* keywords[] = { "fn", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:linemod_Modality.read", (char**)keywords, &pyobj_fn) &&
        pyopencv_to(pyobj_fn, fn, ArgInfo("fn", 0)) )
    {
        ERRWRAP2(_self_->read(fn));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (linemod_Modality)

static PyGetSetDef pyopencv_linemod_Modality_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_linemod_Modality_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Modality_create_static, METH_STATIC), "create(modality_type) -> retval\n.   * \\brief Create modality by name.\n.      *\n.      * The following modality types are supported:\n.      * - \"ColorGradient\"\n.      * - \"DepthNormal\"\n\n\n\ncreate(fn) -> retval\n.   * \\brief Load a modality from file."},
    {"name", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Modality_name, 0), "name() -> retval\n."},
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Modality_process, 0), "process(src[, mask]) -> retval\n.   * \\brief Form a quantized image pyramid from a source image.\n.      *\n.      * \\param[in] src  The source image. Type depends on the modality.\n.      * \\param[in] mask Optional mask. If not empty, unmasked pixels are set to zero\n.      *                 in quantized image and cannot be extracted as features."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_Modality_read, 0), "read(fn) -> None\n."},

    {NULL,          NULL}
};

// Converter (linemod_Modality)

template<>
struct PyOpenCV_Converter< Ptr<cv::linemod::Modality> >
{
    static PyObject* from(const Ptr<cv::linemod::Modality>& r)
    {
        return pyopencv_linemod_Modality_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::linemod::Modality>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::linemod::Modality> * dst_;
        if (pyopencv_linemod_Modality_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::linemod::Modality> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// linemod_QuantizedPyramid (Generic)
//================================================================================

// GetSet (linemod_QuantizedPyramid)



// Methods (linemod_QuantizedPyramid)

static PyObject* pyopencv_cv_linemod_linemod_QuantizedPyramid_extractTemplate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::QuantizedPyramid> * self1 = 0;
    if (!pyopencv_linemod_QuantizedPyramid_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_QuantizedPyramid' or its derivative)");
    Ptr<cv::linemod::QuantizedPyramid> _self_ = *(self1);
    Template templ;
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->extractTemplate(templ));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(templ));
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_QuantizedPyramid_pyrDown(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::QuantizedPyramid> * self1 = 0;
    if (!pyopencv_linemod_QuantizedPyramid_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_QuantizedPyramid' or its derivative)");
    Ptr<cv::linemod::QuantizedPyramid> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->pyrDown());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_linemod_linemod_QuantizedPyramid_quantize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::linemod;


    Ptr<cv::linemod::QuantizedPyramid> * self1 = 0;
    if (!pyopencv_linemod_QuantizedPyramid_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'linemod_QuantizedPyramid' or its derivative)");
    Ptr<cv::linemod::QuantizedPyramid> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:linemod_QuantizedPyramid.quantize", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->quantize(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:linemod_QuantizedPyramid.quantize", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->quantize(dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (linemod_QuantizedPyramid)

static PyGetSetDef pyopencv_linemod_QuantizedPyramid_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_linemod_QuantizedPyramid_methods[] =
{
    {"extractTemplate", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_QuantizedPyramid_extractTemplate, 0), "extractTemplate() -> retval, templ\n.   * \\brief Extract most discriminant features at current pyramid level to form a new template.\n.      *\n.      * \\param[out] templ The new template."},
    {"pyrDown", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_QuantizedPyramid_pyrDown, 0), "pyrDown() -> None\n.   * \\brief Go to the next pyramid level.\n.      *\n.      * \\todo Allow pyramid scale factor other than 2"},
    {"quantize", CV_PY_FN_WITH_KW_(pyopencv_cv_linemod_linemod_QuantizedPyramid_quantize, 0), "quantize([, dst]) -> dst\n.   * \\brief Compute quantized image at current pyramid level for online detection.\n.      *\n.      * \\param[out] dst The destination 8-bit image. For each pixel at most one bit is set,\n.      *                 representing its classification."},

    {NULL,          NULL}
};

// Converter (linemod_QuantizedPyramid)

template<>
struct PyOpenCV_Converter< Ptr<cv::linemod::QuantizedPyramid> >
{
    static PyObject* from(const Ptr<cv::linemod::QuantizedPyramid>& r)
    {
        return pyopencv_linemod_QuantizedPyramid_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::linemod::QuantizedPyramid>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::linemod::QuantizedPyramid> * dst_;
        if (pyopencv_linemod_QuantizedPyramid_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::linemod::QuantizedPyramid> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// linemod_Template (Generic)
//================================================================================

// GetSet (linemod_Template)


static PyObject* pyopencv_linemod_Template_get_features(pyopencv_linemod_Template_t* p, void *closure)
{
    return pyopencv_from(p->v.features);
}

static PyObject* pyopencv_linemod_Template_get_height(pyopencv_linemod_Template_t* p, void *closure)
{
    return pyopencv_from(p->v.height);
}

static PyObject* pyopencv_linemod_Template_get_pyramid_level(pyopencv_linemod_Template_t* p, void *closure)
{
    return pyopencv_from(p->v.pyramid_level);
}

static PyObject* pyopencv_linemod_Template_get_width(pyopencv_linemod_Template_t* p, void *closure)
{
    return pyopencv_from(p->v.width);
}


// Methods (linemod_Template)



// Tables (linemod_Template)

static PyGetSetDef pyopencv_linemod_Template_getseters[] =
{
    {(char*)"features", (getter)pyopencv_linemod_Template_get_features, NULL, (char*)"features", NULL},
    {(char*)"height", (getter)pyopencv_linemod_Template_get_height, NULL, (char*)"height", NULL},
    {(char*)"pyramid_level", (getter)pyopencv_linemod_Template_get_pyramid_level, NULL, (char*)"pyramid_level", NULL},
    {(char*)"width", (getter)pyopencv_linemod_Template_get_width, NULL, (char*)"width", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_linemod_Template_methods[] =
{

    {NULL,          NULL}
};

// Converter (linemod_Template)

template<>
struct PyOpenCV_Converter< cv::linemod::Template >
{
    static PyObject* from(const cv::linemod::Template& r)
    {
        return pyopencv_linemod_Template_Instance(r);
    }
    static bool to(PyObject* src, cv::linemod::Template& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::linemod::Template * dst_;
        if (pyopencv_linemod_Template_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::linemod::Template for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_ANN_MLP (Generic)
//================================================================================

// GetSet (ml_ANN_MLP)



// Methods (ml_ANN_MLP)

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<ANN_MLP> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::ANN_MLP::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getAnnealCoolingRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAnnealCoolingRatio());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getAnnealFinalT(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAnnealFinalT());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getAnnealInitialT(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAnnealInitialT());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getAnnealItePerStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAnnealItePerStep());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getBackpropMomentumScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBackpropMomentumScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getBackpropWeightScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBackpropWeightScale());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getLayerSizes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLayerSizes());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getRpropDW0(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRpropDW0());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getRpropDWMax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRpropDWMax());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getRpropDWMin(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRpropDWMin());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getRpropDWMinus(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRpropDWMinus());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getRpropDWPlus(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRpropDWPlus());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    TermCriteria retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTermCriteria());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getTrainMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTrainMethod());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_getWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int layerIdx=0;
    Mat retval;

    const char* keywords[] = { "layerIdx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_ANN_MLP.getWeights", (char**)keywords, &layerIdx) )
    {
        ERRWRAP2(retval = _self_->getWeights(layerIdx));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    Ptr<ANN_MLP> retval;

    const char* keywords[] = { "filepath", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_ANN_MLP.load", (char**)keywords, &pyobj_filepath) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) )
    {
        ERRWRAP2(retval = cv::ml::ANN_MLP::load(filepath));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setActivationFunction(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int type=0;
    double param1=0;
    double param2=0;

    const char* keywords[] = { "type", "param1", "param2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|dd:ml_ANN_MLP.setActivationFunction", (char**)keywords, &type, &param1, &param2) )
    {
        ERRWRAP2(_self_->setActivationFunction(type, param1, param2));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setAnnealCoolingRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setAnnealCoolingRatio", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setAnnealCoolingRatio(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setAnnealFinalT(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setAnnealFinalT", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setAnnealFinalT(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setAnnealInitialT(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setAnnealInitialT", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setAnnealInitialT(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setAnnealItePerStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_ANN_MLP.setAnnealItePerStep", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setAnnealItePerStep(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setBackpropMomentumScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setBackpropMomentumScale", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setBackpropMomentumScale(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setBackpropWeightScale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setBackpropWeightScale", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setBackpropWeightScale(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setLayerSizes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    {
    PyObject* pyobj__layer_sizes = NULL;
    Mat _layer_sizes;

    const char* keywords[] = { "_layer_sizes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_ANN_MLP.setLayerSizes", (char**)keywords, &pyobj__layer_sizes) &&
        pyopencv_to(pyobj__layer_sizes, _layer_sizes, ArgInfo("_layer_sizes", 0)) )
    {
        ERRWRAP2(_self_->setLayerSizes(_layer_sizes));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__layer_sizes = NULL;
    UMat _layer_sizes;

    const char* keywords[] = { "_layer_sizes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_ANN_MLP.setLayerSizes", (char**)keywords, &pyobj__layer_sizes) &&
        pyopencv_to(pyobj__layer_sizes, _layer_sizes, ArgInfo("_layer_sizes", 0)) )
    {
        ERRWRAP2(_self_->setLayerSizes(_layer_sizes));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setRpropDW0(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setRpropDW0", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRpropDW0(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setRpropDWMax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setRpropDWMax", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRpropDWMax(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setRpropDWMin(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setRpropDWMin", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRpropDWMin(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setRpropDWMinus(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setRpropDWMinus", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRpropDWMinus(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setRpropDWPlus(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_ANN_MLP.setRpropDWPlus", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRpropDWPlus(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    TermCriteria val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_ANN_MLP.setTermCriteria", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setTermCriteria(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_ANN_MLP_setTrainMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::ANN_MLP> * self1 = 0;
    if (!pyopencv_ml_ANN_MLP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_ANN_MLP' or its derivative)");
    Ptr<cv::ml::ANN_MLP> _self_ = *(self1);
    int method=0;
    double param1=0;
    double param2=0;

    const char* keywords[] = { "method", "param1", "param2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|dd:ml_ANN_MLP.setTrainMethod", (char**)keywords, &method, &param1, &param2) )
    {
        ERRWRAP2(_self_->setTrainMethod(method, param1, param2));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ml_ANN_MLP)

static PyGetSetDef pyopencv_ml_ANN_MLP_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_ANN_MLP_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_create_static, METH_STATIC), "create() -> retval\n.   @brief Creates empty model\n.   \n.       Use StatModel::train to train the model, Algorithm::load\\<ANN_MLP\\>(filename) to load the pre-trained model.\n.       Note that the train method has optional flags: ANN_MLP::TrainFlags."},
    {"getAnnealCoolingRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getAnnealCoolingRatio, 0), "getAnnealCoolingRatio() -> retval\n.   @see setAnnealCoolingRatio"},
    {"getAnnealFinalT", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getAnnealFinalT, 0), "getAnnealFinalT() -> retval\n.   @see setAnnealFinalT"},
    {"getAnnealInitialT", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getAnnealInitialT, 0), "getAnnealInitialT() -> retval\n.   @see setAnnealInitialT"},
    {"getAnnealItePerStep", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getAnnealItePerStep, 0), "getAnnealItePerStep() -> retval\n.   @see setAnnealItePerStep"},
    {"getBackpropMomentumScale", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getBackpropMomentumScale, 0), "getBackpropMomentumScale() -> retval\n.   @see setBackpropMomentumScale"},
    {"getBackpropWeightScale", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getBackpropWeightScale, 0), "getBackpropWeightScale() -> retval\n.   @see setBackpropWeightScale"},
    {"getLayerSizes", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getLayerSizes, 0), "getLayerSizes() -> retval\n.   Integer vector specifying the number of neurons in each layer including the input and output layers.\n.       The very first element specifies the number of elements in the input layer.\n.       The last element - number of elements in the output layer.\n.   @sa setLayerSizes"},
    {"getRpropDW0", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getRpropDW0, 0), "getRpropDW0() -> retval\n.   @see setRpropDW0"},
    {"getRpropDWMax", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getRpropDWMax, 0), "getRpropDWMax() -> retval\n.   @see setRpropDWMax"},
    {"getRpropDWMin", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getRpropDWMin, 0), "getRpropDWMin() -> retval\n.   @see setRpropDWMin"},
    {"getRpropDWMinus", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getRpropDWMinus, 0), "getRpropDWMinus() -> retval\n.   @see setRpropDWMinus"},
    {"getRpropDWPlus", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getRpropDWPlus, 0), "getRpropDWPlus() -> retval\n.   @see setRpropDWPlus"},
    {"getTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getTermCriteria, 0), "getTermCriteria() -> retval\n.   @see setTermCriteria"},
    {"getTrainMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getTrainMethod, 0), "getTrainMethod() -> retval\n.   Returns current training method"},
    {"getWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_getWeights, 0), "getWeights(layerIdx) -> retval\n."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_load_static, METH_STATIC), "load(filepath) -> retval\n.   @brief Loads and creates a serialized ANN from a file\n.        *\n.        * Use ANN::save to serialize and store an ANN to disk.\n.        * Load the ANN from this file again, by calling this function with the path to the file.\n.        *\n.        * @param filepath path to serialized ANN"},
    {"setActivationFunction", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setActivationFunction, 0), "setActivationFunction(type[, param1[, param2]]) -> None\n.   Initialize the activation function for each neuron.\n.       Currently the default and the only fully supported activation function is ANN_MLP::SIGMOID_SYM.\n.       @param type The type of activation function. See ANN_MLP::ActivationFunctions.\n.       @param param1 The first parameter of the activation function, \\f$\\alpha\\f$. Default value is 0.\n.       @param param2 The second parameter of the activation function, \\f$\\beta\\f$. Default value is 0."},
    {"setAnnealCoolingRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setAnnealCoolingRatio, 0), "setAnnealCoolingRatio(val) -> None\n.   @copybrief getAnnealCoolingRatio @see getAnnealCoolingRatio"},
    {"setAnnealFinalT", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setAnnealFinalT, 0), "setAnnealFinalT(val) -> None\n.   @copybrief getAnnealFinalT @see getAnnealFinalT"},
    {"setAnnealInitialT", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setAnnealInitialT, 0), "setAnnealInitialT(val) -> None\n.   @copybrief getAnnealInitialT @see getAnnealInitialT"},
    {"setAnnealItePerStep", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setAnnealItePerStep, 0), "setAnnealItePerStep(val) -> None\n.   @copybrief getAnnealItePerStep @see getAnnealItePerStep"},
    {"setBackpropMomentumScale", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setBackpropMomentumScale, 0), "setBackpropMomentumScale(val) -> None\n.   @copybrief getBackpropMomentumScale @see getBackpropMomentumScale"},
    {"setBackpropWeightScale", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setBackpropWeightScale, 0), "setBackpropWeightScale(val) -> None\n.   @copybrief getBackpropWeightScale @see getBackpropWeightScale"},
    {"setLayerSizes", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setLayerSizes, 0), "setLayerSizes(_layer_sizes) -> None\n.   Integer vector specifying the number of neurons in each layer including the input and output layers.\n.       The very first element specifies the number of elements in the input layer.\n.       The last element - number of elements in the output layer. Default value is empty Mat.\n.   @sa getLayerSizes"},
    {"setRpropDW0", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setRpropDW0, 0), "setRpropDW0(val) -> None\n.   @copybrief getRpropDW0 @see getRpropDW0"},
    {"setRpropDWMax", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setRpropDWMax, 0), "setRpropDWMax(val) -> None\n.   @copybrief getRpropDWMax @see getRpropDWMax"},
    {"setRpropDWMin", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setRpropDWMin, 0), "setRpropDWMin(val) -> None\n.   @copybrief getRpropDWMin @see getRpropDWMin"},
    {"setRpropDWMinus", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setRpropDWMinus, 0), "setRpropDWMinus(val) -> None\n.   @copybrief getRpropDWMinus @see getRpropDWMinus"},
    {"setRpropDWPlus", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setRpropDWPlus, 0), "setRpropDWPlus(val) -> None\n.   @copybrief getRpropDWPlus @see getRpropDWPlus"},
    {"setTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setTermCriteria, 0), "setTermCriteria(val) -> None\n.   @copybrief getTermCriteria @see getTermCriteria"},
    {"setTrainMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ANN_MLP_setTrainMethod, 0), "setTrainMethod(method[, param1[, param2]]) -> None\n.   Sets training method and common parameters.\n.       @param method Default value is ANN_MLP::RPROP. See ANN_MLP::TrainingMethods.\n.       @param param1 passed to setRpropDW0 for ANN_MLP::RPROP and to setBackpropWeightScale for ANN_MLP::BACKPROP and to initialT for ANN_MLP::ANNEAL.\n.       @param param2 passed to setRpropDWMin for ANN_MLP::RPROP and to setBackpropMomentumScale for ANN_MLP::BACKPROP and to finalT for ANN_MLP::ANNEAL."},

    {NULL,          NULL}
};

// Converter (ml_ANN_MLP)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::ANN_MLP> >
{
    static PyObject* from(const Ptr<cv::ml::ANN_MLP>& r)
    {
        return pyopencv_ml_ANN_MLP_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::ANN_MLP>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::ANN_MLP> * dst_;
        if (pyopencv_ml_ANN_MLP_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::ANN_MLP> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_Boost (Generic)
//================================================================================

// GetSet (ml_Boost)



// Methods (ml_Boost)

static PyObject* pyopencv_cv_ml_ml_Boost_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<Boost> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::Boost::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_Boost_getBoostType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::Boost> * self1 = 0;
    if (!pyopencv_ml_Boost_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_Boost' or its derivative)");
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBoostType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_Boost_getWeakCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::Boost> * self1 = 0;
    if (!pyopencv_ml_Boost_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_Boost' or its derivative)");
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeakCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_Boost_getWeightTrimRate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::Boost> * self1 = 0;
    if (!pyopencv_ml_Boost_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_Boost' or its derivative)");
    Ptr<cv::ml::Boost> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeightTrimRate());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_Boost_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    PyObject* pyobj_nodeName = NULL;
    String nodeName;
    Ptr<Boost> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_Boost.load", (char**)keywords, &pyobj_filepath, &pyobj_nodeName) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        pyopencv_to(pyobj_nodeName, nodeName, ArgInfo("nodeName", 0)) )
    {
        ERRWRAP2(retval = cv::ml::Boost::load(filepath, nodeName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_Boost_setBoostType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::Boost> * self1 = 0;
    if (!pyopencv_ml_Boost_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_Boost' or its derivative)");
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_Boost.setBoostType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setBoostType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_Boost_setWeakCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::Boost> * self1 = 0;
    if (!pyopencv_ml_Boost_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_Boost' or its derivative)");
    Ptr<cv::ml::Boost> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_Boost.setWeakCount", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setWeakCount(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_Boost_setWeightTrimRate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::Boost> * self1 = 0;
    if (!pyopencv_ml_Boost_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_Boost' or its derivative)");
    Ptr<cv::ml::Boost> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_Boost.setWeightTrimRate", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setWeightTrimRate(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ml_Boost)

static PyGetSetDef pyopencv_ml_Boost_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_Boost_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_Boost_create_static, METH_STATIC), "create() -> retval\n.   Creates the empty model.\n.   Use StatModel::train to train the model, Algorithm::load\\<Boost\\>(filename) to load the pre-trained model."},
    {"getBoostType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_Boost_getBoostType, 0), "getBoostType() -> retval\n.   @see setBoostType"},
    {"getWeakCount", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_Boost_getWeakCount, 0), "getWeakCount() -> retval\n.   @see setWeakCount"},
    {"getWeightTrimRate", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_Boost_getWeightTrimRate, 0), "getWeightTrimRate() -> retval\n.   @see setWeightTrimRate"},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_Boost_load_static, METH_STATIC), "load(filepath[, nodeName]) -> retval\n.   @brief Loads and creates a serialized Boost from a file\n.        *\n.        * Use Boost::save to serialize and store an RTree to disk.\n.        * Load the Boost from this file again, by calling this function with the path to the file.\n.        * Optionally specify the node for the file containing the classifier\n.        *\n.        * @param filepath path to serialized Boost\n.        * @param nodeName name of node containing the classifier"},
    {"setBoostType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_Boost_setBoostType, 0), "setBoostType(val) -> None\n.   @copybrief getBoostType @see getBoostType"},
    {"setWeakCount", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_Boost_setWeakCount, 0), "setWeakCount(val) -> None\n.   @copybrief getWeakCount @see getWeakCount"},
    {"setWeightTrimRate", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_Boost_setWeightTrimRate, 0), "setWeightTrimRate(val) -> None\n.   @copybrief getWeightTrimRate @see getWeightTrimRate"},

    {NULL,          NULL}
};

// Converter (ml_Boost)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::Boost> >
{
    static PyObject* from(const Ptr<cv::ml::Boost>& r)
    {
        return pyopencv_ml_Boost_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::Boost>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::Boost> * dst_;
        if (pyopencv_ml_Boost_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::Boost> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_DTrees (Generic)
//================================================================================

// GetSet (ml_DTrees)



// Methods (ml_DTrees)

static PyObject* pyopencv_cv_ml_ml_DTrees_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<DTrees> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::DTrees::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getCVFolds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCVFolds());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getMaxCategories(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxCategories());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getMinSampleCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinSampleCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getPriors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getPriors());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getRegressionAccuracy(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRegressionAccuracy());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getTruncatePrunedTree(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTruncatePrunedTree());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getUse1SERule(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUse1SERule());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_getUseSurrogates(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseSurrogates());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    PyObject* pyobj_nodeName = NULL;
    String nodeName;
    Ptr<DTrees> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_DTrees.load", (char**)keywords, &pyobj_filepath, &pyobj_nodeName) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        pyopencv_to(pyobj_nodeName, nodeName, ArgInfo("nodeName", 0)) )
    {
        ERRWRAP2(retval = cv::ml::DTrees::load(filepath, nodeName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setCVFolds(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_DTrees.setCVFolds", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setCVFolds(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setMaxCategories(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_DTrees.setMaxCategories", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxCategories(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_DTrees.setMaxDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setMinSampleCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_DTrees.setMinSampleCount", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMinSampleCount(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setPriors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_DTrees.setPriors", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setPriors(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_DTrees.setPriors", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setPriors(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setRegressionAccuracy(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ml_DTrees.setRegressionAccuracy", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRegressionAccuracy(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setTruncatePrunedTree(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:ml_DTrees.setTruncatePrunedTree", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTruncatePrunedTree(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setUse1SERule(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:ml_DTrees.setUse1SERule", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUse1SERule(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_DTrees_setUseSurrogates(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::DTrees> * self1 = 0;
    if (!pyopencv_ml_DTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_DTrees' or its derivative)");
    Ptr<cv::ml::DTrees> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:ml_DTrees.setUseSurrogates", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUseSurrogates(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ml_DTrees)

static PyGetSetDef pyopencv_ml_DTrees_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_DTrees_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_create_static, METH_STATIC), "create() -> retval\n.   @brief Creates the empty model\n.   \n.       The static method creates empty decision tree with the specified parameters. It should be then\n.       trained using train method (see StatModel::train). Alternatively, you can load the model from\n.       file using Algorithm::load\\<DTrees\\>(filename)."},
    {"getCVFolds", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getCVFolds, 0), "getCVFolds() -> retval\n.   @see setCVFolds"},
    {"getMaxCategories", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getMaxCategories, 0), "getMaxCategories() -> retval\n.   @see setMaxCategories"},
    {"getMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getMaxDepth, 0), "getMaxDepth() -> retval\n.   @see setMaxDepth"},
    {"getMinSampleCount", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getMinSampleCount, 0), "getMinSampleCount() -> retval\n.   @see setMinSampleCount"},
    {"getPriors", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getPriors, 0), "getPriors() -> retval\n.   @see setPriors"},
    {"getRegressionAccuracy", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getRegressionAccuracy, 0), "getRegressionAccuracy() -> retval\n.   @see setRegressionAccuracy"},
    {"getTruncatePrunedTree", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getTruncatePrunedTree, 0), "getTruncatePrunedTree() -> retval\n.   @see setTruncatePrunedTree"},
    {"getUse1SERule", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getUse1SERule, 0), "getUse1SERule() -> retval\n.   @see setUse1SERule"},
    {"getUseSurrogates", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_getUseSurrogates, 0), "getUseSurrogates() -> retval\n.   @see setUseSurrogates"},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_load_static, METH_STATIC), "load(filepath[, nodeName]) -> retval\n.   @brief Loads and creates a serialized DTrees from a file\n.        *\n.        * Use DTree::save to serialize and store an DTree to disk.\n.        * Load the DTree from this file again, by calling this function with the path to the file.\n.        * Optionally specify the node for the file containing the classifier\n.        *\n.        * @param filepath path to serialized DTree\n.        * @param nodeName name of node containing the classifier"},
    {"setCVFolds", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setCVFolds, 0), "setCVFolds(val) -> None\n.   @copybrief getCVFolds @see getCVFolds"},
    {"setMaxCategories", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setMaxCategories, 0), "setMaxCategories(val) -> None\n.   @copybrief getMaxCategories @see getMaxCategories"},
    {"setMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setMaxDepth, 0), "setMaxDepth(val) -> None\n.   @copybrief getMaxDepth @see getMaxDepth"},
    {"setMinSampleCount", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setMinSampleCount, 0), "setMinSampleCount(val) -> None\n.   @copybrief getMinSampleCount @see getMinSampleCount"},
    {"setPriors", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setPriors, 0), "setPriors(val) -> None\n.   @copybrief getPriors @see getPriors"},
    {"setRegressionAccuracy", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setRegressionAccuracy, 0), "setRegressionAccuracy(val) -> None\n.   @copybrief getRegressionAccuracy @see getRegressionAccuracy"},
    {"setTruncatePrunedTree", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setTruncatePrunedTree, 0), "setTruncatePrunedTree(val) -> None\n.   @copybrief getTruncatePrunedTree @see getTruncatePrunedTree"},
    {"setUse1SERule", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setUse1SERule, 0), "setUse1SERule(val) -> None\n.   @copybrief getUse1SERule @see getUse1SERule"},
    {"setUseSurrogates", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_DTrees_setUseSurrogates, 0), "setUseSurrogates(val) -> None\n.   @copybrief getUseSurrogates @see getUseSurrogates"},

    {NULL,          NULL}
};

// Converter (ml_DTrees)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::DTrees> >
{
    static PyObject* from(const Ptr<cv::ml::DTrees>& r)
    {
        return pyopencv_ml_DTrees_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::DTrees>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::DTrees> * dst_;
        if (pyopencv_ml_DTrees_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::DTrees> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_EM (Generic)
//================================================================================

// GetSet (ml_EM)



// Methods (ml_EM)

static PyObject* pyopencv_cv_ml_ml_EM_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<EM> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::EM::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_getClustersNumber(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getClustersNumber());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_getCovarianceMatrixType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCovarianceMatrixType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_getCovs(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    {
    PyObject* pyobj_covs = NULL;
    vector_Mat covs;

    const char* keywords[] = { "covs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:ml_EM.getCovs", (char**)keywords, &pyobj_covs) &&
        pyopencv_to(pyobj_covs, covs, ArgInfo("covs", 1)) )
    {
        ERRWRAP2(_self_->getCovs(covs));
        return pyopencv_from(covs);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_covs = NULL;
    vector_Mat covs;

    const char* keywords[] = { "covs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:ml_EM.getCovs", (char**)keywords, &pyobj_covs) &&
        pyopencv_to(pyobj_covs, covs, ArgInfo("covs", 1)) )
    {
        ERRWRAP2(_self_->getCovs(covs));
        return pyopencv_from(covs);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_getMeans(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMeans());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_getTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    TermCriteria retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTermCriteria());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_getWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeights());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    PyObject* pyobj_nodeName = NULL;
    String nodeName;
    Ptr<EM> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_EM.load", (char**)keywords, &pyobj_filepath, &pyobj_nodeName) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        pyopencv_to(pyobj_nodeName, nodeName, ArgInfo("nodeName", 0)) )
    {
        ERRWRAP2(retval = cv::ml::EM::load(filepath, nodeName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_predict(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    PyObject* pyobj_results = NULL;
    Mat results;
    int flags=0;
    float retval;

    const char* keywords[] = { "samples", "results", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ml_EM.predict", (char**)keywords, &pyobj_samples, &pyobj_results, &flags) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) )
    {
        ERRWRAP2(retval = _self_->predict(samples, results, flags));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(results));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    PyObject* pyobj_results = NULL;
    UMat results;
    int flags=0;
    float retval;

    const char* keywords[] = { "samples", "results", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ml_EM.predict", (char**)keywords, &pyobj_samples, &pyobj_results, &flags) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) )
    {
        ERRWRAP2(retval = _self_->predict(samples, results, flags));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(results));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_predict2(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    {
    PyObject* pyobj_sample = NULL;
    Mat sample;
    PyObject* pyobj_probs = NULL;
    Mat probs;
    Vec2d retval;

    const char* keywords[] = { "sample", "probs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_EM.predict2", (char**)keywords, &pyobj_sample, &pyobj_probs) &&
        pyopencv_to(pyobj_sample, sample, ArgInfo("sample", 0)) &&
        pyopencv_to(pyobj_probs, probs, ArgInfo("probs", 1)) )
    {
        ERRWRAP2(retval = _self_->predict2(sample, probs));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(probs));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_sample = NULL;
    UMat sample;
    PyObject* pyobj_probs = NULL;
    UMat probs;
    Vec2d retval;

    const char* keywords[] = { "sample", "probs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_EM.predict2", (char**)keywords, &pyobj_sample, &pyobj_probs) &&
        pyopencv_to(pyobj_sample, sample, ArgInfo("sample", 0)) &&
        pyopencv_to(pyobj_probs, probs, ArgInfo("probs", 1)) )
    {
        ERRWRAP2(retval = _self_->predict2(sample, probs));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(probs));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_setClustersNumber(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_EM.setClustersNumber", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setClustersNumber(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_setCovarianceMatrixType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_EM.setCovarianceMatrixType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setCovarianceMatrixType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_setTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    TermCriteria val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_EM.setTermCriteria", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setTermCriteria(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_trainE(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    PyObject* pyobj_means0 = NULL;
    Mat means0;
    PyObject* pyobj_covs0 = NULL;
    Mat covs0;
    PyObject* pyobj_weights0 = NULL;
    Mat weights0;
    PyObject* pyobj_logLikelihoods = NULL;
    Mat logLikelihoods;
    PyObject* pyobj_labels = NULL;
    Mat labels;
    PyObject* pyobj_probs = NULL;
    Mat probs;
    bool retval;

    const char* keywords[] = { "samples", "means0", "covs0", "weights0", "logLikelihoods", "labels", "probs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OOOOO:ml_EM.trainE", (char**)keywords, &pyobj_samples, &pyobj_means0, &pyobj_covs0, &pyobj_weights0, &pyobj_logLikelihoods, &pyobj_labels, &pyobj_probs) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_means0, means0, ArgInfo("means0", 0)) &&
        pyopencv_to(pyobj_covs0, covs0, ArgInfo("covs0", 0)) &&
        pyopencv_to(pyobj_weights0, weights0, ArgInfo("weights0", 0)) &&
        pyopencv_to(pyobj_logLikelihoods, logLikelihoods, ArgInfo("logLikelihoods", 1)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 1)) &&
        pyopencv_to(pyobj_probs, probs, ArgInfo("probs", 1)) )
    {
        ERRWRAP2(retval = _self_->trainE(samples, means0, covs0, weights0, logLikelihoods, labels, probs));
        return Py_BuildValue("(NNNN)", pyopencv_from(retval), pyopencv_from(logLikelihoods), pyopencv_from(labels), pyopencv_from(probs));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    PyObject* pyobj_means0 = NULL;
    UMat means0;
    PyObject* pyobj_covs0 = NULL;
    UMat covs0;
    PyObject* pyobj_weights0 = NULL;
    UMat weights0;
    PyObject* pyobj_logLikelihoods = NULL;
    UMat logLikelihoods;
    PyObject* pyobj_labels = NULL;
    UMat labels;
    PyObject* pyobj_probs = NULL;
    UMat probs;
    bool retval;

    const char* keywords[] = { "samples", "means0", "covs0", "weights0", "logLikelihoods", "labels", "probs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OOOOO:ml_EM.trainE", (char**)keywords, &pyobj_samples, &pyobj_means0, &pyobj_covs0, &pyobj_weights0, &pyobj_logLikelihoods, &pyobj_labels, &pyobj_probs) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_means0, means0, ArgInfo("means0", 0)) &&
        pyopencv_to(pyobj_covs0, covs0, ArgInfo("covs0", 0)) &&
        pyopencv_to(pyobj_weights0, weights0, ArgInfo("weights0", 0)) &&
        pyopencv_to(pyobj_logLikelihoods, logLikelihoods, ArgInfo("logLikelihoods", 1)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 1)) &&
        pyopencv_to(pyobj_probs, probs, ArgInfo("probs", 1)) )
    {
        ERRWRAP2(retval = _self_->trainE(samples, means0, covs0, weights0, logLikelihoods, labels, probs));
        return Py_BuildValue("(NNNN)", pyopencv_from(retval), pyopencv_from(logLikelihoods), pyopencv_from(labels), pyopencv_from(probs));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_trainEM(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    PyObject* pyobj_logLikelihoods = NULL;
    Mat logLikelihoods;
    PyObject* pyobj_labels = NULL;
    Mat labels;
    PyObject* pyobj_probs = NULL;
    Mat probs;
    bool retval;

    const char* keywords[] = { "samples", "logLikelihoods", "labels", "probs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:ml_EM.trainEM", (char**)keywords, &pyobj_samples, &pyobj_logLikelihoods, &pyobj_labels, &pyobj_probs) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_logLikelihoods, logLikelihoods, ArgInfo("logLikelihoods", 1)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 1)) &&
        pyopencv_to(pyobj_probs, probs, ArgInfo("probs", 1)) )
    {
        ERRWRAP2(retval = _self_->trainEM(samples, logLikelihoods, labels, probs));
        return Py_BuildValue("(NNNN)", pyopencv_from(retval), pyopencv_from(logLikelihoods), pyopencv_from(labels), pyopencv_from(probs));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    PyObject* pyobj_logLikelihoods = NULL;
    UMat logLikelihoods;
    PyObject* pyobj_labels = NULL;
    UMat labels;
    PyObject* pyobj_probs = NULL;
    UMat probs;
    bool retval;

    const char* keywords[] = { "samples", "logLikelihoods", "labels", "probs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:ml_EM.trainEM", (char**)keywords, &pyobj_samples, &pyobj_logLikelihoods, &pyobj_labels, &pyobj_probs) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_logLikelihoods, logLikelihoods, ArgInfo("logLikelihoods", 1)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 1)) &&
        pyopencv_to(pyobj_probs, probs, ArgInfo("probs", 1)) )
    {
        ERRWRAP2(retval = _self_->trainEM(samples, logLikelihoods, labels, probs));
        return Py_BuildValue("(NNNN)", pyopencv_from(retval), pyopencv_from(logLikelihoods), pyopencv_from(labels), pyopencv_from(probs));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_EM_trainM(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::EM> * self1 = 0;
    if (!pyopencv_ml_EM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_EM' or its derivative)");
    Ptr<cv::ml::EM> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    PyObject* pyobj_probs0 = NULL;
    Mat probs0;
    PyObject* pyobj_logLikelihoods = NULL;
    Mat logLikelihoods;
    PyObject* pyobj_labels = NULL;
    Mat labels;
    PyObject* pyobj_probs = NULL;
    Mat probs;
    bool retval;

    const char* keywords[] = { "samples", "probs0", "logLikelihoods", "labels", "probs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OOO:ml_EM.trainM", (char**)keywords, &pyobj_samples, &pyobj_probs0, &pyobj_logLikelihoods, &pyobj_labels, &pyobj_probs) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_probs0, probs0, ArgInfo("probs0", 0)) &&
        pyopencv_to(pyobj_logLikelihoods, logLikelihoods, ArgInfo("logLikelihoods", 1)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 1)) &&
        pyopencv_to(pyobj_probs, probs, ArgInfo("probs", 1)) )
    {
        ERRWRAP2(retval = _self_->trainM(samples, probs0, logLikelihoods, labels, probs));
        return Py_BuildValue("(NNNN)", pyopencv_from(retval), pyopencv_from(logLikelihoods), pyopencv_from(labels), pyopencv_from(probs));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    PyObject* pyobj_probs0 = NULL;
    UMat probs0;
    PyObject* pyobj_logLikelihoods = NULL;
    UMat logLikelihoods;
    PyObject* pyobj_labels = NULL;
    UMat labels;
    PyObject* pyobj_probs = NULL;
    UMat probs;
    bool retval;

    const char* keywords[] = { "samples", "probs0", "logLikelihoods", "labels", "probs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OOO:ml_EM.trainM", (char**)keywords, &pyobj_samples, &pyobj_probs0, &pyobj_logLikelihoods, &pyobj_labels, &pyobj_probs) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_probs0, probs0, ArgInfo("probs0", 0)) &&
        pyopencv_to(pyobj_logLikelihoods, logLikelihoods, ArgInfo("logLikelihoods", 1)) &&
        pyopencv_to(pyobj_labels, labels, ArgInfo("labels", 1)) &&
        pyopencv_to(pyobj_probs, probs, ArgInfo("probs", 1)) )
    {
        ERRWRAP2(retval = _self_->trainM(samples, probs0, logLikelihoods, labels, probs));
        return Py_BuildValue("(NNNN)", pyopencv_from(retval), pyopencv_from(logLikelihoods), pyopencv_from(labels), pyopencv_from(probs));
    }
    }

    return NULL;
}



// Tables (ml_EM)

static PyGetSetDef pyopencv_ml_EM_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_EM_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_create_static, METH_STATIC), "create() -> retval\n.   Creates empty %EM model.\n.       The model should be trained then using StatModel::train(traindata, flags) method. Alternatively, you\n.       can use one of the EM::train\\* methods or load it from file using Algorithm::load\\<EM\\>(filename)."},
    {"getClustersNumber", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_getClustersNumber, 0), "getClustersNumber() -> retval\n.   @see setClustersNumber"},
    {"getCovarianceMatrixType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_getCovarianceMatrixType, 0), "getCovarianceMatrixType() -> retval\n.   @see setCovarianceMatrixType"},
    {"getCovs", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_getCovs, 0), "getCovs([, covs]) -> covs\n.   @brief Returns covariation matrices\n.   \n.       Returns vector of covariation matrices. Number of matrices is the number of gaussian mixtures,\n.       each matrix is a square floating-point matrix NxN, where N is the space dimensionality."},
    {"getMeans", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_getMeans, 0), "getMeans() -> retval\n.   @brief Returns the cluster centers (means of the Gaussian mixture)\n.   \n.       Returns matrix with the number of rows equal to the number of mixtures and number of columns\n.       equal to the space dimensionality."},
    {"getTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_getTermCriteria, 0), "getTermCriteria() -> retval\n.   @see setTermCriteria"},
    {"getWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_getWeights, 0), "getWeights() -> retval\n.   @brief Returns weights of the mixtures\n.   \n.       Returns vector with the number of elements equal to the number of mixtures."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_load_static, METH_STATIC), "load(filepath[, nodeName]) -> retval\n.   @brief Loads and creates a serialized EM from a file\n.        *\n.        * Use EM::save to serialize and store an EM to disk.\n.        * Load the EM from this file again, by calling this function with the path to the file.\n.        * Optionally specify the node for the file containing the classifier\n.        *\n.        * @param filepath path to serialized EM\n.        * @param nodeName name of node containing the classifier"},
    {"predict", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_predict, 0), "predict(samples[, results[, flags]]) -> retval, results\n.   @brief Returns posterior probabilities for the provided samples\n.   \n.       @param samples The input samples, floating-point matrix\n.       @param results The optional output \\f$ nSamples \\times nClusters\\f$ matrix of results. It contains\n.       posterior probabilities for each sample from the input\n.       @param flags This parameter will be ignored"},
    {"predict2", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_predict2, 0), "predict2(sample[, probs]) -> retval, probs\n.   @brief Returns a likelihood logarithm value and an index of the most probable mixture component\n.       for the given sample.\n.   \n.       @param sample A sample for classification. It should be a one-channel matrix of\n.           \\f$1 \\times dims\\f$ or \\f$dims \\times 1\\f$ size.\n.       @param probs Optional output matrix that contains posterior probabilities of each component\n.           given the sample. It has \\f$1 \\times nclusters\\f$ size and CV_64FC1 type.\n.   \n.       The method returns a two-element double vector. Zero element is a likelihood logarithm value for\n.       the sample. First element is an index of the most probable mixture component for the given\n.       sample."},
    {"setClustersNumber", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_setClustersNumber, 0), "setClustersNumber(val) -> None\n.   @copybrief getClustersNumber @see getClustersNumber"},
    {"setCovarianceMatrixType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_setCovarianceMatrixType, 0), "setCovarianceMatrixType(val) -> None\n.   @copybrief getCovarianceMatrixType @see getCovarianceMatrixType"},
    {"setTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_setTermCriteria, 0), "setTermCriteria(val) -> None\n.   @copybrief getTermCriteria @see getTermCriteria"},
    {"trainE", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_trainE, 0), "trainE(samples, means0[, covs0[, weights0[, logLikelihoods[, labels[, probs]]]]]) -> retval, logLikelihoods, labels, probs\n.   @brief Estimate the Gaussian mixture parameters from a samples set.\n.   \n.       This variation starts with Expectation step. You need to provide initial means \\f$a_k\\f$ of\n.       mixture components. Optionally you can pass initial weights \\f$\\pi_k\\f$ and covariance matrices\n.       \\f$S_k\\f$ of mixture components.\n.   \n.       @param samples Samples from which the Gaussian mixture model will be estimated. It should be a\n.           one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type\n.           it will be converted to the inner matrix of such type for the further computing.\n.       @param means0 Initial means \\f$a_k\\f$ of mixture components. It is a one-channel matrix of\n.           \\f$nclusters \\times dims\\f$ size. If the matrix does not have CV_64F type it will be\n.           converted to the inner matrix of such type for the further computing.\n.       @param covs0 The vector of initial covariance matrices \\f$S_k\\f$ of mixture components. Each of\n.           covariance matrices is a one-channel matrix of \\f$dims \\times dims\\f$ size. If the matrices\n.           do not have CV_64F type they will be converted to the inner matrices of such type for the\n.           further computing.\n.       @param weights0 Initial weights \\f$\\pi_k\\f$ of mixture components. It should be a one-channel\n.           floating-point matrix with \\f$1 \\times nclusters\\f$ or \\f$nclusters \\times 1\\f$ size.\n.       @param logLikelihoods The optional output matrix that contains a likelihood logarithm value for\n.           each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type.\n.       @param labels The optional output \"class label\" for each sample:\n.           \\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices of the most probable\n.           mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type.\n.       @param probs The optional output matrix that contains posterior probabilities of each Gaussian\n.           mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and\n.           CV_64FC1 type."},
    {"trainEM", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_trainEM, 0), "trainEM(samples[, logLikelihoods[, labels[, probs]]]) -> retval, logLikelihoods, labels, probs\n.   @brief Estimate the Gaussian mixture parameters from a samples set.\n.   \n.       This variation starts with Expectation step. Initial values of the model parameters will be\n.       estimated by the k-means algorithm.\n.   \n.       Unlike many of the ML models, %EM is an unsupervised learning algorithm and it does not take\n.       responses (class labels or function values) as input. Instead, it computes the *Maximum\n.       Likelihood Estimate* of the Gaussian mixture parameters from an input sample set, stores all the\n.       parameters inside the structure: \\f$p_{i,k}\\f$ in probs, \\f$a_k\\f$ in means , \\f$S_k\\f$ in\n.       covs[k], \\f$\\pi_k\\f$ in weights , and optionally computes the output \"class label\" for each\n.       sample: \\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices of the most\n.       probable mixture component for each sample).\n.   \n.       The trained model can be used further for prediction, just like any other classifier. The\n.       trained model is similar to the NormalBayesClassifier.\n.   \n.       @param samples Samples from which the Gaussian mixture model will be estimated. It should be a\n.           one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type\n.           it will be converted to the inner matrix of such type for the further computing.\n.       @param logLikelihoods The optional output matrix that contains a likelihood logarithm value for\n.           each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type.\n.       @param labels The optional output \"class label\" for each sample:\n.           \\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices of the most probable\n.           mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type.\n.       @param probs The optional output matrix that contains posterior probabilities of each Gaussian\n.           mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and\n.           CV_64FC1 type."},
    {"trainM", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_EM_trainM, 0), "trainM(samples, probs0[, logLikelihoods[, labels[, probs]]]) -> retval, logLikelihoods, labels, probs\n.   @brief Estimate the Gaussian mixture parameters from a samples set.\n.   \n.       This variation starts with Maximization step. You need to provide initial probabilities\n.       \\f$p_{i,k}\\f$ to use this option.\n.   \n.       @param samples Samples from which the Gaussian mixture model will be estimated. It should be a\n.           one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type\n.           it will be converted to the inner matrix of such type for the further computing.\n.       @param probs0 the probabilities\n.       @param logLikelihoods The optional output matrix that contains a likelihood logarithm value for\n.           each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type.\n.       @param labels The optional output \"class label\" for each sample:\n.           \\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices of the most probable\n.           mixture component for each sample). It has \\f$nsamples \\times 1\\f$ size and CV_32SC1 type.\n.       @param probs The optional output matrix that contains posterior probabilities of each Gaussian\n.           mixture component given the each sample. It has \\f$nsamples \\times nclusters\\f$ size and\n.           CV_64FC1 type."},

    {NULL,          NULL}
};

// Converter (ml_EM)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::EM> >
{
    static PyObject* from(const Ptr<cv::ml::EM>& r)
    {
        return pyopencv_ml_EM_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::EM>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::EM> * dst_;
        if (pyopencv_ml_EM_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::EM> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_KNearest (Generic)
//================================================================================

// GetSet (ml_KNearest)



// Methods (ml_KNearest)

static PyObject* pyopencv_cv_ml_ml_KNearest_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<KNearest> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::KNearest::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_findNearest(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    int k=0;
    PyObject* pyobj_results = NULL;
    Mat results;
    PyObject* pyobj_neighborResponses = NULL;
    Mat neighborResponses;
    PyObject* pyobj_dist = NULL;
    Mat dist;
    float retval;

    const char* keywords[] = { "samples", "k", "results", "neighborResponses", "dist", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|OOO:ml_KNearest.findNearest", (char**)keywords, &pyobj_samples, &k, &pyobj_results, &pyobj_neighborResponses, &pyobj_dist) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) &&
        pyopencv_to(pyobj_neighborResponses, neighborResponses, ArgInfo("neighborResponses", 1)) &&
        pyopencv_to(pyobj_dist, dist, ArgInfo("dist", 1)) )
    {
        ERRWRAP2(retval = _self_->findNearest(samples, k, results, neighborResponses, dist));
        return Py_BuildValue("(NNNN)", pyopencv_from(retval), pyopencv_from(results), pyopencv_from(neighborResponses), pyopencv_from(dist));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    int k=0;
    PyObject* pyobj_results = NULL;
    UMat results;
    PyObject* pyobj_neighborResponses = NULL;
    UMat neighborResponses;
    PyObject* pyobj_dist = NULL;
    UMat dist;
    float retval;

    const char* keywords[] = { "samples", "k", "results", "neighborResponses", "dist", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|OOO:ml_KNearest.findNearest", (char**)keywords, &pyobj_samples, &k, &pyobj_results, &pyobj_neighborResponses, &pyobj_dist) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) &&
        pyopencv_to(pyobj_neighborResponses, neighborResponses, ArgInfo("neighborResponses", 1)) &&
        pyopencv_to(pyobj_dist, dist, ArgInfo("dist", 1)) )
    {
        ERRWRAP2(retval = _self_->findNearest(samples, k, results, neighborResponses, dist));
        return Py_BuildValue("(NNNN)", pyopencv_from(retval), pyopencv_from(results), pyopencv_from(neighborResponses), pyopencv_from(dist));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_getAlgorithmType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAlgorithmType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_getDefaultK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultK());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_getEmax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEmax());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_getIsClassifier(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIsClassifier());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    Ptr<KNearest> retval;

    const char* keywords[] = { "filepath", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_KNearest.load", (char**)keywords, &pyobj_filepath) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) )
    {
        ERRWRAP2(retval = cv::ml::KNearest::load(filepath));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_setAlgorithmType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_KNearest.setAlgorithmType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setAlgorithmType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_setDefaultK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_KNearest.setDefaultK", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setDefaultK(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_setEmax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_KNearest.setEmax", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setEmax(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_KNearest_setIsClassifier(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::KNearest> * self1 = 0;
    if (!pyopencv_ml_KNearest_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_KNearest' or its derivative)");
    Ptr<cv::ml::KNearest> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:ml_KNearest.setIsClassifier", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setIsClassifier(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ml_KNearest)

static PyGetSetDef pyopencv_ml_KNearest_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_KNearest_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_create_static, METH_STATIC), "create() -> retval\n.   @brief Creates the empty model\n.   \n.       The static method creates empty %KNearest classifier. It should be then trained using StatModel::train method."},
    {"findNearest", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_findNearest, 0), "findNearest(samples, k[, results[, neighborResponses[, dist]]]) -> retval, results, neighborResponses, dist\n.   @brief Finds the neighbors and predicts responses for input vectors.\n.   \n.       @param samples Input samples stored by rows. It is a single-precision floating-point matrix of\n.           `<number_of_samples> * k` size.\n.       @param k Number of used nearest neighbors. Should be greater than 1.\n.       @param results Vector with results of prediction (regression or classification) for each input\n.           sample. It is a single-precision floating-point vector with `<number_of_samples>` elements.\n.       @param neighborResponses Optional output values for corresponding neighbors. It is a single-\n.           precision floating-point matrix of `<number_of_samples> * k` size.\n.       @param dist Optional output distances from the input vectors to the corresponding neighbors. It\n.           is a single-precision floating-point matrix of `<number_of_samples> * k` size.\n.   \n.       For each input vector (a row of the matrix samples), the method finds the k nearest neighbors.\n.       In case of regression, the predicted result is a mean value of the particular vector's neighbor\n.       responses. In case of classification, the class is determined by voting.\n.   \n.       For each input vector, the neighbors are sorted by their distances to the vector.\n.   \n.       In case of C++ interface you can use output pointers to empty matrices and the function will\n.       allocate memory itself.\n.   \n.       If only a single input vector is passed, all output matrices are optional and the predicted\n.       value is returned by the method.\n.   \n.       The function is parallelized with the TBB library."},
    {"getAlgorithmType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_getAlgorithmType, 0), "getAlgorithmType() -> retval\n.   @see setAlgorithmType"},
    {"getDefaultK", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_getDefaultK, 0), "getDefaultK() -> retval\n.   @see setDefaultK"},
    {"getEmax", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_getEmax, 0), "getEmax() -> retval\n.   @see setEmax"},
    {"getIsClassifier", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_getIsClassifier, 0), "getIsClassifier() -> retval\n.   @see setIsClassifier"},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_load_static, METH_STATIC), "load(filepath) -> retval\n.   @brief Loads and creates a serialized knearest from a file\n.        *\n.        * Use KNearest::save to serialize and store an KNearest to disk.\n.        * Load the KNearest from this file again, by calling this function with the path to the file.\n.        *\n.        * @param filepath path to serialized KNearest"},
    {"setAlgorithmType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_setAlgorithmType, 0), "setAlgorithmType(val) -> None\n.   @copybrief getAlgorithmType @see getAlgorithmType"},
    {"setDefaultK", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_setDefaultK, 0), "setDefaultK(val) -> None\n.   @copybrief getDefaultK @see getDefaultK"},
    {"setEmax", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_setEmax, 0), "setEmax(val) -> None\n.   @copybrief getEmax @see getEmax"},
    {"setIsClassifier", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_KNearest_setIsClassifier, 0), "setIsClassifier(val) -> None\n.   @copybrief getIsClassifier @see getIsClassifier"},

    {NULL,          NULL}
};

// Converter (ml_KNearest)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::KNearest> >
{
    static PyObject* from(const Ptr<cv::ml::KNearest>& r)
    {
        return pyopencv_ml_KNearest_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::KNearest>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::KNearest> * dst_;
        if (pyopencv_ml_KNearest_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::KNearest> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_LogisticRegression (Generic)
//================================================================================

// GetSet (ml_LogisticRegression)



// Methods (ml_LogisticRegression)

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<LogisticRegression> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::LogisticRegression::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_getIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_getLearningRate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLearningRate());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_getMiniBatchSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMiniBatchSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_getRegularization(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRegularization());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_getTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    TermCriteria retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTermCriteria());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_getTrainMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTrainMethod());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_get_learnt_thetas(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->get_learnt_thetas());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    PyObject* pyobj_nodeName = NULL;
    String nodeName;
    Ptr<LogisticRegression> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_LogisticRegression.load", (char**)keywords, &pyobj_filepath, &pyobj_nodeName) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        pyopencv_to(pyobj_nodeName, nodeName, ArgInfo("nodeName", 0)) )
    {
        ERRWRAP2(retval = cv::ml::LogisticRegression::load(filepath, nodeName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_predict(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    PyObject* pyobj_results = NULL;
    Mat results;
    int flags=0;
    float retval;

    const char* keywords[] = { "samples", "results", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ml_LogisticRegression.predict", (char**)keywords, &pyobj_samples, &pyobj_results, &flags) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) )
    {
        ERRWRAP2(retval = _self_->predict(samples, results, flags));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(results));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    PyObject* pyobj_results = NULL;
    UMat results;
    int flags=0;
    float retval;

    const char* keywords[] = { "samples", "results", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ml_LogisticRegression.predict", (char**)keywords, &pyobj_samples, &pyobj_results, &flags) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) )
    {
        ERRWRAP2(retval = _self_->predict(samples, results, flags));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(results));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_setIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_LogisticRegression.setIterations", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setIterations(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_setLearningRate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_LogisticRegression.setLearningRate", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setLearningRate(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_setMiniBatchSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_LogisticRegression.setMiniBatchSize", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMiniBatchSize(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_setRegularization(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_LogisticRegression.setRegularization", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRegularization(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_setTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    TermCriteria val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_LogisticRegression.setTermCriteria", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setTermCriteria(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_LogisticRegression_setTrainMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::LogisticRegression> * self1 = 0;
    if (!pyopencv_ml_LogisticRegression_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_LogisticRegression' or its derivative)");
    Ptr<cv::ml::LogisticRegression> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_LogisticRegression.setTrainMethod", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTrainMethod(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ml_LogisticRegression)

static PyGetSetDef pyopencv_ml_LogisticRegression_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_LogisticRegression_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_create_static, METH_STATIC), "create() -> retval\n.   @brief Creates empty model.\n.   \n.       Creates Logistic Regression model with parameters given."},
    {"getIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_getIterations, 0), "getIterations() -> retval\n.   @see setIterations"},
    {"getLearningRate", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_getLearningRate, 0), "getLearningRate() -> retval\n.   @see setLearningRate"},
    {"getMiniBatchSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_getMiniBatchSize, 0), "getMiniBatchSize() -> retval\n.   @see setMiniBatchSize"},
    {"getRegularization", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_getRegularization, 0), "getRegularization() -> retval\n.   @see setRegularization"},
    {"getTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_getTermCriteria, 0), "getTermCriteria() -> retval\n.   @see setTermCriteria"},
    {"getTrainMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_getTrainMethod, 0), "getTrainMethod() -> retval\n.   @see setTrainMethod"},
    {"get_learnt_thetas", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_get_learnt_thetas, 0), "get_learnt_thetas() -> retval\n.   @brief This function returns the trained parameters arranged across rows.\n.   \n.       For a two class classifcation problem, it returns a row matrix. It returns learnt parameters of\n.       the Logistic Regression as a matrix of type CV_32F."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_load_static, METH_STATIC), "load(filepath[, nodeName]) -> retval\n.   @brief Loads and creates a serialized LogisticRegression from a file\n.        *\n.        * Use LogisticRegression::save to serialize and store an LogisticRegression to disk.\n.        * Load the LogisticRegression from this file again, by calling this function with the path to the file.\n.        * Optionally specify the node for the file containing the classifier\n.        *\n.        * @param filepath path to serialized LogisticRegression\n.        * @param nodeName name of node containing the classifier"},
    {"predict", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_predict, 0), "predict(samples[, results[, flags]]) -> retval, results\n.   @brief Predicts responses for input samples and returns a float type.\n.   \n.       @param samples The input data for the prediction algorithm. Matrix [m x n], where each row\n.           contains variables (features) of one object being classified. Should have data type CV_32F.\n.       @param results Predicted labels as a column matrix of type CV_32S.\n.       @param flags Not used."},
    {"setIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_setIterations, 0), "setIterations(val) -> None\n.   @copybrief getIterations @see getIterations"},
    {"setLearningRate", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_setLearningRate, 0), "setLearningRate(val) -> None\n.   @copybrief getLearningRate @see getLearningRate"},
    {"setMiniBatchSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_setMiniBatchSize, 0), "setMiniBatchSize(val) -> None\n.   @copybrief getMiniBatchSize @see getMiniBatchSize"},
    {"setRegularization", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_setRegularization, 0), "setRegularization(val) -> None\n.   @copybrief getRegularization @see getRegularization"},
    {"setTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_setTermCriteria, 0), "setTermCriteria(val) -> None\n.   @copybrief getTermCriteria @see getTermCriteria"},
    {"setTrainMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_LogisticRegression_setTrainMethod, 0), "setTrainMethod(val) -> None\n.   @copybrief getTrainMethod @see getTrainMethod"},

    {NULL,          NULL}
};

// Converter (ml_LogisticRegression)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::LogisticRegression> >
{
    static PyObject* from(const Ptr<cv::ml::LogisticRegression>& r)
    {
        return pyopencv_ml_LogisticRegression_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::LogisticRegression>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::LogisticRegression> * dst_;
        if (pyopencv_ml_LogisticRegression_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::LogisticRegression> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_NormalBayesClassifier (Generic)
//================================================================================

// GetSet (ml_NormalBayesClassifier)



// Methods (ml_NormalBayesClassifier)

static PyObject* pyopencv_cv_ml_ml_NormalBayesClassifier_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<NormalBayesClassifier> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::NormalBayesClassifier::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_NormalBayesClassifier_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    PyObject* pyobj_nodeName = NULL;
    String nodeName;
    Ptr<NormalBayesClassifier> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_NormalBayesClassifier.load", (char**)keywords, &pyobj_filepath, &pyobj_nodeName) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        pyopencv_to(pyobj_nodeName, nodeName, ArgInfo("nodeName", 0)) )
    {
        ERRWRAP2(retval = cv::ml::NormalBayesClassifier::load(filepath, nodeName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_NormalBayesClassifier_predictProb(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::NormalBayesClassifier> * self1 = 0;
    if (!pyopencv_ml_NormalBayesClassifier_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_NormalBayesClassifier' or its derivative)");
    Ptr<cv::ml::NormalBayesClassifier> _self_ = *(self1);
    {
    PyObject* pyobj_inputs = NULL;
    Mat inputs;
    PyObject* pyobj_outputs = NULL;
    Mat outputs;
    PyObject* pyobj_outputProbs = NULL;
    Mat outputProbs;
    int flags=0;
    float retval;

    const char* keywords[] = { "inputs", "outputs", "outputProbs", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOi:ml_NormalBayesClassifier.predictProb", (char**)keywords, &pyobj_inputs, &pyobj_outputs, &pyobj_outputProbs, &flags) &&
        pyopencv_to(pyobj_inputs, inputs, ArgInfo("inputs", 0)) &&
        pyopencv_to(pyobj_outputs, outputs, ArgInfo("outputs", 1)) &&
        pyopencv_to(pyobj_outputProbs, outputProbs, ArgInfo("outputProbs", 1)) )
    {
        ERRWRAP2(retval = _self_->predictProb(inputs, outputs, outputProbs, flags));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(outputs), pyopencv_from(outputProbs));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputs = NULL;
    UMat inputs;
    PyObject* pyobj_outputs = NULL;
    UMat outputs;
    PyObject* pyobj_outputProbs = NULL;
    UMat outputProbs;
    int flags=0;
    float retval;

    const char* keywords[] = { "inputs", "outputs", "outputProbs", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOi:ml_NormalBayesClassifier.predictProb", (char**)keywords, &pyobj_inputs, &pyobj_outputs, &pyobj_outputProbs, &flags) &&
        pyopencv_to(pyobj_inputs, inputs, ArgInfo("inputs", 0)) &&
        pyopencv_to(pyobj_outputs, outputs, ArgInfo("outputs", 1)) &&
        pyopencv_to(pyobj_outputProbs, outputProbs, ArgInfo("outputProbs", 1)) )
    {
        ERRWRAP2(retval = _self_->predictProb(inputs, outputs, outputProbs, flags));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(outputs), pyopencv_from(outputProbs));
    }
    }

    return NULL;
}



// Tables (ml_NormalBayesClassifier)

static PyGetSetDef pyopencv_ml_NormalBayesClassifier_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_NormalBayesClassifier_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_NormalBayesClassifier_create_static, METH_STATIC), "create() -> retval\n.   Creates empty model\n.   Use StatModel::train to train the model after creation."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_NormalBayesClassifier_load_static, METH_STATIC), "load(filepath[, nodeName]) -> retval\n.   @brief Loads and creates a serialized NormalBayesClassifier from a file\n.        *\n.        * Use NormalBayesClassifier::save to serialize and store an NormalBayesClassifier to disk.\n.        * Load the NormalBayesClassifier from this file again, by calling this function with the path to the file.\n.        * Optionally specify the node for the file containing the classifier\n.        *\n.        * @param filepath path to serialized NormalBayesClassifier\n.        * @param nodeName name of node containing the classifier"},
    {"predictProb", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_NormalBayesClassifier_predictProb, 0), "predictProb(inputs[, outputs[, outputProbs[, flags]]]) -> retval, outputs, outputProbs\n.   @brief Predicts the response for sample(s).\n.   \n.       The method estimates the most probable classes for input vectors. Input vectors (one or more)\n.       are stored as rows of the matrix inputs. In case of multiple input vectors, there should be one\n.       output vector outputs. The predicted class for a single input vector is returned by the method.\n.       The vector outputProbs contains the output probabilities corresponding to each element of\n.       result."},

    {NULL,          NULL}
};

// Converter (ml_NormalBayesClassifier)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::NormalBayesClassifier> >
{
    static PyObject* from(const Ptr<cv::ml::NormalBayesClassifier>& r)
    {
        return pyopencv_ml_NormalBayesClassifier_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::NormalBayesClassifier>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::NormalBayesClassifier> * dst_;
        if (pyopencv_ml_NormalBayesClassifier_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::NormalBayesClassifier> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_ParamGrid (Generic)
//================================================================================

// GetSet (ml_ParamGrid)


static PyObject* pyopencv_ml_ParamGrid_get_logStep(pyopencv_ml_ParamGrid_t* p, void *closure)
{
    return pyopencv_from(p->v->logStep);
}

static int pyopencv_ml_ParamGrid_set_logStep(pyopencv_ml_ParamGrid_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the logStep attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->logStep) ? 0 : -1;
}

static PyObject* pyopencv_ml_ParamGrid_get_maxVal(pyopencv_ml_ParamGrid_t* p, void *closure)
{
    return pyopencv_from(p->v->maxVal);
}

static int pyopencv_ml_ParamGrid_set_maxVal(pyopencv_ml_ParamGrid_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the maxVal attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->maxVal) ? 0 : -1;
}

static PyObject* pyopencv_ml_ParamGrid_get_minVal(pyopencv_ml_ParamGrid_t* p, void *closure)
{
    return pyopencv_from(p->v->minVal);
}

static int pyopencv_ml_ParamGrid_set_minVal(pyopencv_ml_ParamGrid_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the minVal attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->minVal) ? 0 : -1;
}


// Methods (ml_ParamGrid)

static PyObject* pyopencv_cv_ml_ml_ParamGrid_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    double minVal=0.;
    double maxVal=0.;
    double logstep=1.;
    Ptr<ParamGrid> retval;

    const char* keywords[] = { "minVal", "maxVal", "logstep", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ddd:ml_ParamGrid.create", (char**)keywords, &minVal, &maxVal, &logstep) )
    {
        ERRWRAP2(retval = cv::ml::ParamGrid::create(minVal, maxVal, logstep));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (ml_ParamGrid)

static PyGetSetDef pyopencv_ml_ParamGrid_getseters[] =
{
    {(char*)"logStep", (getter)pyopencv_ml_ParamGrid_get_logStep, (setter)pyopencv_ml_ParamGrid_set_logStep, (char*)"logStep", NULL},
    {(char*)"maxVal", (getter)pyopencv_ml_ParamGrid_get_maxVal, (setter)pyopencv_ml_ParamGrid_set_maxVal, (char*)"maxVal", NULL},
    {(char*)"minVal", (getter)pyopencv_ml_ParamGrid_get_minVal, (setter)pyopencv_ml_ParamGrid_set_minVal, (char*)"minVal", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_ParamGrid_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_ParamGrid_create_static, METH_STATIC), "create([, minVal[, maxVal[, logstep]]]) -> retval\n.   @brief Creates a ParamGrid Ptr that can be given to the %SVM::trainAuto method\n.   \n.       @param minVal minimum value of the parameter grid\n.       @param maxVal maximum value of the parameter grid\n.       @param logstep Logarithmic step for iterating the statmodel parameter"},

    {NULL,          NULL}
};

// Converter (ml_ParamGrid)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::ParamGrid> >
{
    static PyObject* from(const Ptr<cv::ml::ParamGrid>& r)
    {
        return pyopencv_ml_ParamGrid_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::ParamGrid>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::ParamGrid> * dst_;
        if (pyopencv_ml_ParamGrid_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::ParamGrid> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_RTrees (Generic)
//================================================================================

// GetSet (ml_RTrees)



// Methods (ml_RTrees)

static PyObject* pyopencv_cv_ml_ml_RTrees_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<RTrees> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::RTrees::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_getActiveVarCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!pyopencv_ml_RTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_RTrees' or its derivative)");
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getActiveVarCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_getCalculateVarImportance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!pyopencv_ml_RTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_RTrees' or its derivative)");
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCalculateVarImportance());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_getTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!pyopencv_ml_RTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_RTrees' or its derivative)");
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    TermCriteria retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTermCriteria());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_getVarImportance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!pyopencv_ml_RTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_RTrees' or its derivative)");
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarImportance());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_getVotes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!pyopencv_ml_RTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_RTrees' or its derivative)");
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    PyObject* pyobj_results = NULL;
    Mat results;
    int flags=0;

    const char* keywords[] = { "samples", "flags", "results", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:ml_RTrees.getVotes", (char**)keywords, &pyobj_samples, &flags, &pyobj_results) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) )
    {
        ERRWRAP2(_self_->getVotes(samples, results, flags));
        return pyopencv_from(results);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    PyObject* pyobj_results = NULL;
    UMat results;
    int flags=0;

    const char* keywords[] = { "samples", "flags", "results", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|O:ml_RTrees.getVotes", (char**)keywords, &pyobj_samples, &flags, &pyobj_results) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) )
    {
        ERRWRAP2(_self_->getVotes(samples, results, flags));
        return pyopencv_from(results);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    PyObject* pyobj_nodeName = NULL;
    String nodeName;
    Ptr<RTrees> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_RTrees.load", (char**)keywords, &pyobj_filepath, &pyobj_nodeName) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        pyopencv_to(pyobj_nodeName, nodeName, ArgInfo("nodeName", 0)) )
    {
        ERRWRAP2(retval = cv::ml::RTrees::load(filepath, nodeName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_setActiveVarCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!pyopencv_ml_RTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_RTrees' or its derivative)");
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_RTrees.setActiveVarCount", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setActiveVarCount(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_setCalculateVarImportance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!pyopencv_ml_RTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_RTrees' or its derivative)");
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:ml_RTrees.setCalculateVarImportance", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setCalculateVarImportance(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_RTrees_setTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::RTrees> * self1 = 0;
    if (!pyopencv_ml_RTrees_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_RTrees' or its derivative)");
    Ptr<cv::ml::RTrees> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    TermCriteria val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_RTrees.setTermCriteria", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setTermCriteria(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ml_RTrees)

static PyGetSetDef pyopencv_ml_RTrees_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_RTrees_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_create_static, METH_STATIC), "create() -> retval\n.   Creates the empty model.\n.       Use StatModel::train to train the model, StatModel::train to create and train the model,\n.       Algorithm::load to load the pre-trained model."},
    {"getActiveVarCount", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_getActiveVarCount, 0), "getActiveVarCount() -> retval\n.   @see setActiveVarCount"},
    {"getCalculateVarImportance", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_getCalculateVarImportance, 0), "getCalculateVarImportance() -> retval\n.   @see setCalculateVarImportance"},
    {"getTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_getTermCriteria, 0), "getTermCriteria() -> retval\n.   @see setTermCriteria"},
    {"getVarImportance", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_getVarImportance, 0), "getVarImportance() -> retval\n.   Returns the variable importance array.\n.       The method returns the variable importance vector, computed at the training stage when\n.       CalculateVarImportance is set to true. If this flag was set to false, the empty matrix is\n.       returned."},
    {"getVotes", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_getVotes, 0), "getVotes(samples, flags[, results]) -> results\n.   Returns the result of each individual tree in the forest.\n.       In case the model is a regression problem, the method will return each of the trees'\n.       results for each of the sample cases. If the model is a classifier, it will return\n.       a Mat with samples + 1 rows, where the first row gives the class number and the\n.       following rows return the votes each class had for each sample.\n.           @param samples Array containing the samples for which votes will be calculated.\n.           @param results Array where the result of the calculation will be written.\n.           @param flags Flags for defining the type of RTrees."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_load_static, METH_STATIC), "load(filepath[, nodeName]) -> retval\n.   @brief Loads and creates a serialized RTree from a file\n.        *\n.        * Use RTree::save to serialize and store an RTree to disk.\n.        * Load the RTree from this file again, by calling this function with the path to the file.\n.        * Optionally specify the node for the file containing the classifier\n.        *\n.        * @param filepath path to serialized RTree\n.        * @param nodeName name of node containing the classifier"},
    {"setActiveVarCount", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_setActiveVarCount, 0), "setActiveVarCount(val) -> None\n.   @copybrief getActiveVarCount @see getActiveVarCount"},
    {"setCalculateVarImportance", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_setCalculateVarImportance, 0), "setCalculateVarImportance(val) -> None\n.   @copybrief getCalculateVarImportance @see getCalculateVarImportance"},
    {"setTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_RTrees_setTermCriteria, 0), "setTermCriteria(val) -> None\n.   @copybrief getTermCriteria @see getTermCriteria"},

    {NULL,          NULL}
};

// Converter (ml_RTrees)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::RTrees> >
{
    static PyObject* from(const Ptr<cv::ml::RTrees>& r)
    {
        return pyopencv_ml_RTrees_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::RTrees>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::RTrees> * dst_;
        if (pyopencv_ml_RTrees_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::RTrees> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_SVM (Generic)
//================================================================================

// GetSet (ml_SVM)



// Methods (ml_SVM)

static PyObject* pyopencv_cv_ml_ml_SVM_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<SVM> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::SVM::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getC(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getC());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getClassWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getClassWeights());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getCoef0(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCoef0());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getDecisionFunction(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    {
    int i=0;
    PyObject* pyobj_alpha = NULL;
    Mat alpha;
    PyObject* pyobj_svidx = NULL;
    Mat svidx;
    double retval;

    const char* keywords[] = { "i", "alpha", "svidx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|OO:ml_SVM.getDecisionFunction", (char**)keywords, &i, &pyobj_alpha, &pyobj_svidx) &&
        pyopencv_to(pyobj_alpha, alpha, ArgInfo("alpha", 1)) &&
        pyopencv_to(pyobj_svidx, svidx, ArgInfo("svidx", 1)) )
    {
        ERRWRAP2(retval = _self_->getDecisionFunction(i, alpha, svidx));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(alpha), pyopencv_from(svidx));
    }
    }
    PyErr_Clear();

    {
    int i=0;
    PyObject* pyobj_alpha = NULL;
    UMat alpha;
    PyObject* pyobj_svidx = NULL;
    UMat svidx;
    double retval;

    const char* keywords[] = { "i", "alpha", "svidx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|OO:ml_SVM.getDecisionFunction", (char**)keywords, &i, &pyobj_alpha, &pyobj_svidx) &&
        pyopencv_to(pyobj_alpha, alpha, ArgInfo("alpha", 1)) &&
        pyopencv_to(pyobj_svidx, svidx, ArgInfo("svidx", 1)) )
    {
        ERRWRAP2(retval = _self_->getDecisionFunction(i, alpha, svidx));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(alpha), pyopencv_from(svidx));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getDefaultGridPtr_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    int param_id=0;
    Ptr<ParamGrid> retval;

    const char* keywords[] = { "param_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_SVM.getDefaultGridPtr", (char**)keywords, &param_id) )
    {
        ERRWRAP2(retval = cv::ml::SVM::getDefaultGridPtr(param_id));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getDegree(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDegree());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGamma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getKernelType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getKernelType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getNu(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNu());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getP(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getP());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getSupportVectors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSupportVectors());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    cv::TermCriteria retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTermCriteria());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_getUncompressedSupportVectors(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUncompressedSupportVectors());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    Ptr<SVM> retval;

    const char* keywords[] = { "filepath", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_SVM.load", (char**)keywords, &pyobj_filepath) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) )
    {
        ERRWRAP2(retval = cv::ml::SVM::load(filepath));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setC(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_SVM.setC", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setC(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setClassWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_SVM.setClassWeights", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setClassWeights(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_SVM.setClassWeights", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setClassWeights(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setCoef0(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_SVM.setCoef0", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setCoef0(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setDegree(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_SVM.setDegree", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setDegree(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_SVM.setGamma", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setGamma(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setKernel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int kernelType=0;

    const char* keywords[] = { "kernelType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_SVM.setKernel", (char**)keywords, &kernelType) )
    {
        ERRWRAP2(_self_->setKernel(kernelType));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setNu(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_SVM.setNu", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setNu(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setP(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ml_SVM.setP", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setP(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    TermCriteria val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_SVM.setTermCriteria", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setTermCriteria(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_setType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_SVM.setType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVM_trainAuto(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVM> * self1 = 0;
    if (!pyopencv_ml_SVM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVM' or its derivative)");
    Ptr<cv::ml::SVM> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    int layout=0;
    PyObject* pyobj_responses = NULL;
    Mat responses;
    int kFold=10;
    PyObject* pyobj_Cgrid = NULL;
    Ptr<ParamGrid> Cgrid=SVM::getDefaultGridPtr(SVM::C);
    PyObject* pyobj_gammaGrid = NULL;
    Ptr<ParamGrid> gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA);
    PyObject* pyobj_pGrid = NULL;
    Ptr<ParamGrid> pGrid=SVM::getDefaultGridPtr(SVM::P);
    PyObject* pyobj_nuGrid = NULL;
    Ptr<ParamGrid> nuGrid=SVM::getDefaultGridPtr(SVM::NU);
    PyObject* pyobj_coeffGrid = NULL;
    Ptr<ParamGrid> coeffGrid=SVM::getDefaultGridPtr(SVM::COEF);
    PyObject* pyobj_degreeGrid = NULL;
    Ptr<ParamGrid> degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE);
    bool balanced=false;
    bool retval;

    const char* keywords[] = { "samples", "layout", "responses", "kFold", "Cgrid", "gammaGrid", "pGrid", "nuGrid", "coeffGrid", "degreeGrid", "balanced", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO|iOOOOOOb:ml_SVM.trainAuto", (char**)keywords, &pyobj_samples, &layout, &pyobj_responses, &kFold, &pyobj_Cgrid, &pyobj_gammaGrid, &pyobj_pGrid, &pyobj_nuGrid, &pyobj_coeffGrid, &pyobj_degreeGrid, &balanced) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_responses, responses, ArgInfo("responses", 0)) &&
        pyopencv_to(pyobj_Cgrid, Cgrid, ArgInfo("Cgrid", 0)) &&
        pyopencv_to(pyobj_gammaGrid, gammaGrid, ArgInfo("gammaGrid", 0)) &&
        pyopencv_to(pyobj_pGrid, pGrid, ArgInfo("pGrid", 0)) &&
        pyopencv_to(pyobj_nuGrid, nuGrid, ArgInfo("nuGrid", 0)) &&
        pyopencv_to(pyobj_coeffGrid, coeffGrid, ArgInfo("coeffGrid", 0)) &&
        pyopencv_to(pyobj_degreeGrid, degreeGrid, ArgInfo("degreeGrid", 0)) )
    {
        ERRWRAP2(retval = _self_->trainAuto(samples, layout, responses, kFold, Cgrid, gammaGrid, pGrid, nuGrid, coeffGrid, degreeGrid, balanced));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    int layout=0;
    PyObject* pyobj_responses = NULL;
    UMat responses;
    int kFold=10;
    PyObject* pyobj_Cgrid = NULL;
    Ptr<ParamGrid> Cgrid=SVM::getDefaultGridPtr(SVM::C);
    PyObject* pyobj_gammaGrid = NULL;
    Ptr<ParamGrid> gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA);
    PyObject* pyobj_pGrid = NULL;
    Ptr<ParamGrid> pGrid=SVM::getDefaultGridPtr(SVM::P);
    PyObject* pyobj_nuGrid = NULL;
    Ptr<ParamGrid> nuGrid=SVM::getDefaultGridPtr(SVM::NU);
    PyObject* pyobj_coeffGrid = NULL;
    Ptr<ParamGrid> coeffGrid=SVM::getDefaultGridPtr(SVM::COEF);
    PyObject* pyobj_degreeGrid = NULL;
    Ptr<ParamGrid> degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE);
    bool balanced=false;
    bool retval;

    const char* keywords[] = { "samples", "layout", "responses", "kFold", "Cgrid", "gammaGrid", "pGrid", "nuGrid", "coeffGrid", "degreeGrid", "balanced", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO|iOOOOOOb:ml_SVM.trainAuto", (char**)keywords, &pyobj_samples, &layout, &pyobj_responses, &kFold, &pyobj_Cgrid, &pyobj_gammaGrid, &pyobj_pGrid, &pyobj_nuGrid, &pyobj_coeffGrid, &pyobj_degreeGrid, &balanced) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_responses, responses, ArgInfo("responses", 0)) &&
        pyopencv_to(pyobj_Cgrid, Cgrid, ArgInfo("Cgrid", 0)) &&
        pyopencv_to(pyobj_gammaGrid, gammaGrid, ArgInfo("gammaGrid", 0)) &&
        pyopencv_to(pyobj_pGrid, pGrid, ArgInfo("pGrid", 0)) &&
        pyopencv_to(pyobj_nuGrid, nuGrid, ArgInfo("nuGrid", 0)) &&
        pyopencv_to(pyobj_coeffGrid, coeffGrid, ArgInfo("coeffGrid", 0)) &&
        pyopencv_to(pyobj_degreeGrid, degreeGrid, ArgInfo("degreeGrid", 0)) )
    {
        ERRWRAP2(retval = _self_->trainAuto(samples, layout, responses, kFold, Cgrid, gammaGrid, pGrid, nuGrid, coeffGrid, degreeGrid, balanced));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (ml_SVM)

static PyGetSetDef pyopencv_ml_SVM_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_SVM_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_create_static, METH_STATIC), "create() -> retval\n.   Creates empty model.\n.       Use StatModel::train to train the model. Since %SVM has several parameters, you may want to\n.   find the best parameters for your problem, it can be done with SVM::trainAuto."},
    {"getC", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getC, 0), "getC() -> retval\n.   @see setC"},
    {"getClassWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getClassWeights, 0), "getClassWeights() -> retval\n.   @see setClassWeights"},
    {"getCoef0", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getCoef0, 0), "getCoef0() -> retval\n.   @see setCoef0"},
    {"getDecisionFunction", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getDecisionFunction, 0), "getDecisionFunction(i[, alpha[, svidx]]) -> retval, alpha, svidx\n.   @brief Retrieves the decision function\n.   \n.       @param i the index of the decision function. If the problem solved is regression, 1-class or\n.           2-class classification, then there will be just one decision function and the index should\n.           always be 0. Otherwise, in the case of N-class classification, there will be \\f$N(N-1)/2\\f$\n.           decision functions.\n.       @param alpha the optional output vector for weights, corresponding to different support vectors.\n.           In the case of linear %SVM all the alpha's will be 1's.\n.       @param svidx the optional output vector of indices of support vectors within the matrix of\n.           support vectors (which can be retrieved by SVM::getSupportVectors). In the case of linear\n.           %SVM each decision function consists of a single \"compressed\" support vector.\n.   \n.       The method returns rho parameter of the decision function, a scalar subtracted from the weighted\n.       sum of kernel responses."},
    {"getDefaultGridPtr", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getDefaultGridPtr_static, METH_STATIC), "getDefaultGridPtr(param_id) -> retval\n.   @brief Generates a grid for %SVM parameters.\n.   \n.       @param param_id %SVM parameters IDs that must be one of the SVM::ParamTypes. The grid is\n.       generated for the parameter with this ID.\n.   \n.       The function generates a grid pointer for the specified parameter of the %SVM algorithm.\n.       The grid may be passed to the function SVM::trainAuto."},
    {"getDegree", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getDegree, 0), "getDegree() -> retval\n.   @see setDegree"},
    {"getGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getGamma, 0), "getGamma() -> retval\n.   @see setGamma"},
    {"getKernelType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getKernelType, 0), "getKernelType() -> retval\n.   Type of a %SVM kernel.\n.   See SVM::KernelTypes. Default value is SVM::RBF."},
    {"getNu", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getNu, 0), "getNu() -> retval\n.   @see setNu"},
    {"getP", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getP, 0), "getP() -> retval\n.   @see setP"},
    {"getSupportVectors", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getSupportVectors, 0), "getSupportVectors() -> retval\n.   @brief Retrieves all the support vectors\n.   \n.       The method returns all the support vectors as a floating-point matrix, where support vectors are\n.       stored as matrix rows."},
    {"getTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getTermCriteria, 0), "getTermCriteria() -> retval\n.   @see setTermCriteria"},
    {"getType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getType, 0), "getType() -> retval\n.   @see setType"},
    {"getUncompressedSupportVectors", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_getUncompressedSupportVectors, 0), "getUncompressedSupportVectors() -> retval\n.   @brief Retrieves all the uncompressed support vectors of a linear %SVM\n.   \n.       The method returns all the uncompressed support vectors of a linear %SVM that the compressed\n.       support vector, used for prediction, was derived from. They are returned in a floating-point\n.       matrix, where the support vectors are stored as matrix rows."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_load_static, METH_STATIC), "load(filepath) -> retval\n.   @brief Loads and creates a serialized svm from a file\n.        *\n.        * Use SVM::save to serialize and store an SVM to disk.\n.        * Load the SVM from this file again, by calling this function with the path to the file.\n.        *\n.        * @param filepath path to serialized svm"},
    {"setC", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setC, 0), "setC(val) -> None\n.   @copybrief getC @see getC"},
    {"setClassWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setClassWeights, 0), "setClassWeights(val) -> None\n.   @copybrief getClassWeights @see getClassWeights"},
    {"setCoef0", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setCoef0, 0), "setCoef0(val) -> None\n.   @copybrief getCoef0 @see getCoef0"},
    {"setDegree", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setDegree, 0), "setDegree(val) -> None\n.   @copybrief getDegree @see getDegree"},
    {"setGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setGamma, 0), "setGamma(val) -> None\n.   @copybrief getGamma @see getGamma"},
    {"setKernel", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setKernel, 0), "setKernel(kernelType) -> None\n.   Initialize with one of predefined kernels.\n.   See SVM::KernelTypes."},
    {"setNu", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setNu, 0), "setNu(val) -> None\n.   @copybrief getNu @see getNu"},
    {"setP", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setP, 0), "setP(val) -> None\n.   @copybrief getP @see getP"},
    {"setTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setTermCriteria, 0), "setTermCriteria(val) -> None\n.   @copybrief getTermCriteria @see getTermCriteria"},
    {"setType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_setType, 0), "setType(val) -> None\n.   @copybrief getType @see getType"},
    {"trainAuto", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVM_trainAuto, 0), "trainAuto(samples, layout, responses[, kFold[, Cgrid[, gammaGrid[, pGrid[, nuGrid[, coeffGrid[, degreeGrid[, balanced]]]]]]]]) -> retval\n.   @brief Trains an %SVM with optimal parameters\n.   \n.       @param samples training samples\n.       @param layout See ml::SampleTypes.\n.       @param responses vector of responses associated with the training samples.\n.       @param kFold Cross-validation parameter. The training set is divided into kFold subsets. One\n.           subset is used to test the model, the others form the train set. So, the %SVM algorithm is\n.       @param Cgrid grid for C\n.       @param gammaGrid grid for gamma\n.       @param pGrid grid for p\n.       @param nuGrid grid for nu\n.       @param coeffGrid grid for coeff\n.       @param degreeGrid grid for degree\n.       @param balanced If true and the problem is 2-class classification then the method creates more\n.           balanced cross-validation subsets that is proportions between classes in subsets are close\n.           to such proportion in the whole train dataset.\n.   \n.       The method trains the %SVM model automatically by choosing the optimal parameters C, gamma, p,\n.       nu, coef0, degree. Parameters are considered optimal when the cross-validation\n.       estimate of the test set error is minimal.\n.   \n.       This function only makes use of SVM::getDefaultGrid for parameter optimization and thus only\n.       offers rudimentary parameter options.\n.   \n.       This function works for the classification (SVM::C_SVC or SVM::NU_SVC) as well as for the\n.       regression (SVM::EPS_SVR or SVM::NU_SVR). If it is SVM::ONE_CLASS, no optimization is made and\n.       the usual %SVM with parameters specified in params is executed."},

    {NULL,          NULL}
};

// Converter (ml_SVM)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::SVM> >
{
    static PyObject* from(const Ptr<cv::ml::SVM>& r)
    {
        return pyopencv_ml_SVM_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::SVM>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::SVM> * dst_;
        if (pyopencv_ml_SVM_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::SVM> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_SVMSGD (Generic)
//================================================================================

// GetSet (ml_SVMSGD)



// Methods (ml_SVMSGD)

static PyObject* pyopencv_cv_ml_ml_SVMSGD_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    Ptr<SVMSGD> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ml::SVMSGD::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_getInitialStepSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInitialStepSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_getMarginRegularization(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMarginRegularization());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_getMarginType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMarginType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_getShift(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getShift());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_getStepDecreasingPower(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getStepDecreasingPower());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_getSvmsgdType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSvmsgdType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_getTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    TermCriteria retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTermCriteria());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_getWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeights());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_load_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    PyObject* pyobj_filepath = NULL;
    String filepath;
    PyObject* pyobj_nodeName = NULL;
    String nodeName;
    Ptr<SVMSGD> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ml_SVMSGD.load", (char**)keywords, &pyobj_filepath, &pyobj_nodeName) &&
        pyopencv_to(pyobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        pyopencv_to(pyobj_nodeName, nodeName, ArgInfo("nodeName", 0)) )
    {
        ERRWRAP2(retval = cv::ml::SVMSGD::load(filepath, nodeName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_setInitialStepSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float InitialStepSize=0.f;

    const char* keywords[] = { "InitialStepSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ml_SVMSGD.setInitialStepSize", (char**)keywords, &InitialStepSize) )
    {
        ERRWRAP2(_self_->setInitialStepSize(InitialStepSize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_setMarginRegularization(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float marginRegularization=0.f;

    const char* keywords[] = { "marginRegularization", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ml_SVMSGD.setMarginRegularization", (char**)keywords, &marginRegularization) )
    {
        ERRWRAP2(_self_->setMarginRegularization(marginRegularization));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_setMarginType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int marginType=0;

    const char* keywords[] = { "marginType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_SVMSGD.setMarginType", (char**)keywords, &marginType) )
    {
        ERRWRAP2(_self_->setMarginType(marginType));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_setOptimalParameters(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int svmsgdType=SVMSGD::ASGD;
    int marginType=SVMSGD::SOFT_MARGIN;

    const char* keywords[] = { "svmsgdType", "marginType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ii:ml_SVMSGD.setOptimalParameters", (char**)keywords, &svmsgdType, &marginType) )
    {
        ERRWRAP2(_self_->setOptimalParameters(svmsgdType, marginType));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_setStepDecreasingPower(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    float stepDecreasingPower=0.f;

    const char* keywords[] = { "stepDecreasingPower", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ml_SVMSGD.setStepDecreasingPower", (char**)keywords, &stepDecreasingPower) )
    {
        ERRWRAP2(_self_->setStepDecreasingPower(stepDecreasingPower));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_setSvmsgdType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    int svmsgdType=0;

    const char* keywords[] = { "svmsgdType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_SVMSGD.setSvmsgdType", (char**)keywords, &svmsgdType) )
    {
        ERRWRAP2(_self_->setSvmsgdType(svmsgdType));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_SVMSGD_setTermCriteria(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::SVMSGD> * self1 = 0;
    if (!pyopencv_ml_SVMSGD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_SVMSGD' or its derivative)");
    Ptr<cv::ml::SVMSGD> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    TermCriteria val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_SVMSGD.setTermCriteria", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setTermCriteria(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ml_SVMSGD)

static PyGetSetDef pyopencv_ml_SVMSGD_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_SVMSGD_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_create_static, METH_STATIC), "create() -> retval\n.   @brief Creates empty model.\n.        * Use StatModel::train to train the model. Since %SVMSGD has several parameters, you may want to\n.        * find the best parameters for your problem or use setOptimalParameters() to set some default parameters."},
    {"getInitialStepSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_getInitialStepSize, 0), "getInitialStepSize() -> retval\n.   @see setInitialStepSize"},
    {"getMarginRegularization", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_getMarginRegularization, 0), "getMarginRegularization() -> retval\n.   @see setMarginRegularization"},
    {"getMarginType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_getMarginType, 0), "getMarginType() -> retval\n.   @see setMarginType"},
    {"getShift", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_getShift, 0), "getShift() -> retval\n.   * @return the shift of the trained model (decision function f(x) = weights * x + shift)."},
    {"getStepDecreasingPower", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_getStepDecreasingPower, 0), "getStepDecreasingPower() -> retval\n.   @see setStepDecreasingPower"},
    {"getSvmsgdType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_getSvmsgdType, 0), "getSvmsgdType() -> retval\n.   @see setSvmsgdType"},
    {"getTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_getTermCriteria, 0), "getTermCriteria() -> retval\n.   @see setTermCriteria"},
    {"getWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_getWeights, 0), "getWeights() -> retval\n.   * @return the weights of the trained model (decision function f(x) = weights * x + shift)."},
    {"load", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_load_static, METH_STATIC), "load(filepath[, nodeName]) -> retval\n.   @brief Loads and creates a serialized SVMSGD from a file\n.        *\n.        * Use SVMSGD::save to serialize and store an SVMSGD to disk.\n.        * Load the SVMSGD from this file again, by calling this function with the path to the file.\n.        * Optionally specify the node for the file containing the classifier\n.        *\n.        * @param filepath path to serialized SVMSGD\n.        * @param nodeName name of node containing the classifier"},
    {"setInitialStepSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_setInitialStepSize, 0), "setInitialStepSize(InitialStepSize) -> None\n.   @copybrief getInitialStepSize @see getInitialStepSize"},
    {"setMarginRegularization", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_setMarginRegularization, 0), "setMarginRegularization(marginRegularization) -> None\n.   @copybrief getMarginRegularization @see getMarginRegularization"},
    {"setMarginType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_setMarginType, 0), "setMarginType(marginType) -> None\n.   @copybrief getMarginType @see getMarginType"},
    {"setOptimalParameters", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_setOptimalParameters, 0), "setOptimalParameters([, svmsgdType[, marginType]]) -> None\n.   @brief Function sets optimal parameters values for chosen SVM SGD model.\n.        * @param svmsgdType is the type of SVMSGD classifier.\n.        * @param marginType is the type of margin constraint."},
    {"setStepDecreasingPower", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_setStepDecreasingPower, 0), "setStepDecreasingPower(stepDecreasingPower) -> None\n.   @copybrief getStepDecreasingPower @see getStepDecreasingPower"},
    {"setSvmsgdType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_setSvmsgdType, 0), "setSvmsgdType(svmsgdType) -> None\n.   @copybrief getSvmsgdType @see getSvmsgdType"},
    {"setTermCriteria", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_SVMSGD_setTermCriteria, 0), "setTermCriteria(val) -> None\n.   @copybrief getTermCriteria @see getTermCriteria"},

    {NULL,          NULL}
};

// Converter (ml_SVMSGD)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::SVMSGD> >
{
    static PyObject* from(const Ptr<cv::ml::SVMSGD>& r)
    {
        return pyopencv_ml_SVMSGD_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::SVMSGD>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::SVMSGD> * dst_;
        if (pyopencv_ml_SVMSGD_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::SVMSGD> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_StatModel (Generic)
//================================================================================

// GetSet (ml_StatModel)



// Methods (ml_StatModel)

static PyObject* pyopencv_cv_ml_ml_StatModel_calcError(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!pyopencv_ml_StatModel_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_StatModel' or its derivative)");
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    {
    PyObject* pyobj_data = NULL;
    Ptr<TrainData> data;
    bool test=0;
    PyObject* pyobj_resp = NULL;
    Mat resp;
    float retval;

    const char* keywords[] = { "data", "test", "resp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Ob|O:ml_StatModel.calcError", (char**)keywords, &pyobj_data, &test, &pyobj_resp) &&
        pyopencv_to(pyobj_data, data, ArgInfo("data", 0)) &&
        pyopencv_to(pyobj_resp, resp, ArgInfo("resp", 1)) )
    {
        ERRWRAP2(retval = _self_->calcError(data, test, resp));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(resp));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_data = NULL;
    Ptr<TrainData> data;
    bool test=0;
    PyObject* pyobj_resp = NULL;
    UMat resp;
    float retval;

    const char* keywords[] = { "data", "test", "resp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Ob|O:ml_StatModel.calcError", (char**)keywords, &pyobj_data, &test, &pyobj_resp) &&
        pyopencv_to(pyobj_data, data, ArgInfo("data", 0)) &&
        pyopencv_to(pyobj_resp, resp, ArgInfo("resp", 1)) )
    {
        ERRWRAP2(retval = _self_->calcError(data, test, resp));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(resp));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_StatModel_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!pyopencv_ml_StatModel_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_StatModel' or its derivative)");
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_StatModel_getVarCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!pyopencv_ml_StatModel_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_StatModel' or its derivative)");
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_StatModel_isClassifier(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!pyopencv_ml_StatModel_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_StatModel' or its derivative)");
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isClassifier());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_StatModel_isTrained(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!pyopencv_ml_StatModel_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_StatModel' or its derivative)");
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isTrained());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_StatModel_predict(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!pyopencv_ml_StatModel_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_StatModel' or its derivative)");
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    PyObject* pyobj_results = NULL;
    Mat results;
    int flags=0;
    float retval;

    const char* keywords[] = { "samples", "results", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ml_StatModel.predict", (char**)keywords, &pyobj_samples, &pyobj_results, &flags) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) )
    {
        ERRWRAP2(retval = _self_->predict(samples, results, flags));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(results));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    PyObject* pyobj_results = NULL;
    UMat results;
    int flags=0;
    float retval;

    const char* keywords[] = { "samples", "results", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ml_StatModel.predict", (char**)keywords, &pyobj_samples, &pyobj_results, &flags) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_results, results, ArgInfo("results", 1)) )
    {
        ERRWRAP2(retval = _self_->predict(samples, results, flags));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(results));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_StatModel_train(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::StatModel> * self1 = 0;
    if (!pyopencv_ml_StatModel_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_StatModel' or its derivative)");
    Ptr<cv::ml::StatModel> _self_ = *(self1);
    {
    PyObject* pyobj_trainData = NULL;
    Ptr<TrainData> trainData;
    int flags=0;
    bool retval;

    const char* keywords[] = { "trainData", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:ml_StatModel.train", (char**)keywords, &pyobj_trainData, &flags) &&
        pyopencv_to(pyobj_trainData, trainData, ArgInfo("trainData", 0)) )
    {
        ERRWRAP2(retval = _self_->train(trainData, flags));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    int layout=0;
    PyObject* pyobj_responses = NULL;
    Mat responses;
    bool retval;

    const char* keywords[] = { "samples", "layout", "responses", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO:ml_StatModel.train", (char**)keywords, &pyobj_samples, &layout, &pyobj_responses) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_responses, responses, ArgInfo("responses", 0)) )
    {
        ERRWRAP2(retval = _self_->train(samples, layout, responses));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    int layout=0;
    PyObject* pyobj_responses = NULL;
    UMat responses;
    bool retval;

    const char* keywords[] = { "samples", "layout", "responses", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO:ml_StatModel.train", (char**)keywords, &pyobj_samples, &layout, &pyobj_responses) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_responses, responses, ArgInfo("responses", 0)) )
    {
        ERRWRAP2(retval = _self_->train(samples, layout, responses));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (ml_StatModel)

static PyGetSetDef pyopencv_ml_StatModel_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_StatModel_methods[] =
{
    {"calcError", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_StatModel_calcError, 0), "calcError(data, test[, resp]) -> retval, resp\n.   @brief Computes error on the training or test dataset\n.   \n.       @param data the training data\n.       @param test if true, the error is computed over the test subset of the data, otherwise it's\n.           computed over the training subset of the data. Please note that if you loaded a completely\n.           different dataset to evaluate already trained classifier, you will probably want not to set\n.           the test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so\n.           that the error is computed for the whole new set. Yes, this sounds a bit confusing.\n.       @param resp the optional output responses.\n.   \n.       The method uses StatModel::predict to compute the error. For regression models the error is\n.       computed as RMS, for classifiers - as a percent of missclassified samples (0%-100%)."},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_StatModel_empty, 0), "empty() -> retval\n."},
    {"getVarCount", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_StatModel_getVarCount, 0), "getVarCount() -> retval\n.   @brief Returns the number of variables in training samples"},
    {"isClassifier", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_StatModel_isClassifier, 0), "isClassifier() -> retval\n.   @brief Returns true if the model is classifier"},
    {"isTrained", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_StatModel_isTrained, 0), "isTrained() -> retval\n.   @brief Returns true if the model is trained"},
    {"predict", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_StatModel_predict, 0), "predict(samples[, results[, flags]]) -> retval, results\n.   @brief Predicts response(s) for the provided sample(s)\n.   \n.       @param samples The input samples, floating-point matrix\n.       @param results The optional output matrix of results.\n.       @param flags The optional flags, model-dependent. See cv::ml::StatModel::Flags."},
    {"train", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_StatModel_train, 0), "train(trainData[, flags]) -> retval\n.   @brief Trains the statistical model\n.   \n.       @param trainData training data that can be loaded from file using TrainData::loadFromCSV or\n.           created with TrainData::create.\n.       @param flags optional flags, depending on the model. Some of the models can be updated with the\n.           new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP).\n\n\n\ntrain(samples, layout, responses) -> retval\n.   @brief Trains the statistical model\n.   \n.       @param samples training samples\n.       @param layout See ml::SampleTypes.\n.       @param responses vector of responses associated with the training samples."},

    {NULL,          NULL}
};

// Converter (ml_StatModel)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::StatModel> >
{
    static PyObject* from(const Ptr<cv::ml::StatModel>& r)
    {
        return pyopencv_ml_StatModel_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::StatModel>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::StatModel> * dst_;
        if (pyopencv_ml_StatModel_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::StatModel> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ml_TrainData (Generic)
//================================================================================

// GetSet (ml_TrainData)



// Methods (ml_TrainData)

static PyObject* pyopencv_cv_ml_ml_TrainData_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    {
    PyObject* pyobj_samples = NULL;
    Mat samples;
    int layout=0;
    PyObject* pyobj_responses = NULL;
    Mat responses;
    PyObject* pyobj_varIdx = NULL;
    Mat varIdx;
    PyObject* pyobj_sampleIdx = NULL;
    Mat sampleIdx;
    PyObject* pyobj_sampleWeights = NULL;
    Mat sampleWeights;
    PyObject* pyobj_varType = NULL;
    Mat varType;
    Ptr<TrainData> retval;

    const char* keywords[] = { "samples", "layout", "responses", "varIdx", "sampleIdx", "sampleWeights", "varType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO|OOOO:ml_TrainData.create", (char**)keywords, &pyobj_samples, &layout, &pyobj_responses, &pyobj_varIdx, &pyobj_sampleIdx, &pyobj_sampleWeights, &pyobj_varType) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_responses, responses, ArgInfo("responses", 0)) &&
        pyopencv_to(pyobj_varIdx, varIdx, ArgInfo("varIdx", 0)) &&
        pyopencv_to(pyobj_sampleIdx, sampleIdx, ArgInfo("sampleIdx", 0)) &&
        pyopencv_to(pyobj_sampleWeights, sampleWeights, ArgInfo("sampleWeights", 0)) &&
        pyopencv_to(pyobj_varType, varType, ArgInfo("varType", 0)) )
    {
        ERRWRAP2(retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_samples = NULL;
    UMat samples;
    int layout=0;
    PyObject* pyobj_responses = NULL;
    UMat responses;
    PyObject* pyobj_varIdx = NULL;
    UMat varIdx;
    PyObject* pyobj_sampleIdx = NULL;
    UMat sampleIdx;
    PyObject* pyobj_sampleWeights = NULL;
    UMat sampleWeights;
    PyObject* pyobj_varType = NULL;
    UMat varType;
    Ptr<TrainData> retval;

    const char* keywords[] = { "samples", "layout", "responses", "varIdx", "sampleIdx", "sampleWeights", "varType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OiO|OOOO:ml_TrainData.create", (char**)keywords, &pyobj_samples, &layout, &pyobj_responses, &pyobj_varIdx, &pyobj_sampleIdx, &pyobj_sampleWeights, &pyobj_varType) &&
        pyopencv_to(pyobj_samples, samples, ArgInfo("samples", 0)) &&
        pyopencv_to(pyobj_responses, responses, ArgInfo("responses", 0)) &&
        pyopencv_to(pyobj_varIdx, varIdx, ArgInfo("varIdx", 0)) &&
        pyopencv_to(pyobj_sampleIdx, sampleIdx, ArgInfo("sampleIdx", 0)) &&
        pyopencv_to(pyobj_sampleWeights, sampleWeights, ArgInfo("sampleWeights", 0)) &&
        pyopencv_to(pyobj_varType, varType, ArgInfo("varType", 0)) )
    {
        ERRWRAP2(retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getCatCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int vi=0;
    int retval;

    const char* keywords[] = { "vi", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ml_TrainData.getCatCount", (char**)keywords, &vi) )
    {
        ERRWRAP2(retval = _self_->getCatCount(vi));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getCatMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCatMap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getCatOfs(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCatOfs());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getClassLabels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getClassLabels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getDefaultSubstValues(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDefaultSubstValues());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getLayout(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLayout());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getMissing(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMissing());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getNAllVars(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNAllVars());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getNSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNSamples());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getNTestSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNTestSamples());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getNTrainSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNTrainSamples());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getNVars(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNVars());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getNames(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    PyObject* pyobj_names = NULL;
    vector_String names;

    const char* keywords[] = { "names", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ml_TrainData.getNames", (char**)keywords, &pyobj_names) &&
        pyopencv_to(pyobj_names, names, ArgInfo("names", 0)) )
    {
        ERRWRAP2(_self_->getNames(names));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getNormCatResponses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNormCatResponses());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getResponseType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getResponseType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getResponses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getResponses());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getSample(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    {
    PyObject* pyobj_varIdx = NULL;
    Mat varIdx;
    int sidx=0;
    float buf=0.f;

    const char* keywords[] = { "varIdx", "sidx", "buf", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oif:ml_TrainData.getSample", (char**)keywords, &pyobj_varIdx, &sidx, &buf) &&
        pyopencv_to(pyobj_varIdx, varIdx, ArgInfo("varIdx", 0)) )
    {
        ERRWRAP2(_self_->getSample(varIdx, sidx, &buf));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_varIdx = NULL;
    UMat varIdx;
    int sidx=0;
    float buf=0.f;

    const char* keywords[] = { "varIdx", "sidx", "buf", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oif:ml_TrainData.getSample", (char**)keywords, &pyobj_varIdx, &sidx, &buf) &&
        pyopencv_to(pyobj_varIdx, varIdx, ArgInfo("varIdx", 0)) )
    {
        ERRWRAP2(_self_->getSample(varIdx, sidx, &buf));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getSampleWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSampleWeights());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSamples());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getSubMatrix_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    {
    PyObject* pyobj_matrix = NULL;
    Mat matrix;
    PyObject* pyobj_idx = NULL;
    Mat idx;
    int layout=0;
    Mat retval;

    const char* keywords[] = { "matrix", "idx", "layout", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi:ml_TrainData.getSubMatrix", (char**)keywords, &pyobj_matrix, &pyobj_idx, &layout) &&
        pyopencv_to(pyobj_matrix, matrix, ArgInfo("matrix", 0)) &&
        pyopencv_to(pyobj_idx, idx, ArgInfo("idx", 0)) )
    {
        ERRWRAP2(retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_matrix = NULL;
    Mat matrix;
    PyObject* pyobj_idx = NULL;
    Mat idx;
    int layout=0;
    Mat retval;

    const char* keywords[] = { "matrix", "idx", "layout", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi:ml_TrainData.getSubMatrix", (char**)keywords, &pyobj_matrix, &pyobj_idx, &layout) &&
        pyopencv_to(pyobj_matrix, matrix, ArgInfo("matrix", 0)) &&
        pyopencv_to(pyobj_idx, idx, ArgInfo("idx", 0)) )
    {
        ERRWRAP2(retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getSubVector_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;

    {
    PyObject* pyobj_vec = NULL;
    Mat vec;
    PyObject* pyobj_idx = NULL;
    Mat idx;
    Mat retval;

    const char* keywords[] = { "vec", "idx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ml_TrainData.getSubVector", (char**)keywords, &pyobj_vec, &pyobj_idx) &&
        pyopencv_to(pyobj_vec, vec, ArgInfo("vec", 0)) &&
        pyopencv_to(pyobj_idx, idx, ArgInfo("idx", 0)) )
    {
        ERRWRAP2(retval = cv::ml::TrainData::getSubVector(vec, idx));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_vec = NULL;
    Mat vec;
    PyObject* pyobj_idx = NULL;
    Mat idx;
    Mat retval;

    const char* keywords[] = { "vec", "idx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ml_TrainData.getSubVector", (char**)keywords, &pyobj_vec, &pyobj_idx) &&
        pyopencv_to(pyobj_vec, vec, ArgInfo("vec", 0)) &&
        pyopencv_to(pyobj_idx, idx, ArgInfo("idx", 0)) )
    {
        ERRWRAP2(retval = cv::ml::TrainData::getSubVector(vec, idx));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTestNormCatResponses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTestNormCatResponses());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTestResponses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTestResponses());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTestSampleIdx(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTestSampleIdx());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTestSampleWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTestSampleWeights());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTestSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTestSamples());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTrainNormCatResponses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTrainNormCatResponses());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTrainResponses(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTrainResponses());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTrainSampleIdx(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTrainSampleIdx());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTrainSampleWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTrainSampleWeights());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getTrainSamples(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int layout=ROW_SAMPLE;
    bool compressSamples=true;
    bool compressVars=true;
    Mat retval;

    const char* keywords[] = { "layout", "compressSamples", "compressVars", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ibb:ml_TrainData.getTrainSamples", (char**)keywords, &layout, &compressSamples, &compressVars) )
    {
        ERRWRAP2(retval = _self_->getTrainSamples(layout, compressSamples, compressVars));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getValues(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    {
    int vi=0;
    PyObject* pyobj_sidx = NULL;
    Mat sidx;
    float values=0.f;

    const char* keywords[] = { "vi", "sidx", "values", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOf:ml_TrainData.getValues", (char**)keywords, &vi, &pyobj_sidx, &values) &&
        pyopencv_to(pyobj_sidx, sidx, ArgInfo("sidx", 0)) )
    {
        ERRWRAP2(_self_->getValues(vi, sidx, &values));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    int vi=0;
    PyObject* pyobj_sidx = NULL;
    UMat sidx;
    float values=0.f;

    const char* keywords[] = { "vi", "sidx", "values", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iOf:ml_TrainData.getValues", (char**)keywords, &vi, &pyobj_sidx, &values) &&
        pyopencv_to(pyobj_sidx, sidx, ArgInfo("sidx", 0)) )
    {
        ERRWRAP2(_self_->getValues(vi, sidx, &values));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getVarIdx(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarIdx());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getVarSymbolFlags(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarSymbolFlags());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_getVarType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getVarType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_setTrainTestSplit(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    int count=0;
    bool shuffle=true;

    const char* keywords[] = { "count", "shuffle", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|b:ml_TrainData.setTrainTestSplit", (char**)keywords, &count, &shuffle) )
    {
        ERRWRAP2(_self_->setTrainTestSplit(count, shuffle));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_setTrainTestSplitRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);
    double ratio=0;
    bool shuffle=true;

    const char* keywords[] = { "ratio", "shuffle", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d|b:ml_TrainData.setTrainTestSplitRatio", (char**)keywords, &ratio, &shuffle) )
    {
        ERRWRAP2(_self_->setTrainTestSplitRatio(ratio, shuffle));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ml_ml_TrainData_shuffleTrainTest(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ml;


    Ptr<cv::ml::TrainData> * self1 = 0;
    if (!pyopencv_ml_TrainData_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ml_TrainData' or its derivative)");
    Ptr<cv::ml::TrainData> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->shuffleTrainTest());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ml_TrainData)

static PyGetSetDef pyopencv_ml_TrainData_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ml_TrainData_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_create_static, METH_STATIC), "create(samples, layout, responses[, varIdx[, sampleIdx[, sampleWeights[, varType]]]]) -> retval\n.   @brief Creates training data from in-memory arrays.\n.   \n.       @param samples matrix of samples. It should have CV_32F type.\n.       @param layout see ml::SampleTypes.\n.       @param responses matrix of responses. If the responses are scalar, they should be stored as a\n.           single row or as a single column. The matrix should have type CV_32F or CV_32S (in the\n.           former case the responses are considered as ordered by default; in the latter case - as\n.           categorical)\n.       @param varIdx vector specifying which variables to use for training. It can be an integer vector\n.           (CV_32S) containing 0-based variable indices or byte vector (CV_8U) containing a mask of\n.           active variables.\n.       @param sampleIdx vector specifying which samples to use for training. It can be an integer\n.           vector (CV_32S) containing 0-based sample indices or byte vector (CV_8U) containing a mask\n.           of training samples.\n.       @param sampleWeights optional vector with weights for each sample. It should have CV_32F type.\n.       @param varType optional vector of type CV_8U and size `<number_of_variables_in_samples> +\n.           <number_of_variables_in_responses>`, containing types of each input and output variable. See\n.           ml::VariableTypes."},
    {"getCatCount", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getCatCount, 0), "getCatCount(vi) -> retval\n."},
    {"getCatMap", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getCatMap, 0), "getCatMap() -> retval\n."},
    {"getCatOfs", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getCatOfs, 0), "getCatOfs() -> retval\n."},
    {"getClassLabels", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getClassLabels, 0), "getClassLabels() -> retval\n.   @brief Returns the vector of class labels\n.   \n.       The function returns vector of unique labels occurred in the responses."},
    {"getDefaultSubstValues", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getDefaultSubstValues, 0), "getDefaultSubstValues() -> retval\n."},
    {"getLayout", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getLayout, 0), "getLayout() -> retval\n."},
    {"getMissing", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getMissing, 0), "getMissing() -> retval\n."},
    {"getNAllVars", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getNAllVars, 0), "getNAllVars() -> retval\n."},
    {"getNSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getNSamples, 0), "getNSamples() -> retval\n."},
    {"getNTestSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getNTestSamples, 0), "getNTestSamples() -> retval\n."},
    {"getNTrainSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getNTrainSamples, 0), "getNTrainSamples() -> retval\n."},
    {"getNVars", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getNVars, 0), "getNVars() -> retval\n."},
    {"getNames", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getNames, 0), "getNames(names) -> None\n.   @brief Returns vector of symbolic names captured in loadFromCSV()"},
    {"getNormCatResponses", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getNormCatResponses, 0), "getNormCatResponses() -> retval\n."},
    {"getResponseType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getResponseType, 0), "getResponseType() -> retval\n."},
    {"getResponses", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getResponses, 0), "getResponses() -> retval\n."},
    {"getSample", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getSample, 0), "getSample(varIdx, sidx, buf) -> None\n."},
    {"getSampleWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getSampleWeights, 0), "getSampleWeights() -> retval\n."},
    {"getSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getSamples, 0), "getSamples() -> retval\n."},
    {"getSubMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getSubMatrix_static, METH_STATIC), "getSubMatrix(matrix, idx, layout) -> retval\n.   @brief Extract from matrix rows/cols specified by passed indexes.\n.       @param matrix input matrix (supported types: CV_32S, CV_32F, CV_64F)\n.       @param idx 1D index vector\n.       @param layout specifies to extract rows (cv::ml::ROW_SAMPLES) or to extract columns (cv::ml::COL_SAMPLES)"},
    {"getSubVector", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getSubVector_static, METH_STATIC), "getSubVector(vec, idx) -> retval\n.   @brief Extract from 1D vector elements specified by passed indexes.\n.       @param vec input vector (supported types: CV_32S, CV_32F, CV_64F)\n.       @param idx 1D index vector"},
    {"getTestNormCatResponses", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTestNormCatResponses, 0), "getTestNormCatResponses() -> retval\n."},
    {"getTestResponses", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTestResponses, 0), "getTestResponses() -> retval\n."},
    {"getTestSampleIdx", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTestSampleIdx, 0), "getTestSampleIdx() -> retval\n."},
    {"getTestSampleWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTestSampleWeights, 0), "getTestSampleWeights() -> retval\n."},
    {"getTestSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTestSamples, 0), "getTestSamples() -> retval\n.   @brief Returns matrix of test samples"},
    {"getTrainNormCatResponses", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTrainNormCatResponses, 0), "getTrainNormCatResponses() -> retval\n.   @brief Returns the vector of normalized categorical responses\n.   \n.       The function returns vector of responses. Each response is integer from `0` to `<number of\n.       classes>-1`. The actual label value can be retrieved then from the class label vector, see\n.       TrainData::getClassLabels."},
    {"getTrainResponses", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTrainResponses, 0), "getTrainResponses() -> retval\n.   @brief Returns the vector of responses\n.   \n.       The function returns ordered or the original categorical responses. Usually it's used in\n.       regression algorithms."},
    {"getTrainSampleIdx", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTrainSampleIdx, 0), "getTrainSampleIdx() -> retval\n."},
    {"getTrainSampleWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTrainSampleWeights, 0), "getTrainSampleWeights() -> retval\n."},
    {"getTrainSamples", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getTrainSamples, 0), "getTrainSamples([, layout[, compressSamples[, compressVars]]]) -> retval\n.   @brief Returns matrix of train samples\n.   \n.       @param layout The requested layout. If it's different from the initial one, the matrix is\n.           transposed. See ml::SampleTypes.\n.       @param compressSamples if true, the function returns only the training samples (specified by\n.           sampleIdx)\n.       @param compressVars if true, the function returns the shorter training samples, containing only\n.           the active variables.\n.   \n.       In current implementation the function tries to avoid physical data copying and returns the\n.       matrix stored inside TrainData (unless the transposition or compression is needed)."},
    {"getValues", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getValues, 0), "getValues(vi, sidx, values) -> None\n."},
    {"getVarIdx", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getVarIdx, 0), "getVarIdx() -> retval\n."},
    {"getVarSymbolFlags", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getVarSymbolFlags, 0), "getVarSymbolFlags() -> retval\n."},
    {"getVarType", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_getVarType, 0), "getVarType() -> retval\n."},
    {"setTrainTestSplit", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_setTrainTestSplit, 0), "setTrainTestSplit(count[, shuffle]) -> None\n.   @brief Splits the training data into the training and test parts\n.       @sa TrainData::setTrainTestSplitRatio"},
    {"setTrainTestSplitRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_setTrainTestSplitRatio, 0), "setTrainTestSplitRatio(ratio[, shuffle]) -> None\n.   @brief Splits the training data into the training and test parts\n.   \n.       The function selects a subset of specified relative size and then returns it as the training\n.       set. If the function is not called, all the data is used for training. Please, note that for\n.       each of TrainData::getTrain\\* there is corresponding TrainData::getTest\\*, so that the test\n.       subset can be retrieved and processed as well.\n.       @sa TrainData::setTrainTestSplit"},
    {"shuffleTrainTest", CV_PY_FN_WITH_KW_(pyopencv_cv_ml_ml_TrainData_shuffleTrainTest, 0), "shuffleTrainTest() -> None\n."},

    {NULL,          NULL}
};

// Converter (ml_TrainData)

template<>
struct PyOpenCV_Converter< Ptr<cv::ml::TrainData> >
{
    static PyObject* from(const Ptr<cv::ml::TrainData>& r)
    {
        return pyopencv_ml_TrainData_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ml::TrainData>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ml::TrainData> * dst_;
        if (pyopencv_ml_TrainData_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ml::TrainData> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ocl_Device (Generic)
//================================================================================

// GetSet (ocl_Device)



// Methods (ocl_Device)

static int pyopencv_cv_ocl_ocl_Device_Device(pyopencv_ocl_Device_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        if(self) ERRWRAP2(new (&(self->v)) cv::ocl::Device());
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_OpenCLVersion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->OpenCLVersion());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_OpenCL_C_Version(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->OpenCL_C_Version());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_addressBits(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->addressBits());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_available(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->available());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_compilerAvailable(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->compilerAvailable());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_deviceVersionMajor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->deviceVersionMajor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_deviceVersionMinor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->deviceVersionMinor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_doubleFPConfig(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->doubleFPConfig());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_driverVersion(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->driverVersion());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_endianLittle(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->endianLittle());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_errorCorrectionSupport(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->errorCorrectionSupport());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_executionCapabilities(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->executionCapabilities());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_extensions(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->extensions());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_getDefault_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;

    Device retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ocl::Device::getDefault());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_globalMemCacheLineSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->globalMemCacheLineSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_globalMemCacheSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->globalMemCacheSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_globalMemCacheType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->globalMemCacheType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_globalMemSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->globalMemSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_halfFPConfig(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->halfFPConfig());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_hostUnifiedMemory(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->hostUnifiedMemory());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_image2DMaxHeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->image2DMaxHeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_image2DMaxWidth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->image2DMaxWidth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_image3DMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->image3DMaxDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_image3DMaxHeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->image3DMaxHeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_image3DMaxWidth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->image3DMaxWidth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_imageFromBufferSupport(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->imageFromBufferSupport());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_imageMaxArraySize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->imageMaxArraySize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_imageMaxBufferSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->imageMaxBufferSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_imageSupport(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->imageSupport());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_intelSubgroupsSupport(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->intelSubgroupsSupport());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_isAMD(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isAMD());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_isExtensionSupported(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    PyObject* pyobj_extensionName = NULL;
    String extensionName;
    bool retval;

    const char* keywords[] = { "extensionName", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ocl_Device.isExtensionSupported", (char**)keywords, &pyobj_extensionName) &&
        pyopencv_to(pyobj_extensionName, extensionName, ArgInfo("extensionName", 0)) )
    {
        ERRWRAP2(retval = _self_->isExtensionSupported(extensionName));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_isIntel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isIntel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_isNVidia(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->isNVidia());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_linkerAvailable(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->linkerAvailable());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_localMemSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->localMemSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_localMemType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->localMemType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxClockFrequency(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxClockFrequency());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxComputeUnits(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxComputeUnits());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxConstantArgs(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxConstantArgs());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxConstantBufferSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxConstantBufferSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxMemAllocSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxMemAllocSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxParameterSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxParameterSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxReadImageArgs(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxReadImageArgs());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxSamplers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxSamplers());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxWorkGroupSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxWorkGroupSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxWorkItemDims(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxWorkItemDims());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_maxWriteImageArgs(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->maxWriteImageArgs());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_memBaseAddrAlign(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->memBaseAddrAlign());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_name(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->name());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_nativeVectorWidthChar(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->nativeVectorWidthChar());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_nativeVectorWidthDouble(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->nativeVectorWidthDouble());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_nativeVectorWidthFloat(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->nativeVectorWidthFloat());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_nativeVectorWidthHalf(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->nativeVectorWidthHalf());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_nativeVectorWidthInt(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->nativeVectorWidthInt());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_nativeVectorWidthLong(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->nativeVectorWidthLong());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_nativeVectorWidthShort(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->nativeVectorWidthShort());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_preferredVectorWidthChar(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->preferredVectorWidthChar());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_preferredVectorWidthDouble(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->preferredVectorWidthDouble());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_preferredVectorWidthFloat(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->preferredVectorWidthFloat());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_preferredVectorWidthHalf(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->preferredVectorWidthHalf());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_preferredVectorWidthInt(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->preferredVectorWidthInt());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_preferredVectorWidthLong(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->preferredVectorWidthLong());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_preferredVectorWidthShort(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->preferredVectorWidthShort());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_printfBufferSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->printfBufferSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_profilingTimerResolution(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->profilingTimerResolution());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_singleFPConfig(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->singleFPConfig());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_type(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->type());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_vendorID(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->vendorID());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_vendorName(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->vendorName());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ocl_ocl_Device_version(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ocl;


    cv::ocl::Device * self1 = 0;
    if (!pyopencv_ocl_Device_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ocl_Device' or its derivative)");
    cv::ocl::Device* _self_ = (self1);
    String retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->version());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (ocl_Device)

static PyGetSetDef pyopencv_ocl_Device_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ocl_Device_methods[] =
{
    {"OpenCLVersion", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_OpenCLVersion, 0), "OpenCLVersion() -> retval\n."},
    {"OpenCL_C_Version", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_OpenCL_C_Version, 0), "OpenCL_C_Version() -> retval\n."},
    {"addressBits", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_addressBits, 0), "addressBits() -> retval\n."},
    {"available", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_available, 0), "available() -> retval\n."},
    {"compilerAvailable", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_compilerAvailable, 0), "compilerAvailable() -> retval\n."},
    {"deviceVersionMajor", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_deviceVersionMajor, 0), "deviceVersionMajor() -> retval\n."},
    {"deviceVersionMinor", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_deviceVersionMinor, 0), "deviceVersionMinor() -> retval\n."},
    {"doubleFPConfig", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_doubleFPConfig, 0), "doubleFPConfig() -> retval\n."},
    {"driverVersion", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_driverVersion, 0), "driverVersion() -> retval\n."},
    {"endianLittle", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_endianLittle, 0), "endianLittle() -> retval\n."},
    {"errorCorrectionSupport", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_errorCorrectionSupport, 0), "errorCorrectionSupport() -> retval\n."},
    {"executionCapabilities", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_executionCapabilities, 0), "executionCapabilities() -> retval\n."},
    {"extensions", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_extensions, 0), "extensions() -> retval\n."},
    {"getDefault", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_getDefault_static, METH_STATIC), "getDefault() -> retval\n."},
    {"globalMemCacheLineSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_globalMemCacheLineSize, 0), "globalMemCacheLineSize() -> retval\n."},
    {"globalMemCacheSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_globalMemCacheSize, 0), "globalMemCacheSize() -> retval\n."},
    {"globalMemCacheType", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_globalMemCacheType, 0), "globalMemCacheType() -> retval\n."},
    {"globalMemSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_globalMemSize, 0), "globalMemSize() -> retval\n."},
    {"halfFPConfig", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_halfFPConfig, 0), "halfFPConfig() -> retval\n."},
    {"hostUnifiedMemory", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_hostUnifiedMemory, 0), "hostUnifiedMemory() -> retval\n."},
    {"image2DMaxHeight", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_image2DMaxHeight, 0), "image2DMaxHeight() -> retval\n."},
    {"image2DMaxWidth", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_image2DMaxWidth, 0), "image2DMaxWidth() -> retval\n."},
    {"image3DMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_image3DMaxDepth, 0), "image3DMaxDepth() -> retval\n."},
    {"image3DMaxHeight", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_image3DMaxHeight, 0), "image3DMaxHeight() -> retval\n."},
    {"image3DMaxWidth", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_image3DMaxWidth, 0), "image3DMaxWidth() -> retval\n."},
    {"imageFromBufferSupport", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_imageFromBufferSupport, 0), "imageFromBufferSupport() -> retval\n."},
    {"imageMaxArraySize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_imageMaxArraySize, 0), "imageMaxArraySize() -> retval\n."},
    {"imageMaxBufferSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_imageMaxBufferSize, 0), "imageMaxBufferSize() -> retval\n."},
    {"imageSupport", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_imageSupport, 0), "imageSupport() -> retval\n."},
    {"intelSubgroupsSupport", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_intelSubgroupsSupport, 0), "intelSubgroupsSupport() -> retval\n."},
    {"isAMD", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_isAMD, 0), "isAMD() -> retval\n."},
    {"isExtensionSupported", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_isExtensionSupported, 0), "isExtensionSupported(extensionName) -> retval\n."},
    {"isIntel", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_isIntel, 0), "isIntel() -> retval\n."},
    {"isNVidia", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_isNVidia, 0), "isNVidia() -> retval\n."},
    {"linkerAvailable", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_linkerAvailable, 0), "linkerAvailable() -> retval\n."},
    {"localMemSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_localMemSize, 0), "localMemSize() -> retval\n."},
    {"localMemType", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_localMemType, 0), "localMemType() -> retval\n."},
    {"maxClockFrequency", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxClockFrequency, 0), "maxClockFrequency() -> retval\n."},
    {"maxComputeUnits", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxComputeUnits, 0), "maxComputeUnits() -> retval\n."},
    {"maxConstantArgs", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxConstantArgs, 0), "maxConstantArgs() -> retval\n."},
    {"maxConstantBufferSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxConstantBufferSize, 0), "maxConstantBufferSize() -> retval\n."},
    {"maxMemAllocSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxMemAllocSize, 0), "maxMemAllocSize() -> retval\n."},
    {"maxParameterSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxParameterSize, 0), "maxParameterSize() -> retval\n."},
    {"maxReadImageArgs", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxReadImageArgs, 0), "maxReadImageArgs() -> retval\n."},
    {"maxSamplers", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxSamplers, 0), "maxSamplers() -> retval\n."},
    {"maxWorkGroupSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxWorkGroupSize, 0), "maxWorkGroupSize() -> retval\n."},
    {"maxWorkItemDims", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxWorkItemDims, 0), "maxWorkItemDims() -> retval\n."},
    {"maxWriteImageArgs", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_maxWriteImageArgs, 0), "maxWriteImageArgs() -> retval\n."},
    {"memBaseAddrAlign", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_memBaseAddrAlign, 0), "memBaseAddrAlign() -> retval\n."},
    {"name", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_name, 0), "name() -> retval\n."},
    {"nativeVectorWidthChar", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_nativeVectorWidthChar, 0), "nativeVectorWidthChar() -> retval\n."},
    {"nativeVectorWidthDouble", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_nativeVectorWidthDouble, 0), "nativeVectorWidthDouble() -> retval\n."},
    {"nativeVectorWidthFloat", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_nativeVectorWidthFloat, 0), "nativeVectorWidthFloat() -> retval\n."},
    {"nativeVectorWidthHalf", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_nativeVectorWidthHalf, 0), "nativeVectorWidthHalf() -> retval\n."},
    {"nativeVectorWidthInt", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_nativeVectorWidthInt, 0), "nativeVectorWidthInt() -> retval\n."},
    {"nativeVectorWidthLong", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_nativeVectorWidthLong, 0), "nativeVectorWidthLong() -> retval\n."},
    {"nativeVectorWidthShort", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_nativeVectorWidthShort, 0), "nativeVectorWidthShort() -> retval\n."},
    {"preferredVectorWidthChar", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_preferredVectorWidthChar, 0), "preferredVectorWidthChar() -> retval\n."},
    {"preferredVectorWidthDouble", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_preferredVectorWidthDouble, 0), "preferredVectorWidthDouble() -> retval\n."},
    {"preferredVectorWidthFloat", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_preferredVectorWidthFloat, 0), "preferredVectorWidthFloat() -> retval\n."},
    {"preferredVectorWidthHalf", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_preferredVectorWidthHalf, 0), "preferredVectorWidthHalf() -> retval\n."},
    {"preferredVectorWidthInt", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_preferredVectorWidthInt, 0), "preferredVectorWidthInt() -> retval\n."},
    {"preferredVectorWidthLong", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_preferredVectorWidthLong, 0), "preferredVectorWidthLong() -> retval\n."},
    {"preferredVectorWidthShort", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_preferredVectorWidthShort, 0), "preferredVectorWidthShort() -> retval\n."},
    {"printfBufferSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_printfBufferSize, 0), "printfBufferSize() -> retval\n."},
    {"profilingTimerResolution", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_profilingTimerResolution, 0), "profilingTimerResolution() -> retval\n."},
    {"singleFPConfig", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_singleFPConfig, 0), "singleFPConfig() -> retval\n."},
    {"type", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_type, 0), "type() -> retval\n."},
    {"vendorID", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_vendorID, 0), "vendorID() -> retval\n."},
    {"vendorName", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_vendorName, 0), "vendorName() -> retval\n."},
    {"version", CV_PY_FN_WITH_KW_(pyopencv_cv_ocl_ocl_Device_version, 0), "version() -> retval\n."},

    {NULL,          NULL}
};

// Converter (ocl_Device)

template<>
struct PyOpenCV_Converter< cv::ocl::Device >
{
    static PyObject* from(const cv::ocl::Device& r)
    {
        return pyopencv_ocl_Device_Instance(r);
    }
    static bool to(PyObject* src, cv::ocl::Device& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        cv::ocl::Device * dst_;
        if (pyopencv_ocl_Device_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected cv::ocl::Device for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_DenseRLOFOpticalFlow (Generic)
//================================================================================

// GetSet (optflow_DenseRLOFOpticalFlow)



// Methods (optflow_DenseRLOFOpticalFlow)

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;

    PyObject* pyobj_rlofParam = NULL;
    Ptr<RLOFOpticalFlowParameter> rlofParam;
    float forwardBackwardThreshold=1.f;
    PyObject* pyobj_gridStep = NULL;
    Size gridStep=Size(6, 6);
    PyObject* pyobj_interp_type = NULL;
    InterpolationType interp_type=InterpolationType::INTERP_EPIC;
    int epicK=128;
    float epicSigma=0.05f;
    float epicLambda=999.0f;
    bool use_post_proc=true;
    float fgsLambda=500.0f;
    float fgsSigma=1.5f;
    Ptr<DenseRLOFOpticalFlow> retval;

    const char* keywords[] = { "rlofParam", "forwardBackwardThreshold", "gridStep", "interp_type", "epicK", "epicSigma", "epicLambda", "use_post_proc", "fgsLambda", "fgsSigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OfOOiffbff:optflow_DenseRLOFOpticalFlow.create", (char**)keywords, &pyobj_rlofParam, &forwardBackwardThreshold, &pyobj_gridStep, &pyobj_interp_type, &epicK, &epicSigma, &epicLambda, &use_post_proc, &fgsLambda, &fgsSigma) &&
        pyopencv_to(pyobj_rlofParam, rlofParam, ArgInfo("rlofParam", 0)) &&
        pyopencv_to(pyobj_gridStep, gridStep, ArgInfo("gridStep", 0)) &&
        pyopencv_to(pyobj_interp_type, interp_type, ArgInfo("interp_type", 0)) )
    {
        ERRWRAP2(retval = cv::optflow::DenseRLOFOpticalFlow::create(rlofParam, forwardBackwardThreshold, gridStep, interp_type, epicK, epicSigma, epicLambda, use_post_proc, fgsLambda, fgsSigma));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getEPICK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEPICK());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getEPICLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEPICLambda());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getEPICSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEPICSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getFgsLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFgsLambda());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getFgsSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFgsSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getForwardBackward(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getForwardBackward());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getGridStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    Size retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGridStep());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getInterpolation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    InterpolationType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInterpolation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getRLOFOpticalFlowParameter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    Ptr<RLOFOpticalFlowParameter> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRLOFOpticalFlowParameter());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getUsePostProc(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUsePostProc());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setEPICK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_DenseRLOFOpticalFlow.setEPICK", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setEPICK(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setEPICLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_DenseRLOFOpticalFlow.setEPICLambda", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setEPICLambda(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setEPICSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_DenseRLOFOpticalFlow.setEPICSigma", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setEPICSigma(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setFgsLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_DenseRLOFOpticalFlow.setFgsLambda", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setFgsLambda(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setFgsSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_DenseRLOFOpticalFlow.setFgsSigma", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setFgsSigma(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setForwardBackward(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_DenseRLOFOpticalFlow.setForwardBackward", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setForwardBackward(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setGridStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    Size val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:optflow_DenseRLOFOpticalFlow.setGridStep", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setGridStep(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setInterpolation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    InterpolationType val=static_cast<InterpolationType>(0);

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:optflow_DenseRLOFOpticalFlow.setInterpolation", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setInterpolation(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setRLOFOpticalFlowParameter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    Ptr<RLOFOpticalFlowParameter> val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:optflow_DenseRLOFOpticalFlow.setRLOFOpticalFlowParameter", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setRLOFOpticalFlowParameter(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setUsePostProc(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DenseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DenseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DenseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::DenseRLOFOpticalFlow> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:optflow_DenseRLOFOpticalFlow.setUsePostProc", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUsePostProc(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (optflow_DenseRLOFOpticalFlow)

static PyGetSetDef pyopencv_optflow_DenseRLOFOpticalFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_DenseRLOFOpticalFlow_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_create_static, METH_STATIC), "create([, rlofParam[, forwardBackwardThreshold[, gridStep[, interp_type[, epicK[, epicSigma[, epicLambda[, use_post_proc[, fgsLambda[, fgsSigma]]]]]]]]]]) -> retval\n.   *    @param rlofParam see optflow::RLOFOpticalFlowParameter\n.        *    @param forwardBackwardThreshold see setForwardBackward\n.        *    @param gridStep see setGridStep\n.        *    @param interp_type see setInterpolation\n.        *    @param epicK see setEPICK\n.        *    @param epicSigma see setEPICSigma\n.        *    @param epicLambda see setEPICLambda\n.        *    @param use_post_proc see setUsePostProc\n.        *    @param fgsLambda see setFgsLambda\n.        *    @param fgsSigma see setFgsSigma"},
    {"getEPICK", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getEPICK, 0), "getEPICK() -> retval\n.   K is a number of nearest-neighbor matches considered, when fitting a locally affine\n.        *    model. Usually it should be around 128. However, lower values would make the interpolation noticeably faster.\n.        *    @see ximgproc::EdgeAwareInterpolator,  setEPICK"},
    {"getEPICLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getEPICLambda, 0), "getEPICLambda() -> retval\n.   Lambda is a parameter defining the weight of the edge-aware term in geodesic distance,\n.        *    should be in the range of 0 to 1000.\n.        *    @see ximgproc::EdgeAwareInterpolator, setEPICSigma"},
    {"getEPICSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getEPICSigma, 0), "getEPICSigma() -> retval\n.   Sigma is a parameter defining how fast the weights decrease in the locally-weighted affine\n.        *  fitting. Higher values can help preserve fine details, lower values can help to get rid of noise in the\n.        *  output flow.\n.        *    @see ximgproc::EdgeAwareInterpolator, setEPICSigma"},
    {"getFgsLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getFgsLambda, 0), "getFgsLambda() -> retval\n.   Sets the respective fastGlobalSmootherFilter() parameter.\n.        *    @see ximgproc::EdgeAwareInterpolator, setFgsLambda"},
    {"getFgsSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getFgsSigma, 0), "getFgsSigma() -> retval\n.   Sets the respective fastGlobalSmootherFilter() parameter.\n.        *    @see ximgproc::EdgeAwareInterpolator, ximgproc::fastGlobalSmootherFilter, setFgsSigma"},
    {"getForwardBackward", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getForwardBackward, 0), "getForwardBackward() -> retval\n.   @copybrief setForwardBackward\n.           @see setForwardBackward"},
    {"getGridStep", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getGridStep, 0), "getGridStep() -> retval\n.   For each grid point a motion vector is computed. Some motion vectors will be removed due to the forwatd backward\n.        *  threshold (if set >0). The rest will be the base of the vector field interpolation.\n.        *    @see getForwardBackward, setGridStep"},
    {"getInterpolation", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getInterpolation, 0), "getInterpolation() -> retval\n.   @copybrief setInterpolation\n.        *    @see ximgproc::EdgeAwareInterpolator, setInterpolation"},
    {"getRLOFOpticalFlowParameter", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getRLOFOpticalFlowParameter, 0), "getRLOFOpticalFlowParameter() -> retval\n.   @copybrief setRLOFOpticalFlowParameter\n.           @see optflow::RLOFOpticalFlowParameter, setRLOFOpticalFlowParameter"},
    {"getUsePostProc", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_getUsePostProc, 0), "getUsePostProc() -> retval\n.   @copybrief setUsePostProc\n.        *    @see ximgproc::fastGlobalSmootherFilter, setUsePostProc"},
    {"setEPICK", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setEPICK, 0), "setEPICK(val) -> None\n.   @copybrief getEPICK\n.        *    @see ximgproc::EdgeAwareInterpolator, getEPICK"},
    {"setEPICLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setEPICLambda, 0), "setEPICLambda(val) -> None\n.   @copybrief getEPICLambda\n.        *    @see ximgproc::EdgeAwareInterpolator, getEPICLambda"},
    {"setEPICSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setEPICSigma, 0), "setEPICSigma(val) -> None\n.   @copybrief getEPICSigma\n.        *  @see ximgproc::EdgeAwareInterpolator, getEPICSigma"},
    {"setFgsLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setFgsLambda, 0), "setFgsLambda(val) -> None\n.   @copybrief getFgsLambda\n.        *    @see ximgproc::EdgeAwareInterpolator, ximgproc::fastGlobalSmootherFilter, getFgsLambda"},
    {"setFgsSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setFgsSigma, 0), "setFgsSigma(val) -> None\n.   @copybrief getFgsSigma\n.        *    @see ximgproc::EdgeAwareInterpolator, ximgproc::fastGlobalSmootherFilter, getFgsSigma"},
    {"setForwardBackward", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setForwardBackward, 0), "setForwardBackward(val) -> None\n.   For each grid point \\f$ \\mathbf{x} \\f$ a motion vector \\f$ d_{I0,I1}(\\mathbf{x}) \\f$ is computed.\n.        *     If the forward backward error \\f[ EP_{FB} = || d_{I0,I1} + d_{I1,I0} || \\f]\n.        *     is larger than threshold given by this function then the motion vector will not be used by the following\n.        *    vector field interpolation. \\f$ d_{I1,I0} \\f$ denotes the backward flow. Note, the forward backward test\n.        *    will only be applied if the threshold > 0. This may results into a doubled runtime for the motion estimation.\n.        *    @see getForwardBackward, setGridStep"},
    {"setGridStep", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setGridStep, 0), "setGridStep(val) -> None\n.   @copybrief getGridStep\n.        *    @see getGridStep"},
    {"setInterpolation", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setInterpolation, 0), "setInterpolation(val) -> None\n.   Two interpolation algorithms are supported\n.        * - **INTERP_GEO** applies the fast geodesic interpolation, see @cite Geistert2016.\n.        * - **INTERP_EPIC_RESIDUAL** applies the edge-preserving interpolation, see @cite Revaud2015,Geistert2016.\n.        * @see ximgproc::EdgeAwareInterpolator, getInterpolation"},
    {"setRLOFOpticalFlowParameter", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setRLOFOpticalFlowParameter, 0), "setRLOFOpticalFlowParameter(val) -> None\n.   @see optflow::RLOFOpticalFlowParameter, getRLOFOpticalFlowParameter"},
    {"setUsePostProc", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DenseRLOFOpticalFlow_setUsePostProc, 0), "setUsePostProc(val) -> None\n.   * @see getUsePostProc"},

    {NULL,          NULL}
};

// Converter (optflow_DenseRLOFOpticalFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::DenseRLOFOpticalFlow> >
{
    static PyObject* from(const Ptr<cv::optflow::DenseRLOFOpticalFlow>& r)
    {
        return pyopencv_optflow_DenseRLOFOpticalFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::DenseRLOFOpticalFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::DenseRLOFOpticalFlow> * dst_;
        if (pyopencv_optflow_DenseRLOFOpticalFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::DenseRLOFOpticalFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_DualTVL1OpticalFlow (Generic)
//================================================================================

// GetSet (optflow_DualTVL1OpticalFlow)



// Methods (optflow_DualTVL1OpticalFlow)

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;

    double tau=0.25;
    double lambda=0.15;
    double theta=0.3;
    int nscales=5;
    int warps=5;
    double epsilon=0.01;
    int innnerIterations=30;
    int outerIterations=10;
    double scaleStep=0.8;
    double gamma=0.0;
    int medianFiltering=5;
    bool useInitialFlow=false;
    Ptr<DualTVL1OpticalFlow> retval;

    const char* keywords[] = { "tau", "lambda", "theta", "nscales", "warps", "epsilon", "innnerIterations", "outerIterations", "scaleStep", "gamma", "medianFiltering", "useInitialFlow", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|dddiidiiddib:optflow_DualTVL1OpticalFlow.create", (char**)keywords, &tau, &lambda, &theta, &nscales, &warps, &epsilon, &innnerIterations, &outerIterations, &scaleStep, &gamma, &medianFiltering, &useInitialFlow) )
    {
        ERRWRAP2(retval = cv::optflow::DualTVL1OpticalFlow::create(tau, lambda, theta, nscales, warps, epsilon, innnerIterations, outerIterations, scaleStep, gamma, medianFiltering, useInitialFlow));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getEpsilon(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEpsilon());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGamma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getInnerIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInnerIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLambda());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getMedianFiltering(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMedianFiltering());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getOuterIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getOuterIterations());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getScaleStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScaleStep());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getScalesNumber(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScalesNumber());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getTau(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTau());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getTheta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTheta());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getUseInitialFlow(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseInitialFlow());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getWarpingsNumber(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWarpingsNumber());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setEpsilon(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:optflow_DualTVL1OpticalFlow.setEpsilon", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setEpsilon(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:optflow_DualTVL1OpticalFlow.setGamma", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setGamma(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setInnerIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_DualTVL1OpticalFlow.setInnerIterations", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setInnerIterations(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:optflow_DualTVL1OpticalFlow.setLambda", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setLambda(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setMedianFiltering(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_DualTVL1OpticalFlow.setMedianFiltering", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMedianFiltering(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setOuterIterations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_DualTVL1OpticalFlow.setOuterIterations", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setOuterIterations(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setScaleStep(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:optflow_DualTVL1OpticalFlow.setScaleStep", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setScaleStep(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setScalesNumber(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_DualTVL1OpticalFlow.setScalesNumber", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setScalesNumber(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setTau(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:optflow_DualTVL1OpticalFlow.setTau", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTau(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setTheta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:optflow_DualTVL1OpticalFlow.setTheta", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTheta(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setUseInitialFlow(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:optflow_DualTVL1OpticalFlow.setUseInitialFlow", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUseInitialFlow(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setWarpingsNumber(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::DualTVL1OpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_DualTVL1OpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_DualTVL1OpticalFlow' or its derivative)");
    Ptr<cv::optflow::DualTVL1OpticalFlow> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_DualTVL1OpticalFlow.setWarpingsNumber", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setWarpingsNumber(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (optflow_DualTVL1OpticalFlow)

static PyGetSetDef pyopencv_optflow_DualTVL1OpticalFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_DualTVL1OpticalFlow_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_create_static, METH_STATIC), "create([, tau[, lambda[, theta[, nscales[, warps[, epsilon[, innnerIterations[, outerIterations[, scaleStep[, gamma[, medianFiltering[, useInitialFlow]]]]]]]]]]]]) -> retval\n.   @brief Creates instance of cv::DualTVL1OpticalFlow"},
    {"getEpsilon", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getEpsilon, 0), "getEpsilon() -> retval\n.   @see setEpsilon"},
    {"getGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getGamma, 0), "getGamma() -> retval\n.   @see setGamma"},
    {"getInnerIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getInnerIterations, 0), "getInnerIterations() -> retval\n.   @see setInnerIterations"},
    {"getLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getLambda, 0), "getLambda() -> retval\n.   @see setLambda"},
    {"getMedianFiltering", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getMedianFiltering, 0), "getMedianFiltering() -> retval\n.   @see setMedianFiltering"},
    {"getOuterIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getOuterIterations, 0), "getOuterIterations() -> retval\n.   @see setOuterIterations"},
    {"getScaleStep", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getScaleStep, 0), "getScaleStep() -> retval\n.   @see setScaleStep"},
    {"getScalesNumber", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getScalesNumber, 0), "getScalesNumber() -> retval\n.   @see setScalesNumber"},
    {"getTau", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getTau, 0), "getTau() -> retval\n.   @see setTau"},
    {"getTheta", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getTheta, 0), "getTheta() -> retval\n.   @see setTheta"},
    {"getUseInitialFlow", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getUseInitialFlow, 0), "getUseInitialFlow() -> retval\n.   @see setUseInitialFlow"},
    {"getWarpingsNumber", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_getWarpingsNumber, 0), "getWarpingsNumber() -> retval\n.   @see setWarpingsNumber"},
    {"setEpsilon", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setEpsilon, 0), "setEpsilon(val) -> None\n.   @copybrief getEpsilon @see getEpsilon"},
    {"setGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setGamma, 0), "setGamma(val) -> None\n.   @copybrief getGamma @see getGamma"},
    {"setInnerIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setInnerIterations, 0), "setInnerIterations(val) -> None\n.   @copybrief getInnerIterations @see getInnerIterations"},
    {"setLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setLambda, 0), "setLambda(val) -> None\n.   @copybrief getLambda @see getLambda"},
    {"setMedianFiltering", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setMedianFiltering, 0), "setMedianFiltering(val) -> None\n.   @copybrief getMedianFiltering @see getMedianFiltering"},
    {"setOuterIterations", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setOuterIterations, 0), "setOuterIterations(val) -> None\n.   @copybrief getOuterIterations @see getOuterIterations"},
    {"setScaleStep", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setScaleStep, 0), "setScaleStep(val) -> None\n.   @copybrief getScaleStep @see getScaleStep"},
    {"setScalesNumber", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setScalesNumber, 0), "setScalesNumber(val) -> None\n.   @copybrief getScalesNumber @see getScalesNumber"},
    {"setTau", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setTau, 0), "setTau(val) -> None\n.   @copybrief getTau @see getTau"},
    {"setTheta", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setTheta, 0), "setTheta(val) -> None\n.   @copybrief getTheta @see getTheta"},
    {"setUseInitialFlow", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setUseInitialFlow, 0), "setUseInitialFlow(val) -> None\n.   @copybrief getUseInitialFlow @see getUseInitialFlow"},
    {"setWarpingsNumber", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_DualTVL1OpticalFlow_setWarpingsNumber, 0), "setWarpingsNumber(val) -> None\n.   @copybrief getWarpingsNumber @see getWarpingsNumber"},

    {NULL,          NULL}
};

// Converter (optflow_DualTVL1OpticalFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::DualTVL1OpticalFlow> >
{
    static PyObject* from(const Ptr<cv::optflow::DualTVL1OpticalFlow>& r)
    {
        return pyopencv_optflow_DualTVL1OpticalFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::DualTVL1OpticalFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::DualTVL1OpticalFlow> * dst_;
        if (pyopencv_optflow_DualTVL1OpticalFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::DualTVL1OpticalFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_GPCDetails (Generic)
//================================================================================

// GetSet (optflow_GPCDetails)



// Methods (optflow_GPCDetails)



// Tables (optflow_GPCDetails)

static PyGetSetDef pyopencv_optflow_GPCDetails_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_GPCDetails_methods[] =
{

    {NULL,          NULL}
};

// Converter (optflow_GPCDetails)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::GPCDetails> >
{
    static PyObject* from(const Ptr<cv::optflow::GPCDetails>& r)
    {
        return pyopencv_optflow_GPCDetails_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::GPCDetails>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::GPCDetails> * dst_;
        if (pyopencv_optflow_GPCDetails_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::GPCDetails> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_GPCPatchDescriptor (Generic)
//================================================================================

// GetSet (optflow_GPCPatchDescriptor)



// Methods (optflow_GPCPatchDescriptor)



// Tables (optflow_GPCPatchDescriptor)

static PyGetSetDef pyopencv_optflow_GPCPatchDescriptor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_GPCPatchDescriptor_methods[] =
{

    {NULL,          NULL}
};

// Converter (optflow_GPCPatchDescriptor)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::GPCPatchDescriptor> >
{
    static PyObject* from(const Ptr<cv::optflow::GPCPatchDescriptor>& r)
    {
        return pyopencv_optflow_GPCPatchDescriptor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::GPCPatchDescriptor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::GPCPatchDescriptor> * dst_;
        if (pyopencv_optflow_GPCPatchDescriptor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::GPCPatchDescriptor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_GPCPatchSample (Generic)
//================================================================================

// GetSet (optflow_GPCPatchSample)



// Methods (optflow_GPCPatchSample)



// Tables (optflow_GPCPatchSample)

static PyGetSetDef pyopencv_optflow_GPCPatchSample_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_GPCPatchSample_methods[] =
{

    {NULL,          NULL}
};

// Converter (optflow_GPCPatchSample)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::GPCPatchSample> >
{
    static PyObject* from(const Ptr<cv::optflow::GPCPatchSample>& r)
    {
        return pyopencv_optflow_GPCPatchSample_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::GPCPatchSample>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::GPCPatchSample> * dst_;
        if (pyopencv_optflow_GPCPatchSample_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::GPCPatchSample> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_GPCTrainingSamples (Generic)
//================================================================================

// GetSet (optflow_GPCTrainingSamples)



// Methods (optflow_GPCTrainingSamples)



// Tables (optflow_GPCTrainingSamples)

static PyGetSetDef pyopencv_optflow_GPCTrainingSamples_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_GPCTrainingSamples_methods[] =
{

    {NULL,          NULL}
};

// Converter (optflow_GPCTrainingSamples)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::GPCTrainingSamples> >
{
    static PyObject* from(const Ptr<cv::optflow::GPCTrainingSamples>& r)
    {
        return pyopencv_optflow_GPCTrainingSamples_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::GPCTrainingSamples>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::GPCTrainingSamples> * dst_;
        if (pyopencv_optflow_GPCTrainingSamples_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::GPCTrainingSamples> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_GPCTree (Generic)
//================================================================================

// GetSet (optflow_GPCTree)



// Methods (optflow_GPCTree)



// Tables (optflow_GPCTree)

static PyGetSetDef pyopencv_optflow_GPCTree_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_GPCTree_methods[] =
{

    {NULL,          NULL}
};

// Converter (optflow_GPCTree)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::GPCTree> >
{
    static PyObject* from(const Ptr<cv::optflow::GPCTree>& r)
    {
        return pyopencv_optflow_GPCTree_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::GPCTree>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::GPCTree> * dst_;
        if (pyopencv_optflow_GPCTree_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::GPCTree> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_OpticalFlowPCAFlow (Generic)
//================================================================================

// GetSet (optflow_OpticalFlowPCAFlow)



// Methods (optflow_OpticalFlowPCAFlow)



// Tables (optflow_OpticalFlowPCAFlow)

static PyGetSetDef pyopencv_optflow_OpticalFlowPCAFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_OpticalFlowPCAFlow_methods[] =
{

    {NULL,          NULL}
};

// Converter (optflow_OpticalFlowPCAFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::OpticalFlowPCAFlow> >
{
    static PyObject* from(const Ptr<cv::optflow::OpticalFlowPCAFlow>& r)
    {
        return pyopencv_optflow_OpticalFlowPCAFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::OpticalFlowPCAFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::OpticalFlowPCAFlow> * dst_;
        if (pyopencv_optflow_OpticalFlowPCAFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::OpticalFlowPCAFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_PCAPrior (Generic)
//================================================================================

// GetSet (optflow_PCAPrior)



// Methods (optflow_PCAPrior)



// Tables (optflow_PCAPrior)

static PyGetSetDef pyopencv_optflow_PCAPrior_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_PCAPrior_methods[] =
{

    {NULL,          NULL}
};

// Converter (optflow_PCAPrior)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::PCAPrior> >
{
    static PyObject* from(const Ptr<cv::optflow::PCAPrior>& r)
    {
        return pyopencv_optflow_PCAPrior_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::PCAPrior>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::PCAPrior> * dst_;
        if (pyopencv_optflow_PCAPrior_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::PCAPrior> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_RLOFOpticalFlowParameter (Generic)
//================================================================================

// GetSet (optflow_RLOFOpticalFlowParameter)



// Methods (optflow_RLOFOpticalFlowParameter)

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;

    Ptr<RLOFOpticalFlowParameter> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::optflow::RLOFOpticalFlowParameter::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getCrossSegmentationThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCrossSegmentationThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getGlobalMotionRansacThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGlobalMotionRansacThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getLargeWinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLargeWinSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getMaxIteration(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxIteration());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getMaxLevel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxLevel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getMinEigenValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinEigenValue());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getNormSigma0(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNormSigma0());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getNormSigma1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNormSigma1());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getSmallWinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSmallWinSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getSolverType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    SolverType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSolverType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getSupportRegionType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    SupportRegionType retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSupportRegionType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getUseGlobalMotionPrior(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseGlobalMotionPrior());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getUseIlluminationModel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseIlluminationModel());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getUseInitialFlow(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseInitialFlow());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setCrossSegmentationThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_RLOFOpticalFlowParameter.setCrossSegmentationThreshold", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setCrossSegmentationThreshold(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setGlobalMotionRansacThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_RLOFOpticalFlowParameter.setGlobalMotionRansacThreshold", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setGlobalMotionRansacThreshold(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setLargeWinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_RLOFOpticalFlowParameter.setLargeWinSize", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setLargeWinSize(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setMaxIteration(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_RLOFOpticalFlowParameter.setMaxIteration", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxIteration(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setMaxLevel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_RLOFOpticalFlowParameter.setMaxLevel", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxLevel(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setMinEigenValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_RLOFOpticalFlowParameter.setMinEigenValue", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMinEigenValue(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setNormSigma0(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_RLOFOpticalFlowParameter.setNormSigma0", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setNormSigma0(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setNormSigma1(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_RLOFOpticalFlowParameter.setNormSigma1", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setNormSigma1(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setSmallWinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:optflow_RLOFOpticalFlowParameter.setSmallWinSize", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setSmallWinSize(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setSolverType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    SolverType val=static_cast<SolverType>(0);

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:optflow_RLOFOpticalFlowParameter.setSolverType", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setSolverType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setSupportRegionType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    SupportRegionType val=static_cast<SupportRegionType>(0);

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:optflow_RLOFOpticalFlowParameter.setSupportRegionType", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setSupportRegionType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setUseGlobalMotionPrior(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:optflow_RLOFOpticalFlowParameter.setUseGlobalMotionPrior", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUseGlobalMotionPrior(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setUseIlluminationModel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:optflow_RLOFOpticalFlowParameter.setUseIlluminationModel", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUseIlluminationModel(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setUseInitialFlow(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::RLOFOpticalFlowParameter> * self1 = 0;
    if (!pyopencv_optflow_RLOFOpticalFlowParameter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_RLOFOpticalFlowParameter' or its derivative)");
    Ptr<cv::optflow::RLOFOpticalFlowParameter> _self_ = *(self1);
    bool val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:optflow_RLOFOpticalFlowParameter.setUseInitialFlow", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setUseInitialFlow(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (optflow_RLOFOpticalFlowParameter)

static PyGetSetDef pyopencv_optflow_RLOFOpticalFlowParameter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_RLOFOpticalFlowParameter_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_create_static, METH_STATIC), "create() -> retval\n."},
    {"getCrossSegmentationThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getCrossSegmentationThreshold, 0), "getCrossSegmentationThreshold() -> retval\n."},
    {"getGlobalMotionRansacThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getGlobalMotionRansacThreshold, 0), "getGlobalMotionRansacThreshold() -> retval\n."},
    {"getLargeWinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getLargeWinSize, 0), "getLargeWinSize() -> retval\n."},
    {"getMaxIteration", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getMaxIteration, 0), "getMaxIteration() -> retval\n."},
    {"getMaxLevel", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getMaxLevel, 0), "getMaxLevel() -> retval\n."},
    {"getMinEigenValue", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getMinEigenValue, 0), "getMinEigenValue() -> retval\n."},
    {"getNormSigma0", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getNormSigma0, 0), "getNormSigma0() -> retval\n."},
    {"getNormSigma1", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getNormSigma1, 0), "getNormSigma1() -> retval\n."},
    {"getSmallWinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getSmallWinSize, 0), "getSmallWinSize() -> retval\n."},
    {"getSolverType", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getSolverType, 0), "getSolverType() -> retval\n."},
    {"getSupportRegionType", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getSupportRegionType, 0), "getSupportRegionType() -> retval\n."},
    {"getUseGlobalMotionPrior", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getUseGlobalMotionPrior, 0), "getUseGlobalMotionPrior() -> retval\n."},
    {"getUseIlluminationModel", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getUseIlluminationModel, 0), "getUseIlluminationModel() -> retval\n."},
    {"getUseInitialFlow", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_getUseInitialFlow, 0), "getUseInitialFlow() -> retval\n."},
    {"setCrossSegmentationThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setCrossSegmentationThreshold, 0), "setCrossSegmentationThreshold(val) -> None\n."},
    {"setGlobalMotionRansacThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setGlobalMotionRansacThreshold, 0), "setGlobalMotionRansacThreshold(val) -> None\n."},
    {"setLargeWinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setLargeWinSize, 0), "setLargeWinSize(val) -> None\n."},
    {"setMaxIteration", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setMaxIteration, 0), "setMaxIteration(val) -> None\n."},
    {"setMaxLevel", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setMaxLevel, 0), "setMaxLevel(val) -> None\n."},
    {"setMinEigenValue", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setMinEigenValue, 0), "setMinEigenValue(val) -> None\n."},
    {"setNormSigma0", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setNormSigma0, 0), "setNormSigma0(val) -> None\n."},
    {"setNormSigma1", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setNormSigma1, 0), "setNormSigma1(val) -> None\n."},
    {"setSmallWinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setSmallWinSize, 0), "setSmallWinSize(val) -> None\n."},
    {"setSolverType", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setSolverType, 0), "setSolverType(val) -> None\n.   < To apply the global motion prior motion vectors will be computed on a regulary sampled which\n.        *   are the basis for Homography estimation using RANSAC. The reprojection threshold is based on\n.        *   n-th percentil (given by this value [0 ... 100]) of the motion vectors magnitude.\n.        *   See @cite Senst2016 for more details."},
    {"setSupportRegionType", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setSupportRegionType, 0), "setSupportRegionType(val) -> None\n."},
    {"setUseGlobalMotionPrior", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setUseGlobalMotionPrior, 0), "setUseGlobalMotionPrior(val) -> None\n."},
    {"setUseIlluminationModel", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setUseIlluminationModel, 0), "setUseIlluminationModel(val) -> None\n."},
    {"setUseInitialFlow", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_RLOFOpticalFlowParameter_setUseInitialFlow, 0), "setUseInitialFlow(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (optflow_RLOFOpticalFlowParameter)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::RLOFOpticalFlowParameter> >
{
    static PyObject* from(const Ptr<cv::optflow::RLOFOpticalFlowParameter>& r)
    {
        return pyopencv_optflow_RLOFOpticalFlowParameter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::RLOFOpticalFlowParameter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::RLOFOpticalFlowParameter> * dst_;
        if (pyopencv_optflow_RLOFOpticalFlowParameter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::RLOFOpticalFlowParameter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// optflow_SparseRLOFOpticalFlow (Generic)
//================================================================================

// GetSet (optflow_SparseRLOFOpticalFlow)



// Methods (optflow_SparseRLOFOpticalFlow)

static PyObject* pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;

    PyObject* pyobj_rlofParam = NULL;
    Ptr<RLOFOpticalFlowParameter> rlofParam;
    float forwardBackwardThreshold=1.f;
    Ptr<SparseRLOFOpticalFlow> retval;

    const char* keywords[] = { "rlofParam", "forwardBackwardThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Of:optflow_SparseRLOFOpticalFlow.create", (char**)keywords, &pyobj_rlofParam, &forwardBackwardThreshold) &&
        pyopencv_to(pyobj_rlofParam, rlofParam, ArgInfo("rlofParam", 0)) )
    {
        ERRWRAP2(retval = cv::optflow::SparseRLOFOpticalFlow::create(rlofParam, forwardBackwardThreshold));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_getForwardBackward(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::SparseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_SparseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_SparseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::SparseRLOFOpticalFlow> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getForwardBackward());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_getRLOFOpticalFlowParameter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::SparseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_SparseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_SparseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::SparseRLOFOpticalFlow> _self_ = *(self1);
    Ptr<RLOFOpticalFlowParameter> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRLOFOpticalFlowParameter());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_setForwardBackward(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::SparseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_SparseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_SparseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::SparseRLOFOpticalFlow> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:optflow_SparseRLOFOpticalFlow.setForwardBackward", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setForwardBackward(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_setRLOFOpticalFlowParameter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::optflow;


    Ptr<cv::optflow::SparseRLOFOpticalFlow> * self1 = 0;
    if (!pyopencv_optflow_SparseRLOFOpticalFlow_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'optflow_SparseRLOFOpticalFlow' or its derivative)");
    Ptr<cv::optflow::SparseRLOFOpticalFlow> _self_ = *(self1);
    PyObject* pyobj_val = NULL;
    Ptr<RLOFOpticalFlowParameter> val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:optflow_SparseRLOFOpticalFlow.setRLOFOpticalFlowParameter", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setRLOFOpticalFlowParameter(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (optflow_SparseRLOFOpticalFlow)

static PyGetSetDef pyopencv_optflow_SparseRLOFOpticalFlow_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_optflow_SparseRLOFOpticalFlow_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_create_static, METH_STATIC), "create([, rlofParam[, forwardBackwardThreshold]]) -> retval\n.   *    @param rlofParam see setRLOFOpticalFlowParameter\n.        *    @param forwardBackwardThreshold see setForwardBackward"},
    {"getForwardBackward", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_getForwardBackward, 0), "getForwardBackward() -> retval\n.   @copybrief setForwardBackward\n.        *    @see setForwardBackward"},
    {"getRLOFOpticalFlowParameter", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_getRLOFOpticalFlowParameter, 0), "getRLOFOpticalFlowParameter() -> retval\n.   @copybrief setRLOFOpticalFlowParameter\n.        *    @see setRLOFOpticalFlowParameter"},
    {"setForwardBackward", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_setForwardBackward, 0), "setForwardBackward(val) -> None\n.   For each feature point a motion vector \\f$ d_{I0,I1}(\\mathbf{x}) \\f$ is computed.\n.        *     If the forward backward error \\f[ EP_{FB} = || d_{I0,I1} + d_{I1,I0} || \\f]\n.        *     is larger than threshold given by this function then the status  will not be used by the following\n.        *    vector field interpolation. \\f$ d_{I1,I0} \\f$ denotes the backward flow. Note, the forward backward test\n.        *    will only be applied if the threshold > 0. This may results into a doubled runtime for the motion estimation.\n.        *    @see setForwardBackward"},
    {"setRLOFOpticalFlowParameter", CV_PY_FN_WITH_KW_(pyopencv_cv_optflow_optflow_SparseRLOFOpticalFlow_setRLOFOpticalFlowParameter, 0), "setRLOFOpticalFlowParameter(val) -> None\n.   @copydoc DenseRLOFOpticalFlow::setRLOFOpticalFlowParameter"},

    {NULL,          NULL}
};

// Converter (optflow_SparseRLOFOpticalFlow)

template<>
struct PyOpenCV_Converter< Ptr<cv::optflow::SparseRLOFOpticalFlow> >
{
    static PyObject* from(const Ptr<cv::optflow::SparseRLOFOpticalFlow>& r)
    {
        return pyopencv_optflow_SparseRLOFOpticalFlow_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::optflow::SparseRLOFOpticalFlow>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::optflow::SparseRLOFOpticalFlow> * dst_;
        if (pyopencv_optflow_SparseRLOFOpticalFlow_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::optflow::SparseRLOFOpticalFlow> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// phase_unwrapping_HistogramPhaseUnwrapping (Generic)
//================================================================================

// GetSet (phase_unwrapping_HistogramPhaseUnwrapping)



// Methods (phase_unwrapping_HistogramPhaseUnwrapping)

static PyObject* pyopencv_cv_phase_unwrapping_phase_unwrapping_HistogramPhaseUnwrapping_getInverseReliabilityMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::phase_unwrapping;


    Ptr<cv::phase_unwrapping::HistogramPhaseUnwrapping> * self1 = 0;
    if (!pyopencv_phase_unwrapping_HistogramPhaseUnwrapping_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'phase_unwrapping_HistogramPhaseUnwrapping' or its derivative)");
    Ptr<cv::phase_unwrapping::HistogramPhaseUnwrapping> _self_ = *(self1);
    {
    PyObject* pyobj_reliabilityMap = NULL;
    Mat reliabilityMap;

    const char* keywords[] = { "reliabilityMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:phase_unwrapping_HistogramPhaseUnwrapping.getInverseReliabilityMap", (char**)keywords, &pyobj_reliabilityMap) &&
        pyopencv_to(pyobj_reliabilityMap, reliabilityMap, ArgInfo("reliabilityMap", 1)) )
    {
        ERRWRAP2(_self_->getInverseReliabilityMap(reliabilityMap));
        return pyopencv_from(reliabilityMap);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_reliabilityMap = NULL;
    UMat reliabilityMap;

    const char* keywords[] = { "reliabilityMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:phase_unwrapping_HistogramPhaseUnwrapping.getInverseReliabilityMap", (char**)keywords, &pyobj_reliabilityMap) &&
        pyopencv_to(pyobj_reliabilityMap, reliabilityMap, ArgInfo("reliabilityMap", 1)) )
    {
        ERRWRAP2(_self_->getInverseReliabilityMap(reliabilityMap));
        return pyopencv_from(reliabilityMap);
    }
    }

    return NULL;
}



// Tables (phase_unwrapping_HistogramPhaseUnwrapping)

static PyGetSetDef pyopencv_phase_unwrapping_HistogramPhaseUnwrapping_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_phase_unwrapping_HistogramPhaseUnwrapping_methods[] =
{
    {"getInverseReliabilityMap", CV_PY_FN_WITH_KW_(pyopencv_cv_phase_unwrapping_phase_unwrapping_HistogramPhaseUnwrapping_getInverseReliabilityMap, 0), "getInverseReliabilityMap([, reliabilityMap]) -> reliabilityMap\n.   * @brief Get the reliability map computed from the wrapped phase map.\n.   \n.        * @param reliabilityMap Image where the reliability map is stored."},

    {NULL,          NULL}
};

// Converter (phase_unwrapping_HistogramPhaseUnwrapping)

template<>
struct PyOpenCV_Converter< Ptr<cv::phase_unwrapping::HistogramPhaseUnwrapping> >
{
    static PyObject* from(const Ptr<cv::phase_unwrapping::HistogramPhaseUnwrapping>& r)
    {
        return pyopencv_phase_unwrapping_HistogramPhaseUnwrapping_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::phase_unwrapping::HistogramPhaseUnwrapping>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::phase_unwrapping::HistogramPhaseUnwrapping> * dst_;
        if (pyopencv_phase_unwrapping_HistogramPhaseUnwrapping_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::phase_unwrapping::HistogramPhaseUnwrapping> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// phase_unwrapping_PhaseUnwrapping (Generic)
//================================================================================

// GetSet (phase_unwrapping_PhaseUnwrapping)



// Methods (phase_unwrapping_PhaseUnwrapping)

static PyObject* pyopencv_cv_phase_unwrapping_phase_unwrapping_PhaseUnwrapping_unwrapPhaseMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::phase_unwrapping;


    Ptr<cv::phase_unwrapping::PhaseUnwrapping> * self1 = 0;
    if (!pyopencv_phase_unwrapping_PhaseUnwrapping_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'phase_unwrapping_PhaseUnwrapping' or its derivative)");
    Ptr<cv::phase_unwrapping::PhaseUnwrapping> _self_ = *(self1);
    {
    PyObject* pyobj_wrappedPhaseMap = NULL;
    Mat wrappedPhaseMap;
    PyObject* pyobj_unwrappedPhaseMap = NULL;
    Mat unwrappedPhaseMap;
    PyObject* pyobj_shadowMask = NULL;
    Mat shadowMask;

    const char* keywords[] = { "wrappedPhaseMap", "unwrappedPhaseMap", "shadowMask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:phase_unwrapping_PhaseUnwrapping.unwrapPhaseMap", (char**)keywords, &pyobj_wrappedPhaseMap, &pyobj_unwrappedPhaseMap, &pyobj_shadowMask) &&
        pyopencv_to(pyobj_wrappedPhaseMap, wrappedPhaseMap, ArgInfo("wrappedPhaseMap", 0)) &&
        pyopencv_to(pyobj_unwrappedPhaseMap, unwrappedPhaseMap, ArgInfo("unwrappedPhaseMap", 1)) &&
        pyopencv_to(pyobj_shadowMask, shadowMask, ArgInfo("shadowMask", 0)) )
    {
        ERRWRAP2(_self_->unwrapPhaseMap(wrappedPhaseMap, unwrappedPhaseMap, shadowMask));
        return pyopencv_from(unwrappedPhaseMap);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_wrappedPhaseMap = NULL;
    UMat wrappedPhaseMap;
    PyObject* pyobj_unwrappedPhaseMap = NULL;
    UMat unwrappedPhaseMap;
    PyObject* pyobj_shadowMask = NULL;
    UMat shadowMask;

    const char* keywords[] = { "wrappedPhaseMap", "unwrappedPhaseMap", "shadowMask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:phase_unwrapping_PhaseUnwrapping.unwrapPhaseMap", (char**)keywords, &pyobj_wrappedPhaseMap, &pyobj_unwrappedPhaseMap, &pyobj_shadowMask) &&
        pyopencv_to(pyobj_wrappedPhaseMap, wrappedPhaseMap, ArgInfo("wrappedPhaseMap", 0)) &&
        pyopencv_to(pyobj_unwrappedPhaseMap, unwrappedPhaseMap, ArgInfo("unwrappedPhaseMap", 1)) &&
        pyopencv_to(pyobj_shadowMask, shadowMask, ArgInfo("shadowMask", 0)) )
    {
        ERRWRAP2(_self_->unwrapPhaseMap(wrappedPhaseMap, unwrappedPhaseMap, shadowMask));
        return pyopencv_from(unwrappedPhaseMap);
    }
    }

    return NULL;
}



// Tables (phase_unwrapping_PhaseUnwrapping)

static PyGetSetDef pyopencv_phase_unwrapping_PhaseUnwrapping_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_phase_unwrapping_PhaseUnwrapping_methods[] =
{
    {"unwrapPhaseMap", CV_PY_FN_WITH_KW_(pyopencv_cv_phase_unwrapping_phase_unwrapping_PhaseUnwrapping_unwrapPhaseMap, 0), "unwrapPhaseMap(wrappedPhaseMap[, unwrappedPhaseMap[, shadowMask]]) -> unwrappedPhaseMap\n.   * @brief Unwraps a 2D phase map.\n.   \n.        * @param wrappedPhaseMap The wrapped phase map that needs to be unwrapped.\n.        * @param unwrappedPhaseMap The unwrapped phase map.\n.        * @param shadowMask Optional parameter used when some pixels do not hold any phase information in the wrapped phase map."},

    {NULL,          NULL}
};

// Converter (phase_unwrapping_PhaseUnwrapping)

template<>
struct PyOpenCV_Converter< Ptr<cv::phase_unwrapping::PhaseUnwrapping> >
{
    static PyObject* from(const Ptr<cv::phase_unwrapping::PhaseUnwrapping>& r)
    {
        return pyopencv_phase_unwrapping_PhaseUnwrapping_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::phase_unwrapping::PhaseUnwrapping>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::phase_unwrapping::PhaseUnwrapping> * dst_;
        if (pyopencv_phase_unwrapping_PhaseUnwrapping_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::phase_unwrapping::PhaseUnwrapping> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// plot_Plot2d (Generic)
//================================================================================

// GetSet (plot_Plot2d)



// Methods (plot_Plot2d)

static PyObject* pyopencv_cv_plot_plot_Plot2d_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;

    {
    PyObject* pyobj_data = NULL;
    Mat data;
    Ptr<Plot2d> retval;

    const char* keywords[] = { "data", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:plot_Plot2d.create", (char**)keywords, &pyobj_data) &&
        pyopencv_to(pyobj_data, data, ArgInfo("data", 0)) )
    {
        ERRWRAP2(retval = cv::plot::Plot2d::create(data));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_data = NULL;
    UMat data;
    Ptr<Plot2d> retval;

    const char* keywords[] = { "data", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:plot_Plot2d.create", (char**)keywords, &pyobj_data) &&
        pyopencv_to(pyobj_data, data, ArgInfo("data", 0)) )
    {
        ERRWRAP2(retval = cv::plot::Plot2d::create(data));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dataX = NULL;
    Mat dataX;
    PyObject* pyobj_dataY = NULL;
    Mat dataY;
    Ptr<Plot2d> retval;

    const char* keywords[] = { "dataX", "dataY", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:plot_Plot2d.create", (char**)keywords, &pyobj_dataX, &pyobj_dataY) &&
        pyopencv_to(pyobj_dataX, dataX, ArgInfo("dataX", 0)) &&
        pyopencv_to(pyobj_dataY, dataY, ArgInfo("dataY", 0)) )
    {
        ERRWRAP2(retval = cv::plot::Plot2d::create(dataX, dataY));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dataX = NULL;
    UMat dataX;
    PyObject* pyobj_dataY = NULL;
    UMat dataY;
    Ptr<Plot2d> retval;

    const char* keywords[] = { "dataX", "dataY", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:plot_Plot2d.create", (char**)keywords, &pyobj_dataX, &pyobj_dataY) &&
        pyopencv_to(pyobj_dataX, dataX, ArgInfo("dataX", 0)) &&
        pyopencv_to(pyobj_dataY, dataY, ArgInfo("dataY", 0)) )
    {
        ERRWRAP2(retval = cv::plot::Plot2d::create(dataX, dataY));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_render(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    {
    PyObject* pyobj__plotResult = NULL;
    Mat _plotResult;

    const char* keywords[] = { "_plotResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:plot_Plot2d.render", (char**)keywords, &pyobj__plotResult) &&
        pyopencv_to(pyobj__plotResult, _plotResult, ArgInfo("_plotResult", 1)) )
    {
        ERRWRAP2(_self_->render(_plotResult));
        return pyopencv_from(_plotResult);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__plotResult = NULL;
    UMat _plotResult;

    const char* keywords[] = { "_plotResult", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:plot_Plot2d.render", (char**)keywords, &pyobj__plotResult) &&
        pyopencv_to(pyobj__plotResult, _plotResult, ArgInfo("_plotResult", 1)) )
    {
        ERRWRAP2(_self_->render(_plotResult));
        return pyopencv_from(_plotResult);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setGridLinesNumber(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    int gridLinesNumber=0;

    const char* keywords[] = { "gridLinesNumber", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:plot_Plot2d.setGridLinesNumber", (char**)keywords, &gridLinesNumber) )
    {
        ERRWRAP2(_self_->setGridLinesNumber(gridLinesNumber));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setInvertOrientation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    bool _invertOrientation=0;

    const char* keywords[] = { "_invertOrientation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:plot_Plot2d.setInvertOrientation", (char**)keywords, &_invertOrientation) )
    {
        ERRWRAP2(_self_->setInvertOrientation(_invertOrientation));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setMaxX(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    double _plotMaxX=0;

    const char* keywords[] = { "_plotMaxX", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:plot_Plot2d.setMaxX", (char**)keywords, &_plotMaxX) )
    {
        ERRWRAP2(_self_->setMaxX(_plotMaxX));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setMaxY(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    double _plotMaxY=0;

    const char* keywords[] = { "_plotMaxY", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:plot_Plot2d.setMaxY", (char**)keywords, &_plotMaxY) )
    {
        ERRWRAP2(_self_->setMaxY(_plotMaxY));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setMinX(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    double _plotMinX=0;

    const char* keywords[] = { "_plotMinX", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:plot_Plot2d.setMinX", (char**)keywords, &_plotMinX) )
    {
        ERRWRAP2(_self_->setMinX(_plotMinX));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setMinY(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    double _plotMinY=0;

    const char* keywords[] = { "_plotMinY", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:plot_Plot2d.setMinY", (char**)keywords, &_plotMinY) )
    {
        ERRWRAP2(_self_->setMinY(_plotMinY));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setNeedPlotLine(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    bool _needPlotLine=0;

    const char* keywords[] = { "_needPlotLine", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:plot_Plot2d.setNeedPlotLine", (char**)keywords, &_needPlotLine) )
    {
        ERRWRAP2(_self_->setNeedPlotLine(_needPlotLine));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setPlotAxisColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    PyObject* pyobj__plotAxisColor = NULL;
    Scalar _plotAxisColor;

    const char* keywords[] = { "_plotAxisColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:plot_Plot2d.setPlotAxisColor", (char**)keywords, &pyobj__plotAxisColor) &&
        pyopencv_to(pyobj__plotAxisColor, _plotAxisColor, ArgInfo("_plotAxisColor", 0)) )
    {
        ERRWRAP2(_self_->setPlotAxisColor(_plotAxisColor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setPlotBackgroundColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    PyObject* pyobj__plotBackgroundColor = NULL;
    Scalar _plotBackgroundColor;

    const char* keywords[] = { "_plotBackgroundColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:plot_Plot2d.setPlotBackgroundColor", (char**)keywords, &pyobj__plotBackgroundColor) &&
        pyopencv_to(pyobj__plotBackgroundColor, _plotBackgroundColor, ArgInfo("_plotBackgroundColor", 0)) )
    {
        ERRWRAP2(_self_->setPlotBackgroundColor(_plotBackgroundColor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setPlotGridColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    PyObject* pyobj__plotGridColor = NULL;
    Scalar _plotGridColor;

    const char* keywords[] = { "_plotGridColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:plot_Plot2d.setPlotGridColor", (char**)keywords, &pyobj__plotGridColor) &&
        pyopencv_to(pyobj__plotGridColor, _plotGridColor, ArgInfo("_plotGridColor", 0)) )
    {
        ERRWRAP2(_self_->setPlotGridColor(_plotGridColor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setPlotLineColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    PyObject* pyobj__plotLineColor = NULL;
    Scalar _plotLineColor;

    const char* keywords[] = { "_plotLineColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:plot_Plot2d.setPlotLineColor", (char**)keywords, &pyobj__plotLineColor) &&
        pyopencv_to(pyobj__plotLineColor, _plotLineColor, ArgInfo("_plotLineColor", 0)) )
    {
        ERRWRAP2(_self_->setPlotLineColor(_plotLineColor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setPlotLineWidth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    int _plotLineWidth=0;

    const char* keywords[] = { "_plotLineWidth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:plot_Plot2d.setPlotLineWidth", (char**)keywords, &_plotLineWidth) )
    {
        ERRWRAP2(_self_->setPlotLineWidth(_plotLineWidth));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setPlotSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    int _plotSizeWidth=0;
    int _plotSizeHeight=0;

    const char* keywords[] = { "_plotSizeWidth", "_plotSizeHeight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:plot_Plot2d.setPlotSize", (char**)keywords, &_plotSizeWidth, &_plotSizeHeight) )
    {
        ERRWRAP2(_self_->setPlotSize(_plotSizeWidth, _plotSizeHeight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setPlotTextColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    PyObject* pyobj__plotTextColor = NULL;
    Scalar _plotTextColor;

    const char* keywords[] = { "_plotTextColor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:plot_Plot2d.setPlotTextColor", (char**)keywords, &pyobj__plotTextColor) &&
        pyopencv_to(pyobj__plotTextColor, _plotTextColor, ArgInfo("_plotTextColor", 0)) )
    {
        ERRWRAP2(_self_->setPlotTextColor(_plotTextColor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setPointIdxToPrint(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    int pointIdx=0;

    const char* keywords[] = { "pointIdx", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:plot_Plot2d.setPointIdxToPrint", (char**)keywords, &pointIdx) )
    {
        ERRWRAP2(_self_->setPointIdxToPrint(pointIdx));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setShowGrid(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    bool needShowGrid=0;

    const char* keywords[] = { "needShowGrid", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:plot_Plot2d.setShowGrid", (char**)keywords, &needShowGrid) )
    {
        ERRWRAP2(_self_->setShowGrid(needShowGrid));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_plot_plot_Plot2d_setShowText(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::plot;


    Ptr<cv::plot::Plot2d> * self1 = 0;
    if (!pyopencv_plot_Plot2d_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'plot_Plot2d' or its derivative)");
    Ptr<cv::plot::Plot2d> _self_ = *(self1);
    bool needShowText=0;

    const char* keywords[] = { "needShowText", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:plot_Plot2d.setShowText", (char**)keywords, &needShowText) )
    {
        ERRWRAP2(_self_->setShowText(needShowText));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (plot_Plot2d)

static PyGetSetDef pyopencv_plot_Plot2d_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_plot_Plot2d_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_create_static, METH_STATIC), "create(data) -> retval\n.   * @brief Creates Plot2d object\n.                *\n.                * @param data \\f$1xN\\f$ or \\f$Nx1\\f$ matrix containing \\f$Y\\f$ values of points to plot. \\f$X\\f$ values\n.                * will be equal to indexes of correspondind elements in data matrix.\n\n\n\ncreate(dataX, dataY) -> retval\n.   * @brief Creates Plot2d object\n.                *\n.                * @param dataX \\f$1xN\\f$ or \\f$Nx1\\f$ matrix \\f$X\\f$ values of points to plot.\n.                * @param dataY \\f$1xN\\f$ or \\f$Nx1\\f$ matrix containing \\f$Y\\f$ values of points to plot."},
    {"render", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_render, 0), "render([, _plotResult]) -> _plotResult\n."},
    {"setGridLinesNumber", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setGridLinesNumber, 0), "setGridLinesNumber(gridLinesNumber) -> None\n."},
    {"setInvertOrientation", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setInvertOrientation, 0), "setInvertOrientation(_invertOrientation) -> None\n."},
    {"setMaxX", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setMaxX, 0), "setMaxX(_plotMaxX) -> None\n."},
    {"setMaxY", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setMaxY, 0), "setMaxY(_plotMaxY) -> None\n."},
    {"setMinX", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setMinX, 0), "setMinX(_plotMinX) -> None\n."},
    {"setMinY", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setMinY, 0), "setMinY(_plotMinY) -> None\n."},
    {"setNeedPlotLine", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setNeedPlotLine, 0), "setNeedPlotLine(_needPlotLine) -> None\n.   * @brief Switches data visualization mode\n.                *\n.                * @param _needPlotLine if true then neighbour plot points will be connected by lines.\n.                * In other case data will be plotted as a set of standalone points."},
    {"setPlotAxisColor", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setPlotAxisColor, 0), "setPlotAxisColor(_plotAxisColor) -> None\n."},
    {"setPlotBackgroundColor", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setPlotBackgroundColor, 0), "setPlotBackgroundColor(_plotBackgroundColor) -> None\n."},
    {"setPlotGridColor", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setPlotGridColor, 0), "setPlotGridColor(_plotGridColor) -> None\n."},
    {"setPlotLineColor", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setPlotLineColor, 0), "setPlotLineColor(_plotLineColor) -> None\n."},
    {"setPlotLineWidth", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setPlotLineWidth, 0), "setPlotLineWidth(_plotLineWidth) -> None\n."},
    {"setPlotSize", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setPlotSize, 0), "setPlotSize(_plotSizeWidth, _plotSizeHeight) -> None\n."},
    {"setPlotTextColor", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setPlotTextColor, 0), "setPlotTextColor(_plotTextColor) -> None\n."},
    {"setPointIdxToPrint", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setPointIdxToPrint, 0), "setPointIdxToPrint(pointIdx) -> None\n.   * @brief Sets the index of a point which coordinates will be printed on the top left corner of the plot (if ShowText flag is true).\n.                *\n.                * @param pointIdx index of the required point in data array."},
    {"setShowGrid", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setShowGrid, 0), "setShowGrid(needShowGrid) -> None\n."},
    {"setShowText", CV_PY_FN_WITH_KW_(pyopencv_cv_plot_plot_Plot2d_setShowText, 0), "setShowText(needShowText) -> None\n."},

    {NULL,          NULL}
};

// Converter (plot_Plot2d)

template<>
struct PyOpenCV_Converter< Ptr<cv::plot::Plot2d> >
{
    static PyObject* from(const Ptr<cv::plot::Plot2d>& r)
    {
        return pyopencv_plot_Plot2d_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::plot::Plot2d>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::plot::Plot2d> * dst_;
        if (pyopencv_plot_Plot2d_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::plot::Plot2d> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ppf_match_3d_ICP (Generic)
//================================================================================

// GetSet (ppf_match_3d_ICP)



// Methods (ppf_match_3d_ICP)

static int pyopencv_cv_ppf_match_3d_ppf_match_3d_ICP_ICP(pyopencv_ppf_match_3d_ICP_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::ppf_match_3d::ICP>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::ppf_match_3d::ICP()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    int iterations=0;
    float tolerence=0.05f;
    float rejectionScale=2.5f;
    int numLevels=6;
    int sampleType=ICP::ICP_SAMPLING_TYPE_UNIFORM;
    int numMaxCorr=1;

    const char* keywords[] = { "iterations", "tolerence", "rejectionScale", "numLevels", "sampleType", "numMaxCorr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|ffiii:ICP", (char**)keywords, &iterations, &tolerence, &rejectionScale, &numLevels, &sampleType, &numMaxCorr) )
    {
        new (&(self->v)) Ptr<cv::ppf_match_3d::ICP>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::ppf_match_3d::ICP(iterations, tolerence, rejectionScale, numLevels, sampleType, numMaxCorr)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_ppf_match_3d_ppf_match_3d_ICP_registerModelToScene(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;


    Ptr<cv::ppf_match_3d::ICP> * self1 = 0;
    if (!pyopencv_ppf_match_3d_ICP_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ppf_match_3d_ICP' or its derivative)");
    Ptr<cv::ppf_match_3d::ICP> _self_ = *(self1);
    {
    PyObject* pyobj_srcPC = NULL;
    Mat srcPC;
    PyObject* pyobj_dstPC = NULL;
    Mat dstPC;
    double residual;
    Matx44d pose;
    int retval;

    const char* keywords[] = { "srcPC", "dstPC", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ppf_match_3d_ICP.registerModelToScene", (char**)keywords, &pyobj_srcPC, &pyobj_dstPC) &&
        pyopencv_to(pyobj_srcPC, srcPC, ArgInfo("srcPC", 0)) &&
        pyopencv_to(pyobj_dstPC, dstPC, ArgInfo("dstPC", 0)) )
    {
        ERRWRAP2(retval = _self_->registerModelToScene(srcPC, dstPC, residual, pose));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(residual), pyopencv_from(pose));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_srcPC = NULL;
    Mat srcPC;
    PyObject* pyobj_dstPC = NULL;
    Mat dstPC;
    double residual;
    Matx44d pose;
    int retval;

    const char* keywords[] = { "srcPC", "dstPC", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ppf_match_3d_ICP.registerModelToScene", (char**)keywords, &pyobj_srcPC, &pyobj_dstPC) &&
        pyopencv_to(pyobj_srcPC, srcPC, ArgInfo("srcPC", 0)) &&
        pyopencv_to(pyobj_dstPC, dstPC, ArgInfo("dstPC", 0)) )
    {
        ERRWRAP2(retval = _self_->registerModelToScene(srcPC, dstPC, residual, pose));
        return Py_BuildValue("(NNN)", pyopencv_from(retval), pyopencv_from(residual), pyopencv_from(pose));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_srcPC = NULL;
    Mat srcPC;
    PyObject* pyobj_dstPC = NULL;
    Mat dstPC;
    PyObject* pyobj_poses = NULL;
    vector_Pose3DPtr poses;
    int retval;

    const char* keywords[] = { "srcPC", "dstPC", "poses", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:ppf_match_3d_ICP.registerModelToScene", (char**)keywords, &pyobj_srcPC, &pyobj_dstPC, &pyobj_poses) &&
        pyopencv_to(pyobj_srcPC, srcPC, ArgInfo("srcPC", 0)) &&
        pyopencv_to(pyobj_dstPC, dstPC, ArgInfo("dstPC", 0)) &&
        pyopencv_to(pyobj_poses, poses, ArgInfo("poses", 1)) )
    {
        ERRWRAP2(retval = _self_->registerModelToScene(srcPC, dstPC, poses));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(poses));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_srcPC = NULL;
    Mat srcPC;
    PyObject* pyobj_dstPC = NULL;
    Mat dstPC;
    PyObject* pyobj_poses = NULL;
    vector_Pose3DPtr poses;
    int retval;

    const char* keywords[] = { "srcPC", "dstPC", "poses", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:ppf_match_3d_ICP.registerModelToScene", (char**)keywords, &pyobj_srcPC, &pyobj_dstPC, &pyobj_poses) &&
        pyopencv_to(pyobj_srcPC, srcPC, ArgInfo("srcPC", 0)) &&
        pyopencv_to(pyobj_dstPC, dstPC, ArgInfo("dstPC", 0)) &&
        pyopencv_to(pyobj_poses, poses, ArgInfo("poses", 1)) )
    {
        ERRWRAP2(retval = _self_->registerModelToScene(srcPC, dstPC, poses));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(poses));
    }
    }

    return NULL;
}



// Tables (ppf_match_3d_ICP)

static PyGetSetDef pyopencv_ppf_match_3d_ICP_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ppf_match_3d_ICP_methods[] =
{
    {"registerModelToScene", CV_PY_FN_WITH_KW_(pyopencv_cv_ppf_match_3d_ppf_match_3d_ICP_registerModelToScene, 0), "registerModelToScene(srcPC, dstPC) -> retval, residual, pose\n.   *  \\brief Perform registration\n.        *\n.        *  @param [in] srcPC The input point cloud for the model. Expected to have the normals (Nx6). Currently,\n.        *  CV_32F is the only supported data type.\n.        *  @param [in] dstPC The input point cloud for the scene. It is assumed that the model is registered on the scene. Scene remains static. Expected to have the normals (Nx6). Currently, CV_32F is the only supported data type.\n.        *  @param [out] residual The output registration error.\n.        *  @param [out] pose Transformation between srcPC and dstPC.\n.        *  \\return On successful termination, the function returns 0.\n.        *\n.        *  \\details It is assumed that the model is registered on the scene. Scene remains static, while the model transforms. The output poses transform the models onto the scene. Because of the point to plane minimization, the scene is expected to have the normals available. Expected to have the normals (Nx6).\n\n\n\nregisterModelToScene(srcPC, dstPC, poses) -> retval, poses\n.   *  \\brief Perform registration with multiple initial poses\n.        *\n.        *  @param [in] srcPC The input point cloud for the model. Expected to have the normals (Nx6). Currently,\n.        *  CV_32F is the only supported data type.\n.        *  @param [in] dstPC The input point cloud for the scene. Currently, CV_32F is the only supported data type.\n.        *  @param [in,out] poses Input poses to start with but also list output of poses.\n.        *  \\return On successful termination, the function returns 0.\n.        *\n.        *  \\details It is assumed that the model is registered on the scene. Scene remains static, while the model transforms. The output poses transform the models onto the scene. Because of the point to plane minimization, the scene is expected to have the normals available. Expected to have the normals (Nx6)."},

    {NULL,          NULL}
};

// Converter (ppf_match_3d_ICP)

template<>
struct PyOpenCV_Converter< Ptr<cv::ppf_match_3d::ICP> >
{
    static PyObject* from(const Ptr<cv::ppf_match_3d::ICP>& r)
    {
        return pyopencv_ppf_match_3d_ICP_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ppf_match_3d::ICP>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ppf_match_3d::ICP> * dst_;
        if (pyopencv_ppf_match_3d_ICP_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ppf_match_3d::ICP> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ppf_match_3d_PPF3DDetector (Generic)
//================================================================================

// GetSet (ppf_match_3d_PPF3DDetector)



// Methods (ppf_match_3d_PPF3DDetector)

static int pyopencv_cv_ppf_match_3d_ppf_match_3d_PPF3DDetector_PPF3DDetector(pyopencv_ppf_match_3d_PPF3DDetector_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::ppf_match_3d::PPF3DDetector>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::ppf_match_3d::PPF3DDetector()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    double relativeSamplingStep=0;
    double relativeDistanceStep=0.05;
    double numAngles=30;

    const char* keywords[] = { "relativeSamplingStep", "relativeDistanceStep", "numAngles", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d|dd:PPF3DDetector", (char**)keywords, &relativeSamplingStep, &relativeDistanceStep, &numAngles) )
    {
        new (&(self->v)) Ptr<cv::ppf_match_3d::PPF3DDetector>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::ppf_match_3d::PPF3DDetector(relativeSamplingStep, relativeDistanceStep, numAngles)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_ppf_match_3d_ppf_match_3d_PPF3DDetector_match(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;


    Ptr<cv::ppf_match_3d::PPF3DDetector> * self1 = 0;
    if (!pyopencv_ppf_match_3d_PPF3DDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ppf_match_3d_PPF3DDetector' or its derivative)");
    Ptr<cv::ppf_match_3d::PPF3DDetector> _self_ = *(self1);
    {
    PyObject* pyobj_scene = NULL;
    Mat scene;
    vector_Pose3DPtr results;
    double relativeSceneSampleStep=1.0/5.0;
    double relativeSceneDistance=0.03;

    const char* keywords[] = { "scene", "relativeSceneSampleStep", "relativeSceneDistance", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|dd:ppf_match_3d_PPF3DDetector.match", (char**)keywords, &pyobj_scene, &relativeSceneSampleStep, &relativeSceneDistance) &&
        pyopencv_to(pyobj_scene, scene, ArgInfo("scene", 0)) )
    {
        ERRWRAP2(_self_->match(scene, results, relativeSceneSampleStep, relativeSceneDistance));
        return pyopencv_from(results);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_scene = NULL;
    Mat scene;
    vector_Pose3DPtr results;
    double relativeSceneSampleStep=1.0/5.0;
    double relativeSceneDistance=0.03;

    const char* keywords[] = { "scene", "relativeSceneSampleStep", "relativeSceneDistance", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|dd:ppf_match_3d_PPF3DDetector.match", (char**)keywords, &pyobj_scene, &relativeSceneSampleStep, &relativeSceneDistance) &&
        pyopencv_to(pyobj_scene, scene, ArgInfo("scene", 0)) )
    {
        ERRWRAP2(_self_->match(scene, results, relativeSceneSampleStep, relativeSceneDistance));
        return pyopencv_from(results);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ppf_match_3d_ppf_match_3d_PPF3DDetector_trainModel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;


    Ptr<cv::ppf_match_3d::PPF3DDetector> * self1 = 0;
    if (!pyopencv_ppf_match_3d_PPF3DDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ppf_match_3d_PPF3DDetector' or its derivative)");
    Ptr<cv::ppf_match_3d::PPF3DDetector> _self_ = *(self1);
    {
    PyObject* pyobj_Model = NULL;
    Mat Model;

    const char* keywords[] = { "Model", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ppf_match_3d_PPF3DDetector.trainModel", (char**)keywords, &pyobj_Model) &&
        pyopencv_to(pyobj_Model, Model, ArgInfo("Model", 0)) )
    {
        ERRWRAP2(_self_->trainModel(Model));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_Model = NULL;
    Mat Model;

    const char* keywords[] = { "Model", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ppf_match_3d_PPF3DDetector.trainModel", (char**)keywords, &pyobj_Model) &&
        pyopencv_to(pyobj_Model, Model, ArgInfo("Model", 0)) )
    {
        ERRWRAP2(_self_->trainModel(Model));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (ppf_match_3d_PPF3DDetector)

static PyGetSetDef pyopencv_ppf_match_3d_PPF3DDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ppf_match_3d_PPF3DDetector_methods[] =
{
    {"match", CV_PY_FN_WITH_KW_(pyopencv_cv_ppf_match_3d_ppf_match_3d_PPF3DDetector_match, 0), "match(scene[, relativeSceneSampleStep[, relativeSceneDistance]]) -> results\n.   *  \\brief Matches a trained model across a provided scene.\n.       *\n.       *  @param [in] scene Point cloud for the scene\n.       *  @param [out] results List of output poses\n.       *  @param [in] relativeSceneSampleStep The ratio of scene points to be used for the matching after sampling with relativeSceneDistance. For example, if this value is set to 1.0/5.0, every 5th point from the scene is used for pose estimation. This parameter allows an easy trade-off between speed and accuracy of the matching. Increasing the value leads to less points being used and in turn to a faster but less accurate pose computation. Decreasing the value has the inverse effect.\n.       *  @param [in] relativeSceneDistance Set the distance threshold relative to the diameter of the model. This parameter is equivalent to relativeSamplingStep in the training stage. This parameter acts like a prior sampling with the relativeSceneSampleStep parameter."},
    {"trainModel", CV_PY_FN_WITH_KW_(pyopencv_cv_ppf_match_3d_ppf_match_3d_PPF3DDetector_trainModel, 0), "trainModel(Model) -> None\n.   *  \\brief Trains a new model.\n.       *\n.       *  @param [in] Model The input point cloud with normals (Nx6)\n.       *\n.       *  \\details Uses the parameters set in the constructor to downsample and learn a new model. When the model is learnt, the instance gets ready for calling \"match\"."},

    {NULL,          NULL}
};

// Converter (ppf_match_3d_PPF3DDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::ppf_match_3d::PPF3DDetector> >
{
    static PyObject* from(const Ptr<cv::ppf_match_3d::PPF3DDetector>& r)
    {
        return pyopencv_ppf_match_3d_PPF3DDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ppf_match_3d::PPF3DDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ppf_match_3d::PPF3DDetector> * dst_;
        if (pyopencv_ppf_match_3d_PPF3DDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ppf_match_3d::PPF3DDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ppf_match_3d_Pose3D (Generic)
//================================================================================

// GetSet (ppf_match_3d_Pose3D)


static PyObject* pyopencv_ppf_match_3d_Pose3D_get_alpha(pyopencv_ppf_match_3d_Pose3D_t* p, void *closure)
{
    return pyopencv_from(p->v->alpha);
}

static PyObject* pyopencv_ppf_match_3d_Pose3D_get_angle(pyopencv_ppf_match_3d_Pose3D_t* p, void *closure)
{
    return pyopencv_from(p->v->angle);
}

static PyObject* pyopencv_ppf_match_3d_Pose3D_get_modelIndex(pyopencv_ppf_match_3d_Pose3D_t* p, void *closure)
{
    return pyopencv_from(p->v->modelIndex);
}

static PyObject* pyopencv_ppf_match_3d_Pose3D_get_numVotes(pyopencv_ppf_match_3d_Pose3D_t* p, void *closure)
{
    return pyopencv_from(p->v->numVotes);
}

static PyObject* pyopencv_ppf_match_3d_Pose3D_get_pose(pyopencv_ppf_match_3d_Pose3D_t* p, void *closure)
{
    return pyopencv_from(p->v->pose);
}

static PyObject* pyopencv_ppf_match_3d_Pose3D_get_q(pyopencv_ppf_match_3d_Pose3D_t* p, void *closure)
{
    return pyopencv_from(p->v->q);
}

static PyObject* pyopencv_ppf_match_3d_Pose3D_get_residual(pyopencv_ppf_match_3d_Pose3D_t* p, void *closure)
{
    return pyopencv_from(p->v->residual);
}

static PyObject* pyopencv_ppf_match_3d_Pose3D_get_t(pyopencv_ppf_match_3d_Pose3D_t* p, void *closure)
{
    return pyopencv_from(p->v->t);
}


// Methods (ppf_match_3d_Pose3D)

static int pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_Pose3D(pyopencv_ppf_match_3d_Pose3D_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::ppf_match_3d::Pose3D>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::ppf_match_3d::Pose3D()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    double Alpha=0;
    size_t ModelIndex=0;
    size_t NumVotes=0;

    const char* keywords[] = { "Alpha", "ModelIndex", "NumVotes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d|II:Pose3D", (char**)keywords, &Alpha, &ModelIndex, &NumVotes) )
    {
        new (&(self->v)) Ptr<cv::ppf_match_3d::Pose3D>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::ppf_match_3d::Pose3D(Alpha, ModelIndex, NumVotes)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_appendPose(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;


    Ptr<cv::ppf_match_3d::Pose3D> * self1 = 0;
    if (!pyopencv_ppf_match_3d_Pose3D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ppf_match_3d_Pose3D' or its derivative)");
    Ptr<cv::ppf_match_3d::Pose3D> _self_ = *(self1);
    PyObject* pyobj_IncrementalPose = NULL;
    Matx44d IncrementalPose;

    const char* keywords[] = { "IncrementalPose", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ppf_match_3d_Pose3D.appendPose", (char**)keywords, &pyobj_IncrementalPose) &&
        pyopencv_to(pyobj_IncrementalPose, IncrementalPose, ArgInfo("IncrementalPose", 0)) )
    {
        ERRWRAP2(_self_->appendPose(IncrementalPose));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_printPose(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;


    Ptr<cv::ppf_match_3d::Pose3D> * self1 = 0;
    if (!pyopencv_ppf_match_3d_Pose3D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ppf_match_3d_Pose3D' or its derivative)");
    Ptr<cv::ppf_match_3d::Pose3D> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->printPose());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_updatePose(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;


    Ptr<cv::ppf_match_3d::Pose3D> * self1 = 0;
    if (!pyopencv_ppf_match_3d_Pose3D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ppf_match_3d_Pose3D' or its derivative)");
    Ptr<cv::ppf_match_3d::Pose3D> _self_ = *(self1);
    {
    PyObject* pyobj_NewPose = NULL;
    Matx44d NewPose;

    const char* keywords[] = { "NewPose", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ppf_match_3d_Pose3D.updatePose", (char**)keywords, &pyobj_NewPose) &&
        pyopencv_to(pyobj_NewPose, NewPose, ArgInfo("NewPose", 0)) )
    {
        ERRWRAP2(_self_->updatePose(NewPose));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_NewR = NULL;
    Matx33d NewR;
    PyObject* pyobj_NewT = NULL;
    Vec3d NewT;

    const char* keywords[] = { "NewR", "NewT", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ppf_match_3d_Pose3D.updatePose", (char**)keywords, &pyobj_NewR, &pyobj_NewT) &&
        pyopencv_to(pyobj_NewR, NewR, ArgInfo("NewR", 0)) &&
        pyopencv_to(pyobj_NewT, NewT, ArgInfo("NewT", 0)) )
    {
        ERRWRAP2(_self_->updatePose(NewR, NewT));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_updatePoseQuat(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ppf_match_3d;


    Ptr<cv::ppf_match_3d::Pose3D> * self1 = 0;
    if (!pyopencv_ppf_match_3d_Pose3D_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ppf_match_3d_Pose3D' or its derivative)");
    Ptr<cv::ppf_match_3d::Pose3D> _self_ = *(self1);
    PyObject* pyobj_Q = NULL;
    Vec4d Q;
    PyObject* pyobj_NewT = NULL;
    Vec3d NewT;

    const char* keywords[] = { "Q", "NewT", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:ppf_match_3d_Pose3D.updatePoseQuat", (char**)keywords, &pyobj_Q, &pyobj_NewT) &&
        pyopencv_to(pyobj_Q, Q, ArgInfo("Q", 0)) &&
        pyopencv_to(pyobj_NewT, NewT, ArgInfo("NewT", 0)) )
    {
        ERRWRAP2(_self_->updatePoseQuat(Q, NewT));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ppf_match_3d_Pose3D)

static PyGetSetDef pyopencv_ppf_match_3d_Pose3D_getseters[] =
{
    {(char*)"alpha", (getter)pyopencv_ppf_match_3d_Pose3D_get_alpha, NULL, (char*)"alpha", NULL},
    {(char*)"angle", (getter)pyopencv_ppf_match_3d_Pose3D_get_angle, NULL, (char*)"angle", NULL},
    {(char*)"modelIndex", (getter)pyopencv_ppf_match_3d_Pose3D_get_modelIndex, NULL, (char*)"modelIndex", NULL},
    {(char*)"numVotes", (getter)pyopencv_ppf_match_3d_Pose3D_get_numVotes, NULL, (char*)"numVotes", NULL},
    {(char*)"pose", (getter)pyopencv_ppf_match_3d_Pose3D_get_pose, NULL, (char*)"pose", NULL},
    {(char*)"q", (getter)pyopencv_ppf_match_3d_Pose3D_get_q, NULL, (char*)"q", NULL},
    {(char*)"residual", (getter)pyopencv_ppf_match_3d_Pose3D_get_residual, NULL, (char*)"residual", NULL},
    {(char*)"t", (getter)pyopencv_ppf_match_3d_Pose3D_get_t, NULL, (char*)"t", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ppf_match_3d_Pose3D_methods[] =
{
    {"appendPose", CV_PY_FN_WITH_KW_(pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_appendPose, 0), "appendPose(IncrementalPose) -> None\n.   *  \\brief Left multiplies the existing pose in order to update the transformation\n.      *  \\param [in] IncrementalPose New pose to apply"},
    {"printPose", CV_PY_FN_WITH_KW_(pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_printPose, 0), "printPose() -> None\n."},
    {"updatePose", CV_PY_FN_WITH_KW_(pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_updatePose, 0), "updatePose(NewPose) -> None\n.   *  \\brief Updates the pose with the new one\n.      *  \\param [in] NewPose New pose to overwrite\n\n\n\nupdatePose(NewR, NewT) -> None\n.   *  \\brief Updates the pose with the new one"},
    {"updatePoseQuat", CV_PY_FN_WITH_KW_(pyopencv_cv_ppf_match_3d_ppf_match_3d_Pose3D_updatePoseQuat, 0), "updatePoseQuat(Q, NewT) -> None\n.   *  \\brief Updates the pose with the new one, but this time using quaternions to represent rotation"},

    {NULL,          NULL}
};

// Converter (ppf_match_3d_Pose3D)

template<>
struct PyOpenCV_Converter< Ptr<cv::ppf_match_3d::Pose3D> >
{
    static PyObject* from(const Ptr<cv::ppf_match_3d::Pose3D>& r)
    {
        return pyopencv_ppf_match_3d_Pose3D_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ppf_match_3d::Pose3D>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ppf_match_3d::Pose3D> * dst_;
        if (pyopencv_ppf_match_3d_Pose3D_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ppf_match_3d::Pose3D> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ppf_match_3d_PoseCluster3D (Generic)
//================================================================================

// GetSet (ppf_match_3d_PoseCluster3D)



// Methods (ppf_match_3d_PoseCluster3D)



// Tables (ppf_match_3d_PoseCluster3D)

static PyGetSetDef pyopencv_ppf_match_3d_PoseCluster3D_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ppf_match_3d_PoseCluster3D_methods[] =
{

    {NULL,          NULL}
};

// Converter (ppf_match_3d_PoseCluster3D)

template<>
struct PyOpenCV_Converter< Ptr<cv::ppf_match_3d::PoseCluster3D> >
{
    static PyObject* from(const Ptr<cv::ppf_match_3d::PoseCluster3D>& r)
    {
        return pyopencv_ppf_match_3d_PoseCluster3D_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ppf_match_3d::PoseCluster3D>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ppf_match_3d::PoseCluster3D> * dst_;
        if (pyopencv_ppf_match_3d_PoseCluster3D_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ppf_match_3d::PoseCluster3D> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// quality_QualityBRISQUE (Generic)
//================================================================================

// GetSet (quality_QualityBRISQUE)



// Methods (quality_QualityBRISQUE)

static PyObject* pyopencv_cv_quality_quality_QualityBRISQUE_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityBRISQUE> * self1 = 0;
    if (!pyopencv_quality_QualityBRISQUE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityBRISQUE' or its derivative)");
    Ptr<cv::quality::QualityBRISQUE> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    cv::Scalar retval;

    const char* keywords[] = { "img", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityBRISQUE.compute", (char**)keywords, &pyobj_img) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(img));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    cv::Scalar retval;

    const char* keywords[] = { "img", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityBRISQUE.compute", (char**)keywords, &pyobj_img) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(img));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_model_file_path = NULL;
    String model_file_path;
    PyObject* pyobj_range_file_path = NULL;
    String range_file_path;
    cv::Scalar retval;

    const char* keywords[] = { "img", "model_file_path", "range_file_path", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:quality_QualityBRISQUE.compute", (char**)keywords, &pyobj_img, &pyobj_model_file_path, &pyobj_range_file_path) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_model_file_path, model_file_path, ArgInfo("model_file_path", 0)) &&
        pyopencv_to(pyobj_range_file_path, range_file_path, ArgInfo("range_file_path", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(img, model_file_path, range_file_path));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_model_file_path = NULL;
    String model_file_path;
    PyObject* pyobj_range_file_path = NULL;
    String range_file_path;
    cv::Scalar retval;

    const char* keywords[] = { "img", "model_file_path", "range_file_path", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:quality_QualityBRISQUE.compute", (char**)keywords, &pyobj_img, &pyobj_model_file_path, &pyobj_range_file_path) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_model_file_path, model_file_path, ArgInfo("model_file_path", 0)) &&
        pyopencv_to(pyobj_range_file_path, range_file_path, ArgInfo("range_file_path", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(img, model_file_path, range_file_path));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityBRISQUE_computeFeatures_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;

    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_features = NULL;
    Mat features;

    const char* keywords[] = { "img", "features", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:quality_QualityBRISQUE.computeFeatures", (char**)keywords, &pyobj_img, &pyobj_features) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 1)) )
    {
        ERRWRAP2(cv::quality::QualityBRISQUE::computeFeatures(img, features));
        return pyopencv_from(features);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_features = NULL;
    UMat features;

    const char* keywords[] = { "img", "features", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:quality_QualityBRISQUE.computeFeatures", (char**)keywords, &pyobj_img, &pyobj_features) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 1)) )
    {
        ERRWRAP2(cv::quality::QualityBRISQUE::computeFeatures(img, features));
        return pyopencv_from(features);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityBRISQUE_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;

    {
    PyObject* pyobj_model_file_path = NULL;
    String model_file_path;
    PyObject* pyobj_range_file_path = NULL;
    String range_file_path;
    Ptr<QualityBRISQUE> retval;

    const char* keywords[] = { "model_file_path", "range_file_path", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:quality_QualityBRISQUE.create", (char**)keywords, &pyobj_model_file_path, &pyobj_range_file_path) &&
        pyopencv_to(pyobj_model_file_path, model_file_path, ArgInfo("model_file_path", 0)) &&
        pyopencv_to(pyobj_range_file_path, range_file_path, ArgInfo("range_file_path", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityBRISQUE::create(model_file_path, range_file_path));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_model = NULL;
    Ptr<ml::SVM> model;
    PyObject* pyobj_range = NULL;
    Mat range;
    Ptr<QualityBRISQUE> retval;

    const char* keywords[] = { "model", "range", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:quality_QualityBRISQUE.create", (char**)keywords, &pyobj_model, &pyobj_range) &&
        pyopencv_to(pyobj_model, model, ArgInfo("model", 0)) &&
        pyopencv_to(pyobj_range, range, ArgInfo("range", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityBRISQUE::create(model, range));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_model = NULL;
    Ptr<ml::SVM> model;
    PyObject* pyobj_range = NULL;
    Mat range;
    Ptr<QualityBRISQUE> retval;

    const char* keywords[] = { "model", "range", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:quality_QualityBRISQUE.create", (char**)keywords, &pyobj_model, &pyobj_range) &&
        pyopencv_to(pyobj_model, model, ArgInfo("model", 0)) &&
        pyopencv_to(pyobj_range, range, ArgInfo("range", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityBRISQUE::create(model, range));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (quality_QualityBRISQUE)

static PyGetSetDef pyopencv_quality_QualityBRISQUE_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_quality_QualityBRISQUE_methods[] =
{
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityBRISQUE_compute, 0), "compute(img) -> retval\n.   @brief Computes BRISQUE quality score for input image\n.       @param img Image for which to compute quality\n.       @returns cv::Scalar with the score in the first element.  The score ranges from 0 (best quality) to 100 (worst quality)\n\n\n\ncompute(img, model_file_path, range_file_path) -> retval\n.   @brief static method for computing quality\n.       @param img image for which to compute quality\n.       @param model_file_path cv::String which contains a path to the BRISQUE model data, eg. /path/to/brisque_model_live.yml\n.       @param range_file_path cv::String which contains a path to the BRISQUE range data, eg. /path/to/brisque_range_live.yml\n.       @returns cv::Scalar with the score in the first element.  The score ranges from 0 (best quality) to 100 (worst quality)"},
    {"computeFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityBRISQUE_computeFeatures_static, METH_STATIC), "computeFeatures(img[, features]) -> features\n.   @brief static method for computing image features used by the BRISQUE algorithm\n.       @param img image (BGR(A) or grayscale) for which to compute features\n.       @param features output row vector of features to cv::Mat or cv::UMat"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityBRISQUE_create_static, METH_STATIC), "create(model_file_path, range_file_path) -> retval\n.   @brief Create an object which calculates quality\n.       @param model_file_path cv::String which contains a path to the BRISQUE model data, eg. /path/to/brisque_model_live.yml\n.       @param range_file_path cv::String which contains a path to the BRISQUE range data, eg. /path/to/brisque_range_live.yml\n\n\n\ncreate(model, range) -> retval\n.   @brief Create an object which calculates quality\n.       @param model cv::Ptr<cv::ml::SVM> which contains a loaded BRISQUE model\n.       @param range cv::Mat which contains BRISQUE range data"},

    {NULL,          NULL}
};

// Converter (quality_QualityBRISQUE)

template<>
struct PyOpenCV_Converter< Ptr<cv::quality::QualityBRISQUE> >
{
    static PyObject* from(const Ptr<cv::quality::QualityBRISQUE>& r)
    {
        return pyopencv_quality_QualityBRISQUE_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::quality::QualityBRISQUE>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::quality::QualityBRISQUE> * dst_;
        if (pyopencv_quality_QualityBRISQUE_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::quality::QualityBRISQUE> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// quality_QualityBase (Generic)
//================================================================================

// GetSet (quality_QualityBase)



// Methods (quality_QualityBase)

static PyObject* pyopencv_cv_quality_quality_QualityBase_clear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityBase> * self1 = 0;
    if (!pyopencv_quality_QualityBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityBase' or its derivative)");
    Ptr<cv::quality::QualityBase> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clear());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityBase_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityBase> * self1 = 0;
    if (!pyopencv_quality_QualityBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityBase' or its derivative)");
    Ptr<cv::quality::QualityBase> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    cv::Scalar retval;

    const char* keywords[] = { "img", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityBase.compute", (char**)keywords, &pyobj_img) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(img));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    cv::Scalar retval;

    const char* keywords[] = { "img", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityBase.compute", (char**)keywords, &pyobj_img) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(img));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityBase_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityBase> * self1 = 0;
    if (!pyopencv_quality_QualityBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityBase' or its derivative)");
    Ptr<cv::quality::QualityBase> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityBase_getQualityMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityBase> * self1 = 0;
    if (!pyopencv_quality_QualityBase_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityBase' or its derivative)");
    Ptr<cv::quality::QualityBase> _self_ = *(self1);
    {
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:quality_QualityBase.getQualityMap", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->getQualityMap(dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:quality_QualityBase.getQualityMap", (char**)keywords, &pyobj_dst) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->getQualityMap(dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (quality_QualityBase)

static PyGetSetDef pyopencv_quality_QualityBase_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_quality_QualityBase_methods[] =
{
    {"clear", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityBase_clear, 0), "clear() -> None\n.   @brief Implements Algorithm::clear()"},
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityBase_compute, 0), "compute(img) -> retval\n.   @brief Compute quality score per channel with the per-channel score in each element of the resulting cv::Scalar.  See specific algorithm for interpreting result scores\n.       @param img comparison image, or image to evalute for no-reference quality algorithms"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityBase_empty, 0), "empty() -> retval\n.   @brief Implements Algorithm::empty()"},
    {"getQualityMap", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityBase_getQualityMap, 0), "getQualityMap([, dst]) -> dst\n.   @brief Returns output quality map that was generated during computation, if supported by the algorithm"},

    {NULL,          NULL}
};

// Converter (quality_QualityBase)

template<>
struct PyOpenCV_Converter< Ptr<cv::quality::QualityBase> >
{
    static PyObject* from(const Ptr<cv::quality::QualityBase>& r)
    {
        return pyopencv_quality_QualityBase_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::quality::QualityBase>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::quality::QualityBase> * dst_;
        if (pyopencv_quality_QualityBase_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::quality::QualityBase> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// quality_QualityGMSD (Generic)
//================================================================================

// GetSet (quality_QualityGMSD)



// Methods (quality_QualityGMSD)

static PyObject* pyopencv_cv_quality_quality_QualityGMSD_clear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityGMSD> * self1 = 0;
    if (!pyopencv_quality_QualityGMSD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityGMSD' or its derivative)");
    Ptr<cv::quality::QualityGMSD> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clear());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityGMSD_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityGMSD> * self1 = 0;
    if (!pyopencv_quality_QualityGMSD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityGMSD' or its derivative)");
    Ptr<cv::quality::QualityGMSD> _self_ = *(self1);
    {
    PyObject* pyobj_cmp = NULL;
    Mat cmp;
    cv::Scalar retval;

    const char* keywords[] = { "cmp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityGMSD.compute", (char**)keywords, &pyobj_cmp) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(cmp));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_cmp = NULL;
    UMat cmp;
    cv::Scalar retval;

    const char* keywords[] = { "cmp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityGMSD.compute", (char**)keywords, &pyobj_cmp) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(cmp));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    Mat ref;
    PyObject* pyobj_cmp = NULL;
    Mat cmp;
    PyObject* pyobj_qualityMap = NULL;
    Mat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:quality_QualityGMSD.compute", (char**)keywords, &pyobj_ref, &pyobj_cmp, &pyobj_qualityMap) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        pyopencv_to(pyobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) )
    {
        ERRWRAP2(retval = _self_->compute(ref, cmp, qualityMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(qualityMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    UMat ref;
    PyObject* pyobj_cmp = NULL;
    UMat cmp;
    PyObject* pyobj_qualityMap = NULL;
    UMat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:quality_QualityGMSD.compute", (char**)keywords, &pyobj_ref, &pyobj_cmp, &pyobj_qualityMap) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        pyopencv_to(pyobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) )
    {
        ERRWRAP2(retval = _self_->compute(ref, cmp, qualityMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(qualityMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityGMSD_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;

    {
    PyObject* pyobj_ref = NULL;
    Mat ref;
    Ptr<QualityGMSD> retval;

    const char* keywords[] = { "ref", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityGMSD.create", (char**)keywords, &pyobj_ref) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityGMSD::create(ref));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    UMat ref;
    Ptr<QualityGMSD> retval;

    const char* keywords[] = { "ref", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityGMSD.create", (char**)keywords, &pyobj_ref) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityGMSD::create(ref));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityGMSD_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityGMSD> * self1 = 0;
    if (!pyopencv_quality_QualityGMSD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityGMSD' or its derivative)");
    Ptr<cv::quality::QualityGMSD> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (quality_QualityGMSD)

static PyGetSetDef pyopencv_quality_QualityGMSD_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_quality_QualityGMSD_methods[] =
{
    {"clear", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityGMSD_clear, 0), "clear() -> None\n.   @brief Implements Algorithm::clear()"},
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityGMSD_compute, 0), "compute(cmp) -> retval\n.   @brief Compute GMSD\n.       @param cmp comparison image\n.       @returns cv::Scalar with per-channel quality value.  Values range from 0 (worst) to 1 (best)\n\n\n\ncompute(ref, cmp[, qualityMap]) -> retval, qualityMap\n.   @brief static method for computing quality\n.       @param ref reference image\n.       @param cmp comparison image\n.       @param qualityMap output quality map, or cv::noArray()\n.       @returns cv::Scalar with per-channel quality value.  Values range from 0 (worst) to 1 (best)"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityGMSD_create_static, METH_STATIC), "create(ref) -> retval\n.   @brief Create an object which calculates image quality\n.       @param ref reference image"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityGMSD_empty, 0), "empty() -> retval\n.   @brief Implements Algorithm::empty()"},

    {NULL,          NULL}
};

// Converter (quality_QualityGMSD)

template<>
struct PyOpenCV_Converter< Ptr<cv::quality::QualityGMSD> >
{
    static PyObject* from(const Ptr<cv::quality::QualityGMSD>& r)
    {
        return pyopencv_quality_QualityGMSD_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::quality::QualityGMSD>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::quality::QualityGMSD> * dst_;
        if (pyopencv_quality_QualityGMSD_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::quality::QualityGMSD> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// quality_QualityMSE (Generic)
//================================================================================

// GetSet (quality_QualityMSE)



// Methods (quality_QualityMSE)

static PyObject* pyopencv_cv_quality_quality_QualityMSE_clear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityMSE> * self1 = 0;
    if (!pyopencv_quality_QualityMSE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityMSE' or its derivative)");
    Ptr<cv::quality::QualityMSE> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clear());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityMSE_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityMSE> * self1 = 0;
    if (!pyopencv_quality_QualityMSE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityMSE' or its derivative)");
    Ptr<cv::quality::QualityMSE> _self_ = *(self1);
    {
    PyObject* pyobj_cmpImgs = NULL;
    vector_Mat cmpImgs;
    cv::Scalar retval;

    const char* keywords[] = { "cmpImgs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityMSE.compute", (char**)keywords, &pyobj_cmpImgs) &&
        pyopencv_to(pyobj_cmpImgs, cmpImgs, ArgInfo("cmpImgs", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(cmpImgs));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_cmpImgs = NULL;
    vector_Mat cmpImgs;
    cv::Scalar retval;

    const char* keywords[] = { "cmpImgs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityMSE.compute", (char**)keywords, &pyobj_cmpImgs) &&
        pyopencv_to(pyobj_cmpImgs, cmpImgs, ArgInfo("cmpImgs", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(cmpImgs));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    Mat ref;
    PyObject* pyobj_cmp = NULL;
    Mat cmp;
    PyObject* pyobj_qualityMap = NULL;
    Mat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:quality_QualityMSE.compute", (char**)keywords, &pyobj_ref, &pyobj_cmp, &pyobj_qualityMap) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        pyopencv_to(pyobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) )
    {
        ERRWRAP2(retval = _self_->compute(ref, cmp, qualityMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(qualityMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    UMat ref;
    PyObject* pyobj_cmp = NULL;
    UMat cmp;
    PyObject* pyobj_qualityMap = NULL;
    UMat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:quality_QualityMSE.compute", (char**)keywords, &pyobj_ref, &pyobj_cmp, &pyobj_qualityMap) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        pyopencv_to(pyobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) )
    {
        ERRWRAP2(retval = _self_->compute(ref, cmp, qualityMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(qualityMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityMSE_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;

    {
    PyObject* pyobj_ref = NULL;
    Mat ref;
    Ptr<QualityMSE> retval;

    const char* keywords[] = { "ref", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityMSE.create", (char**)keywords, &pyobj_ref) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityMSE::create(ref));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    UMat ref;
    Ptr<QualityMSE> retval;

    const char* keywords[] = { "ref", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityMSE.create", (char**)keywords, &pyobj_ref) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityMSE::create(ref));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityMSE_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityMSE> * self1 = 0;
    if (!pyopencv_quality_QualityMSE_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityMSE' or its derivative)");
    Ptr<cv::quality::QualityMSE> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (quality_QualityMSE)

static PyGetSetDef pyopencv_quality_QualityMSE_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_quality_QualityMSE_methods[] =
{
    {"clear", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityMSE_clear, 0), "clear() -> None\n.   @brief Implements Algorithm::clear()"},
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityMSE_compute, 0), "compute(cmpImgs) -> retval\n.   @brief Computes MSE for reference images supplied in class constructor and provided comparison images\n.       @param cmpImgs Comparison image(s)\n.       @returns cv::Scalar with per-channel quality values.  Values range from 0 (best) to potentially max float (worst)\n\n\n\ncompute(ref, cmp[, qualityMap]) -> retval, qualityMap\n.   @brief static method for computing quality\n.       @param ref reference image\n.       @param cmp comparison image=\n.       @param qualityMap output quality map, or cv::noArray()\n.       @returns cv::Scalar with per-channel quality values.  Values range from 0 (best) to max float (worst)"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityMSE_create_static, METH_STATIC), "create(ref) -> retval\n.   @brief Create an object which calculates quality\n.       @param ref input image to use as the reference for comparison"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityMSE_empty, 0), "empty() -> retval\n.   @brief Implements Algorithm::empty()"},

    {NULL,          NULL}
};

// Converter (quality_QualityMSE)

template<>
struct PyOpenCV_Converter< Ptr<cv::quality::QualityMSE> >
{
    static PyObject* from(const Ptr<cv::quality::QualityMSE>& r)
    {
        return pyopencv_quality_QualityMSE_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::quality::QualityMSE>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::quality::QualityMSE> * dst_;
        if (pyopencv_quality_QualityMSE_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::quality::QualityMSE> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// quality_QualityPSNR (Generic)
//================================================================================

// GetSet (quality_QualityPSNR)



// Methods (quality_QualityPSNR)

static PyObject* pyopencv_cv_quality_quality_QualityPSNR_clear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityPSNR> * self1 = 0;
    if (!pyopencv_quality_QualityPSNR_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityPSNR' or its derivative)");
    Ptr<cv::quality::QualityPSNR> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clear());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityPSNR_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityPSNR> * self1 = 0;
    if (!pyopencv_quality_QualityPSNR_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityPSNR' or its derivative)");
    Ptr<cv::quality::QualityPSNR> _self_ = *(self1);
    {
    PyObject* pyobj_cmp = NULL;
    Mat cmp;
    cv::Scalar retval;

    const char* keywords[] = { "cmp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityPSNR.compute", (char**)keywords, &pyobj_cmp) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(cmp));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_cmp = NULL;
    UMat cmp;
    cv::Scalar retval;

    const char* keywords[] = { "cmp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualityPSNR.compute", (char**)keywords, &pyobj_cmp) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(cmp));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    Mat ref;
    PyObject* pyobj_cmp = NULL;
    Mat cmp;
    PyObject* pyobj_qualityMap = NULL;
    Mat qualityMap;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", "maxPixelValue", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Od:quality_QualityPSNR.compute", (char**)keywords, &pyobj_ref, &pyobj_cmp, &pyobj_qualityMap, &maxPixelValue) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        pyopencv_to(pyobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) )
    {
        ERRWRAP2(retval = _self_->compute(ref, cmp, qualityMap, maxPixelValue));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(qualityMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    UMat ref;
    PyObject* pyobj_cmp = NULL;
    UMat cmp;
    PyObject* pyobj_qualityMap = NULL;
    UMat qualityMap;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", "maxPixelValue", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Od:quality_QualityPSNR.compute", (char**)keywords, &pyobj_ref, &pyobj_cmp, &pyobj_qualityMap, &maxPixelValue) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        pyopencv_to(pyobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) )
    {
        ERRWRAP2(retval = _self_->compute(ref, cmp, qualityMap, maxPixelValue));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(qualityMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityPSNR_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;

    {
    PyObject* pyobj_ref = NULL;
    Mat ref;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    Ptr<QualityPSNR> retval;

    const char* keywords[] = { "ref", "maxPixelValue", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|d:quality_QualityPSNR.create", (char**)keywords, &pyobj_ref, &maxPixelValue) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityPSNR::create(ref, maxPixelValue));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    UMat ref;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    Ptr<QualityPSNR> retval;

    const char* keywords[] = { "ref", "maxPixelValue", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|d:quality_QualityPSNR.create", (char**)keywords, &pyobj_ref, &maxPixelValue) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualityPSNR::create(ref, maxPixelValue));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityPSNR_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityPSNR> * self1 = 0;
    if (!pyopencv_quality_QualityPSNR_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityPSNR' or its derivative)");
    Ptr<cv::quality::QualityPSNR> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityPSNR_getMaxPixelValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityPSNR> * self1 = 0;
    if (!pyopencv_quality_QualityPSNR_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityPSNR' or its derivative)");
    Ptr<cv::quality::QualityPSNR> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxPixelValue());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualityPSNR_setMaxPixelValue(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualityPSNR> * self1 = 0;
    if (!pyopencv_quality_QualityPSNR_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualityPSNR' or its derivative)");
    Ptr<cv::quality::QualityPSNR> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:quality_QualityPSNR.setMaxPixelValue", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxPixelValue(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (quality_QualityPSNR)

static PyGetSetDef pyopencv_quality_QualityPSNR_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_quality_QualityPSNR_methods[] =
{
    {"clear", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityPSNR_clear, 0), "clear() -> None\n.   @brief Implements Algorithm::clear()"},
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityPSNR_compute, 0), "compute(cmp) -> retval\n.   @brief Compute the PSNR\n.       @param cmp Comparison image\n.       @returns Per-channel PSNR value, or std::numeric_limits<double>::infinity() if the MSE between the two images == 0\n\n\n\ncompute(ref, cmp[, qualityMap[, maxPixelValue]]) -> retval, qualityMap\n.   @brief static method for computing quality\n.       @param ref reference image\n.       @param cmp comparison image\n.       @param qualityMap output quality map, or cv::noArray()\n.       @param maxPixelValue maximum per-channel value for any individual pixel; eg 255 for uint8 image\n.       @returns PSNR value, or std::numeric_limits<double>::infinity() if the MSE between the two images == 0"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityPSNR_create_static, METH_STATIC), "create(ref[, maxPixelValue]) -> retval\n.   @brief Create an object which calculates quality\n.       @param ref input image to use as the source for comparison\n.       @param maxPixelValue maximum per-channel value for any individual pixel; eg 255 for uint8 image"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityPSNR_empty, 0), "empty() -> retval\n.   @brief Implements Algorithm::empty()"},
    {"getMaxPixelValue", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityPSNR_getMaxPixelValue, 0), "getMaxPixelValue() -> retval\n.   @brief return the maximum pixel value used for PSNR computation"},
    {"setMaxPixelValue", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualityPSNR_setMaxPixelValue, 0), "setMaxPixelValue(val) -> None\n.   @brief sets the maximum pixel value used for PSNR computation\n.       @param val Maximum pixel value"},

    {NULL,          NULL}
};

// Converter (quality_QualityPSNR)

template<>
struct PyOpenCV_Converter< Ptr<cv::quality::QualityPSNR> >
{
    static PyObject* from(const Ptr<cv::quality::QualityPSNR>& r)
    {
        return pyopencv_quality_QualityPSNR_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::quality::QualityPSNR>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::quality::QualityPSNR> * dst_;
        if (pyopencv_quality_QualityPSNR_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::quality::QualityPSNR> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// quality_QualitySSIM (Generic)
//================================================================================

// GetSet (quality_QualitySSIM)



// Methods (quality_QualitySSIM)

static PyObject* pyopencv_cv_quality_quality_QualitySSIM_clear(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualitySSIM> * self1 = 0;
    if (!pyopencv_quality_QualitySSIM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualitySSIM' or its derivative)");
    Ptr<cv::quality::QualitySSIM> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clear());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualitySSIM_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualitySSIM> * self1 = 0;
    if (!pyopencv_quality_QualitySSIM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualitySSIM' or its derivative)");
    Ptr<cv::quality::QualitySSIM> _self_ = *(self1);
    {
    PyObject* pyobj_cmp = NULL;
    Mat cmp;
    cv::Scalar retval;

    const char* keywords[] = { "cmp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualitySSIM.compute", (char**)keywords, &pyobj_cmp) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(cmp));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_cmp = NULL;
    UMat cmp;
    cv::Scalar retval;

    const char* keywords[] = { "cmp", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualitySSIM.compute", (char**)keywords, &pyobj_cmp) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(cmp));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    Mat ref;
    PyObject* pyobj_cmp = NULL;
    Mat cmp;
    PyObject* pyobj_qualityMap = NULL;
    Mat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:quality_QualitySSIM.compute", (char**)keywords, &pyobj_ref, &pyobj_cmp, &pyobj_qualityMap) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        pyopencv_to(pyobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) )
    {
        ERRWRAP2(retval = _self_->compute(ref, cmp, qualityMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(qualityMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    UMat ref;
    PyObject* pyobj_cmp = NULL;
    UMat cmp;
    PyObject* pyobj_qualityMap = NULL;
    UMat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:quality_QualitySSIM.compute", (char**)keywords, &pyobj_ref, &pyobj_cmp, &pyobj_qualityMap) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) &&
        pyopencv_to(pyobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        pyopencv_to(pyobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) )
    {
        ERRWRAP2(retval = _self_->compute(ref, cmp, qualityMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(qualityMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualitySSIM_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;

    {
    PyObject* pyobj_ref = NULL;
    Mat ref;
    Ptr<QualitySSIM> retval;

    const char* keywords[] = { "ref", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualitySSIM.create", (char**)keywords, &pyobj_ref) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualitySSIM::create(ref));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_ref = NULL;
    UMat ref;
    Ptr<QualitySSIM> retval;

    const char* keywords[] = { "ref", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:quality_QualitySSIM.create", (char**)keywords, &pyobj_ref) &&
        pyopencv_to(pyobj_ref, ref, ArgInfo("ref", 0)) )
    {
        ERRWRAP2(retval = cv::quality::QualitySSIM::create(ref));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_quality_quality_QualitySSIM_empty(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::quality;


    Ptr<cv::quality::QualitySSIM> * self1 = 0;
    if (!pyopencv_quality_QualitySSIM_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'quality_QualitySSIM' or its derivative)");
    Ptr<cv::quality::QualitySSIM> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->empty());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (quality_QualitySSIM)

static PyGetSetDef pyopencv_quality_QualitySSIM_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_quality_QualitySSIM_methods[] =
{
    {"clear", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualitySSIM_clear, 0), "clear() -> None\n.   @brief Implements Algorithm::clear()"},
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualitySSIM_compute, 0), "compute(cmp) -> retval\n.   @brief Computes SSIM\n.       @param cmp Comparison image\n.       @returns cv::Scalar with per-channel quality values.  Values range from 0 (worst) to 1 (best)\n\n\n\ncompute(ref, cmp[, qualityMap]) -> retval, qualityMap\n.   @brief static method for computing quality\n.       @param ref reference image\n.       @param cmp comparison image\n.       @param qualityMap output quality map, or cv::noArray()\n.       @returns cv::Scalar with per-channel quality values.  Values range from 0 (worst) to 1 (best)"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualitySSIM_create_static, METH_STATIC), "create(ref) -> retval\n.   @brief Create an object which calculates quality\n.       @param ref input image to use as the reference image for comparison"},
    {"empty", CV_PY_FN_WITH_KW_(pyopencv_cv_quality_quality_QualitySSIM_empty, 0), "empty() -> retval\n.   @brief Implements Algorithm::empty()"},

    {NULL,          NULL}
};

// Converter (quality_QualitySSIM)

template<>
struct PyOpenCV_Converter< Ptr<cv::quality::QualitySSIM> >
{
    static PyObject* from(const Ptr<cv::quality::QualitySSIM>& r)
    {
        return pyopencv_quality_QualitySSIM_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::quality::QualitySSIM>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::quality::QualitySSIM> * dst_;
        if (pyopencv_quality_QualitySSIM_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::quality::QualitySSIM> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_Map (Generic)
//================================================================================

// GetSet (reg_Map)



// Methods (reg_Map)

static PyObject* pyopencv_cv_reg_reg_Map_compose(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::Map> * self1 = 0;
    if (!pyopencv_reg_Map_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_Map' or its derivative)");
    Ptr<cv::reg::Map> _self_ = *(self1);
    PyObject* pyobj_map = NULL;
    Ptr<Map> map;

    const char* keywords[] = { "map", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:reg_Map.compose", (char**)keywords, &pyobj_map) &&
        pyopencv_to(pyobj_map, map, ArgInfo("map", 0)) )
    {
        ERRWRAP2(_self_->compose(map));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_Map_inverseMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::Map> * self1 = 0;
    if (!pyopencv_reg_Map_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_Map' or its derivative)");
    Ptr<cv::reg::Map> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->inverseMap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_Map_inverseWarp(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::Map> * self1 = 0;
    if (!pyopencv_reg_Map_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_Map' or its derivative)");
    Ptr<cv::reg::Map> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_Map.inverseWarp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->inverseWarp(img1, img2));
        return pyopencv_from(img2);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_Map.inverseWarp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->inverseWarp(img1, img2));
        return pyopencv_from(img2);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_Map_scale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::Map> * self1 = 0;
    if (!pyopencv_reg_Map_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_Map' or its derivative)");
    Ptr<cv::reg::Map> _self_ = *(self1);
    double factor=0;

    const char* keywords[] = { "factor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:reg_Map.scale", (char**)keywords, &factor) )
    {
        ERRWRAP2(_self_->scale(factor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_Map_warp(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::Map> * self1 = 0;
    if (!pyopencv_reg_Map_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_Map' or its derivative)");
    Ptr<cv::reg::Map> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_Map.warp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->warp(img1, img2));
        return pyopencv_from(img2);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_Map.warp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->warp(img1, img2));
        return pyopencv_from(img2);
    }
    }

    return NULL;
}



// Tables (reg_Map)

static PyGetSetDef pyopencv_reg_Map_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_Map_methods[] =
{
    {"compose", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_Map_compose, 0), "compose(map) -> None\n."},
    {"inverseMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_Map_inverseMap, 0), "inverseMap() -> retval\n."},
    {"inverseWarp", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_Map_inverseWarp, 0), "inverseWarp(img1[, img2]) -> img2\n."},
    {"scale", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_Map_scale, 0), "scale(factor) -> None\n."},
    {"warp", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_Map_warp, 0), "warp(img1[, img2]) -> img2\n."},

    {NULL,          NULL}
};

// Converter (reg_Map)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::Map> >
{
    static PyObject* from(const Ptr<cv::reg::Map>& r)
    {
        return pyopencv_reg_Map_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::Map>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::Map> * dst_;
        if (pyopencv_reg_Map_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::Map> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapAffine (Generic)
//================================================================================

// GetSet (reg_MapAffine)



// Methods (reg_MapAffine)

static int pyopencv_cv_reg_reg_MapAffine_MapAffine(pyopencv_reg_MapAffine_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::reg::MapAffine>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapAffine()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_linTr = NULL;
    Mat linTr;
    PyObject* pyobj_shift = NULL;
    Mat shift;

    const char* keywords[] = { "linTr", "shift", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:MapAffine", (char**)keywords, &pyobj_linTr, &pyobj_shift) &&
        pyopencv_to(pyobj_linTr, linTr, ArgInfo("linTr", 0)) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 0)) )
    {
        new (&(self->v)) Ptr<cv::reg::MapAffine>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapAffine(linTr, shift)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_linTr = NULL;
    UMat linTr;
    PyObject* pyobj_shift = NULL;
    UMat shift;

    const char* keywords[] = { "linTr", "shift", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:MapAffine", (char**)keywords, &pyobj_linTr, &pyobj_shift) &&
        pyopencv_to(pyobj_linTr, linTr, ArgInfo("linTr", 0)) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 0)) )
    {
        new (&(self->v)) Ptr<cv::reg::MapAffine>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapAffine(linTr, shift)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapAffine_compose(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapAffine> * self1 = 0;
    if (!pyopencv_reg_MapAffine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapAffine' or its derivative)");
    Ptr<cv::reg::MapAffine> _self_ = *(self1);
    PyObject* pyobj_map = NULL;
    Ptr<Map> map;

    const char* keywords[] = { "map", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:reg_MapAffine.compose", (char**)keywords, &pyobj_map) &&
        pyopencv_to(pyobj_map, map, ArgInfo("map", 0)) )
    {
        ERRWRAP2(_self_->compose(map));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapAffine_getLinTr(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapAffine> * self1 = 0;
    if (!pyopencv_reg_MapAffine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapAffine' or its derivative)");
    Ptr<cv::reg::MapAffine> _self_ = *(self1);
    {
    PyObject* pyobj_linTr = NULL;
    Mat linTr;

    const char* keywords[] = { "linTr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:reg_MapAffine.getLinTr", (char**)keywords, &pyobj_linTr) &&
        pyopencv_to(pyobj_linTr, linTr, ArgInfo("linTr", 1)) )
    {
        ERRWRAP2(_self_->getLinTr(linTr));
        return pyopencv_from(linTr);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_linTr = NULL;
    UMat linTr;

    const char* keywords[] = { "linTr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:reg_MapAffine.getLinTr", (char**)keywords, &pyobj_linTr) &&
        pyopencv_to(pyobj_linTr, linTr, ArgInfo("linTr", 1)) )
    {
        ERRWRAP2(_self_->getLinTr(linTr));
        return pyopencv_from(linTr);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapAffine_getShift(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapAffine> * self1 = 0;
    if (!pyopencv_reg_MapAffine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapAffine' or its derivative)");
    Ptr<cv::reg::MapAffine> _self_ = *(self1);
    {
    PyObject* pyobj_shift = NULL;
    Mat shift;

    const char* keywords[] = { "shift", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:reg_MapAffine.getShift", (char**)keywords, &pyobj_shift) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 1)) )
    {
        ERRWRAP2(_self_->getShift(shift));
        return pyopencv_from(shift);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_shift = NULL;
    UMat shift;

    const char* keywords[] = { "shift", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:reg_MapAffine.getShift", (char**)keywords, &pyobj_shift) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 1)) )
    {
        ERRWRAP2(_self_->getShift(shift));
        return pyopencv_from(shift);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapAffine_inverseMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapAffine> * self1 = 0;
    if (!pyopencv_reg_MapAffine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapAffine' or its derivative)");
    Ptr<cv::reg::MapAffine> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->inverseMap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapAffine_inverseWarp(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapAffine> * self1 = 0;
    if (!pyopencv_reg_MapAffine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapAffine' or its derivative)");
    Ptr<cv::reg::MapAffine> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_MapAffine.inverseWarp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->inverseWarp(img1, img2));
        return pyopencv_from(img2);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_MapAffine.inverseWarp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->inverseWarp(img1, img2));
        return pyopencv_from(img2);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapAffine_scale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapAffine> * self1 = 0;
    if (!pyopencv_reg_MapAffine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapAffine' or its derivative)");
    Ptr<cv::reg::MapAffine> _self_ = *(self1);
    double factor=0;

    const char* keywords[] = { "factor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:reg_MapAffine.scale", (char**)keywords, &factor) )
    {
        ERRWRAP2(_self_->scale(factor));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (reg_MapAffine)

static PyGetSetDef pyopencv_reg_MapAffine_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapAffine_methods[] =
{
    {"compose", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapAffine_compose, 0), "compose(map) -> None\n."},
    {"getLinTr", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapAffine_getLinTr, 0), "getLinTr([, linTr]) -> linTr\n."},
    {"getShift", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapAffine_getShift, 0), "getShift([, shift]) -> shift\n."},
    {"inverseMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapAffine_inverseMap, 0), "inverseMap() -> retval\n."},
    {"inverseWarp", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapAffine_inverseWarp, 0), "inverseWarp(img1[, img2]) -> img2\n."},
    {"scale", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapAffine_scale, 0), "scale(factor) -> None\n."},

    {NULL,          NULL}
};

// Converter (reg_MapAffine)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapAffine> >
{
    static PyObject* from(const Ptr<cv::reg::MapAffine>& r)
    {
        return pyopencv_reg_MapAffine_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapAffine>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapAffine> * dst_;
        if (pyopencv_reg_MapAffine_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapAffine> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapProjec (Generic)
//================================================================================

// GetSet (reg_MapProjec)



// Methods (reg_MapProjec)

static int pyopencv_cv_reg_reg_MapProjec_MapProjec(pyopencv_reg_MapProjec_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::reg::MapProjec>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapProjec()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_projTr = NULL;
    Mat projTr;

    const char* keywords[] = { "projTr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MapProjec", (char**)keywords, &pyobj_projTr) &&
        pyopencv_to(pyobj_projTr, projTr, ArgInfo("projTr", 0)) )
    {
        new (&(self->v)) Ptr<cv::reg::MapProjec>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapProjec(projTr)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_projTr = NULL;
    UMat projTr;

    const char* keywords[] = { "projTr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MapProjec", (char**)keywords, &pyobj_projTr) &&
        pyopencv_to(pyobj_projTr, projTr, ArgInfo("projTr", 0)) )
    {
        new (&(self->v)) Ptr<cv::reg::MapProjec>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapProjec(projTr)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapProjec_compose(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapProjec> * self1 = 0;
    if (!pyopencv_reg_MapProjec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapProjec' or its derivative)");
    Ptr<cv::reg::MapProjec> _self_ = *(self1);
    PyObject* pyobj_map = NULL;
    Ptr<Map> map;

    const char* keywords[] = { "map", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:reg_MapProjec.compose", (char**)keywords, &pyobj_map) &&
        pyopencv_to(pyobj_map, map, ArgInfo("map", 0)) )
    {
        ERRWRAP2(_self_->compose(map));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapProjec_getProjTr(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapProjec> * self1 = 0;
    if (!pyopencv_reg_MapProjec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapProjec' or its derivative)");
    Ptr<cv::reg::MapProjec> _self_ = *(self1);
    {
    PyObject* pyobj_projTr = NULL;
    Mat projTr;

    const char* keywords[] = { "projTr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:reg_MapProjec.getProjTr", (char**)keywords, &pyobj_projTr) &&
        pyopencv_to(pyobj_projTr, projTr, ArgInfo("projTr", 1)) )
    {
        ERRWRAP2(_self_->getProjTr(projTr));
        return pyopencv_from(projTr);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_projTr = NULL;
    UMat projTr;

    const char* keywords[] = { "projTr", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:reg_MapProjec.getProjTr", (char**)keywords, &pyobj_projTr) &&
        pyopencv_to(pyobj_projTr, projTr, ArgInfo("projTr", 1)) )
    {
        ERRWRAP2(_self_->getProjTr(projTr));
        return pyopencv_from(projTr);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapProjec_inverseMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapProjec> * self1 = 0;
    if (!pyopencv_reg_MapProjec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapProjec' or its derivative)");
    Ptr<cv::reg::MapProjec> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->inverseMap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapProjec_inverseWarp(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapProjec> * self1 = 0;
    if (!pyopencv_reg_MapProjec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapProjec' or its derivative)");
    Ptr<cv::reg::MapProjec> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_MapProjec.inverseWarp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->inverseWarp(img1, img2));
        return pyopencv_from(img2);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_MapProjec.inverseWarp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->inverseWarp(img1, img2));
        return pyopencv_from(img2);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapProjec_normalize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapProjec> * self1 = 0;
    if (!pyopencv_reg_MapProjec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapProjec' or its derivative)");
    Ptr<cv::reg::MapProjec> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->normalize());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapProjec_scale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapProjec> * self1 = 0;
    if (!pyopencv_reg_MapProjec_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapProjec' or its derivative)");
    Ptr<cv::reg::MapProjec> _self_ = *(self1);
    double factor=0;

    const char* keywords[] = { "factor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:reg_MapProjec.scale", (char**)keywords, &factor) )
    {
        ERRWRAP2(_self_->scale(factor));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (reg_MapProjec)

static PyGetSetDef pyopencv_reg_MapProjec_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapProjec_methods[] =
{
    {"compose", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapProjec_compose, 0), "compose(map) -> None\n."},
    {"getProjTr", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapProjec_getProjTr, 0), "getProjTr([, projTr]) -> projTr\n."},
    {"inverseMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapProjec_inverseMap, 0), "inverseMap() -> retval\n."},
    {"inverseWarp", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapProjec_inverseWarp, 0), "inverseWarp(img1[, img2]) -> img2\n."},
    {"normalize", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapProjec_normalize, 0), "normalize() -> None\n."},
    {"scale", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapProjec_scale, 0), "scale(factor) -> None\n."},

    {NULL,          NULL}
};

// Converter (reg_MapProjec)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapProjec> >
{
    static PyObject* from(const Ptr<cv::reg::MapProjec>& r)
    {
        return pyopencv_reg_MapProjec_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapProjec>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapProjec> * dst_;
        if (pyopencv_reg_MapProjec_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapProjec> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapShift (Generic)
//================================================================================

// GetSet (reg_MapShift)



// Methods (reg_MapShift)

static int pyopencv_cv_reg_reg_MapShift_MapShift(pyopencv_reg_MapShift_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;

    {

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::reg::MapShift>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapShift()));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_shift = NULL;
    Mat shift;

    const char* keywords[] = { "shift", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MapShift", (char**)keywords, &pyobj_shift) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 0)) )
    {
        new (&(self->v)) Ptr<cv::reg::MapShift>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapShift(shift)));
        return 0;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_shift = NULL;
    UMat shift;

    const char* keywords[] = { "shift", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MapShift", (char**)keywords, &pyobj_shift) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 0)) )
    {
        new (&(self->v)) Ptr<cv::reg::MapShift>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapShift(shift)));
        return 0;
    }
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapShift_compose(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapShift> * self1 = 0;
    if (!pyopencv_reg_MapShift_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapShift' or its derivative)");
    Ptr<cv::reg::MapShift> _self_ = *(self1);
    PyObject* pyobj_map = NULL;
    Ptr<Map> map;

    const char* keywords[] = { "map", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:reg_MapShift.compose", (char**)keywords, &pyobj_map) &&
        pyopencv_to(pyobj_map, map, ArgInfo("map", 0)) )
    {
        ERRWRAP2(_self_->compose(map));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapShift_getShift(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapShift> * self1 = 0;
    if (!pyopencv_reg_MapShift_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapShift' or its derivative)");
    Ptr<cv::reg::MapShift> _self_ = *(self1);
    {
    PyObject* pyobj_shift = NULL;
    Mat shift;

    const char* keywords[] = { "shift", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:reg_MapShift.getShift", (char**)keywords, &pyobj_shift) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 1)) )
    {
        ERRWRAP2(_self_->getShift(shift));
        return pyopencv_from(shift);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_shift = NULL;
    UMat shift;

    const char* keywords[] = { "shift", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:reg_MapShift.getShift", (char**)keywords, &pyobj_shift) &&
        pyopencv_to(pyobj_shift, shift, ArgInfo("shift", 1)) )
    {
        ERRWRAP2(_self_->getShift(shift));
        return pyopencv_from(shift);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapShift_inverseMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapShift> * self1 = 0;
    if (!pyopencv_reg_MapShift_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapShift' or its derivative)");
    Ptr<cv::reg::MapShift> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->inverseMap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapShift_inverseWarp(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapShift> * self1 = 0;
    if (!pyopencv_reg_MapShift_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapShift' or its derivative)");
    Ptr<cv::reg::MapShift> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_MapShift.inverseWarp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->inverseWarp(img1, img2));
        return pyopencv_from(img2);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;

    const char* keywords[] = { "img1", "img2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:reg_MapShift.inverseWarp", (char**)keywords, &pyobj_img1, &pyobj_img2) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 1)) )
    {
        ERRWRAP2(_self_->inverseWarp(img1, img2));
        return pyopencv_from(img2);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapShift_scale(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapShift> * self1 = 0;
    if (!pyopencv_reg_MapShift_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapShift' or its derivative)");
    Ptr<cv::reg::MapShift> _self_ = *(self1);
    double factor=0;

    const char* keywords[] = { "factor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:reg_MapShift.scale", (char**)keywords, &factor) )
    {
        ERRWRAP2(_self_->scale(factor));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (reg_MapShift)

static PyGetSetDef pyopencv_reg_MapShift_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapShift_methods[] =
{
    {"compose", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapShift_compose, 0), "compose(map) -> None\n."},
    {"getShift", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapShift_getShift, 0), "getShift([, shift]) -> shift\n."},
    {"inverseMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapShift_inverseMap, 0), "inverseMap() -> retval\n."},
    {"inverseWarp", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapShift_inverseWarp, 0), "inverseWarp(img1[, img2]) -> img2\n."},
    {"scale", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapShift_scale, 0), "scale(factor) -> None\n."},

    {NULL,          NULL}
};

// Converter (reg_MapShift)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapShift> >
{
    static PyObject* from(const Ptr<cv::reg::MapShift>& r)
    {
        return pyopencv_reg_MapShift_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapShift>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapShift> * dst_;
        if (pyopencv_reg_MapShift_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapShift> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapTypeCaster (Generic)
//================================================================================

// GetSet (reg_MapTypeCaster)



// Methods (reg_MapTypeCaster)

static PyObject* pyopencv_cv_reg_reg_MapTypeCaster_toAffine_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;

    PyObject* pyobj_sourceMap = NULL;
    Ptr<Map> sourceMap;
    Ptr<MapAffine> retval;

    const char* keywords[] = { "sourceMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:reg_MapTypeCaster.toAffine", (char**)keywords, &pyobj_sourceMap) &&
        pyopencv_to(pyobj_sourceMap, sourceMap, ArgInfo("sourceMap", 0)) )
    {
        ERRWRAP2(retval = cv::reg::MapTypeCaster::toAffine(sourceMap));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapTypeCaster_toProjec_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;

    PyObject* pyobj_sourceMap = NULL;
    Ptr<Map> sourceMap;
    Ptr<MapProjec> retval;

    const char* keywords[] = { "sourceMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:reg_MapTypeCaster.toProjec", (char**)keywords, &pyobj_sourceMap) &&
        pyopencv_to(pyobj_sourceMap, sourceMap, ArgInfo("sourceMap", 0)) )
    {
        ERRWRAP2(retval = cv::reg::MapTypeCaster::toProjec(sourceMap));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapTypeCaster_toShift_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;

    PyObject* pyobj_sourceMap = NULL;
    Ptr<Map> sourceMap;
    Ptr<MapShift> retval;

    const char* keywords[] = { "sourceMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:reg_MapTypeCaster.toShift", (char**)keywords, &pyobj_sourceMap) &&
        pyopencv_to(pyobj_sourceMap, sourceMap, ArgInfo("sourceMap", 0)) )
    {
        ERRWRAP2(retval = cv::reg::MapTypeCaster::toShift(sourceMap));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (reg_MapTypeCaster)

static PyGetSetDef pyopencv_reg_MapTypeCaster_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapTypeCaster_methods[] =
{
    {"toAffine", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapTypeCaster_toAffine_static, METH_STATIC), "toAffine(sourceMap) -> retval\n."},
    {"toProjec", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapTypeCaster_toProjec_static, METH_STATIC), "toProjec(sourceMap) -> retval\n."},
    {"toShift", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapTypeCaster_toShift_static, METH_STATIC), "toShift(sourceMap) -> retval\n."},

    {NULL,          NULL}
};

// Converter (reg_MapTypeCaster)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapTypeCaster> >
{
    static PyObject* from(const Ptr<cv::reg::MapTypeCaster>& r)
    {
        return pyopencv_reg_MapTypeCaster_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapTypeCaster>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapTypeCaster> * dst_;
        if (pyopencv_reg_MapTypeCaster_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapTypeCaster> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_Mapper (Generic)
//================================================================================

// GetSet (reg_Mapper)



// Methods (reg_Mapper)

static PyObject* pyopencv_cv_reg_reg_Mapper_calculate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::Mapper> * self1 = 0;
    if (!pyopencv_reg_Mapper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_Mapper' or its derivative)");
    Ptr<cv::reg::Mapper> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_Mapper.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_Mapper.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_Mapper_getMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::Mapper> * self1 = 0;
    if (!pyopencv_reg_Mapper_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_Mapper' or its derivative)");
    Ptr<cv::reg::Mapper> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMap());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (reg_Mapper)

static PyGetSetDef pyopencv_reg_Mapper_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_Mapper_methods[] =
{
    {"calculate", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_Mapper_calculate, 0), "calculate(img1, img2[, init]) -> retval\n."},
    {"getMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_Mapper_getMap, 0), "getMap() -> retval\n."},

    {NULL,          NULL}
};

// Converter (reg_Mapper)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::Mapper> >
{
    static PyObject* from(const Ptr<cv::reg::Mapper>& r)
    {
        return pyopencv_reg_Mapper_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::Mapper>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::Mapper> * dst_;
        if (pyopencv_reg_Mapper_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::Mapper> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapperGradAffine (Generic)
//================================================================================

// GetSet (reg_MapperGradAffine)



// Methods (reg_MapperGradAffine)

static int pyopencv_cv_reg_reg_MapperGradAffine_MapperGradAffine(pyopencv_reg_MapperGradAffine_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::reg::MapperGradAffine>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapperGradAffine()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradAffine_calculate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradAffine> * self1 = 0;
    if (!pyopencv_reg_MapperGradAffine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradAffine' or its derivative)");
    Ptr<cv::reg::MapperGradAffine> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradAffine.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradAffine.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradAffine_getMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradAffine> * self1 = 0;
    if (!pyopencv_reg_MapperGradAffine_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradAffine' or its derivative)");
    Ptr<cv::reg::MapperGradAffine> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMap());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (reg_MapperGradAffine)

static PyGetSetDef pyopencv_reg_MapperGradAffine_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapperGradAffine_methods[] =
{
    {"calculate", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradAffine_calculate, 0), "calculate(img1, img2[, init]) -> retval\n."},
    {"getMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradAffine_getMap, 0), "getMap() -> retval\n."},

    {NULL,          NULL}
};

// Converter (reg_MapperGradAffine)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapperGradAffine> >
{
    static PyObject* from(const Ptr<cv::reg::MapperGradAffine>& r)
    {
        return pyopencv_reg_MapperGradAffine_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapperGradAffine>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapperGradAffine> * dst_;
        if (pyopencv_reg_MapperGradAffine_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapperGradAffine> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapperGradEuclid (Generic)
//================================================================================

// GetSet (reg_MapperGradEuclid)



// Methods (reg_MapperGradEuclid)

static int pyopencv_cv_reg_reg_MapperGradEuclid_MapperGradEuclid(pyopencv_reg_MapperGradEuclid_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::reg::MapperGradEuclid>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapperGradEuclid()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradEuclid_calculate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradEuclid> * self1 = 0;
    if (!pyopencv_reg_MapperGradEuclid_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradEuclid' or its derivative)");
    Ptr<cv::reg::MapperGradEuclid> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradEuclid.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradEuclid.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradEuclid_getMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradEuclid> * self1 = 0;
    if (!pyopencv_reg_MapperGradEuclid_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradEuclid' or its derivative)");
    Ptr<cv::reg::MapperGradEuclid> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMap());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (reg_MapperGradEuclid)

static PyGetSetDef pyopencv_reg_MapperGradEuclid_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapperGradEuclid_methods[] =
{
    {"calculate", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradEuclid_calculate, 0), "calculate(img1, img2[, init]) -> retval\n."},
    {"getMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradEuclid_getMap, 0), "getMap() -> retval\n."},

    {NULL,          NULL}
};

// Converter (reg_MapperGradEuclid)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapperGradEuclid> >
{
    static PyObject* from(const Ptr<cv::reg::MapperGradEuclid>& r)
    {
        return pyopencv_reg_MapperGradEuclid_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapperGradEuclid>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapperGradEuclid> * dst_;
        if (pyopencv_reg_MapperGradEuclid_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapperGradEuclid> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapperGradProj (Generic)
//================================================================================

// GetSet (reg_MapperGradProj)



// Methods (reg_MapperGradProj)

static int pyopencv_cv_reg_reg_MapperGradProj_MapperGradProj(pyopencv_reg_MapperGradProj_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::reg::MapperGradProj>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapperGradProj()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradProj_calculate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradProj> * self1 = 0;
    if (!pyopencv_reg_MapperGradProj_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradProj' or its derivative)");
    Ptr<cv::reg::MapperGradProj> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradProj.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradProj.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradProj_getMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradProj> * self1 = 0;
    if (!pyopencv_reg_MapperGradProj_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradProj' or its derivative)");
    Ptr<cv::reg::MapperGradProj> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMap());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (reg_MapperGradProj)

static PyGetSetDef pyopencv_reg_MapperGradProj_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapperGradProj_methods[] =
{
    {"calculate", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradProj_calculate, 0), "calculate(img1, img2[, init]) -> retval\n."},
    {"getMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradProj_getMap, 0), "getMap() -> retval\n."},

    {NULL,          NULL}
};

// Converter (reg_MapperGradProj)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapperGradProj> >
{
    static PyObject* from(const Ptr<cv::reg::MapperGradProj>& r)
    {
        return pyopencv_reg_MapperGradProj_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapperGradProj>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapperGradProj> * dst_;
        if (pyopencv_reg_MapperGradProj_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapperGradProj> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapperGradShift (Generic)
//================================================================================

// GetSet (reg_MapperGradShift)



// Methods (reg_MapperGradShift)

static int pyopencv_cv_reg_reg_MapperGradShift_MapperGradShift(pyopencv_reg_MapperGradShift_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::reg::MapperGradShift>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapperGradShift()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradShift_calculate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradShift> * self1 = 0;
    if (!pyopencv_reg_MapperGradShift_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradShift' or its derivative)");
    Ptr<cv::reg::MapperGradShift> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradShift.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradShift.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradShift_getMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradShift> * self1 = 0;
    if (!pyopencv_reg_MapperGradShift_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradShift' or its derivative)");
    Ptr<cv::reg::MapperGradShift> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMap());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (reg_MapperGradShift)

static PyGetSetDef pyopencv_reg_MapperGradShift_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapperGradShift_methods[] =
{
    {"calculate", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradShift_calculate, 0), "calculate(img1, img2[, init]) -> retval\n."},
    {"getMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradShift_getMap, 0), "getMap() -> retval\n."},

    {NULL,          NULL}
};

// Converter (reg_MapperGradShift)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapperGradShift> >
{
    static PyObject* from(const Ptr<cv::reg::MapperGradShift>& r)
    {
        return pyopencv_reg_MapperGradShift_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapperGradShift>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapperGradShift> * dst_;
        if (pyopencv_reg_MapperGradShift_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapperGradShift> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapperGradSimilar (Generic)
//================================================================================

// GetSet (reg_MapperGradSimilar)



// Methods (reg_MapperGradSimilar)

static int pyopencv_cv_reg_reg_MapperGradSimilar_MapperGradSimilar(pyopencv_reg_MapperGradSimilar_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::reg::MapperGradSimilar>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapperGradSimilar()));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradSimilar_calculate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradSimilar> * self1 = 0;
    if (!pyopencv_reg_MapperGradSimilar_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradSimilar' or its derivative)");
    Ptr<cv::reg::MapperGradSimilar> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradSimilar.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperGradSimilar.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapperGradSimilar_getMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperGradSimilar> * self1 = 0;
    if (!pyopencv_reg_MapperGradSimilar_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperGradSimilar' or its derivative)");
    Ptr<cv::reg::MapperGradSimilar> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMap());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (reg_MapperGradSimilar)

static PyGetSetDef pyopencv_reg_MapperGradSimilar_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapperGradSimilar_methods[] =
{
    {"calculate", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradSimilar_calculate, 0), "calculate(img1, img2[, init]) -> retval\n."},
    {"getMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperGradSimilar_getMap, 0), "getMap() -> retval\n."},

    {NULL,          NULL}
};

// Converter (reg_MapperGradSimilar)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapperGradSimilar> >
{
    static PyObject* from(const Ptr<cv::reg::MapperGradSimilar>& r)
    {
        return pyopencv_reg_MapperGradSimilar_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapperGradSimilar>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapperGradSimilar> * dst_;
        if (pyopencv_reg_MapperGradSimilar_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapperGradSimilar> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// reg_MapperPyramid (Generic)
//================================================================================

// GetSet (reg_MapperPyramid)


static PyObject* pyopencv_reg_MapperPyramid_get_numIterPerScale_(pyopencv_reg_MapperPyramid_t* p, void *closure)
{
    return pyopencv_from(p->v->numIterPerScale_);
}

static int pyopencv_reg_MapperPyramid_set_numIterPerScale_(pyopencv_reg_MapperPyramid_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the numIterPerScale_ attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->numIterPerScale_) ? 0 : -1;
}

static PyObject* pyopencv_reg_MapperPyramid_get_numLev_(pyopencv_reg_MapperPyramid_t* p, void *closure)
{
    return pyopencv_from(p->v->numLev_);
}

static int pyopencv_reg_MapperPyramid_set_numLev_(pyopencv_reg_MapperPyramid_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the numLev_ attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->numLev_) ? 0 : -1;
}


// Methods (reg_MapperPyramid)

static int pyopencv_cv_reg_reg_MapperPyramid_MapperPyramid(pyopencv_reg_MapperPyramid_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;

    PyObject* pyobj_baseMapper = NULL;
    Ptr<Mapper> baseMapper;

    const char* keywords[] = { "baseMapper", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:MapperPyramid", (char**)keywords, &pyobj_baseMapper) &&
        pyopencv_to(pyobj_baseMapper, baseMapper, ArgInfo("baseMapper", 0)) )
    {
        new (&(self->v)) Ptr<cv::reg::MapperPyramid>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::reg::MapperPyramid(baseMapper)));
        return 0;
    }

    return -1;
}

static PyObject* pyopencv_cv_reg_reg_MapperPyramid_calculate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperPyramid> * self1 = 0;
    if (!pyopencv_reg_MapperPyramid_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperPyramid' or its derivative)");
    Ptr<cv::reg::MapperPyramid> _self_ = *(self1);
    {
    PyObject* pyobj_img1 = NULL;
    Mat img1;
    PyObject* pyobj_img2 = NULL;
    Mat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperPyramid.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img1 = NULL;
    UMat img1;
    PyObject* pyobj_img2 = NULL;
    UMat img2;
    PyObject* pyobj_init = NULL;
    Ptr<Map> init=cv::Ptr<Map>();
    cv::Ptr<Map> retval;

    const char* keywords[] = { "img1", "img2", "init", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reg_MapperPyramid.calculate", (char**)keywords, &pyobj_img1, &pyobj_img2, &pyobj_init) &&
        pyopencv_to(pyobj_img1, img1, ArgInfo("img1", 0)) &&
        pyopencv_to(pyobj_img2, img2, ArgInfo("img2", 0)) &&
        pyopencv_to(pyobj_init, init, ArgInfo("init", 0)) )
    {
        ERRWRAP2(retval = _self_->calculate(img1, img2, init));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_reg_reg_MapperPyramid_getMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::reg;


    Ptr<cv::reg::MapperPyramid> * self1 = 0;
    if (!pyopencv_reg_MapperPyramid_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'reg_MapperPyramid' or its derivative)");
    Ptr<cv::reg::MapperPyramid> _self_ = *(self1);
    cv::Ptr<Map> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMap());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (reg_MapperPyramid)

static PyGetSetDef pyopencv_reg_MapperPyramid_getseters[] =
{
    {(char*)"numIterPerScale_", (getter)pyopencv_reg_MapperPyramid_get_numIterPerScale_, (setter)pyopencv_reg_MapperPyramid_set_numIterPerScale_, (char*)"numIterPerScale_", NULL},
    {(char*)"numLev_", (getter)pyopencv_reg_MapperPyramid_get_numLev_, (setter)pyopencv_reg_MapperPyramid_set_numLev_, (char*)"numLev_", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_reg_MapperPyramid_methods[] =
{
    {"calculate", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperPyramid_calculate, 0), "calculate(img1, img2[, init]) -> retval\n."},
    {"getMap", CV_PY_FN_WITH_KW_(pyopencv_cv_reg_reg_MapperPyramid_getMap, 0), "getMap() -> retval\n."},

    {NULL,          NULL}
};

// Converter (reg_MapperPyramid)

template<>
struct PyOpenCV_Converter< Ptr<cv::reg::MapperPyramid> >
{
    static PyObject* from(const Ptr<cv::reg::MapperPyramid>& r)
    {
        return pyopencv_reg_MapperPyramid_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::reg::MapperPyramid>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::reg::MapperPyramid> * dst_;
        if (pyopencv_reg_MapperPyramid_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::reg::MapperPyramid> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_DepthCleaner (Generic)
//================================================================================

// GetSet (rgbd_DepthCleaner)



// Methods (rgbd_DepthCleaner)

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::DepthCleaner> * self1 = 0;
    if (!pyopencv_rgbd_DepthCleaner_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_DepthCleaner' or its derivative)");
    Ptr<cv::rgbd::DepthCleaner> _self_ = *(self1);
    {
    PyObject* pyobj_points = NULL;
    Mat points;
    PyObject* pyobj_depth = NULL;
    Mat depth;

    const char* keywords[] = { "points", "depth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:rgbd_DepthCleaner.apply", (char**)keywords, &pyobj_points, &pyobj_depth) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 0)) &&
        pyopencv_to(pyobj_depth, depth, ArgInfo("depth", 1)) )
    {
        ERRWRAP2(_self_->operator ()(points, depth));
        return pyopencv_from(depth);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points = NULL;
    UMat points;
    PyObject* pyobj_depth = NULL;
    UMat depth;

    const char* keywords[] = { "points", "depth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:rgbd_DepthCleaner.apply", (char**)keywords, &pyobj_points, &pyobj_depth) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 0)) &&
        pyopencv_to(pyobj_depth, depth, ArgInfo("depth", 1)) )
    {
        ERRWRAP2(_self_->operator ()(points, depth));
        return pyopencv_from(depth);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    int depth=0;
    int window_size=5;
    int method=DepthCleaner::DEPTH_CLEANER_NIL;
    Ptr<DepthCleaner> retval;

    const char* keywords[] = { "depth", "window_size", "method", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i|ii:rgbd_DepthCleaner.create", (char**)keywords, &depth, &window_size, &method) )
    {
        ERRWRAP2(retval = cv::rgbd::DepthCleaner::create(depth, window_size, method));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_getDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::DepthCleaner> * self1 = 0;
    if (!pyopencv_rgbd_DepthCleaner_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_DepthCleaner' or its derivative)");
    Ptr<cv::rgbd::DepthCleaner> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_getMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::DepthCleaner> * self1 = 0;
    if (!pyopencv_rgbd_DepthCleaner_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_DepthCleaner' or its derivative)");
    Ptr<cv::rgbd::DepthCleaner> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMethod());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_getWindowSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::DepthCleaner> * self1 = 0;
    if (!pyopencv_rgbd_DepthCleaner_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_DepthCleaner' or its derivative)");
    Ptr<cv::rgbd::DepthCleaner> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWindowSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_initialize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::DepthCleaner> * self1 = 0;
    if (!pyopencv_rgbd_DepthCleaner_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_DepthCleaner' or its derivative)");
    Ptr<cv::rgbd::DepthCleaner> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->initialize());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_setDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::DepthCleaner> * self1 = 0;
    if (!pyopencv_rgbd_DepthCleaner_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_DepthCleaner' or its derivative)");
    Ptr<cv::rgbd::DepthCleaner> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_DepthCleaner.setDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_setMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::DepthCleaner> * self1 = 0;
    if (!pyopencv_rgbd_DepthCleaner_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_DepthCleaner' or its derivative)");
    Ptr<cv::rgbd::DepthCleaner> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_DepthCleaner.setMethod", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMethod(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_DepthCleaner_setWindowSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::DepthCleaner> * self1 = 0;
    if (!pyopencv_rgbd_DepthCleaner_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_DepthCleaner' or its derivative)");
    Ptr<cv::rgbd::DepthCleaner> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_DepthCleaner.setWindowSize", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setWindowSize(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_DepthCleaner)

static PyGetSetDef pyopencv_rgbd_DepthCleaner_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_DepthCleaner_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_apply, 0), "apply(points[, depth]) -> depth\n.   Given a set of 3d points in a depth image, compute the normals at each point.\n.        * @param points a rows x cols x 3 matrix of CV_32F/CV64F or a rows x cols x 1 CV_U16S\n.        * @param depth a rows x cols matrix of the cleaned up depth"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_create_static, METH_STATIC), "create(depth[, window_size[, method]]) -> retval\n.   Constructor\n.        * @param depth the depth of the normals (only CV_32F or CV_64F)\n.        * @param window_size the window size to compute the normals: can only be 1,3,5 or 7\n.        * @param method one of the methods to use: RGBD_NORMALS_METHOD_SRI, RGBD_NORMALS_METHOD_FALS"},
    {"getDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_getDepth, 0), "getDepth() -> retval\n."},
    {"getMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_getMethod, 0), "getMethod() -> retval\n."},
    {"getWindowSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_getWindowSize, 0), "getWindowSize() -> retval\n."},
    {"initialize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_initialize, 0), "initialize() -> None\n.   Initializes some data that is cached for later computation\n.        * If that function is not called, it will be called the first time normals are computed"},
    {"setDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_setDepth, 0), "setDepth(val) -> None\n."},
    {"setMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_setMethod, 0), "setMethod(val) -> None\n."},
    {"setWindowSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_DepthCleaner_setWindowSize, 0), "setWindowSize(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_DepthCleaner)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::DepthCleaner> >
{
    static PyObject* from(const Ptr<cv::rgbd::DepthCleaner>& r)
    {
        return pyopencv_rgbd_DepthCleaner_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::DepthCleaner>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::DepthCleaner> * dst_;
        if (pyopencv_rgbd_DepthCleaner_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::DepthCleaner> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_FastICPOdometry (Generic)
//================================================================================

// GetSet (rgbd_FastICPOdometry)



// Methods (rgbd_FastICPOdometry)

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    {
    PyObject* pyobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    float maxDistDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float angleThreshold=(float)(30. * CV_PI / 180.);
    float sigmaDepth=0.04f;
    float sigmaSpatial=4.5f;
    int kernelSize=7;
    PyObject* pyobj_iterCounts = NULL;
    vector_int iterCounts=std::vector<int>();
    Ptr<FastICPOdometry> retval;

    const char* keywords[] = { "cameraMatrix", "maxDistDiff", "angleThreshold", "sigmaDepth", "sigmaSpatial", "kernelSize", "iterCounts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|ffffiO:rgbd_FastICPOdometry.create", (char**)keywords, &pyobj_cameraMatrix, &maxDistDiff, &angleThreshold, &sigmaDepth, &sigmaSpatial, &kernelSize, &pyobj_iterCounts) &&
        pyopencv_to(pyobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        pyopencv_to(pyobj_iterCounts, iterCounts, ArgInfo("iterCounts", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::FastICPOdometry::create(cameraMatrix, maxDistDiff, angleThreshold, sigmaDepth, sigmaSpatial, kernelSize, iterCounts));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    float maxDistDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float angleThreshold=(float)(30. * CV_PI / 180.);
    float sigmaDepth=0.04f;
    float sigmaSpatial=4.5f;
    int kernelSize=7;
    PyObject* pyobj_iterCounts = NULL;
    vector_int iterCounts=std::vector<int>();
    Ptr<FastICPOdometry> retval;

    const char* keywords[] = { "cameraMatrix", "maxDistDiff", "angleThreshold", "sigmaDepth", "sigmaSpatial", "kernelSize", "iterCounts", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|ffffiO:rgbd_FastICPOdometry.create", (char**)keywords, &pyobj_cameraMatrix, &maxDistDiff, &angleThreshold, &sigmaDepth, &sigmaSpatial, &kernelSize, &pyobj_iterCounts) &&
        pyopencv_to(pyobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        pyopencv_to(pyobj_iterCounts, iterCounts, ArgInfo("iterCounts", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::FastICPOdometry::create(cameraMatrix, maxDistDiff, angleThreshold, sigmaDepth, sigmaSpatial, kernelSize, iterCounts));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_getAngleThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAngleThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_getCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCameraMatrix());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_getIterationCounts(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIterationCounts());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_getKernelSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getKernelSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_getMaxDistDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxDistDiff());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_getSigmaDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigmaDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_getSigmaSpatial(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigmaSpatial());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_getTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTransformType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_prepareFrameCache(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    PyObject* pyobj_frame = NULL;
    Ptr<OdometryFrame> frame;
    int cacheType=0;
    Size retval;

    const char* keywords[] = { "frame", "cacheType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:rgbd_FastICPOdometry.prepareFrameCache", (char**)keywords, &pyobj_frame, &cacheType) &&
        pyopencv_to(pyobj_frame, frame, ArgInfo("frame", 0)) )
    {
        ERRWRAP2(retval = _self_->prepareFrameCache(frame, cacheType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_setAngleThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    float f=0.f;

    const char* keywords[] = { "f", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:rgbd_FastICPOdometry.setAngleThreshold", (char**)keywords, &f) )
    {
        ERRWRAP2(_self_->setAngleThreshold(f));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_setCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_FastICPOdometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_FastICPOdometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_setIterationCounts(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_FastICPOdometry.setIterationCounts", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setIterationCounts(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_FastICPOdometry.setIterationCounts", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setIterationCounts(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_setKernelSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    int f=0;

    const char* keywords[] = { "f", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_FastICPOdometry.setKernelSize", (char**)keywords, &f) )
    {
        ERRWRAP2(_self_->setKernelSize(f));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_setMaxDistDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:rgbd_FastICPOdometry.setMaxDistDiff", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxDistDiff(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_setSigmaDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    float f=0.f;

    const char* keywords[] = { "f", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:rgbd_FastICPOdometry.setSigmaDepth", (char**)keywords, &f) )
    {
        ERRWRAP2(_self_->setSigmaDepth(f));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_setSigmaSpatial(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    float f=0.f;

    const char* keywords[] = { "f", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:rgbd_FastICPOdometry.setSigmaSpatial", (char**)keywords, &f) )
    {
        ERRWRAP2(_self_->setSigmaSpatial(f));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_FastICPOdometry_setTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::FastICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_FastICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_FastICPOdometry' or its derivative)");
    Ptr<cv::rgbd::FastICPOdometry> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_FastICPOdometry.setTransformType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTransformType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_FastICPOdometry)

static PyGetSetDef pyopencv_rgbd_FastICPOdometry_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_FastICPOdometry_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_create_static, METH_STATIC), "create(cameraMatrix[, maxDistDiff[, angleThreshold[, sigmaDepth[, sigmaSpatial[, kernelSize[, iterCounts]]]]]]) -> retval\n.   Constructor.\n.        * @param cameraMatrix Camera matrix\n.        * @param maxDistDiff Correspondences between pixels of two given frames will be filtered out\n.        *                     if their depth difference is larger than maxDepthDiff\n.        * @param angleThreshold Correspondence will be filtered out\n.        *                     if an angle between their normals is bigger than threshold\n.        * @param sigmaDepth Depth sigma in meters for bilateral smooth\n.        * @param sigmaSpatial Spatial sigma in pixels for bilateral smooth\n.        * @param kernelSize Kernel size in pixels for bilateral smooth\n.        * @param iterCounts Count of iterations on each pyramid level"},
    {"getAngleThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_getAngleThreshold, 0), "getAngleThreshold() -> retval\n."},
    {"getCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_getCameraMatrix, 0), "getCameraMatrix() -> retval\n."},
    {"getIterationCounts", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_getIterationCounts, 0), "getIterationCounts() -> retval\n."},
    {"getKernelSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_getKernelSize, 0), "getKernelSize() -> retval\n."},
    {"getMaxDistDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_getMaxDistDiff, 0), "getMaxDistDiff() -> retval\n."},
    {"getSigmaDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_getSigmaDepth, 0), "getSigmaDepth() -> retval\n."},
    {"getSigmaSpatial", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_getSigmaSpatial, 0), "getSigmaSpatial() -> retval\n."},
    {"getTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_getTransformType, 0), "getTransformType() -> retval\n."},
    {"prepareFrameCache", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_prepareFrameCache, 0), "prepareFrameCache(frame, cacheType) -> retval\n."},
    {"setAngleThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_setAngleThreshold, 0), "setAngleThreshold(f) -> None\n."},
    {"setCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_setCameraMatrix, 0), "setCameraMatrix(val) -> None\n."},
    {"setIterationCounts", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_setIterationCounts, 0), "setIterationCounts(val) -> None\n."},
    {"setKernelSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_setKernelSize, 0), "setKernelSize(f) -> None\n."},
    {"setMaxDistDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_setMaxDistDiff, 0), "setMaxDistDiff(val) -> None\n."},
    {"setSigmaDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_setSigmaDepth, 0), "setSigmaDepth(f) -> None\n."},
    {"setSigmaSpatial", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_setSigmaSpatial, 0), "setSigmaSpatial(f) -> None\n."},
    {"setTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_FastICPOdometry_setTransformType, 0), "setTransformType(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_FastICPOdometry)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::FastICPOdometry> >
{
    static PyObject* from(const Ptr<cv::rgbd::FastICPOdometry>& r)
    {
        return pyopencv_rgbd_FastICPOdometry_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::FastICPOdometry>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::FastICPOdometry> * dst_;
        if (pyopencv_rgbd_FastICPOdometry_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::FastICPOdometry> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_ICPOdometry (Generic)
//================================================================================

// GetSet (rgbd_ICPOdometry)



// Methods (rgbd_ICPOdometry)

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    {
    PyObject* pyobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    PyObject* pyobj_iterCounts = NULL;
    vector_int iterCounts=std::vector<int>();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<ICPOdometry> retval;

    const char* keywords[] = { "cameraMatrix", "minDepth", "maxDepth", "maxDepthDiff", "maxPointsPart", "iterCounts", "transformType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OffffOi:rgbd_ICPOdometry.create", (char**)keywords, &pyobj_cameraMatrix, &minDepth, &maxDepth, &maxDepthDiff, &maxPointsPart, &pyobj_iterCounts, &transformType) &&
        pyopencv_to(pyobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        pyopencv_to(pyobj_iterCounts, iterCounts, ArgInfo("iterCounts", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::ICPOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, maxPointsPart, iterCounts, transformType));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    PyObject* pyobj_iterCounts = NULL;
    vector_int iterCounts=std::vector<int>();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<ICPOdometry> retval;

    const char* keywords[] = { "cameraMatrix", "minDepth", "maxDepth", "maxDepthDiff", "maxPointsPart", "iterCounts", "transformType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OffffOi:rgbd_ICPOdometry.create", (char**)keywords, &pyobj_cameraMatrix, &minDepth, &maxDepth, &maxDepthDiff, &maxPointsPart, &pyobj_iterCounts, &transformType) &&
        pyopencv_to(pyobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        pyopencv_to(pyobj_iterCounts, iterCounts, ArgInfo("iterCounts", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::ICPOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, maxPointsPart, iterCounts, transformType));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCameraMatrix());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getIterationCounts(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIterationCounts());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxDepthDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxDepthDiff());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxPointsPart(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxPointsPart());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxRotation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxRotation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxTranslation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxTranslation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getMinDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getNormalsComputer(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    Ptr<RgbdNormals> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNormalsComputer());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_getTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTransformType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_prepareFrameCache(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    PyObject* pyobj_frame = NULL;
    Ptr<OdometryFrame> frame;
    int cacheType=0;
    Size retval;

    const char* keywords[] = { "frame", "cacheType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:rgbd_ICPOdometry.prepareFrameCache", (char**)keywords, &pyobj_frame, &cacheType) &&
        pyopencv_to(pyobj_frame, frame, ArgInfo("frame", 0)) )
    {
        ERRWRAP2(retval = _self_->prepareFrameCache(frame, cacheType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_ICPOdometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_ICPOdometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setIterationCounts(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_ICPOdometry.setIterationCounts", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setIterationCounts(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_ICPOdometry.setIterationCounts", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setIterationCounts(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_ICPOdometry.setMaxDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxDepthDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_ICPOdometry.setMaxDepthDiff", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxDepthDiff(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxPointsPart(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_ICPOdometry.setMaxPointsPart", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxPointsPart(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxRotation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_ICPOdometry.setMaxRotation", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxRotation(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxTranslation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_ICPOdometry.setMaxTranslation", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxTranslation(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setMinDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_ICPOdometry.setMinDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMinDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_ICPOdometry_setTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::ICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_ICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_ICPOdometry' or its derivative)");
    Ptr<cv::rgbd::ICPOdometry> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_ICPOdometry.setTransformType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTransformType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_ICPOdometry)

static PyGetSetDef pyopencv_rgbd_ICPOdometry_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_ICPOdometry_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_create_static, METH_STATIC), "create([, cameraMatrix[, minDepth[, maxDepth[, maxDepthDiff[, maxPointsPart[, iterCounts[, transformType]]]]]]]) -> retval\n.   Constructor.\n.        * @param cameraMatrix Camera matrix\n.        * @param minDepth Pixels with depth less than minDepth will not be used\n.        * @param maxDepth Pixels with depth larger than maxDepth will not be used\n.        * @param maxDepthDiff Correspondences between pixels of two given frames will be filtered out\n.        *                     if their depth difference is larger than maxDepthDiff\n.        * @param maxPointsPart The method uses a random pixels subset of size frameWidth x frameHeight x pointsPart\n.        * @param iterCounts Count of iterations on each pyramid level.\n.        * @param transformType Class of trasformation"},
    {"getCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getCameraMatrix, 0), "getCameraMatrix() -> retval\n."},
    {"getIterationCounts", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getIterationCounts, 0), "getIterationCounts() -> retval\n."},
    {"getMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxDepth, 0), "getMaxDepth() -> retval\n."},
    {"getMaxDepthDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxDepthDiff, 0), "getMaxDepthDiff() -> retval\n."},
    {"getMaxPointsPart", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxPointsPart, 0), "getMaxPointsPart() -> retval\n."},
    {"getMaxRotation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxRotation, 0), "getMaxRotation() -> retval\n."},
    {"getMaxTranslation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getMaxTranslation, 0), "getMaxTranslation() -> retval\n."},
    {"getMinDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getMinDepth, 0), "getMinDepth() -> retval\n."},
    {"getNormalsComputer", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getNormalsComputer, 0), "getNormalsComputer() -> retval\n."},
    {"getTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_getTransformType, 0), "getTransformType() -> retval\n."},
    {"prepareFrameCache", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_prepareFrameCache, 0), "prepareFrameCache(frame, cacheType) -> retval\n."},
    {"setCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setCameraMatrix, 0), "setCameraMatrix(val) -> None\n."},
    {"setIterationCounts", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setIterationCounts, 0), "setIterationCounts(val) -> None\n."},
    {"setMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxDepth, 0), "setMaxDepth(val) -> None\n."},
    {"setMaxDepthDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxDepthDiff, 0), "setMaxDepthDiff(val) -> None\n."},
    {"setMaxPointsPart", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxPointsPart, 0), "setMaxPointsPart(val) -> None\n."},
    {"setMaxRotation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxRotation, 0), "setMaxRotation(val) -> None\n."},
    {"setMaxTranslation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setMaxTranslation, 0), "setMaxTranslation(val) -> None\n."},
    {"setMinDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setMinDepth, 0), "setMinDepth(val) -> None\n."},
    {"setTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_ICPOdometry_setTransformType, 0), "setTransformType(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_ICPOdometry)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::ICPOdometry> >
{
    static PyObject* from(const Ptr<cv::rgbd::ICPOdometry>& r)
    {
        return pyopencv_rgbd_ICPOdometry_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::ICPOdometry>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::ICPOdometry> * dst_;
        if (pyopencv_rgbd_ICPOdometry_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::ICPOdometry> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_Odometry (Generic)
//================================================================================

// GetSet (rgbd_Odometry)



// Methods (rgbd_Odometry)

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_DEPTH(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->DEFAULT_MAX_DEPTH());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_DEPTH_DIFF(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->DEFAULT_MAX_DEPTH_DIFF());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_POINTS_PART(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->DEFAULT_MAX_POINTS_PART());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_ROTATION(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->DEFAULT_MAX_ROTATION());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_TRANSLATION(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->DEFAULT_MAX_TRANSLATION());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MIN_DEPTH(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->DEFAULT_MIN_DEPTH());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_compute(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    {
    PyObject* pyobj_srcImage = NULL;
    Mat srcImage;
    PyObject* pyobj_srcDepth = NULL;
    Mat srcDepth;
    PyObject* pyobj_srcMask = NULL;
    Mat srcMask;
    PyObject* pyobj_dstImage = NULL;
    Mat dstImage;
    PyObject* pyobj_dstDepth = NULL;
    Mat dstDepth;
    PyObject* pyobj_dstMask = NULL;
    Mat dstMask;
    PyObject* pyobj_Rt = NULL;
    Mat Rt;
    PyObject* pyobj_initRt = NULL;
    Mat initRt;
    bool retval;

    const char* keywords[] = { "srcImage", "srcDepth", "srcMask", "dstImage", "dstDepth", "dstMask", "Rt", "initRt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO|OO:rgbd_Odometry.compute", (char**)keywords, &pyobj_srcImage, &pyobj_srcDepth, &pyobj_srcMask, &pyobj_dstImage, &pyobj_dstDepth, &pyobj_dstMask, &pyobj_Rt, &pyobj_initRt) &&
        pyopencv_to(pyobj_srcImage, srcImage, ArgInfo("srcImage", 0)) &&
        pyopencv_to(pyobj_srcDepth, srcDepth, ArgInfo("srcDepth", 0)) &&
        pyopencv_to(pyobj_srcMask, srcMask, ArgInfo("srcMask", 0)) &&
        pyopencv_to(pyobj_dstImage, dstImage, ArgInfo("dstImage", 0)) &&
        pyopencv_to(pyobj_dstDepth, dstDepth, ArgInfo("dstDepth", 0)) &&
        pyopencv_to(pyobj_dstMask, dstMask, ArgInfo("dstMask", 0)) &&
        pyopencv_to(pyobj_Rt, Rt, ArgInfo("Rt", 1)) &&
        pyopencv_to(pyobj_initRt, initRt, ArgInfo("initRt", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(srcImage, srcDepth, srcMask, dstImage, dstDepth, dstMask, Rt, initRt));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(Rt));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_srcImage = NULL;
    Mat srcImage;
    PyObject* pyobj_srcDepth = NULL;
    Mat srcDepth;
    PyObject* pyobj_srcMask = NULL;
    Mat srcMask;
    PyObject* pyobj_dstImage = NULL;
    Mat dstImage;
    PyObject* pyobj_dstDepth = NULL;
    Mat dstDepth;
    PyObject* pyobj_dstMask = NULL;
    Mat dstMask;
    PyObject* pyobj_Rt = NULL;
    UMat Rt;
    PyObject* pyobj_initRt = NULL;
    Mat initRt;
    bool retval;

    const char* keywords[] = { "srcImage", "srcDepth", "srcMask", "dstImage", "dstDepth", "dstMask", "Rt", "initRt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO|OO:rgbd_Odometry.compute", (char**)keywords, &pyobj_srcImage, &pyobj_srcDepth, &pyobj_srcMask, &pyobj_dstImage, &pyobj_dstDepth, &pyobj_dstMask, &pyobj_Rt, &pyobj_initRt) &&
        pyopencv_to(pyobj_srcImage, srcImage, ArgInfo("srcImage", 0)) &&
        pyopencv_to(pyobj_srcDepth, srcDepth, ArgInfo("srcDepth", 0)) &&
        pyopencv_to(pyobj_srcMask, srcMask, ArgInfo("srcMask", 0)) &&
        pyopencv_to(pyobj_dstImage, dstImage, ArgInfo("dstImage", 0)) &&
        pyopencv_to(pyobj_dstDepth, dstDepth, ArgInfo("dstDepth", 0)) &&
        pyopencv_to(pyobj_dstMask, dstMask, ArgInfo("dstMask", 0)) &&
        pyopencv_to(pyobj_Rt, Rt, ArgInfo("Rt", 1)) &&
        pyopencv_to(pyobj_initRt, initRt, ArgInfo("initRt", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(srcImage, srcDepth, srcMask, dstImage, dstDepth, dstMask, Rt, initRt));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(Rt));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_compute2(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    {
    PyObject* pyobj_srcFrame = NULL;
    Ptr<OdometryFrame> srcFrame;
    PyObject* pyobj_dstFrame = NULL;
    Ptr<OdometryFrame> dstFrame;
    PyObject* pyobj_Rt = NULL;
    Mat Rt;
    PyObject* pyobj_initRt = NULL;
    Mat initRt;
    bool retval;

    const char* keywords[] = { "srcFrame", "dstFrame", "Rt", "initRt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:rgbd_Odometry.compute2", (char**)keywords, &pyobj_srcFrame, &pyobj_dstFrame, &pyobj_Rt, &pyobj_initRt) &&
        pyopencv_to(pyobj_srcFrame, srcFrame, ArgInfo("srcFrame", 0)) &&
        pyopencv_to(pyobj_dstFrame, dstFrame, ArgInfo("dstFrame", 0)) &&
        pyopencv_to(pyobj_Rt, Rt, ArgInfo("Rt", 1)) &&
        pyopencv_to(pyobj_initRt, initRt, ArgInfo("initRt", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(srcFrame, dstFrame, Rt, initRt));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(Rt));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_srcFrame = NULL;
    Ptr<OdometryFrame> srcFrame;
    PyObject* pyobj_dstFrame = NULL;
    Ptr<OdometryFrame> dstFrame;
    PyObject* pyobj_Rt = NULL;
    UMat Rt;
    PyObject* pyobj_initRt = NULL;
    Mat initRt;
    bool retval;

    const char* keywords[] = { "srcFrame", "dstFrame", "Rt", "initRt", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:rgbd_Odometry.compute2", (char**)keywords, &pyobj_srcFrame, &pyobj_dstFrame, &pyobj_Rt, &pyobj_initRt) &&
        pyopencv_to(pyobj_srcFrame, srcFrame, ArgInfo("srcFrame", 0)) &&
        pyopencv_to(pyobj_dstFrame, dstFrame, ArgInfo("dstFrame", 0)) &&
        pyopencv_to(pyobj_Rt, Rt, ArgInfo("Rt", 1)) &&
        pyopencv_to(pyobj_initRt, initRt, ArgInfo("initRt", 0)) )
    {
        ERRWRAP2(retval = _self_->compute(srcFrame, dstFrame, Rt, initRt));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(Rt));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    PyObject* pyobj_odometryType = NULL;
    String odometryType;
    Ptr<Odometry> retval;

    const char* keywords[] = { "odometryType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_Odometry.create", (char**)keywords, &pyobj_odometryType) &&
        pyopencv_to(pyobj_odometryType, odometryType, ArgInfo("odometryType", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::Odometry::create(odometryType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_getCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCameraMatrix());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_getTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTransformType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_prepareFrameCache(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    PyObject* pyobj_frame = NULL;
    Ptr<OdometryFrame> frame;
    int cacheType=0;
    Size retval;

    const char* keywords[] = { "frame", "cacheType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:rgbd_Odometry.prepareFrameCache", (char**)keywords, &pyobj_frame, &cacheType) &&
        pyopencv_to(pyobj_frame, frame, ArgInfo("frame", 0)) )
    {
        ERRWRAP2(retval = _self_->prepareFrameCache(frame, cacheType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_setCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_Odometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_Odometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_Odometry_setTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::Odometry> * self1 = 0;
    if (!pyopencv_rgbd_Odometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_Odometry' or its derivative)");
    Ptr<cv::rgbd::Odometry> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_Odometry.setTransformType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTransformType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_Odometry)

static PyGetSetDef pyopencv_rgbd_Odometry_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_Odometry_methods[] =
{
    {"DEFAULT_MAX_DEPTH", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_DEPTH, 0), "DEFAULT_MAX_DEPTH() -> retval\n."},
    {"DEFAULT_MAX_DEPTH_DIFF", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_DEPTH_DIFF, 0), "DEFAULT_MAX_DEPTH_DIFF() -> retval\n."},
    {"DEFAULT_MAX_POINTS_PART", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_POINTS_PART, 0), "DEFAULT_MAX_POINTS_PART() -> retval\n."},
    {"DEFAULT_MAX_ROTATION", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_ROTATION, 0), "DEFAULT_MAX_ROTATION() -> retval\n."},
    {"DEFAULT_MAX_TRANSLATION", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MAX_TRANSLATION, 0), "DEFAULT_MAX_TRANSLATION() -> retval\n."},
    {"DEFAULT_MIN_DEPTH", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_DEFAULT_MIN_DEPTH, 0), "DEFAULT_MIN_DEPTH() -> retval\n."},
    {"compute", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_compute, 0), "compute(srcImage, srcDepth, srcMask, dstImage, dstDepth, dstMask[, Rt[, initRt]]) -> retval, Rt\n.   Method to compute a transformation from the source frame to the destination one.\n.        * Some odometry algorithms do not used some data of frames (eg. ICP does not use images).\n.        * In such case corresponding arguments can be set as empty Mat.\n.        * The method returns true if all internal computions were possible (e.g. there were enough correspondences,\n.        * system of equations has a solution, etc) and resulting transformation satisfies some test if it's provided\n.        * by the Odometry inheritor implementation (e.g. thresholds for maximum translation and rotation).\n.        * @param srcImage Image data of the source frame (CV_8UC1)\n.        * @param srcDepth Depth data of the source frame (CV_32FC1, in meters)\n.        * @param srcMask Mask that sets which pixels have to be used from the source frame (CV_8UC1)\n.        * @param dstImage Image data of the destination frame (CV_8UC1)\n.        * @param dstDepth Depth data of the destination frame (CV_32FC1, in meters)\n.        * @param dstMask Mask that sets which pixels have to be used from the destination frame (CV_8UC1)\n.        * @param Rt Resulting transformation from the source frame to the destination one (rigid body motion):\n.        dst_p = Rt * src_p, where dst_p is a homogeneous point in the destination frame and src_p is\n.        homogeneous point in the source frame,\n.        Rt is 4x4 matrix of CV_64FC1 type.\n.        * @param initRt Initial transformation from the source frame to the destination one (optional)"},
    {"compute2", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_compute2, 0), "compute2(srcFrame, dstFrame[, Rt[, initRt]]) -> retval, Rt\n.   One more method to compute a transformation from the source frame to the destination one.\n.        * It is designed to save on computing the frame data (image pyramids, normals, etc.)."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_create_static, METH_STATIC), "create(odometryType) -> retval\n."},
    {"getCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_getCameraMatrix, 0), "getCameraMatrix() -> retval\n.   @see setCameraMatrix"},
    {"getTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_getTransformType, 0), "getTransformType() -> retval\n.   @see setTransformType"},
    {"prepareFrameCache", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_prepareFrameCache, 0), "prepareFrameCache(frame, cacheType) -> retval\n.   Prepare a cache for the frame. The function checks the precomputed/passed data (throws the error if this data\n.        * does not satisfy) and computes all remaining cache data needed for the frame. Returned size is a resolution\n.        * of the prepared frame.\n.        * @param frame The odometry which will process the frame.\n.        * @param cacheType The cache type: CACHE_SRC, CACHE_DST or CACHE_ALL."},
    {"setCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_setCameraMatrix, 0), "setCameraMatrix(val) -> None\n.   @copybrief getCameraMatrix @see getCameraMatrix"},
    {"setTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_Odometry_setTransformType, 0), "setTransformType(val) -> None\n.   @copybrief getTransformType @see getTransformType"},

    {NULL,          NULL}
};

// Converter (rgbd_Odometry)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::Odometry> >
{
    static PyObject* from(const Ptr<cv::rgbd::Odometry>& r)
    {
        return pyopencv_rgbd_Odometry_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::Odometry>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::Odometry> * dst_;
        if (pyopencv_rgbd_Odometry_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::Odometry> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_OdometryFrame (Generic)
//================================================================================

// GetSet (rgbd_OdometryFrame)


static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramidCloud(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramidCloud);
}

static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramidDepth(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramidDepth);
}

static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramidImage(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramidImage);
}

static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramidMask(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramidMask);
}

static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramidNormals(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramidNormals);
}

static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramidNormalsMask(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramidNormalsMask);
}

static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramidTexturedMask(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramidTexturedMask);
}

static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramid_dI_dx(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramid_dI_dx);
}

static PyObject* pyopencv_rgbd_OdometryFrame_get_pyramid_dI_dy(pyopencv_rgbd_OdometryFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->pyramid_dI_dy);
}


// Methods (rgbd_OdometryFrame)

static PyObject* pyopencv_cv_rgbd_rgbd_OdometryFrame_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_depth = NULL;
    Mat depth;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_normals = NULL;
    Mat normals;
    int ID=-1;
    Ptr<OdometryFrame> retval;

    const char* keywords[] = { "image", "depth", "mask", "normals", "ID", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OOOOi:rgbd_OdometryFrame.create", (char**)keywords, &pyobj_image, &pyobj_depth, &pyobj_mask, &pyobj_normals, &ID) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_depth, depth, ArgInfo("depth", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::OdometryFrame::create(image, depth, mask, normals, ID));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_depth = NULL;
    Mat depth;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_normals = NULL;
    Mat normals;
    int ID=-1;
    Ptr<OdometryFrame> retval;

    const char* keywords[] = { "image", "depth", "mask", "normals", "ID", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OOOOi:rgbd_OdometryFrame.create", (char**)keywords, &pyobj_image, &pyobj_depth, &pyobj_mask, &pyobj_normals, &ID) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_depth, depth, ArgInfo("depth", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::OdometryFrame::create(image, depth, mask, normals, ID));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_OdometryFrame_release(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::OdometryFrame> * self1 = 0;
    if (!pyopencv_rgbd_OdometryFrame_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_OdometryFrame' or its derivative)");
    Ptr<cv::rgbd::OdometryFrame> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->release());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_OdometryFrame_releasePyramids(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::OdometryFrame> * self1 = 0;
    if (!pyopencv_rgbd_OdometryFrame_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_OdometryFrame' or its derivative)");
    Ptr<cv::rgbd::OdometryFrame> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->releasePyramids());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_OdometryFrame)

static PyGetSetDef pyopencv_rgbd_OdometryFrame_getseters[] =
{
    {(char*)"pyramidCloud", (getter)pyopencv_rgbd_OdometryFrame_get_pyramidCloud, NULL, (char*)"pyramidCloud", NULL},
    {(char*)"pyramidDepth", (getter)pyopencv_rgbd_OdometryFrame_get_pyramidDepth, NULL, (char*)"pyramidDepth", NULL},
    {(char*)"pyramidImage", (getter)pyopencv_rgbd_OdometryFrame_get_pyramidImage, NULL, (char*)"pyramidImage", NULL},
    {(char*)"pyramidMask", (getter)pyopencv_rgbd_OdometryFrame_get_pyramidMask, NULL, (char*)"pyramidMask", NULL},
    {(char*)"pyramidNormals", (getter)pyopencv_rgbd_OdometryFrame_get_pyramidNormals, NULL, (char*)"pyramidNormals", NULL},
    {(char*)"pyramidNormalsMask", (getter)pyopencv_rgbd_OdometryFrame_get_pyramidNormalsMask, NULL, (char*)"pyramidNormalsMask", NULL},
    {(char*)"pyramidTexturedMask", (getter)pyopencv_rgbd_OdometryFrame_get_pyramidTexturedMask, NULL, (char*)"pyramidTexturedMask", NULL},
    {(char*)"pyramid_dI_dx", (getter)pyopencv_rgbd_OdometryFrame_get_pyramid_dI_dx, NULL, (char*)"pyramid_dI_dx", NULL},
    {(char*)"pyramid_dI_dy", (getter)pyopencv_rgbd_OdometryFrame_get_pyramid_dI_dy, NULL, (char*)"pyramid_dI_dy", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_OdometryFrame_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_OdometryFrame_create_static, METH_STATIC), "create([, image[, depth[, mask[, normals[, ID]]]]]) -> retval\n."},
    {"release", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_OdometryFrame_release, 0), "release() -> None\n."},
    {"releasePyramids", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_OdometryFrame_releasePyramids, 0), "releasePyramids() -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_OdometryFrame)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::OdometryFrame> >
{
    static PyObject* from(const Ptr<cv::rgbd::OdometryFrame>& r)
    {
        return pyopencv_rgbd_OdometryFrame_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::OdometryFrame>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::OdometryFrame> * dst_;
        if (pyopencv_rgbd_OdometryFrame_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::OdometryFrame> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_RgbdFrame (Generic)
//================================================================================

// GetSet (rgbd_RgbdFrame)


static PyObject* pyopencv_rgbd_RgbdFrame_get_ID(pyopencv_rgbd_RgbdFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->ID);
}

static PyObject* pyopencv_rgbd_RgbdFrame_get_depth(pyopencv_rgbd_RgbdFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->depth);
}

static PyObject* pyopencv_rgbd_RgbdFrame_get_image(pyopencv_rgbd_RgbdFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->image);
}

static PyObject* pyopencv_rgbd_RgbdFrame_get_mask(pyopencv_rgbd_RgbdFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->mask);
}

static PyObject* pyopencv_rgbd_RgbdFrame_get_normals(pyopencv_rgbd_RgbdFrame_t* p, void *closure)
{
    return pyopencv_from(p->v->normals);
}


// Methods (rgbd_RgbdFrame)

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdFrame_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_depth = NULL;
    Mat depth;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_normals = NULL;
    Mat normals;
    int ID=-1;
    Ptr<RgbdFrame> retval;

    const char* keywords[] = { "image", "depth", "mask", "normals", "ID", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OOOOi:rgbd_RgbdFrame.create", (char**)keywords, &pyobj_image, &pyobj_depth, &pyobj_mask, &pyobj_normals, &ID) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_depth, depth, ArgInfo("depth", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::RgbdFrame::create(image, depth, mask, normals, ID));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_depth = NULL;
    Mat depth;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_normals = NULL;
    Mat normals;
    int ID=-1;
    Ptr<RgbdFrame> retval;

    const char* keywords[] = { "image", "depth", "mask", "normals", "ID", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OOOOi:rgbd_RgbdFrame.create", (char**)keywords, &pyobj_image, &pyobj_depth, &pyobj_mask, &pyobj_normals, &ID) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_depth, depth, ArgInfo("depth", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::RgbdFrame::create(image, depth, mask, normals, ID));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdFrame_release(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdFrame> * self1 = 0;
    if (!pyopencv_rgbd_RgbdFrame_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdFrame' or its derivative)");
    Ptr<cv::rgbd::RgbdFrame> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->release());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_RgbdFrame)

static PyGetSetDef pyopencv_rgbd_RgbdFrame_getseters[] =
{
    {(char*)"ID", (getter)pyopencv_rgbd_RgbdFrame_get_ID, NULL, (char*)"ID", NULL},
    {(char*)"depth", (getter)pyopencv_rgbd_RgbdFrame_get_depth, NULL, (char*)"depth", NULL},
    {(char*)"image", (getter)pyopencv_rgbd_RgbdFrame_get_image, NULL, (char*)"image", NULL},
    {(char*)"mask", (getter)pyopencv_rgbd_RgbdFrame_get_mask, NULL, (char*)"mask", NULL},
    {(char*)"normals", (getter)pyopencv_rgbd_RgbdFrame_get_normals, NULL, (char*)"normals", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_RgbdFrame_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdFrame_create_static, METH_STATIC), "create([, image[, depth[, mask[, normals[, ID]]]]]) -> retval\n."},
    {"release", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdFrame_release, 0), "release() -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_RgbdFrame)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::RgbdFrame> >
{
    static PyObject* from(const Ptr<cv::rgbd::RgbdFrame>& r)
    {
        return pyopencv_rgbd_RgbdFrame_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::RgbdFrame>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::RgbdFrame> * dst_;
        if (pyopencv_rgbd_RgbdFrame_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::RgbdFrame> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_RgbdICPOdometry (Generic)
//================================================================================

// GetSet (rgbd_RgbdICPOdometry)



// Methods (rgbd_RgbdICPOdometry)

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    {
    PyObject* pyobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    PyObject* pyobj_iterCounts = NULL;
    vector_int iterCounts=std::vector<int>();
    PyObject* pyobj_minGradientMagnitudes = NULL;
    vector_float minGradientMagnitudes=std::vector<float>();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<RgbdICPOdometry> retval;

    const char* keywords[] = { "cameraMatrix", "minDepth", "maxDepth", "maxDepthDiff", "maxPointsPart", "iterCounts", "minGradientMagnitudes", "transformType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OffffOOi:rgbd_RgbdICPOdometry.create", (char**)keywords, &pyobj_cameraMatrix, &minDepth, &maxDepth, &maxDepthDiff, &maxPointsPart, &pyobj_iterCounts, &pyobj_minGradientMagnitudes, &transformType) &&
        pyopencv_to(pyobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        pyopencv_to(pyobj_iterCounts, iterCounts, ArgInfo("iterCounts", 0)) &&
        pyopencv_to(pyobj_minGradientMagnitudes, minGradientMagnitudes, ArgInfo("minGradientMagnitudes", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::RgbdICPOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, maxPointsPart, iterCounts, minGradientMagnitudes, transformType));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    PyObject* pyobj_iterCounts = NULL;
    vector_int iterCounts=std::vector<int>();
    PyObject* pyobj_minGradientMagnitudes = NULL;
    vector_float minGradientMagnitudes=std::vector<float>();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<RgbdICPOdometry> retval;

    const char* keywords[] = { "cameraMatrix", "minDepth", "maxDepth", "maxDepthDiff", "maxPointsPart", "iterCounts", "minGradientMagnitudes", "transformType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OffffOOi:rgbd_RgbdICPOdometry.create", (char**)keywords, &pyobj_cameraMatrix, &minDepth, &maxDepth, &maxDepthDiff, &maxPointsPart, &pyobj_iterCounts, &pyobj_minGradientMagnitudes, &transformType) &&
        pyopencv_to(pyobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        pyopencv_to(pyobj_iterCounts, iterCounts, ArgInfo("iterCounts", 0)) &&
        pyopencv_to(pyobj_minGradientMagnitudes, minGradientMagnitudes, ArgInfo("minGradientMagnitudes", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::RgbdICPOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, maxPointsPart, iterCounts, minGradientMagnitudes, transformType));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCameraMatrix());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getIterationCounts(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIterationCounts());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxDepthDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxDepthDiff());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxPointsPart(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxPointsPart());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxRotation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxRotation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxTranslation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxTranslation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMinDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMinGradientMagnitudes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinGradientMagnitudes());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getNormalsComputer(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    Ptr<RgbdNormals> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNormalsComputer());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTransformType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_prepareFrameCache(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    PyObject* pyobj_frame = NULL;
    Ptr<OdometryFrame> frame;
    int cacheType=0;
    Size retval;

    const char* keywords[] = { "frame", "cacheType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:rgbd_RgbdICPOdometry.prepareFrameCache", (char**)keywords, &pyobj_frame, &cacheType) &&
        pyopencv_to(pyobj_frame, frame, ArgInfo("frame", 0)) )
    {
        ERRWRAP2(retval = _self_->prepareFrameCache(frame, cacheType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdICPOdometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdICPOdometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setIterationCounts(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdICPOdometry.setIterationCounts", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setIterationCounts(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdICPOdometry.setIterationCounts", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setIterationCounts(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdICPOdometry.setMaxDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxDepthDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdICPOdometry.setMaxDepthDiff", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxDepthDiff(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxPointsPart(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdICPOdometry.setMaxPointsPart", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxPointsPart(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxRotation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdICPOdometry.setMaxRotation", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxRotation(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxTranslation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdICPOdometry.setMaxTranslation", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxTranslation(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMinDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdICPOdometry.setMinDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMinDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMinGradientMagnitudes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdICPOdometry.setMinGradientMagnitudes", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setMinGradientMagnitudes(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdICPOdometry.setMinGradientMagnitudes", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setMinGradientMagnitudes(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdICPOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdICPOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdICPOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdICPOdometry> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdICPOdometry.setTransformType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTransformType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_RgbdICPOdometry)

static PyGetSetDef pyopencv_rgbd_RgbdICPOdometry_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_RgbdICPOdometry_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_create_static, METH_STATIC), "create([, cameraMatrix[, minDepth[, maxDepth[, maxDepthDiff[, maxPointsPart[, iterCounts[, minGradientMagnitudes[, transformType]]]]]]]]) -> retval\n.   Constructor.\n.        * @param cameraMatrix Camera matrix\n.        * @param minDepth Pixels with depth less than minDepth will not be used\n.        * @param maxDepth Pixels with depth larger than maxDepth will not be used\n.        * @param maxDepthDiff Correspondences between pixels of two given frames will be filtered out\n.        *                     if their depth difference is larger than maxDepthDiff\n.        * @param maxPointsPart The method uses a random pixels subset of size frameWidth x frameHeight x pointsPart\n.        * @param iterCounts Count of iterations on each pyramid level.\n.        * @param minGradientMagnitudes For each pyramid level the pixels will be filtered out\n.        *                              if they have gradient magnitude less than minGradientMagnitudes[level].\n.        * @param transformType Class of trasformation"},
    {"getCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getCameraMatrix, 0), "getCameraMatrix() -> retval\n."},
    {"getIterationCounts", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getIterationCounts, 0), "getIterationCounts() -> retval\n."},
    {"getMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxDepth, 0), "getMaxDepth() -> retval\n."},
    {"getMaxDepthDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxDepthDiff, 0), "getMaxDepthDiff() -> retval\n."},
    {"getMaxPointsPart", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxPointsPart, 0), "getMaxPointsPart() -> retval\n."},
    {"getMaxRotation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxRotation, 0), "getMaxRotation() -> retval\n."},
    {"getMaxTranslation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMaxTranslation, 0), "getMaxTranslation() -> retval\n."},
    {"getMinDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMinDepth, 0), "getMinDepth() -> retval\n."},
    {"getMinGradientMagnitudes", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getMinGradientMagnitudes, 0), "getMinGradientMagnitudes() -> retval\n."},
    {"getNormalsComputer", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getNormalsComputer, 0), "getNormalsComputer() -> retval\n."},
    {"getTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_getTransformType, 0), "getTransformType() -> retval\n."},
    {"prepareFrameCache", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_prepareFrameCache, 0), "prepareFrameCache(frame, cacheType) -> retval\n."},
    {"setCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setCameraMatrix, 0), "setCameraMatrix(val) -> None\n."},
    {"setIterationCounts", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setIterationCounts, 0), "setIterationCounts(val) -> None\n."},
    {"setMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxDepth, 0), "setMaxDepth(val) -> None\n."},
    {"setMaxDepthDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxDepthDiff, 0), "setMaxDepthDiff(val) -> None\n."},
    {"setMaxPointsPart", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxPointsPart, 0), "setMaxPointsPart(val) -> None\n."},
    {"setMaxRotation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxRotation, 0), "setMaxRotation(val) -> None\n."},
    {"setMaxTranslation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMaxTranslation, 0), "setMaxTranslation(val) -> None\n."},
    {"setMinDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMinDepth, 0), "setMinDepth(val) -> None\n."},
    {"setMinGradientMagnitudes", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setMinGradientMagnitudes, 0), "setMinGradientMagnitudes(val) -> None\n."},
    {"setTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdICPOdometry_setTransformType, 0), "setTransformType(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_RgbdICPOdometry)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::RgbdICPOdometry> >
{
    static PyObject* from(const Ptr<cv::rgbd::RgbdICPOdometry>& r)
    {
        return pyopencv_rgbd_RgbdICPOdometry_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::RgbdICPOdometry>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::RgbdICPOdometry> * dst_;
        if (pyopencv_rgbd_RgbdICPOdometry_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::RgbdICPOdometry> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_RgbdNormals (Generic)
//================================================================================

// GetSet (rgbd_RgbdNormals)



// Methods (rgbd_RgbdNormals)

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    {
    PyObject* pyobj_points = NULL;
    Mat points;
    PyObject* pyobj_normals = NULL;
    Mat normals;

    const char* keywords[] = { "points", "normals", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:rgbd_RgbdNormals.apply", (char**)keywords, &pyobj_points, &pyobj_normals) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 1)) )
    {
        ERRWRAP2(_self_->operator ()(points, normals));
        return pyopencv_from(normals);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points = NULL;
    UMat points;
    PyObject* pyobj_normals = NULL;
    UMat normals;

    const char* keywords[] = { "points", "normals", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:rgbd_RgbdNormals.apply", (char**)keywords, &pyobj_points, &pyobj_normals) &&
        pyopencv_to(pyobj_points, points, ArgInfo("points", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 1)) )
    {
        ERRWRAP2(_self_->operator ()(points, normals));
        return pyopencv_from(normals);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    {
    int rows=0;
    int cols=0;
    int depth=0;
    PyObject* pyobj_K = NULL;
    Mat K;
    int window_size=5;
    int method=RgbdNormals::RGBD_NORMALS_METHOD_FALS;
    Ptr<RgbdNormals> retval;

    const char* keywords[] = { "rows", "cols", "depth", "K", "window_size", "method", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiO|ii:rgbd_RgbdNormals.create", (char**)keywords, &rows, &cols, &depth, &pyobj_K, &window_size, &method) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::RgbdNormals::create(rows, cols, depth, K, window_size, method));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    int rows=0;
    int cols=0;
    int depth=0;
    PyObject* pyobj_K = NULL;
    UMat K;
    int window_size=5;
    int method=RgbdNormals::RGBD_NORMALS_METHOD_FALS;
    Ptr<RgbdNormals> retval;

    const char* keywords[] = { "rows", "cols", "depth", "K", "window_size", "method", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "iiiO|ii:rgbd_RgbdNormals.create", (char**)keywords, &rows, &cols, &depth, &pyobj_K, &window_size, &method) &&
        pyopencv_to(pyobj_K, K, ArgInfo("K", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::RgbdNormals::create(rows, cols, depth, K, window_size, method));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_getCols(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCols());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_getDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_getK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getK());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_getMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMethod());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_getRows(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRows());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_getWindowSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWindowSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_initialize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->initialize());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_setCols(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdNormals.setCols", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setCols(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_setDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdNormals.setDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_setK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdNormals.setK", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setK(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdNormals.setK", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setK(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_setMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdNormals.setMethod", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMethod(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_setRows(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdNormals.setRows", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRows(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdNormals_setWindowSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdNormals> * self1 = 0;
    if (!pyopencv_rgbd_RgbdNormals_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdNormals' or its derivative)");
    Ptr<cv::rgbd::RgbdNormals> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdNormals.setWindowSize", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setWindowSize(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_RgbdNormals)

static PyGetSetDef pyopencv_rgbd_RgbdNormals_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_RgbdNormals_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_apply, 0), "apply(points[, normals]) -> normals\n.   Given a set of 3d points in a depth image, compute the normals at each point.\n.        * @param points a rows x cols x 3 matrix of CV_32F/CV64F or a rows x cols x 1 CV_U16S\n.        * @param normals a rows x cols x 3 matrix"},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_create_static, METH_STATIC), "create(rows, cols, depth, K[, window_size[, method]]) -> retval\n.   Constructor\n.        * @param rows the number of rows of the depth image normals will be computed on\n.        * @param cols the number of cols of the depth image normals will be computed on\n.        * @param depth the depth of the normals (only CV_32F or CV_64F)\n.        * @param K the calibration matrix to use\n.        * @param window_size the window size to compute the normals: can only be 1,3,5 or 7\n.        * @param method one of the methods to use: RGBD_NORMALS_METHOD_SRI, RGBD_NORMALS_METHOD_FALS"},
    {"getCols", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_getCols, 0), "getCols() -> retval\n."},
    {"getDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_getDepth, 0), "getDepth() -> retval\n."},
    {"getK", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_getK, 0), "getK() -> retval\n."},
    {"getMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_getMethod, 0), "getMethod() -> retval\n."},
    {"getRows", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_getRows, 0), "getRows() -> retval\n."},
    {"getWindowSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_getWindowSize, 0), "getWindowSize() -> retval\n."},
    {"initialize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_initialize, 0), "initialize() -> None\n.   Initializes some data that is cached for later computation\n.        * If that function is not called, it will be called the first time normals are computed"},
    {"setCols", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_setCols, 0), "setCols(val) -> None\n."},
    {"setDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_setDepth, 0), "setDepth(val) -> None\n."},
    {"setK", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_setK, 0), "setK(val) -> None\n."},
    {"setMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_setMethod, 0), "setMethod(val) -> None\n."},
    {"setRows", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_setRows, 0), "setRows(val) -> None\n."},
    {"setWindowSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdNormals_setWindowSize, 0), "setWindowSize(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_RgbdNormals)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::RgbdNormals> >
{
    static PyObject* from(const Ptr<cv::rgbd::RgbdNormals>& r)
    {
        return pyopencv_rgbd_RgbdNormals_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::RgbdNormals>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::RgbdNormals> * dst_;
        if (pyopencv_rgbd_RgbdNormals_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::RgbdNormals> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_RgbdOdometry (Generic)
//================================================================================

// GetSet (rgbd_RgbdOdometry)



// Methods (rgbd_RgbdOdometry)

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;

    {
    PyObject* pyobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    PyObject* pyobj_iterCounts = NULL;
    vector_int iterCounts=std::vector<int>();
    PyObject* pyobj_minGradientMagnitudes = NULL;
    vector_float minGradientMagnitudes=std::vector<float>();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<RgbdOdometry> retval;

    const char* keywords[] = { "cameraMatrix", "minDepth", "maxDepth", "maxDepthDiff", "iterCounts", "minGradientMagnitudes", "maxPointsPart", "transformType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OfffOOfi:rgbd_RgbdOdometry.create", (char**)keywords, &pyobj_cameraMatrix, &minDepth, &maxDepth, &maxDepthDiff, &pyobj_iterCounts, &pyobj_minGradientMagnitudes, &maxPointsPart, &transformType) &&
        pyopencv_to(pyobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        pyopencv_to(pyobj_iterCounts, iterCounts, ArgInfo("iterCounts", 0)) &&
        pyopencv_to(pyobj_minGradientMagnitudes, minGradientMagnitudes, ArgInfo("minGradientMagnitudes", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::RgbdOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, iterCounts, minGradientMagnitudes, maxPointsPart, transformType));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    PyObject* pyobj_iterCounts = NULL;
    vector_int iterCounts=std::vector<int>();
    PyObject* pyobj_minGradientMagnitudes = NULL;
    vector_float minGradientMagnitudes=std::vector<float>();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<RgbdOdometry> retval;

    const char* keywords[] = { "cameraMatrix", "minDepth", "maxDepth", "maxDepthDiff", "iterCounts", "minGradientMagnitudes", "maxPointsPart", "transformType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|OfffOOfi:rgbd_RgbdOdometry.create", (char**)keywords, &pyobj_cameraMatrix, &minDepth, &maxDepth, &maxDepthDiff, &pyobj_iterCounts, &pyobj_minGradientMagnitudes, &maxPointsPart, &transformType) &&
        pyopencv_to(pyobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        pyopencv_to(pyobj_iterCounts, iterCounts, ArgInfo("iterCounts", 0)) &&
        pyopencv_to(pyobj_minGradientMagnitudes, minGradientMagnitudes, ArgInfo("minGradientMagnitudes", 0)) )
    {
        ERRWRAP2(retval = cv::rgbd::RgbdOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, iterCounts, minGradientMagnitudes, maxPointsPart, transformType));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCameraMatrix());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getIterationCounts(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIterationCounts());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxDepthDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxDepthDiff());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxPointsPart(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxPointsPart());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxRotation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxRotation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxTranslation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxTranslation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMinDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinDepth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMinGradientMagnitudes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    cv::Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinGradientMagnitudes());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_getTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getTransformType());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_prepareFrameCache(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    PyObject* pyobj_frame = NULL;
    Ptr<OdometryFrame> frame;
    int cacheType=0;
    Size retval;

    const char* keywords[] = { "frame", "cacheType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:rgbd_RgbdOdometry.prepareFrameCache", (char**)keywords, &pyobj_frame, &cacheType) &&
        pyopencv_to(pyobj_frame, frame, ArgInfo("frame", 0)) )
    {
        ERRWRAP2(retval = _self_->prepareFrameCache(frame, cacheType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setCameraMatrix(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdOdometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdOdometry.setCameraMatrix", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setCameraMatrix(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setIterationCounts(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdOdometry.setIterationCounts", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setIterationCounts(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdOdometry.setIterationCounts", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setIterationCounts(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdOdometry.setMaxDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxDepthDiff(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdOdometry.setMaxDepthDiff", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxDepthDiff(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxPointsPart(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdOdometry.setMaxPointsPart", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxPointsPart(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxRotation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdOdometry.setMaxRotation", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxRotation(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxTranslation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdOdometry.setMaxTranslation", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMaxTranslation(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMinDepth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdOdometry.setMinDepth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMinDepth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMinGradientMagnitudes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdOdometry.setMinGradientMagnitudes", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setMinGradientMagnitudes(val));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_val = NULL;
    Mat val;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:rgbd_RgbdOdometry.setMinGradientMagnitudes", (char**)keywords, &pyobj_val) &&
        pyopencv_to(pyobj_val, val, ArgInfo("val", 0)) )
    {
        ERRWRAP2(_self_->setMinGradientMagnitudes(val));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdOdometry_setTransformType(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdOdometry> * self1 = 0;
    if (!pyopencv_rgbd_RgbdOdometry_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdOdometry' or its derivative)");
    Ptr<cv::rgbd::RgbdOdometry> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdOdometry.setTransformType", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setTransformType(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_RgbdOdometry)

static PyGetSetDef pyopencv_rgbd_RgbdOdometry_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_RgbdOdometry_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_create_static, METH_STATIC), "create([, cameraMatrix[, minDepth[, maxDepth[, maxDepthDiff[, iterCounts[, minGradientMagnitudes[, maxPointsPart[, transformType]]]]]]]]) -> retval\n.   Constructor.\n.        * @param cameraMatrix Camera matrix\n.        * @param minDepth Pixels with depth less than minDepth will not be used (in meters)\n.        * @param maxDepth Pixels with depth larger than maxDepth will not be used (in meters)\n.        * @param maxDepthDiff Correspondences between pixels of two given frames will be filtered out\n.        *                     if their depth difference is larger than maxDepthDiff (in meters)\n.        * @param iterCounts Count of iterations on each pyramid level.\n.        * @param minGradientMagnitudes For each pyramid level the pixels will be filtered out\n.        *                              if they have gradient magnitude less than minGradientMagnitudes[level].\n.        * @param maxPointsPart The method uses a random pixels subset of size frameWidth x frameHeight x pointsPart\n.        * @param transformType Class of transformation"},
    {"getCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getCameraMatrix, 0), "getCameraMatrix() -> retval\n."},
    {"getIterationCounts", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getIterationCounts, 0), "getIterationCounts() -> retval\n."},
    {"getMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxDepth, 0), "getMaxDepth() -> retval\n."},
    {"getMaxDepthDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxDepthDiff, 0), "getMaxDepthDiff() -> retval\n."},
    {"getMaxPointsPart", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxPointsPart, 0), "getMaxPointsPart() -> retval\n."},
    {"getMaxRotation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxRotation, 0), "getMaxRotation() -> retval\n."},
    {"getMaxTranslation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMaxTranslation, 0), "getMaxTranslation() -> retval\n."},
    {"getMinDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMinDepth, 0), "getMinDepth() -> retval\n."},
    {"getMinGradientMagnitudes", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getMinGradientMagnitudes, 0), "getMinGradientMagnitudes() -> retval\n."},
    {"getTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_getTransformType, 0), "getTransformType() -> retval\n."},
    {"prepareFrameCache", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_prepareFrameCache, 0), "prepareFrameCache(frame, cacheType) -> retval\n."},
    {"setCameraMatrix", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setCameraMatrix, 0), "setCameraMatrix(val) -> None\n."},
    {"setIterationCounts", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setIterationCounts, 0), "setIterationCounts(val) -> None\n."},
    {"setMaxDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxDepth, 0), "setMaxDepth(val) -> None\n."},
    {"setMaxDepthDiff", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxDepthDiff, 0), "setMaxDepthDiff(val) -> None\n."},
    {"setMaxPointsPart", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxPointsPart, 0), "setMaxPointsPart(val) -> None\n."},
    {"setMaxRotation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxRotation, 0), "setMaxRotation(val) -> None\n."},
    {"setMaxTranslation", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMaxTranslation, 0), "setMaxTranslation(val) -> None\n."},
    {"setMinDepth", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMinDepth, 0), "setMinDepth(val) -> None\n."},
    {"setMinGradientMagnitudes", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setMinGradientMagnitudes, 0), "setMinGradientMagnitudes(val) -> None\n."},
    {"setTransformType", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdOdometry_setTransformType, 0), "setTransformType(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_RgbdOdometry)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::RgbdOdometry> >
{
    static PyObject* from(const Ptr<cv::rgbd::RgbdOdometry>& r)
    {
        return pyopencv_rgbd_RgbdOdometry_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::RgbdOdometry>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::RgbdOdometry> * dst_;
        if (pyopencv_rgbd_RgbdOdometry_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::RgbdOdometry> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// rgbd_RgbdPlane (Generic)
//================================================================================

// GetSet (rgbd_RgbdPlane)



// Methods (rgbd_RgbdPlane)

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_apply(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    {
    PyObject* pyobj_points3d = NULL;
    Mat points3d;
    PyObject* pyobj_normals = NULL;
    Mat normals;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_plane_coefficients = NULL;
    Mat plane_coefficients;

    const char* keywords[] = { "points3d", "normals", "mask", "plane_coefficients", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:rgbd_RgbdPlane.apply", (char**)keywords, &pyobj_points3d, &pyobj_normals, &pyobj_mask, &pyobj_plane_coefficients) &&
        pyopencv_to(pyobj_points3d, points3d, ArgInfo("points3d", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 1)) &&
        pyopencv_to(pyobj_plane_coefficients, plane_coefficients, ArgInfo("plane_coefficients", 1)) )
    {
        ERRWRAP2(_self_->operator ()(points3d, normals, mask, plane_coefficients));
        return Py_BuildValue("(NN)", pyopencv_from(mask), pyopencv_from(plane_coefficients));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points3d = NULL;
    UMat points3d;
    PyObject* pyobj_normals = NULL;
    UMat normals;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    PyObject* pyobj_plane_coefficients = NULL;
    UMat plane_coefficients;

    const char* keywords[] = { "points3d", "normals", "mask", "plane_coefficients", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:rgbd_RgbdPlane.apply", (char**)keywords, &pyobj_points3d, &pyobj_normals, &pyobj_mask, &pyobj_plane_coefficients) &&
        pyopencv_to(pyobj_points3d, points3d, ArgInfo("points3d", 0)) &&
        pyopencv_to(pyobj_normals, normals, ArgInfo("normals", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 1)) &&
        pyopencv_to(pyobj_plane_coefficients, plane_coefficients, ArgInfo("plane_coefficients", 1)) )
    {
        ERRWRAP2(_self_->operator ()(points3d, normals, mask, plane_coefficients));
        return Py_BuildValue("(NN)", pyopencv_from(mask), pyopencv_from(plane_coefficients));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points3d = NULL;
    Mat points3d;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    PyObject* pyobj_plane_coefficients = NULL;
    Mat plane_coefficients;

    const char* keywords[] = { "points3d", "mask", "plane_coefficients", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:rgbd_RgbdPlane.apply", (char**)keywords, &pyobj_points3d, &pyobj_mask, &pyobj_plane_coefficients) &&
        pyopencv_to(pyobj_points3d, points3d, ArgInfo("points3d", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 1)) &&
        pyopencv_to(pyobj_plane_coefficients, plane_coefficients, ArgInfo("plane_coefficients", 1)) )
    {
        ERRWRAP2(_self_->operator ()(points3d, mask, plane_coefficients));
        return Py_BuildValue("(NN)", pyopencv_from(mask), pyopencv_from(plane_coefficients));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_points3d = NULL;
    UMat points3d;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    PyObject* pyobj_plane_coefficients = NULL;
    UMat plane_coefficients;

    const char* keywords[] = { "points3d", "mask", "plane_coefficients", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:rgbd_RgbdPlane.apply", (char**)keywords, &pyobj_points3d, &pyobj_mask, &pyobj_plane_coefficients) &&
        pyopencv_to(pyobj_points3d, points3d, ArgInfo("points3d", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 1)) &&
        pyopencv_to(pyobj_plane_coefficients, plane_coefficients, ArgInfo("plane_coefficients", 1)) )
    {
        ERRWRAP2(_self_->operator ()(points3d, mask, plane_coefficients));
        return Py_BuildValue("(NN)", pyopencv_from(mask), pyopencv_from(plane_coefficients));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_getBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBlockSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_getMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMethod());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_getMinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_getSensorErrorA(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSensorErrorA());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_getSensorErrorB(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSensorErrorB());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_getSensorErrorC(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSensorErrorC());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_getThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_setBlockSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdPlane.setBlockSize", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setBlockSize(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_setMethod(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdPlane.setMethod", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMethod(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_setMinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:rgbd_RgbdPlane.setMinSize", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setMinSize(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_setSensorErrorA(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdPlane.setSensorErrorA", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setSensorErrorA(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_setSensorErrorB(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdPlane.setSensorErrorB", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setSensorErrorB(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_setSensorErrorC(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdPlane.setSensorErrorC", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setSensorErrorC(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_rgbd_rgbd_RgbdPlane_setThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::rgbd;


    Ptr<cv::rgbd::RgbdPlane> * self1 = 0;
    if (!pyopencv_rgbd_RgbdPlane_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'rgbd_RgbdPlane' or its derivative)");
    Ptr<cv::rgbd::RgbdPlane> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:rgbd_RgbdPlane.setThreshold", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setThreshold(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (rgbd_RgbdPlane)

static PyGetSetDef pyopencv_rgbd_RgbdPlane_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_rgbd_RgbdPlane_methods[] =
{
    {"apply", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_apply, 0), "apply(points3d, normals[, mask[, plane_coefficients]]) -> mask, plane_coefficients\n.   Find The planes in a depth image\n.        * @param points3d the 3d points organized like the depth image: rows x cols with 3 channels\n.        * @param normals the normals for every point in the depth image\n.        * @param mask An image where each pixel is labeled with the plane it belongs to\n.        *        and 255 if it does not belong to any plane\n.        * @param plane_coefficients the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1\n.        *        and c < 0 (so that the normal points towards the camera)\n\n\n\napply(points3d[, mask[, plane_coefficients]]) -> mask, plane_coefficients\n.   Find The planes in a depth image but without doing a normal check, which is faster but less accurate\n.        * @param points3d the 3d points organized like the depth image: rows x cols with 3 channels\n.        * @param mask An image where each pixel is labeled with the plane it belongs to\n.        *        and 255 if it does not belong to any plane\n.        * @param plane_coefficients the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0"},
    {"getBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_getBlockSize, 0), "getBlockSize() -> retval\n."},
    {"getMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_getMethod, 0), "getMethod() -> retval\n."},
    {"getMinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_getMinSize, 0), "getMinSize() -> retval\n."},
    {"getSensorErrorA", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_getSensorErrorA, 0), "getSensorErrorA() -> retval\n."},
    {"getSensorErrorB", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_getSensorErrorB, 0), "getSensorErrorB() -> retval\n."},
    {"getSensorErrorC", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_getSensorErrorC, 0), "getSensorErrorC() -> retval\n."},
    {"getThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_getThreshold, 0), "getThreshold() -> retval\n."},
    {"setBlockSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_setBlockSize, 0), "setBlockSize(val) -> None\n."},
    {"setMethod", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_setMethod, 0), "setMethod(val) -> None\n."},
    {"setMinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_setMinSize, 0), "setMinSize(val) -> None\n."},
    {"setSensorErrorA", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_setSensorErrorA, 0), "setSensorErrorA(val) -> None\n."},
    {"setSensorErrorB", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_setSensorErrorB, 0), "setSensorErrorB(val) -> None\n."},
    {"setSensorErrorC", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_setSensorErrorC, 0), "setSensorErrorC(val) -> None\n."},
    {"setThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_rgbd_rgbd_RgbdPlane_setThreshold, 0), "setThreshold(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (rgbd_RgbdPlane)

template<>
struct PyOpenCV_Converter< Ptr<cv::rgbd::RgbdPlane> >
{
    static PyObject* from(const Ptr<cv::rgbd::RgbdPlane>& r)
    {
        return pyopencv_rgbd_RgbdPlane_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::rgbd::RgbdPlane>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::rgbd::RgbdPlane> * dst_;
        if (pyopencv_rgbd_RgbdPlane_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::rgbd::RgbdPlane> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// saliency_MotionSaliency (Generic)
//================================================================================

// GetSet (saliency_MotionSaliency)



// Methods (saliency_MotionSaliency)



// Tables (saliency_MotionSaliency)

static PyGetSetDef pyopencv_saliency_MotionSaliency_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_saliency_MotionSaliency_methods[] =
{

    {NULL,          NULL}
};

// Converter (saliency_MotionSaliency)

template<>
struct PyOpenCV_Converter< Ptr<cv::saliency::MotionSaliency> >
{
    static PyObject* from(const Ptr<cv::saliency::MotionSaliency>& r)
    {
        return pyopencv_saliency_MotionSaliency_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::saliency::MotionSaliency>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::saliency::MotionSaliency> * dst_;
        if (pyopencv_saliency_MotionSaliency_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::saliency::MotionSaliency> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// saliency_MotionSaliencyBinWangApr2014 (Generic)
//================================================================================

// GetSet (saliency_MotionSaliencyBinWangApr2014)



// Methods (saliency_MotionSaliencyBinWangApr2014)

static PyObject* pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_computeSaliency(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> * self1 = 0;
    if (!pyopencv_saliency_MotionSaliencyBinWangApr2014_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_MotionSaliencyBinWangApr2014' or its derivative)");
    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_saliencyMap = NULL;
    Mat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_MotionSaliencyBinWangApr2014.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_saliencyMap = NULL;
    UMat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_MotionSaliencyBinWangApr2014.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;

    Ptr<MotionSaliencyBinWangApr2014> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::saliency::MotionSaliencyBinWangApr2014::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_getImageHeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> * self1 = 0;
    if (!pyopencv_saliency_MotionSaliencyBinWangApr2014_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_MotionSaliencyBinWangApr2014' or its derivative)");
    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getImageHeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_getImageWidth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> * self1 = 0;
    if (!pyopencv_saliency_MotionSaliencyBinWangApr2014_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_MotionSaliencyBinWangApr2014' or its derivative)");
    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getImageWidth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_init(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> * self1 = 0;
    if (!pyopencv_saliency_MotionSaliencyBinWangApr2014_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_MotionSaliencyBinWangApr2014' or its derivative)");
    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->init());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_setImageHeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> * self1 = 0;
    if (!pyopencv_saliency_MotionSaliencyBinWangApr2014_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_MotionSaliencyBinWangApr2014' or its derivative)");
    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:saliency_MotionSaliencyBinWangApr2014.setImageHeight", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setImageHeight(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_setImageWidth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> * self1 = 0;
    if (!pyopencv_saliency_MotionSaliencyBinWangApr2014_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_MotionSaliencyBinWangApr2014' or its derivative)");
    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:saliency_MotionSaliencyBinWangApr2014.setImageWidth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setImageWidth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_setImagesize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> * self1 = 0;
    if (!pyopencv_saliency_MotionSaliencyBinWangApr2014_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_MotionSaliencyBinWangApr2014' or its derivative)");
    Ptr<cv::saliency::MotionSaliencyBinWangApr2014> _self_ = *(self1);
    int W=0;
    int H=0;

    const char* keywords[] = { "W", "H", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:saliency_MotionSaliencyBinWangApr2014.setImagesize", (char**)keywords, &W, &H) )
    {
        ERRWRAP2(_self_->setImagesize(W, H));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (saliency_MotionSaliencyBinWangApr2014)

static PyGetSetDef pyopencv_saliency_MotionSaliencyBinWangApr2014_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_saliency_MotionSaliencyBinWangApr2014_methods[] =
{
    {"computeSaliency", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_computeSaliency, 0), "computeSaliency(image[, saliencyMap]) -> retval, saliencyMap\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_create_static, METH_STATIC), "create() -> retval\n."},
    {"getImageHeight", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_getImageHeight, 0), "getImageHeight() -> retval\n."},
    {"getImageWidth", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_getImageWidth, 0), "getImageWidth() -> retval\n."},
    {"init", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_init, 0), "init() -> retval\n.   @brief This function allows the correct initialization of all data structures that will be used by the\n.       algorithm."},
    {"setImageHeight", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_setImageHeight, 0), "setImageHeight(val) -> None\n."},
    {"setImageWidth", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_setImageWidth, 0), "setImageWidth(val) -> None\n."},
    {"setImagesize", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_MotionSaliencyBinWangApr2014_setImagesize, 0), "setImagesize(W, H) -> None\n.   @brief This is a utility function that allows to set the correct size (taken from the input image) in the\n.       corresponding variables that will be used to size the data structures of the algorithm.\n.       @param W width of input image\n.       @param H height of input image"},

    {NULL,          NULL}
};

// Converter (saliency_MotionSaliencyBinWangApr2014)

template<>
struct PyOpenCV_Converter< Ptr<cv::saliency::MotionSaliencyBinWangApr2014> >
{
    static PyObject* from(const Ptr<cv::saliency::MotionSaliencyBinWangApr2014>& r)
    {
        return pyopencv_saliency_MotionSaliencyBinWangApr2014_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::saliency::MotionSaliencyBinWangApr2014>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::saliency::MotionSaliencyBinWangApr2014> * dst_;
        if (pyopencv_saliency_MotionSaliencyBinWangApr2014_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::saliency::MotionSaliencyBinWangApr2014> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// saliency_Objectness (Generic)
//================================================================================

// GetSet (saliency_Objectness)



// Methods (saliency_Objectness)



// Tables (saliency_Objectness)

static PyGetSetDef pyopencv_saliency_Objectness_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_saliency_Objectness_methods[] =
{

    {NULL,          NULL}
};

// Converter (saliency_Objectness)

template<>
struct PyOpenCV_Converter< Ptr<cv::saliency::Objectness> >
{
    static PyObject* from(const Ptr<cv::saliency::Objectness>& r)
    {
        return pyopencv_saliency_Objectness_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::saliency::Objectness>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::saliency::Objectness> * dst_;
        if (pyopencv_saliency_Objectness_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::saliency::Objectness> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// saliency_ObjectnessBING (Generic)
//================================================================================

// GetSet (saliency_ObjectnessBING)



// Methods (saliency_ObjectnessBING)

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_computeSaliency(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_saliencyMap = NULL;
    Mat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_ObjectnessBING.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_saliencyMap = NULL;
    UMat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_ObjectnessBING.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;

    Ptr<ObjectnessBING> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::saliency::ObjectnessBING::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_getBase(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBase());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_getNSS(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNSS());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_getW(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getW());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_getobjectnessValues(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    std::vector<float> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getobjectnessValues());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->read());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_setBBResDir(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    PyObject* pyobj_resultsDir = NULL;
    String resultsDir;

    const char* keywords[] = { "resultsDir", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:saliency_ObjectnessBING.setBBResDir", (char**)keywords, &pyobj_resultsDir) &&
        pyopencv_to(pyobj_resultsDir, resultsDir, ArgInfo("resultsDir", 0)) )
    {
        ERRWRAP2(_self_->setBBResDir(resultsDir));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_setBase(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    double val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:saliency_ObjectnessBING.setBase", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setBase(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_setNSS(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:saliency_ObjectnessBING.setNSS", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setNSS(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_setTrainingPath(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    PyObject* pyobj_trainingPath = NULL;
    String trainingPath;

    const char* keywords[] = { "trainingPath", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:saliency_ObjectnessBING.setTrainingPath", (char**)keywords, &pyobj_trainingPath) &&
        pyopencv_to(pyobj_trainingPath, trainingPath, ArgInfo("trainingPath", 0)) )
    {
        ERRWRAP2(_self_->setTrainingPath(trainingPath));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_setW(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:saliency_ObjectnessBING.setW", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setW(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_ObjectnessBING_write(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::ObjectnessBING> * self1 = 0;
    if (!pyopencv_saliency_ObjectnessBING_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_ObjectnessBING' or its derivative)");
    Ptr<cv::saliency::ObjectnessBING> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->write());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (saliency_ObjectnessBING)

static PyGetSetDef pyopencv_saliency_ObjectnessBING_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_saliency_ObjectnessBING_methods[] =
{
    {"computeSaliency", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_computeSaliency, 0), "computeSaliency(image[, saliencyMap]) -> retval, saliencyMap\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_create_static, METH_STATIC), "create() -> retval\n."},
    {"getBase", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_getBase, 0), "getBase() -> retval\n."},
    {"getNSS", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_getNSS, 0), "getNSS() -> retval\n."},
    {"getW", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_getW, 0), "getW() -> retval\n."},
    {"getobjectnessValues", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_getobjectnessValues, 0), "getobjectnessValues() -> retval\n.   @brief Return the list of the rectangles' objectness value,\n.   \n.       in the same order as the *vector\\<Vec4i\\> objectnessBoundingBox* returned by the algorithm (in\n.       computeSaliencyImpl function). The bigger value these scores are, it is more likely to be an\n.       object window."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_read, 0), "read() -> None\n."},
    {"setBBResDir", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_setBBResDir, 0), "setBBResDir(resultsDir) -> None\n.   @brief This is a utility function that allows to set an arbitrary path in which the algorithm will save the\n.       optional results\n.   \n.       (ie writing on file the total number and the list of rectangles returned by objectess, one for\n.       each row).\n.       @param resultsDir results' folder path"},
    {"setBase", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_setBase, 0), "setBase(val) -> None\n."},
    {"setNSS", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_setNSS, 0), "setNSS(val) -> None\n."},
    {"setTrainingPath", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_setTrainingPath, 0), "setTrainingPath(trainingPath) -> None\n.   @brief This is a utility function that allows to set the correct path from which the algorithm will load\n.       the trained model.\n.       @param trainingPath trained model path"},
    {"setW", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_setW, 0), "setW(val) -> None\n."},
    {"write", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_ObjectnessBING_write, 0), "write() -> None\n."},

    {NULL,          NULL}
};

// Converter (saliency_ObjectnessBING)

template<>
struct PyOpenCV_Converter< Ptr<cv::saliency::ObjectnessBING> >
{
    static PyObject* from(const Ptr<cv::saliency::ObjectnessBING>& r)
    {
        return pyopencv_saliency_ObjectnessBING_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::saliency::ObjectnessBING>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::saliency::ObjectnessBING> * dst_;
        if (pyopencv_saliency_ObjectnessBING_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::saliency::ObjectnessBING> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// saliency_Saliency (Generic)
//================================================================================

// GetSet (saliency_Saliency)



// Methods (saliency_Saliency)

static PyObject* pyopencv_cv_saliency_saliency_Saliency_computeSaliency(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::Saliency> * self1 = 0;
    if (!pyopencv_saliency_Saliency_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_Saliency' or its derivative)");
    Ptr<cv::saliency::Saliency> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_saliencyMap = NULL;
    Mat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_Saliency.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_saliencyMap = NULL;
    UMat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_Saliency.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }

    return NULL;
}



// Tables (saliency_Saliency)

static PyGetSetDef pyopencv_saliency_Saliency_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_saliency_Saliency_methods[] =
{
    {"computeSaliency", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_Saliency_computeSaliency, 0), "computeSaliency(image[, saliencyMap]) -> retval, saliencyMap\n.   * \\brief Compute the saliency\n.      * \\param image        The image.\n.      * \\param saliencyMap      The computed saliency map.\n.      * \\return true if the saliency map is computed, false otherwise"},

    {NULL,          NULL}
};

// Converter (saliency_Saliency)

template<>
struct PyOpenCV_Converter< Ptr<cv::saliency::Saliency> >
{
    static PyObject* from(const Ptr<cv::saliency::Saliency>& r)
    {
        return pyopencv_saliency_Saliency_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::saliency::Saliency>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::saliency::Saliency> * dst_;
        if (pyopencv_saliency_Saliency_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::saliency::Saliency> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// saliency_StaticSaliency (Generic)
//================================================================================

// GetSet (saliency_StaticSaliency)



// Methods (saliency_StaticSaliency)

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliency_computeBinaryMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::StaticSaliency> * self1 = 0;
    if (!pyopencv_saliency_StaticSaliency_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_StaticSaliency' or its derivative)");
    Ptr<cv::saliency::StaticSaliency> _self_ = *(self1);
    {
    PyObject* pyobj__saliencyMap = NULL;
    Mat _saliencyMap;
    PyObject* pyobj__binaryMap = NULL;
    Mat _binaryMap;
    bool retval;

    const char* keywords[] = { "_saliencyMap", "_binaryMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_StaticSaliency.computeBinaryMap", (char**)keywords, &pyobj__saliencyMap, &pyobj__binaryMap) &&
        pyopencv_to(pyobj__saliencyMap, _saliencyMap, ArgInfo("_saliencyMap", 0)) &&
        pyopencv_to(pyobj__binaryMap, _binaryMap, ArgInfo("_binaryMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeBinaryMap(_saliencyMap, _binaryMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(_binaryMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__saliencyMap = NULL;
    UMat _saliencyMap;
    PyObject* pyobj__binaryMap = NULL;
    UMat _binaryMap;
    bool retval;

    const char* keywords[] = { "_saliencyMap", "_binaryMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_StaticSaliency.computeBinaryMap", (char**)keywords, &pyobj__saliencyMap, &pyobj__binaryMap) &&
        pyopencv_to(pyobj__saliencyMap, _saliencyMap, ArgInfo("_saliencyMap", 0)) &&
        pyopencv_to(pyobj__binaryMap, _binaryMap, ArgInfo("_binaryMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeBinaryMap(_saliencyMap, _binaryMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(_binaryMap));
    }
    }

    return NULL;
}



// Tables (saliency_StaticSaliency)

static PyGetSetDef pyopencv_saliency_StaticSaliency_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_saliency_StaticSaliency_methods[] =
{
    {"computeBinaryMap", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliency_computeBinaryMap, 0), "computeBinaryMap(_saliencyMap[, _binaryMap]) -> retval, _binaryMap\n.   @brief This function perform a binary map of given saliency map. This is obtained in this\n.       way:\n.   \n.       In a first step, to improve the definition of interest areas and facilitate identification of\n.       targets, a segmentation by clustering is performed, using *K-means algorithm*. Then, to gain a\n.       binary representation of clustered saliency map, since values of the map can vary according to\n.       the characteristics of frame under analysis, it is not convenient to use a fixed threshold. So,\n.       *Otsu's algorithm* is used, which assumes that the image to be thresholded contains two classes\n.       of pixels or bi-modal histograms (e.g. foreground and back-ground pixels); later on, the\n.       algorithm calculates the optimal threshold separating those two classes, so that their\n.       intra-class variance is minimal.\n.   \n.       @param _saliencyMap the saliency map obtained through one of the specialized algorithms\n.       @param _binaryMap the binary map"},

    {NULL,          NULL}
};

// Converter (saliency_StaticSaliency)

template<>
struct PyOpenCV_Converter< Ptr<cv::saliency::StaticSaliency> >
{
    static PyObject* from(const Ptr<cv::saliency::StaticSaliency>& r)
    {
        return pyopencv_saliency_StaticSaliency_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::saliency::StaticSaliency>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::saliency::StaticSaliency> * dst_;
        if (pyopencv_saliency_StaticSaliency_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::saliency::StaticSaliency> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// saliency_StaticSaliencyFineGrained (Generic)
//================================================================================

// GetSet (saliency_StaticSaliencyFineGrained)



// Methods (saliency_StaticSaliencyFineGrained)

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencyFineGrained_computeSaliency(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::StaticSaliencyFineGrained> * self1 = 0;
    if (!pyopencv_saliency_StaticSaliencyFineGrained_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_StaticSaliencyFineGrained' or its derivative)");
    Ptr<cv::saliency::StaticSaliencyFineGrained> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_saliencyMap = NULL;
    Mat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_StaticSaliencyFineGrained.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_saliencyMap = NULL;
    UMat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_StaticSaliencyFineGrained.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencyFineGrained_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;

    Ptr<StaticSaliencyFineGrained> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::saliency::StaticSaliencyFineGrained::create());
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (saliency_StaticSaliencyFineGrained)

static PyGetSetDef pyopencv_saliency_StaticSaliencyFineGrained_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_saliency_StaticSaliencyFineGrained_methods[] =
{
    {"computeSaliency", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencyFineGrained_computeSaliency, 0), "computeSaliency(image[, saliencyMap]) -> retval, saliencyMap\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencyFineGrained_create_static, METH_STATIC), "create() -> retval\n."},

    {NULL,          NULL}
};

// Converter (saliency_StaticSaliencyFineGrained)

template<>
struct PyOpenCV_Converter< Ptr<cv::saliency::StaticSaliencyFineGrained> >
{
    static PyObject* from(const Ptr<cv::saliency::StaticSaliencyFineGrained>& r)
    {
        return pyopencv_saliency_StaticSaliencyFineGrained_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::saliency::StaticSaliencyFineGrained>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::saliency::StaticSaliencyFineGrained> * dst_;
        if (pyopencv_saliency_StaticSaliencyFineGrained_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::saliency::StaticSaliencyFineGrained> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// saliency_StaticSaliencySpectralResidual (Generic)
//================================================================================

// GetSet (saliency_StaticSaliencySpectralResidual)



// Methods (saliency_StaticSaliencySpectralResidual)

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_computeSaliency(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::StaticSaliencySpectralResidual> * self1 = 0;
    if (!pyopencv_saliency_StaticSaliencySpectralResidual_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_StaticSaliencySpectralResidual' or its derivative)");
    Ptr<cv::saliency::StaticSaliencySpectralResidual> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_saliencyMap = NULL;
    Mat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_StaticSaliencySpectralResidual.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_saliencyMap = NULL;
    UMat saliencyMap;
    bool retval;

    const char* keywords[] = { "image", "saliencyMap", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:saliency_StaticSaliencySpectralResidual.computeSaliency", (char**)keywords, &pyobj_image, &pyobj_saliencyMap) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_saliencyMap, saliencyMap, ArgInfo("saliencyMap", 1)) )
    {
        ERRWRAP2(retval = _self_->computeSaliency(image, saliencyMap));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(saliencyMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;

    Ptr<StaticSaliencySpectralResidual> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::saliency::StaticSaliencySpectralResidual::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_getImageHeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::StaticSaliencySpectralResidual> * self1 = 0;
    if (!pyopencv_saliency_StaticSaliencySpectralResidual_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_StaticSaliencySpectralResidual' or its derivative)");
    Ptr<cv::saliency::StaticSaliencySpectralResidual> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getImageHeight());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_getImageWidth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::StaticSaliencySpectralResidual> * self1 = 0;
    if (!pyopencv_saliency_StaticSaliencySpectralResidual_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_StaticSaliencySpectralResidual' or its derivative)");
    Ptr<cv::saliency::StaticSaliencySpectralResidual> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getImageWidth());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_read(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::StaticSaliencySpectralResidual> * self1 = 0;
    if (!pyopencv_saliency_StaticSaliencySpectralResidual_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_StaticSaliencySpectralResidual' or its derivative)");
    Ptr<cv::saliency::StaticSaliencySpectralResidual> _self_ = *(self1);
    PyObject* pyobj_fn = NULL;
    FileNode fn;

    const char* keywords[] = { "fn", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:saliency_StaticSaliencySpectralResidual.read", (char**)keywords, &pyobj_fn) &&
        pyopencv_to(pyobj_fn, fn, ArgInfo("fn", 0)) )
    {
        ERRWRAP2(_self_->read(fn));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_setImageHeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::StaticSaliencySpectralResidual> * self1 = 0;
    if (!pyopencv_saliency_StaticSaliencySpectralResidual_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_StaticSaliencySpectralResidual' or its derivative)");
    Ptr<cv::saliency::StaticSaliencySpectralResidual> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:saliency_StaticSaliencySpectralResidual.setImageHeight", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setImageHeight(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_setImageWidth(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::saliency;


    Ptr<cv::saliency::StaticSaliencySpectralResidual> * self1 = 0;
    if (!pyopencv_saliency_StaticSaliencySpectralResidual_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'saliency_StaticSaliencySpectralResidual' or its derivative)");
    Ptr<cv::saliency::StaticSaliencySpectralResidual> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:saliency_StaticSaliencySpectralResidual.setImageWidth", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setImageWidth(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (saliency_StaticSaliencySpectralResidual)

static PyGetSetDef pyopencv_saliency_StaticSaliencySpectralResidual_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_saliency_StaticSaliencySpectralResidual_methods[] =
{
    {"computeSaliency", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_computeSaliency, 0), "computeSaliency(image[, saliencyMap]) -> retval, saliencyMap\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_create_static, METH_STATIC), "create() -> retval\n."},
    {"getImageHeight", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_getImageHeight, 0), "getImageHeight() -> retval\n."},
    {"getImageWidth", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_getImageWidth, 0), "getImageWidth() -> retval\n."},
    {"read", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_read, 0), "read(fn) -> None\n."},
    {"setImageHeight", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_setImageHeight, 0), "setImageHeight(val) -> None\n."},
    {"setImageWidth", CV_PY_FN_WITH_KW_(pyopencv_cv_saliency_saliency_StaticSaliencySpectralResidual_setImageWidth, 0), "setImageWidth(val) -> None\n."},

    {NULL,          NULL}
};

// Converter (saliency_StaticSaliencySpectralResidual)

template<>
struct PyOpenCV_Converter< Ptr<cv::saliency::StaticSaliencySpectralResidual> >
{
    static PyObject* from(const Ptr<cv::saliency::StaticSaliencySpectralResidual>& r)
    {
        return pyopencv_saliency_StaticSaliencySpectralResidual_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::saliency::StaticSaliencySpectralResidual>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::saliency::StaticSaliencySpectralResidual> * dst_;
        if (pyopencv_saliency_StaticSaliencySpectralResidual_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::saliency::StaticSaliencySpectralResidual> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// structured_light_GrayCodePattern (Generic)
//================================================================================

// GetSet (structured_light_GrayCodePattern)



// Methods (structured_light_GrayCodePattern)

static PyObject* pyopencv_cv_structured_light_structured_light_GrayCodePattern_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;

    int width=0;
    int height=0;
    Ptr<GrayCodePattern> retval;

    const char* keywords[] = { "width", "height", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:structured_light_GrayCodePattern.create", (char**)keywords, &width, &height) )
    {
        ERRWRAP2(retval = cv::structured_light::GrayCodePattern::create(width, height));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_GrayCodePattern_getImagesForShadowMasks(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::GrayCodePattern> * self1 = 0;
    if (!pyopencv_structured_light_GrayCodePattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_GrayCodePattern' or its derivative)");
    Ptr<cv::structured_light::GrayCodePattern> _self_ = *(self1);
    {
    PyObject* pyobj_blackImage = NULL;
    Mat blackImage;
    PyObject* pyobj_whiteImage = NULL;
    Mat whiteImage;

    const char* keywords[] = { "blackImage", "whiteImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:structured_light_GrayCodePattern.getImagesForShadowMasks", (char**)keywords, &pyobj_blackImage, &pyobj_whiteImage) &&
        pyopencv_to(pyobj_blackImage, blackImage, ArgInfo("blackImage", 1)) &&
        pyopencv_to(pyobj_whiteImage, whiteImage, ArgInfo("whiteImage", 1)) )
    {
        ERRWRAP2(_self_->getImagesForShadowMasks(blackImage, whiteImage));
        return Py_BuildValue("(NN)", pyopencv_from(blackImage), pyopencv_from(whiteImage));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_blackImage = NULL;
    UMat blackImage;
    PyObject* pyobj_whiteImage = NULL;
    UMat whiteImage;

    const char* keywords[] = { "blackImage", "whiteImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:structured_light_GrayCodePattern.getImagesForShadowMasks", (char**)keywords, &pyobj_blackImage, &pyobj_whiteImage) &&
        pyopencv_to(pyobj_blackImage, blackImage, ArgInfo("blackImage", 1)) &&
        pyopencv_to(pyobj_whiteImage, whiteImage, ArgInfo("whiteImage", 1)) )
    {
        ERRWRAP2(_self_->getImagesForShadowMasks(blackImage, whiteImage));
        return Py_BuildValue("(NN)", pyopencv_from(blackImage), pyopencv_from(whiteImage));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_GrayCodePattern_getNumberOfPatternImages(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::GrayCodePattern> * self1 = 0;
    if (!pyopencv_structured_light_GrayCodePattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_GrayCodePattern' or its derivative)");
    Ptr<cv::structured_light::GrayCodePattern> _self_ = *(self1);
    size_t retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumberOfPatternImages());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_GrayCodePattern_getProjPixel(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::GrayCodePattern> * self1 = 0;
    if (!pyopencv_structured_light_GrayCodePattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_GrayCodePattern' or its derivative)");
    Ptr<cv::structured_light::GrayCodePattern> _self_ = *(self1);
    {
    PyObject* pyobj_patternImages = NULL;
    vector_Mat patternImages;
    int x=0;
    int y=0;
    Point projPix;
    bool retval;

    const char* keywords[] = { "patternImages", "x", "y", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oii:structured_light_GrayCodePattern.getProjPixel", (char**)keywords, &pyobj_patternImages, &x, &y) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 0)) )
    {
        ERRWRAP2(retval = _self_->getProjPixel(patternImages, x, y, projPix));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(projPix));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_patternImages = NULL;
    vector_Mat patternImages;
    int x=0;
    int y=0;
    Point projPix;
    bool retval;

    const char* keywords[] = { "patternImages", "x", "y", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oii:structured_light_GrayCodePattern.getProjPixel", (char**)keywords, &pyobj_patternImages, &x, &y) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 0)) )
    {
        ERRWRAP2(retval = _self_->getProjPixel(patternImages, x, y, projPix));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(projPix));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_GrayCodePattern_setBlackThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::GrayCodePattern> * self1 = 0;
    if (!pyopencv_structured_light_GrayCodePattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_GrayCodePattern' or its derivative)");
    Ptr<cv::structured_light::GrayCodePattern> _self_ = *(self1);
    size_t value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "I:structured_light_GrayCodePattern.setBlackThreshold", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setBlackThreshold(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_GrayCodePattern_setWhiteThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::GrayCodePattern> * self1 = 0;
    if (!pyopencv_structured_light_GrayCodePattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_GrayCodePattern' or its derivative)");
    Ptr<cv::structured_light::GrayCodePattern> _self_ = *(self1);
    size_t value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "I:structured_light_GrayCodePattern.setWhiteThreshold", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setWhiteThreshold(value));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (structured_light_GrayCodePattern)

static PyGetSetDef pyopencv_structured_light_GrayCodePattern_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_structured_light_GrayCodePattern_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_GrayCodePattern_create_static, METH_STATIC), "create(width, height) -> retval\n.   @brief Constructor\n.      @param parameters GrayCodePattern parameters GrayCodePattern::Params: the width and the height of the projector."},
    {"getImagesForShadowMasks", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_GrayCodePattern_getImagesForShadowMasks, 0), "getImagesForShadowMasks(blackImage, whiteImage) -> blackImage, whiteImage\n.   @brief Generates the all-black and all-white images needed for shadowMasks computation.\n.      *\n.      *  To identify shadow regions, the regions of two images where the pixels are not lit by projector's light and thus where there is not coded information,\n.      *  the 3DUNDERWORLD algorithm computes a shadow mask for the two cameras views, starting from a white and a black images captured by each camera.\n.      *  This method generates these two additional images to project.\n.      *\n.      *  @param blackImage The generated all-black CV_8U image, at projector's resolution.\n.      *  @param whiteImage The generated all-white CV_8U image, at projector's resolution."},
    {"getNumberOfPatternImages", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_GrayCodePattern_getNumberOfPatternImages, 0), "getNumberOfPatternImages() -> retval\n.   @brief Get the number of pattern images needed for the graycode pattern.\n.      *\n.      * @return The number of pattern images needed for the graycode pattern.\n.      *"},
    {"getProjPixel", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_GrayCodePattern_getProjPixel, 0), "getProjPixel(patternImages, x, y) -> retval, projPix\n.   @brief For a (x,y) pixel of a camera returns the corresponding projector pixel.\n.      *\n.      *  The function decodes each pixel in the pattern images acquired by a camera into their corresponding decimal numbers representing the projector's column and row,\n.      *  providing a mapping between camera's and projector's pixel.\n.      *\n.      *  @param patternImages The pattern images acquired by the camera, stored in a grayscale vector < Mat >.\n.      *  @param x x coordinate of the image pixel.\n.      *  @param y y coordinate of the image pixel.\n.      *  @param projPix Projector's pixel corresponding to the camera's pixel: projPix.x and projPix.y are the image coordinates of the projector's pixel corresponding to the pixel being decoded in a camera."},
    {"setBlackThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_GrayCodePattern_setBlackThreshold, 0), "setBlackThreshold(value) -> None\n.   @brief Sets the value for black threshold, needed for decoding (shadowsmasks computation).\n.      *\n.      *  Black threshold is a number between 0-255 that represents the minimum brightness difference required for valid pixels, between the fully illuminated (white) and the not illuminated images (black); used in computeShadowMasks method.\n.      *\n.      *  @param value The desired black threshold value.\n.      *"},
    {"setWhiteThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_GrayCodePattern_setWhiteThreshold, 0), "setWhiteThreshold(value) -> None\n.   @brief Sets the value for white threshold, needed for decoding.\n.      *\n.      *  White threshold is a number between 0-255 that represents the minimum brightness difference required for valid pixels, between the graycode pattern and its inverse images; used in getProjPixel method.\n.      *\n.      *  @param value The desired white threshold value.\n.      *"},

    {NULL,          NULL}
};

// Converter (structured_light_GrayCodePattern)

template<>
struct PyOpenCV_Converter< Ptr<cv::structured_light::GrayCodePattern> >
{
    static PyObject* from(const Ptr<cv::structured_light::GrayCodePattern>& r)
    {
        return pyopencv_structured_light_GrayCodePattern_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::structured_light::GrayCodePattern>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::structured_light::GrayCodePattern> * dst_;
        if (pyopencv_structured_light_GrayCodePattern_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::structured_light::GrayCodePattern> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// structured_light_SinusoidalPattern (Generic)
//================================================================================

// GetSet (structured_light_SinusoidalPattern)



// Methods (structured_light_SinusoidalPattern)

static PyObject* pyopencv_cv_structured_light_structured_light_SinusoidalPattern_computeDataModulationTerm(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::SinusoidalPattern> * self1 = 0;
    if (!pyopencv_structured_light_SinusoidalPattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_SinusoidalPattern' or its derivative)");
    Ptr<cv::structured_light::SinusoidalPattern> _self_ = *(self1);
    {
    PyObject* pyobj_patternImages = NULL;
    vector_Mat patternImages;
    PyObject* pyobj_dataModulationTerm = NULL;
    Mat dataModulationTerm;
    PyObject* pyobj_shadowMask = NULL;
    Mat shadowMask;

    const char* keywords[] = { "patternImages", "shadowMask", "dataModulationTerm", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:structured_light_SinusoidalPattern.computeDataModulationTerm", (char**)keywords, &pyobj_patternImages, &pyobj_shadowMask, &pyobj_dataModulationTerm) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 0)) &&
        pyopencv_to(pyobj_dataModulationTerm, dataModulationTerm, ArgInfo("dataModulationTerm", 1)) &&
        pyopencv_to(pyobj_shadowMask, shadowMask, ArgInfo("shadowMask", 0)) )
    {
        ERRWRAP2(_self_->computeDataModulationTerm(patternImages, dataModulationTerm, shadowMask));
        return pyopencv_from(dataModulationTerm);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_patternImages = NULL;
    vector_Mat patternImages;
    PyObject* pyobj_dataModulationTerm = NULL;
    UMat dataModulationTerm;
    PyObject* pyobj_shadowMask = NULL;
    UMat shadowMask;

    const char* keywords[] = { "patternImages", "shadowMask", "dataModulationTerm", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:structured_light_SinusoidalPattern.computeDataModulationTerm", (char**)keywords, &pyobj_patternImages, &pyobj_shadowMask, &pyobj_dataModulationTerm) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 0)) &&
        pyopencv_to(pyobj_dataModulationTerm, dataModulationTerm, ArgInfo("dataModulationTerm", 1)) &&
        pyopencv_to(pyobj_shadowMask, shadowMask, ArgInfo("shadowMask", 0)) )
    {
        ERRWRAP2(_self_->computeDataModulationTerm(patternImages, dataModulationTerm, shadowMask));
        return pyopencv_from(dataModulationTerm);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_SinusoidalPattern_computePhaseMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::SinusoidalPattern> * self1 = 0;
    if (!pyopencv_structured_light_SinusoidalPattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_SinusoidalPattern' or its derivative)");
    Ptr<cv::structured_light::SinusoidalPattern> _self_ = *(self1);
    {
    PyObject* pyobj_patternImages = NULL;
    vector_Mat patternImages;
    PyObject* pyobj_wrappedPhaseMap = NULL;
    Mat wrappedPhaseMap;
    PyObject* pyobj_shadowMask = NULL;
    Mat shadowMask;
    PyObject* pyobj_fundamental = NULL;
    Mat fundamental;

    const char* keywords[] = { "patternImages", "wrappedPhaseMap", "shadowMask", "fundamental", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:structured_light_SinusoidalPattern.computePhaseMap", (char**)keywords, &pyobj_patternImages, &pyobj_wrappedPhaseMap, &pyobj_shadowMask, &pyobj_fundamental) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 0)) &&
        pyopencv_to(pyobj_wrappedPhaseMap, wrappedPhaseMap, ArgInfo("wrappedPhaseMap", 1)) &&
        pyopencv_to(pyobj_shadowMask, shadowMask, ArgInfo("shadowMask", 1)) &&
        pyopencv_to(pyobj_fundamental, fundamental, ArgInfo("fundamental", 0)) )
    {
        ERRWRAP2(_self_->computePhaseMap(patternImages, wrappedPhaseMap, shadowMask, fundamental));
        return Py_BuildValue("(NN)", pyopencv_from(wrappedPhaseMap), pyopencv_from(shadowMask));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_patternImages = NULL;
    vector_Mat patternImages;
    PyObject* pyobj_wrappedPhaseMap = NULL;
    UMat wrappedPhaseMap;
    PyObject* pyobj_shadowMask = NULL;
    UMat shadowMask;
    PyObject* pyobj_fundamental = NULL;
    UMat fundamental;

    const char* keywords[] = { "patternImages", "wrappedPhaseMap", "shadowMask", "fundamental", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:structured_light_SinusoidalPattern.computePhaseMap", (char**)keywords, &pyobj_patternImages, &pyobj_wrappedPhaseMap, &pyobj_shadowMask, &pyobj_fundamental) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 0)) &&
        pyopencv_to(pyobj_wrappedPhaseMap, wrappedPhaseMap, ArgInfo("wrappedPhaseMap", 1)) &&
        pyopencv_to(pyobj_shadowMask, shadowMask, ArgInfo("shadowMask", 1)) &&
        pyopencv_to(pyobj_fundamental, fundamental, ArgInfo("fundamental", 0)) )
    {
        ERRWRAP2(_self_->computePhaseMap(patternImages, wrappedPhaseMap, shadowMask, fundamental));
        return Py_BuildValue("(NN)", pyopencv_from(wrappedPhaseMap), pyopencv_from(shadowMask));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_SinusoidalPattern_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;

    PyObject* pyobj_parameters = NULL;
    Ptr<SinusoidalPattern::Params> parameters=makePtr<SinusoidalPattern::Params>();
    Ptr<SinusoidalPattern> retval;

    const char* keywords[] = { "parameters", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:structured_light_SinusoidalPattern.create", (char**)keywords, &pyobj_parameters) &&
        pyopencv_to(pyobj_parameters, parameters, ArgInfo("parameters", 0)) )
    {
        ERRWRAP2(retval = cv::structured_light::SinusoidalPattern::create(parameters));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_SinusoidalPattern_findProCamMatches(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::SinusoidalPattern> * self1 = 0;
    if (!pyopencv_structured_light_SinusoidalPattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_SinusoidalPattern' or its derivative)");
    Ptr<cv::structured_light::SinusoidalPattern> _self_ = *(self1);
    {
    PyObject* pyobj_projUnwrappedPhaseMap = NULL;
    Mat projUnwrappedPhaseMap;
    PyObject* pyobj_camUnwrappedPhaseMap = NULL;
    Mat camUnwrappedPhaseMap;
    PyObject* pyobj_matches = NULL;
    vector_Mat matches;

    const char* keywords[] = { "projUnwrappedPhaseMap", "camUnwrappedPhaseMap", "matches", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:structured_light_SinusoidalPattern.findProCamMatches", (char**)keywords, &pyobj_projUnwrappedPhaseMap, &pyobj_camUnwrappedPhaseMap, &pyobj_matches) &&
        pyopencv_to(pyobj_projUnwrappedPhaseMap, projUnwrappedPhaseMap, ArgInfo("projUnwrappedPhaseMap", 0)) &&
        pyopencv_to(pyobj_camUnwrappedPhaseMap, camUnwrappedPhaseMap, ArgInfo("camUnwrappedPhaseMap", 0)) &&
        pyopencv_to(pyobj_matches, matches, ArgInfo("matches", 1)) )
    {
        ERRWRAP2(_self_->findProCamMatches(projUnwrappedPhaseMap, camUnwrappedPhaseMap, matches));
        return pyopencv_from(matches);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_projUnwrappedPhaseMap = NULL;
    UMat projUnwrappedPhaseMap;
    PyObject* pyobj_camUnwrappedPhaseMap = NULL;
    UMat camUnwrappedPhaseMap;
    PyObject* pyobj_matches = NULL;
    vector_Mat matches;

    const char* keywords[] = { "projUnwrappedPhaseMap", "camUnwrappedPhaseMap", "matches", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:structured_light_SinusoidalPattern.findProCamMatches", (char**)keywords, &pyobj_projUnwrappedPhaseMap, &pyobj_camUnwrappedPhaseMap, &pyobj_matches) &&
        pyopencv_to(pyobj_projUnwrappedPhaseMap, projUnwrappedPhaseMap, ArgInfo("projUnwrappedPhaseMap", 0)) &&
        pyopencv_to(pyobj_camUnwrappedPhaseMap, camUnwrappedPhaseMap, ArgInfo("camUnwrappedPhaseMap", 0)) &&
        pyopencv_to(pyobj_matches, matches, ArgInfo("matches", 1)) )
    {
        ERRWRAP2(_self_->findProCamMatches(projUnwrappedPhaseMap, camUnwrappedPhaseMap, matches));
        return pyopencv_from(matches);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_SinusoidalPattern_unwrapPhaseMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::SinusoidalPattern> * self1 = 0;
    if (!pyopencv_structured_light_SinusoidalPattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_SinusoidalPattern' or its derivative)");
    Ptr<cv::structured_light::SinusoidalPattern> _self_ = *(self1);
    {
    PyObject* pyobj_wrappedPhaseMap = NULL;
    vector_Mat wrappedPhaseMap;
    PyObject* pyobj_unwrappedPhaseMap = NULL;
    Mat unwrappedPhaseMap;
    PyObject* pyobj_camSize = NULL;
    Size camSize;
    PyObject* pyobj_shadowMask = NULL;
    Mat shadowMask;

    const char* keywords[] = { "wrappedPhaseMap", "camSize", "unwrappedPhaseMap", "shadowMask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:structured_light_SinusoidalPattern.unwrapPhaseMap", (char**)keywords, &pyobj_wrappedPhaseMap, &pyobj_camSize, &pyobj_unwrappedPhaseMap, &pyobj_shadowMask) &&
        pyopencv_to(pyobj_wrappedPhaseMap, wrappedPhaseMap, ArgInfo("wrappedPhaseMap", 0)) &&
        pyopencv_to(pyobj_unwrappedPhaseMap, unwrappedPhaseMap, ArgInfo("unwrappedPhaseMap", 1)) &&
        pyopencv_to(pyobj_camSize, camSize, ArgInfo("camSize", 0)) &&
        pyopencv_to(pyobj_shadowMask, shadowMask, ArgInfo("shadowMask", 0)) )
    {
        ERRWRAP2(_self_->unwrapPhaseMap(wrappedPhaseMap, unwrappedPhaseMap, camSize, shadowMask));
        return pyopencv_from(unwrappedPhaseMap);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_wrappedPhaseMap = NULL;
    vector_Mat wrappedPhaseMap;
    PyObject* pyobj_unwrappedPhaseMap = NULL;
    UMat unwrappedPhaseMap;
    PyObject* pyobj_camSize = NULL;
    Size camSize;
    PyObject* pyobj_shadowMask = NULL;
    UMat shadowMask;

    const char* keywords[] = { "wrappedPhaseMap", "camSize", "unwrappedPhaseMap", "shadowMask", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:structured_light_SinusoidalPattern.unwrapPhaseMap", (char**)keywords, &pyobj_wrappedPhaseMap, &pyobj_camSize, &pyobj_unwrappedPhaseMap, &pyobj_shadowMask) &&
        pyopencv_to(pyobj_wrappedPhaseMap, wrappedPhaseMap, ArgInfo("wrappedPhaseMap", 0)) &&
        pyopencv_to(pyobj_unwrappedPhaseMap, unwrappedPhaseMap, ArgInfo("unwrappedPhaseMap", 1)) &&
        pyopencv_to(pyobj_camSize, camSize, ArgInfo("camSize", 0)) &&
        pyopencv_to(pyobj_shadowMask, shadowMask, ArgInfo("shadowMask", 0)) )
    {
        ERRWRAP2(_self_->unwrapPhaseMap(wrappedPhaseMap, unwrappedPhaseMap, camSize, shadowMask));
        return pyopencv_from(unwrappedPhaseMap);
    }
    }

    return NULL;
}



// Tables (structured_light_SinusoidalPattern)

static PyGetSetDef pyopencv_structured_light_SinusoidalPattern_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_structured_light_SinusoidalPattern_methods[] =
{
    {"computeDataModulationTerm", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_SinusoidalPattern_computeDataModulationTerm, 0), "computeDataModulationTerm(patternImages, shadowMask[, dataModulationTerm]) -> dataModulationTerm\n.   * @brief compute the data modulation term.\n.        * @param patternImages captured images with projected patterns.\n.        * @param dataModulationTerm Mat where the data modulation term is saved.\n.        * @param shadowMask Mask used to discard shadow regions."},
    {"computePhaseMap", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_SinusoidalPattern_computePhaseMap, 0), "computePhaseMap(patternImages[, wrappedPhaseMap[, shadowMask[, fundamental]]]) -> wrappedPhaseMap, shadowMask\n.   * @brief Compute a wrapped phase map from sinusoidal patterns.\n.        * @param patternImages Input data to compute the wrapped phase map.\n.        * @param wrappedPhaseMap Wrapped phase map obtained through one of the three methods.\n.        * @param shadowMask Mask used to discard shadow regions.\n.        * @param fundamental Fundamental matrix used to compute epipolar lines and ease the matching step."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_SinusoidalPattern_create_static, METH_STATIC), "create([, parameters]) -> retval\n.   * @brief Constructor.\n.        * @param parameters SinusoidalPattern parameters SinusoidalPattern::Params: width, height of the projector and patterns parameters.\n.        *"},
    {"findProCamMatches", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_SinusoidalPattern_findProCamMatches, 0), "findProCamMatches(projUnwrappedPhaseMap, camUnwrappedPhaseMap[, matches]) -> matches\n.   * @brief Find correspondences between the two devices thanks to unwrapped phase maps.\n.        * @param projUnwrappedPhaseMap Projector's unwrapped phase map.\n.        * @param camUnwrappedPhaseMap Camera's unwrapped phase map.\n.        * @param matches Images used to display correspondences map."},
    {"unwrapPhaseMap", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_SinusoidalPattern_unwrapPhaseMap, 0), "unwrapPhaseMap(wrappedPhaseMap, camSize[, unwrappedPhaseMap[, shadowMask]]) -> unwrappedPhaseMap\n.   * @brief Unwrap the wrapped phase map to remove phase ambiguities.\n.        * @param wrappedPhaseMap The wrapped phase map computed from the pattern.\n.        * @param unwrappedPhaseMap The unwrapped phase map used to find correspondences between the two devices.\n.        * @param camSize Resolution of the camera.\n.        * @param shadowMask Mask used to discard shadow regions."},

    {NULL,          NULL}
};

// Converter (structured_light_SinusoidalPattern)

template<>
struct PyOpenCV_Converter< Ptr<cv::structured_light::SinusoidalPattern> >
{
    static PyObject* from(const Ptr<cv::structured_light::SinusoidalPattern>& r)
    {
        return pyopencv_structured_light_SinusoidalPattern_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::structured_light::SinusoidalPattern>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::structured_light::SinusoidalPattern> * dst_;
        if (pyopencv_structured_light_SinusoidalPattern_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::structured_light::SinusoidalPattern> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// structured_light_SinusoidalPattern_Params (Generic)
//================================================================================

// GetSet (structured_light_SinusoidalPattern_Params)


static PyObject* pyopencv_structured_light_SinusoidalPattern_Params_get_height(pyopencv_structured_light_SinusoidalPattern_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->height);
}

static int pyopencv_structured_light_SinusoidalPattern_Params_set_height(pyopencv_structured_light_SinusoidalPattern_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the height attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->height) ? 0 : -1;
}

static PyObject* pyopencv_structured_light_SinusoidalPattern_Params_get_horizontal(pyopencv_structured_light_SinusoidalPattern_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->horizontal);
}

static int pyopencv_structured_light_SinusoidalPattern_Params_set_horizontal(pyopencv_structured_light_SinusoidalPattern_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the horizontal attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->horizontal) ? 0 : -1;
}

static PyObject* pyopencv_structured_light_SinusoidalPattern_Params_get_methodId(pyopencv_structured_light_SinusoidalPattern_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->methodId);
}

static int pyopencv_structured_light_SinusoidalPattern_Params_set_methodId(pyopencv_structured_light_SinusoidalPattern_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the methodId attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->methodId) ? 0 : -1;
}

static PyObject* pyopencv_structured_light_SinusoidalPattern_Params_get_nbrOfPeriods(pyopencv_structured_light_SinusoidalPattern_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->nbrOfPeriods);
}

static int pyopencv_structured_light_SinusoidalPattern_Params_set_nbrOfPeriods(pyopencv_structured_light_SinusoidalPattern_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the nbrOfPeriods attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->nbrOfPeriods) ? 0 : -1;
}

static PyObject* pyopencv_structured_light_SinusoidalPattern_Params_get_nbrOfPixelsBetweenMarkers(pyopencv_structured_light_SinusoidalPattern_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->nbrOfPixelsBetweenMarkers);
}

static int pyopencv_structured_light_SinusoidalPattern_Params_set_nbrOfPixelsBetweenMarkers(pyopencv_structured_light_SinusoidalPattern_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the nbrOfPixelsBetweenMarkers attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->nbrOfPixelsBetweenMarkers) ? 0 : -1;
}

static PyObject* pyopencv_structured_light_SinusoidalPattern_Params_get_setMarkers(pyopencv_structured_light_SinusoidalPattern_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->setMarkers);
}

static int pyopencv_structured_light_SinusoidalPattern_Params_set_setMarkers(pyopencv_structured_light_SinusoidalPattern_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the setMarkers attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->setMarkers) ? 0 : -1;
}

static PyObject* pyopencv_structured_light_SinusoidalPattern_Params_get_shiftValue(pyopencv_structured_light_SinusoidalPattern_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->shiftValue);
}

static int pyopencv_structured_light_SinusoidalPattern_Params_set_shiftValue(pyopencv_structured_light_SinusoidalPattern_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the shiftValue attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->shiftValue) ? 0 : -1;
}

static PyObject* pyopencv_structured_light_SinusoidalPattern_Params_get_width(pyopencv_structured_light_SinusoidalPattern_Params_t* p, void *closure)
{
    return pyopencv_from(p->v->width);
}

static int pyopencv_structured_light_SinusoidalPattern_Params_set_width(pyopencv_structured_light_SinusoidalPattern_Params_t* p, PyObject *value, void *closure)
{
    if (!value)
    {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the width attribute");
        return -1;
    }
    return pyopencv_to(value, p->v->width) ? 0 : -1;
}


// Methods (structured_light_SinusoidalPattern_Params)

static int pyopencv_cv_structured_light_structured_light_SinusoidalPattern_Params_SinusoidalPattern_Params(pyopencv_structured_light_SinusoidalPattern_Params_t* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        new (&(self->v)) Ptr<cv::structured_light::SinusoidalPattern::Params>(); // init Ptr with placement new
        if(self) ERRWRAP2(self->v.reset(new cv::structured_light::SinusoidalPattern::Params()));
        return 0;
    }

    return -1;
}



// Tables (structured_light_SinusoidalPattern_Params)

static PyGetSetDef pyopencv_structured_light_SinusoidalPattern_Params_getseters[] =
{
    {(char*)"height", (getter)pyopencv_structured_light_SinusoidalPattern_Params_get_height, (setter)pyopencv_structured_light_SinusoidalPattern_Params_set_height, (char*)"height", NULL},
    {(char*)"horizontal", (getter)pyopencv_structured_light_SinusoidalPattern_Params_get_horizontal, (setter)pyopencv_structured_light_SinusoidalPattern_Params_set_horizontal, (char*)"horizontal", NULL},
    {(char*)"methodId", (getter)pyopencv_structured_light_SinusoidalPattern_Params_get_methodId, (setter)pyopencv_structured_light_SinusoidalPattern_Params_set_methodId, (char*)"methodId", NULL},
    {(char*)"nbrOfPeriods", (getter)pyopencv_structured_light_SinusoidalPattern_Params_get_nbrOfPeriods, (setter)pyopencv_structured_light_SinusoidalPattern_Params_set_nbrOfPeriods, (char*)"nbrOfPeriods", NULL},
    {(char*)"nbrOfPixelsBetweenMarkers", (getter)pyopencv_structured_light_SinusoidalPattern_Params_get_nbrOfPixelsBetweenMarkers, (setter)pyopencv_structured_light_SinusoidalPattern_Params_set_nbrOfPixelsBetweenMarkers, (char*)"nbrOfPixelsBetweenMarkers", NULL},
    {(char*)"setMarkers", (getter)pyopencv_structured_light_SinusoidalPattern_Params_get_setMarkers, (setter)pyopencv_structured_light_SinusoidalPattern_Params_set_setMarkers, (char*)"setMarkers", NULL},
    {(char*)"shiftValue", (getter)pyopencv_structured_light_SinusoidalPattern_Params_get_shiftValue, (setter)pyopencv_structured_light_SinusoidalPattern_Params_set_shiftValue, (char*)"shiftValue", NULL},
    {(char*)"width", (getter)pyopencv_structured_light_SinusoidalPattern_Params_get_width, (setter)pyopencv_structured_light_SinusoidalPattern_Params_set_width, (char*)"width", NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_structured_light_SinusoidalPattern_Params_methods[] =
{

    {NULL,          NULL}
};

// Converter (structured_light_SinusoidalPattern_Params)

template<>
struct PyOpenCV_Converter< Ptr<cv::structured_light::SinusoidalPattern::Params> >
{
    static PyObject* from(const Ptr<cv::structured_light::SinusoidalPattern::Params>& r)
    {
        return pyopencv_structured_light_SinusoidalPattern_Params_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::structured_light::SinusoidalPattern::Params>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::structured_light::SinusoidalPattern::Params> * dst_;
        if (pyopencv_structured_light_SinusoidalPattern_Params_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::structured_light::SinusoidalPattern::Params> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// structured_light_StructuredLightPattern (Generic)
//================================================================================

// GetSet (structured_light_StructuredLightPattern)



// Methods (structured_light_StructuredLightPattern)

static PyObject* pyopencv_cv_structured_light_structured_light_StructuredLightPattern_decode(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::StructuredLightPattern> * self1 = 0;
    if (!pyopencv_structured_light_StructuredLightPattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_StructuredLightPattern' or its derivative)");
    Ptr<cv::structured_light::StructuredLightPattern> _self_ = *(self1);
    {
    PyObject* pyobj_patternImages = NULL;
    vector_vector_Mat patternImages;
    PyObject* pyobj_disparityMap = NULL;
    Mat disparityMap;
    PyObject* pyobj_blackImages = NULL;
    vector_Mat blackImages;
    PyObject* pyobj_whiteImages = NULL;
    vector_Mat whiteImages;
    int flags=DECODE_3D_UNDERWORLD;
    bool retval;

    const char* keywords[] = { "patternImages", "disparityMap", "blackImages", "whiteImages", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOOi:structured_light_StructuredLightPattern.decode", (char**)keywords, &pyobj_patternImages, &pyobj_disparityMap, &pyobj_blackImages, &pyobj_whiteImages, &flags) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 0)) &&
        pyopencv_to(pyobj_disparityMap, disparityMap, ArgInfo("disparityMap", 1)) &&
        pyopencv_to(pyobj_blackImages, blackImages, ArgInfo("blackImages", 0)) &&
        pyopencv_to(pyobj_whiteImages, whiteImages, ArgInfo("whiteImages", 0)) )
    {
        ERRWRAP2(retval = _self_->decode(patternImages, disparityMap, blackImages, whiteImages, flags));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(disparityMap));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_patternImages = NULL;
    vector_vector_Mat patternImages;
    PyObject* pyobj_disparityMap = NULL;
    UMat disparityMap;
    PyObject* pyobj_blackImages = NULL;
    vector_Mat blackImages;
    PyObject* pyobj_whiteImages = NULL;
    vector_Mat whiteImages;
    int flags=DECODE_3D_UNDERWORLD;
    bool retval;

    const char* keywords[] = { "patternImages", "disparityMap", "blackImages", "whiteImages", "flags", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OOOi:structured_light_StructuredLightPattern.decode", (char**)keywords, &pyobj_patternImages, &pyobj_disparityMap, &pyobj_blackImages, &pyobj_whiteImages, &flags) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 0)) &&
        pyopencv_to(pyobj_disparityMap, disparityMap, ArgInfo("disparityMap", 1)) &&
        pyopencv_to(pyobj_blackImages, blackImages, ArgInfo("blackImages", 0)) &&
        pyopencv_to(pyobj_whiteImages, whiteImages, ArgInfo("whiteImages", 0)) )
    {
        ERRWRAP2(retval = _self_->decode(patternImages, disparityMap, blackImages, whiteImages, flags));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(disparityMap));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_structured_light_structured_light_StructuredLightPattern_generate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::structured_light;


    Ptr<cv::structured_light::StructuredLightPattern> * self1 = 0;
    if (!pyopencv_structured_light_StructuredLightPattern_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'structured_light_StructuredLightPattern' or its derivative)");
    Ptr<cv::structured_light::StructuredLightPattern> _self_ = *(self1);
    {
    PyObject* pyobj_patternImages = NULL;
    vector_Mat patternImages;
    bool retval;

    const char* keywords[] = { "patternImages", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:structured_light_StructuredLightPattern.generate", (char**)keywords, &pyobj_patternImages) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 1)) )
    {
        ERRWRAP2(retval = _self_->generate(patternImages));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(patternImages));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_patternImages = NULL;
    vector_Mat patternImages;
    bool retval;

    const char* keywords[] = { "patternImages", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:structured_light_StructuredLightPattern.generate", (char**)keywords, &pyobj_patternImages) &&
        pyopencv_to(pyobj_patternImages, patternImages, ArgInfo("patternImages", 1)) )
    {
        ERRWRAP2(retval = _self_->generate(patternImages));
        return Py_BuildValue("(NN)", pyopencv_from(retval), pyopencv_from(patternImages));
    }
    }

    return NULL;
}



// Tables (structured_light_StructuredLightPattern)

static PyGetSetDef pyopencv_structured_light_StructuredLightPattern_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_structured_light_StructuredLightPattern_methods[] =
{
    {"decode", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_StructuredLightPattern_decode, 0), "decode(patternImages[, disparityMap[, blackImages[, whiteImages[, flags]]]]) -> retval, disparityMap\n.   @brief Decodes the structured light pattern, generating a disparity map\n.   \n.      @param patternImages The acquired pattern images to decode (vector<vector<Mat>>), loaded as grayscale and previously rectified.\n.      @param disparityMap The decoding result: a CV_64F Mat at image resolution, storing the computed disparity map.\n.      @param blackImages The all-black images needed for shadowMasks computation.\n.      @param whiteImages The all-white images needed for shadowMasks computation.\n.      @param flags Flags setting decoding algorithms. Default: DECODE_3D_UNDERWORLD.\n.      @note All the images must be at the same resolution."},
    {"generate", CV_PY_FN_WITH_KW_(pyopencv_cv_structured_light_structured_light_StructuredLightPattern_generate, 0), "generate([, patternImages]) -> retval, patternImages\n.   @brief Generates the structured light pattern to project.\n.   \n.      @param patternImages The generated pattern: a vector<Mat>, in which each image is a CV_8U Mat at projector's resolution."},

    {NULL,          NULL}
};

// Converter (structured_light_StructuredLightPattern)

template<>
struct PyOpenCV_Converter< Ptr<cv::structured_light::StructuredLightPattern> >
{
    static PyObject* from(const Ptr<cv::structured_light::StructuredLightPattern>& r)
    {
        return pyopencv_structured_light_StructuredLightPattern_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::structured_light::StructuredLightPattern>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::structured_light::StructuredLightPattern> * dst_;
        if (pyopencv_structured_light_StructuredLightPattern_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::structured_light::StructuredLightPattern> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_BaseOCR (Generic)
//================================================================================

// GetSet (text_BaseOCR)



// Methods (text_BaseOCR)



// Tables (text_BaseOCR)

static PyGetSetDef pyopencv_text_BaseOCR_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_BaseOCR_methods[] =
{

    {NULL,          NULL}
};

// Converter (text_BaseOCR)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::BaseOCR> >
{
    static PyObject* from(const Ptr<cv::text::BaseOCR>& r)
    {
        return pyopencv_text_BaseOCR_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::BaseOCR>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::BaseOCR> * dst_;
        if (pyopencv_text_BaseOCR_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::BaseOCR> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_ERFilter (Generic)
//================================================================================

// GetSet (text_ERFilter)



// Methods (text_ERFilter)



// Tables (text_ERFilter)

static PyGetSetDef pyopencv_text_ERFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_ERFilter_methods[] =
{

    {NULL,          NULL}
};

// Converter (text_ERFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::ERFilter> >
{
    static PyObject* from(const Ptr<cv::text::ERFilter>& r)
    {
        return pyopencv_text_ERFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::ERFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::ERFilter> * dst_;
        if (pyopencv_text_ERFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::ERFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_ERFilter_Callback (Generic)
//================================================================================

// GetSet (text_ERFilter_Callback)



// Methods (text_ERFilter_Callback)



// Tables (text_ERFilter_Callback)

static PyGetSetDef pyopencv_text_ERFilter_Callback_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_ERFilter_Callback_methods[] =
{

    {NULL,          NULL}
};

// Converter (text_ERFilter_Callback)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::ERFilter::Callback> >
{
    static PyObject* from(const Ptr<cv::text::ERFilter::Callback>& r)
    {
        return pyopencv_text_ERFilter_Callback_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::ERFilter::Callback>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::ERFilter::Callback> * dst_;
        if (pyopencv_text_ERFilter_Callback_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::ERFilter::Callback> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_OCRBeamSearchDecoder (Generic)
//================================================================================

// GetSet (text_OCRBeamSearchDecoder)



// Methods (text_OCRBeamSearchDecoder)

static PyObject* pyopencv_cv_text_text_OCRBeamSearchDecoder_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;

    {
    PyObject* pyobj_classifier = NULL;
    Ptr<OCRBeamSearchDecoder::ClassifierCallback> classifier;
    PyObject* pyobj_vocabulary = NULL;
    String vocabulary;
    PyObject* pyobj_transition_probabilities_table = NULL;
    Mat transition_probabilities_table;
    PyObject* pyobj_emission_probabilities_table = NULL;
    Mat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    int beam_size=500;
    Ptr<OCRBeamSearchDecoder> retval;

    const char* keywords[] = { "classifier", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "beam_size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|ii:text_OCRBeamSearchDecoder.create", (char**)keywords, &pyobj_classifier, &pyobj_vocabulary, &pyobj_transition_probabilities_table, &pyobj_emission_probabilities_table, &mode, &beam_size) &&
        pyopencv_to(pyobj_classifier, classifier, ArgInfo("classifier", 0)) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        pyopencv_to(pyobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        pyopencv_to(pyobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) )
    {
        ERRWRAP2(retval = cv::text::OCRBeamSearchDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, beam_size));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_classifier = NULL;
    Ptr<OCRBeamSearchDecoder::ClassifierCallback> classifier;
    PyObject* pyobj_vocabulary = NULL;
    String vocabulary;
    PyObject* pyobj_transition_probabilities_table = NULL;
    UMat transition_probabilities_table;
    PyObject* pyobj_emission_probabilities_table = NULL;
    UMat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    int beam_size=500;
    Ptr<OCRBeamSearchDecoder> retval;

    const char* keywords[] = { "classifier", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "beam_size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|ii:text_OCRBeamSearchDecoder.create", (char**)keywords, &pyobj_classifier, &pyobj_vocabulary, &pyobj_transition_probabilities_table, &pyobj_emission_probabilities_table, &mode, &beam_size) &&
        pyopencv_to(pyobj_classifier, classifier, ArgInfo("classifier", 0)) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        pyopencv_to(pyobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        pyopencv_to(pyobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) )
    {
        ERRWRAP2(retval = cv::text::OCRBeamSearchDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, beam_size));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    PyObject* pyobj_vocabulary = NULL;
    String vocabulary;
    PyObject* pyobj_transition_probabilities_table = NULL;
    Mat transition_probabilities_table;
    PyObject* pyobj_emission_probabilities_table = NULL;
    Mat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    int beam_size=500;
    Ptr<OCRBeamSearchDecoder> retval;

    const char* keywords[] = { "filename", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "beam_size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|ii:text_OCRBeamSearchDecoder.create", (char**)keywords, &pyobj_filename, &pyobj_vocabulary, &pyobj_transition_probabilities_table, &pyobj_emission_probabilities_table, &mode, &beam_size) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        pyopencv_to(pyobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        pyopencv_to(pyobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) )
    {
        ERRWRAP2(retval = cv::text::OCRBeamSearchDecoder::create(filename, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, beam_size));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    PyObject* pyobj_vocabulary = NULL;
    String vocabulary;
    PyObject* pyobj_transition_probabilities_table = NULL;
    UMat transition_probabilities_table;
    PyObject* pyobj_emission_probabilities_table = NULL;
    UMat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    int beam_size=500;
    Ptr<OCRBeamSearchDecoder> retval;

    const char* keywords[] = { "filename", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "beam_size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|ii:text_OCRBeamSearchDecoder.create", (char**)keywords, &pyobj_filename, &pyobj_vocabulary, &pyobj_transition_probabilities_table, &pyobj_emission_probabilities_table, &mode, &beam_size) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        pyopencv_to(pyobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        pyopencv_to(pyobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) )
    {
        ERRWRAP2(retval = cv::text::OCRBeamSearchDecoder::create(filename, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, beam_size));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_text_text_OCRBeamSearchDecoder_run(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;


    Ptr<cv::text::OCRBeamSearchDecoder> * self1 = 0;
    if (!pyopencv_text_OCRBeamSearchDecoder_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'text_OCRBeamSearchDecoder' or its derivative)");
    Ptr<cv::text::OCRBeamSearchDecoder> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|i:text_OCRBeamSearchDecoder.run", (char**)keywords, &pyobj_image, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|i:text_OCRBeamSearchDecoder.run", (char**)keywords, &pyobj_image, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "mask", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|i:text_OCRBeamSearchDecoder.run", (char**)keywords, &pyobj_image, &pyobj_mask, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, mask, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "mask", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|i:text_OCRBeamSearchDecoder.run", (char**)keywords, &pyobj_image, &pyobj_mask, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, mask, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (text_OCRBeamSearchDecoder)

static PyGetSetDef pyopencv_text_OCRBeamSearchDecoder_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_OCRBeamSearchDecoder_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_OCRBeamSearchDecoder_create_static, METH_STATIC), "create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table[, mode[, beam_size]]) -> retval\n.   @brief Creates an instance of the OCRBeamSearchDecoder class. Initializes HMMDecoder.\n.   \n.       @param classifier The character classifier with built in feature extractor.\n.   \n.       @param vocabulary The language vocabulary (chars when ASCII English text). vocabulary.size()\n.       must be equal to the number of classes of the classifier.\n.   \n.       @param transition_probabilities_table Table with transition probabilities between character\n.       pairs. cols == rows == vocabulary.size().\n.   \n.       @param emission_probabilities_table Table with observation emission probabilities. cols ==\n.       rows == vocabulary.size().\n.   \n.       @param mode HMM Decoding algorithm. Only OCR_DECODER_VITERBI is available for the moment\n.       (<http://en.wikipedia.org/wiki/Viterbi_algorithm>).\n.   \n.       @param beam_size Size of the beam in Beam Search algorithm.\n\n\n\ncreate(filename, vocabulary, transition_probabilities_table, emission_probabilities_table[, mode[, beam_size]]) -> retval\n.   @brief Creates an instance of the OCRBeamSearchDecoder class. Initializes HMMDecoder from the specified path.\n.   \n.       @overload"},
    {"run", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_OCRBeamSearchDecoder_run, 0), "run(image, min_confidence[, component_level]) -> retval\n.   @brief Recognize text using Beam Search.\n.   \n.       Takes image on input and returns recognized text in the output_text parameter. Optionally\n.       provides also the Rects for individual text elements found (e.g. words), and the list of those\n.       text elements with their confidence values.\n.   \n.       @param image Input binary image CV_8UC1 with a single text line (or word).\n.   \n.       @param output_text Output text. Most likely character sequence found by the HMM decoder.\n.   \n.       @param component_rects If provided the method will output a list of Rects for the individual\n.       text elements found (e.g. words).\n.   \n.       @param component_texts If provided the method will output a list of text strings for the\n.       recognition of individual text elements found (e.g. words).\n.   \n.       @param component_confidences If provided the method will output a list of confidence values\n.       for the recognition of individual text elements found (e.g. words).\n.   \n.       @param component_level Only OCR_LEVEL_WORD is supported.\n\n\n\nrun(image, mask, min_confidence[, component_level]) -> retval\n."},

    {NULL,          NULL}
};

// Converter (text_OCRBeamSearchDecoder)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::OCRBeamSearchDecoder> >
{
    static PyObject* from(const Ptr<cv::text::OCRBeamSearchDecoder>& r)
    {
        return pyopencv_text_OCRBeamSearchDecoder_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::OCRBeamSearchDecoder>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::OCRBeamSearchDecoder> * dst_;
        if (pyopencv_text_OCRBeamSearchDecoder_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::OCRBeamSearchDecoder> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_OCRBeamSearchDecoder_ClassifierCallback (Generic)
//================================================================================

// GetSet (text_OCRBeamSearchDecoder_ClassifierCallback)



// Methods (text_OCRBeamSearchDecoder_ClassifierCallback)



// Tables (text_OCRBeamSearchDecoder_ClassifierCallback)

static PyGetSetDef pyopencv_text_OCRBeamSearchDecoder_ClassifierCallback_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_OCRBeamSearchDecoder_ClassifierCallback_methods[] =
{

    {NULL,          NULL}
};

// Converter (text_OCRBeamSearchDecoder_ClassifierCallback)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::OCRBeamSearchDecoder::ClassifierCallback> >
{
    static PyObject* from(const Ptr<cv::text::OCRBeamSearchDecoder::ClassifierCallback>& r)
    {
        return pyopencv_text_OCRBeamSearchDecoder_ClassifierCallback_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::OCRBeamSearchDecoder::ClassifierCallback>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::OCRBeamSearchDecoder::ClassifierCallback> * dst_;
        if (pyopencv_text_OCRBeamSearchDecoder_ClassifierCallback_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::OCRBeamSearchDecoder::ClassifierCallback> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_OCRHMMDecoder (Generic)
//================================================================================

// GetSet (text_OCRHMMDecoder)



// Methods (text_OCRHMMDecoder)

static PyObject* pyopencv_cv_text_text_OCRHMMDecoder_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;

    {
    PyObject* pyobj_classifier = NULL;
    Ptr<OCRHMMDecoder::ClassifierCallback> classifier;
    PyObject* pyobj_vocabulary = NULL;
    String vocabulary;
    PyObject* pyobj_transition_probabilities_table = NULL;
    Mat transition_probabilities_table;
    PyObject* pyobj_emission_probabilities_table = NULL;
    Mat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    Ptr<OCRHMMDecoder> retval;

    const char* keywords[] = { "classifier", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|i:text_OCRHMMDecoder.create", (char**)keywords, &pyobj_classifier, &pyobj_vocabulary, &pyobj_transition_probabilities_table, &pyobj_emission_probabilities_table, &mode) &&
        pyopencv_to(pyobj_classifier, classifier, ArgInfo("classifier", 0)) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        pyopencv_to(pyobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        pyopencv_to(pyobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) )
    {
        ERRWRAP2(retval = cv::text::OCRHMMDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_classifier = NULL;
    Ptr<OCRHMMDecoder::ClassifierCallback> classifier;
    PyObject* pyobj_vocabulary = NULL;
    String vocabulary;
    PyObject* pyobj_transition_probabilities_table = NULL;
    UMat transition_probabilities_table;
    PyObject* pyobj_emission_probabilities_table = NULL;
    UMat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    Ptr<OCRHMMDecoder> retval;

    const char* keywords[] = { "classifier", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|i:text_OCRHMMDecoder.create", (char**)keywords, &pyobj_classifier, &pyobj_vocabulary, &pyobj_transition_probabilities_table, &pyobj_emission_probabilities_table, &mode) &&
        pyopencv_to(pyobj_classifier, classifier, ArgInfo("classifier", 0)) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        pyopencv_to(pyobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        pyopencv_to(pyobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) )
    {
        ERRWRAP2(retval = cv::text::OCRHMMDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    PyObject* pyobj_vocabulary = NULL;
    String vocabulary;
    PyObject* pyobj_transition_probabilities_table = NULL;
    Mat transition_probabilities_table;
    PyObject* pyobj_emission_probabilities_table = NULL;
    Mat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    int classifier=OCR_KNN_CLASSIFIER;
    Ptr<OCRHMMDecoder> retval;

    const char* keywords[] = { "filename", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "classifier", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|ii:text_OCRHMMDecoder.create", (char**)keywords, &pyobj_filename, &pyobj_vocabulary, &pyobj_transition_probabilities_table, &pyobj_emission_probabilities_table, &mode, &classifier) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        pyopencv_to(pyobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        pyopencv_to(pyobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) )
    {
        ERRWRAP2(retval = cv::text::OCRHMMDecoder::create(filename, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, classifier));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_filename = NULL;
    String filename;
    PyObject* pyobj_vocabulary = NULL;
    String vocabulary;
    PyObject* pyobj_transition_probabilities_table = NULL;
    UMat transition_probabilities_table;
    PyObject* pyobj_emission_probabilities_table = NULL;
    UMat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    int classifier=OCR_KNN_CLASSIFIER;
    Ptr<OCRHMMDecoder> retval;

    const char* keywords[] = { "filename", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "classifier", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|ii:text_OCRHMMDecoder.create", (char**)keywords, &pyobj_filename, &pyobj_vocabulary, &pyobj_transition_probabilities_table, &pyobj_emission_probabilities_table, &mode, &classifier) &&
        pyopencv_to(pyobj_filename, filename, ArgInfo("filename", 0)) &&
        pyopencv_to(pyobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        pyopencv_to(pyobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        pyopencv_to(pyobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) )
    {
        ERRWRAP2(retval = cv::text::OCRHMMDecoder::create(filename, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, classifier));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_text_text_OCRHMMDecoder_run(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;


    Ptr<cv::text::OCRHMMDecoder> * self1 = 0;
    if (!pyopencv_text_OCRHMMDecoder_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'text_OCRHMMDecoder' or its derivative)");
    Ptr<cv::text::OCRHMMDecoder> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|i:text_OCRHMMDecoder.run", (char**)keywords, &pyobj_image, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|i:text_OCRHMMDecoder.run", (char**)keywords, &pyobj_image, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "mask", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|i:text_OCRHMMDecoder.run", (char**)keywords, &pyobj_image, &pyobj_mask, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, mask, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "mask", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|i:text_OCRHMMDecoder.run", (char**)keywords, &pyobj_image, &pyobj_mask, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, mask, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (text_OCRHMMDecoder)

static PyGetSetDef pyopencv_text_OCRHMMDecoder_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_OCRHMMDecoder_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_OCRHMMDecoder_create_static, METH_STATIC), "create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table[, mode]) -> retval\n.   @brief Creates an instance of the OCRHMMDecoder class. Initializes HMMDecoder.\n.   \n.       @param classifier The character classifier with built in feature extractor.\n.   \n.       @param vocabulary The language vocabulary (chars when ascii english text). vocabulary.size()\n.       must be equal to the number of classes of the classifier.\n.   \n.       @param transition_probabilities_table Table with transition probabilities between character\n.       pairs. cols == rows == vocabulary.size().\n.   \n.       @param emission_probabilities_table Table with observation emission probabilities. cols ==\n.       rows == vocabulary.size().\n.   \n.       @param mode HMM Decoding algorithm. Only OCR_DECODER_VITERBI is available for the moment\n.       (<http://en.wikipedia.org/wiki/Viterbi_algorithm>).\n\n\n\ncreate(filename, vocabulary, transition_probabilities_table, emission_probabilities_table[, mode[, classifier]]) -> retval\n.   @brief Creates an instance of the OCRHMMDecoder class. Loads and initializes HMMDecoder from the specified path\n.   \n.        @overload"},
    {"run", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_OCRHMMDecoder_run, 0), "run(image, min_confidence[, component_level]) -> retval\n.   @brief Recognize text using HMM.\n.   \n.       Takes an image and a mask (where each connected component corresponds to a segmented character)\n.       on input and returns recognized text in the output_text parameter. Optionally\n.       provides also the Rects for individual text elements found (e.g. words), and the list of those\n.       text elements with their confidence values.\n.   \n.       @param image Input image CV_8UC1 or CV_8UC3 with a single text line (or word).\n.       @param mask Input binary image CV_8UC1 same size as input image. Each connected component in mask corresponds to a segmented character in the input image.\n.   \n.       @param output_text Output text. Most likely character sequence found by the HMM decoder.\n.   \n.       @param component_rects If provided the method will output a list of Rects for the individual\n.       text elements found (e.g. words).\n.   \n.       @param component_texts If provided the method will output a list of text strings for the\n.       recognition of individual text elements found (e.g. words).\n.   \n.       @param component_confidences If provided the method will output a list of confidence values\n.       for the recognition of individual text elements found (e.g. words).\n.   \n.       @param component_level Only OCR_LEVEL_WORD is supported.\n\n\n\nrun(image, mask, min_confidence[, component_level]) -> retval\n."},

    {NULL,          NULL}
};

// Converter (text_OCRHMMDecoder)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::OCRHMMDecoder> >
{
    static PyObject* from(const Ptr<cv::text::OCRHMMDecoder>& r)
    {
        return pyopencv_text_OCRHMMDecoder_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::OCRHMMDecoder>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::OCRHMMDecoder> * dst_;
        if (pyopencv_text_OCRHMMDecoder_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::OCRHMMDecoder> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_OCRHMMDecoder_ClassifierCallback (Generic)
//================================================================================

// GetSet (text_OCRHMMDecoder_ClassifierCallback)



// Methods (text_OCRHMMDecoder_ClassifierCallback)



// Tables (text_OCRHMMDecoder_ClassifierCallback)

static PyGetSetDef pyopencv_text_OCRHMMDecoder_ClassifierCallback_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_OCRHMMDecoder_ClassifierCallback_methods[] =
{

    {NULL,          NULL}
};

// Converter (text_OCRHMMDecoder_ClassifierCallback)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::OCRHMMDecoder::ClassifierCallback> >
{
    static PyObject* from(const Ptr<cv::text::OCRHMMDecoder::ClassifierCallback>& r)
    {
        return pyopencv_text_OCRHMMDecoder_ClassifierCallback_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::OCRHMMDecoder::ClassifierCallback>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::OCRHMMDecoder::ClassifierCallback> * dst_;
        if (pyopencv_text_OCRHMMDecoder_ClassifierCallback_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::OCRHMMDecoder::ClassifierCallback> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_OCRTesseract (Generic)
//================================================================================

// GetSet (text_OCRTesseract)



// Methods (text_OCRTesseract)

static PyObject* pyopencv_cv_text_text_OCRTesseract_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;

    char* datapath=0;
    char* language=0;
    char* char_whitelist=0;
    int oem=OEM_DEFAULT;
    int psmode=PSM_AUTO;
    Ptr<OCRTesseract> retval;

    const char* keywords[] = { "datapath", "language", "char_whitelist", "oem", "psmode", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|sssii:text_OCRTesseract.create", (char**)keywords, &datapath, &language, &char_whitelist, &oem, &psmode) )
    {
        ERRWRAP2(retval = cv::text::OCRTesseract::create(datapath, language, char_whitelist, oem, psmode));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_text_text_OCRTesseract_run(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;


    Ptr<cv::text::OCRTesseract> * self1 = 0;
    if (!pyopencv_text_OCRTesseract_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'text_OCRTesseract' or its derivative)");
    Ptr<cv::text::OCRTesseract> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|i:text_OCRTesseract.run", (char**)keywords, &pyobj_image, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi|i:text_OCRTesseract.run", (char**)keywords, &pyobj_image, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_mask = NULL;
    Mat mask;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "mask", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|i:text_OCRTesseract.run", (char**)keywords, &pyobj_image, &pyobj_mask, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, mask, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_mask = NULL;
    UMat mask;
    int min_confidence=0;
    int component_level=0;
    String retval;

    const char* keywords[] = { "image", "mask", "min_confidence", "component_level", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOi|i:text_OCRTesseract.run", (char**)keywords, &pyobj_image, &pyobj_mask, &min_confidence, &component_level) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_mask, mask, ArgInfo("mask", 0)) )
    {
        ERRWRAP2(retval = _self_->run(image, mask, min_confidence, component_level));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_text_text_OCRTesseract_setWhiteList(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;


    Ptr<cv::text::OCRTesseract> * self1 = 0;
    if (!pyopencv_text_OCRTesseract_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'text_OCRTesseract' or its derivative)");
    Ptr<cv::text::OCRTesseract> _self_ = *(self1);
    PyObject* pyobj_char_whitelist = NULL;
    String char_whitelist;

    const char* keywords[] = { "char_whitelist", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:text_OCRTesseract.setWhiteList", (char**)keywords, &pyobj_char_whitelist) &&
        pyopencv_to(pyobj_char_whitelist, char_whitelist, ArgInfo("char_whitelist", 0)) )
    {
        ERRWRAP2(_self_->setWhiteList(char_whitelist));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (text_OCRTesseract)

static PyGetSetDef pyopencv_text_OCRTesseract_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_OCRTesseract_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_OCRTesseract_create_static, METH_STATIC), "create([, datapath[, language[, char_whitelist[, oem[, psmode]]]]]) -> retval\n.   @brief Creates an instance of the OCRTesseract class. Initializes Tesseract.\n.   \n.       @param datapath the name of the parent directory of tessdata ended with \"/\", or NULL to use the\n.       system's default directory.\n.       @param language an ISO 639-3 code or NULL will default to \"eng\".\n.       @param char_whitelist specifies the list of characters used for recognition. NULL defaults to\n.       \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n.       @param oem tesseract-ocr offers different OCR Engine Modes (OEM), by default\n.       tesseract::OEM_DEFAULT is used. See the tesseract-ocr API documentation for other possible\n.       values.\n.       @param psmode tesseract-ocr offers different Page Segmentation Modes (PSM) tesseract::PSM_AUTO\n.       (fully automatic layout analysis) is used. See the tesseract-ocr API documentation for other\n.       possible values."},
    {"run", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_OCRTesseract_run, 0), "run(image, min_confidence[, component_level]) -> retval\n.   @brief Recognize text using the tesseract-ocr API.\n.   \n.       Takes image on input and returns recognized text in the output_text parameter. Optionally\n.       provides also the Rects for individual text elements found (e.g. words), and the list of those\n.       text elements with their confidence values.\n.   \n.       @param image Input image CV_8UC1 or CV_8UC3\n.       @param output_text Output text of the tesseract-ocr.\n.       @param component_rects If provided the method will output a list of Rects for the individual\n.       text elements found (e.g. words or text lines).\n.       @param component_texts If provided the method will output a list of text strings for the\n.       recognition of individual text elements found (e.g. words or text lines).\n.       @param component_confidences If provided the method will output a list of confidence values\n.       for the recognition of individual text elements found (e.g. words or text lines).\n.       @param component_level OCR_LEVEL_WORD (by default), or OCR_LEVEL_TEXTLINE.\n\n\n\nrun(image, mask, min_confidence[, component_level]) -> retval\n."},
    {"setWhiteList", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_OCRTesseract_setWhiteList, 0), "setWhiteList(char_whitelist) -> None\n."},

    {NULL,          NULL}
};

// Converter (text_OCRTesseract)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::OCRTesseract> >
{
    static PyObject* from(const Ptr<cv::text::OCRTesseract>& r)
    {
        return pyopencv_text_OCRTesseract_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::OCRTesseract>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::OCRTesseract> * dst_;
        if (pyopencv_text_OCRTesseract_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::OCRTesseract> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_TextDetector (Generic)
//================================================================================

// GetSet (text_TextDetector)



// Methods (text_TextDetector)

static PyObject* pyopencv_cv_text_text_TextDetector_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;


    Ptr<cv::text::TextDetector> * self1 = 0;
    if (!pyopencv_text_TextDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'text_TextDetector' or its derivative)");
    Ptr<cv::text::TextDetector> _self_ = *(self1);
    {
    PyObject* pyobj_inputImage = NULL;
    Mat inputImage;
    vector_Rect Bbox;
    vector_float confidence;

    const char* keywords[] = { "inputImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:text_TextDetector.detect", (char**)keywords, &pyobj_inputImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) )
    {
        ERRWRAP2(_self_->detect(inputImage, Bbox, confidence));
        return Py_BuildValue("(NN)", pyopencv_from(Bbox), pyopencv_from(confidence));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputImage = NULL;
    UMat inputImage;
    vector_Rect Bbox;
    vector_float confidence;

    const char* keywords[] = { "inputImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:text_TextDetector.detect", (char**)keywords, &pyobj_inputImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) )
    {
        ERRWRAP2(_self_->detect(inputImage, Bbox, confidence));
        return Py_BuildValue("(NN)", pyopencv_from(Bbox), pyopencv_from(confidence));
    }
    }

    return NULL;
}



// Tables (text_TextDetector)

static PyGetSetDef pyopencv_text_TextDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_TextDetector_methods[] =
{
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_TextDetector_detect, 0), "detect(inputImage) -> Bbox, confidence\n.   @brief Method that provides a quick and simple interface to detect text inside an image\n.   \n.       @param inputImage an image to process\n.       @param Bbox a vector of Rect that will store the detected word bounding box\n.       @param confidence a vector of float that will be updated with the confidence the classifier has for the selected bounding box"},

    {NULL,          NULL}
};

// Converter (text_TextDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::TextDetector> >
{
    static PyObject* from(const Ptr<cv::text::TextDetector>& r)
    {
        return pyopencv_text_TextDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::TextDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::TextDetector> * dst_;
        if (pyopencv_text_TextDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::TextDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// text_TextDetectorCNN (Generic)
//================================================================================

// GetSet (text_TextDetectorCNN)



// Methods (text_TextDetectorCNN)

static PyObject* pyopencv_cv_text_text_TextDetectorCNN_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;

    PyObject* pyobj_modelArchFilename = NULL;
    String modelArchFilename;
    PyObject* pyobj_modelWeightsFilename = NULL;
    String modelWeightsFilename;
    Ptr<TextDetectorCNN> retval;

    const char* keywords[] = { "modelArchFilename", "modelWeightsFilename", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:text_TextDetectorCNN.create", (char**)keywords, &pyobj_modelArchFilename, &pyobj_modelWeightsFilename) &&
        pyopencv_to(pyobj_modelArchFilename, modelArchFilename, ArgInfo("modelArchFilename", 0)) &&
        pyopencv_to(pyobj_modelWeightsFilename, modelWeightsFilename, ArgInfo("modelWeightsFilename", 0)) )
    {
        ERRWRAP2(retval = cv::text::TextDetectorCNN::create(modelArchFilename, modelWeightsFilename));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_text_text_TextDetectorCNN_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::text;


    Ptr<cv::text::TextDetectorCNN> * self1 = 0;
    if (!pyopencv_text_TextDetectorCNN_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'text_TextDetectorCNN' or its derivative)");
    Ptr<cv::text::TextDetectorCNN> _self_ = *(self1);
    {
    PyObject* pyobj_inputImage = NULL;
    Mat inputImage;
    vector_Rect Bbox;
    vector_float confidence;

    const char* keywords[] = { "inputImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:text_TextDetectorCNN.detect", (char**)keywords, &pyobj_inputImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) )
    {
        ERRWRAP2(_self_->detect(inputImage, Bbox, confidence));
        return Py_BuildValue("(NN)", pyopencv_from(Bbox), pyopencv_from(confidence));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_inputImage = NULL;
    UMat inputImage;
    vector_Rect Bbox;
    vector_float confidence;

    const char* keywords[] = { "inputImage", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:text_TextDetectorCNN.detect", (char**)keywords, &pyobj_inputImage) &&
        pyopencv_to(pyobj_inputImage, inputImage, ArgInfo("inputImage", 0)) )
    {
        ERRWRAP2(_self_->detect(inputImage, Bbox, confidence));
        return Py_BuildValue("(NN)", pyopencv_from(Bbox), pyopencv_from(confidence));
    }
    }

    return NULL;
}



// Tables (text_TextDetectorCNN)

static PyGetSetDef pyopencv_text_TextDetectorCNN_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_text_TextDetectorCNN_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_TextDetectorCNN_create_static, METH_STATIC), "create(modelArchFilename, modelWeightsFilename) -> retval\n.   @overload"},
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_text_text_TextDetectorCNN_detect, 0), "detect(inputImage) -> Bbox, confidence\n.   @overload\n.   \n.       @param inputImage an image expected to be a CV_U8C3 of any size\n.       @param Bbox a vector of Rect that will store the detected word bounding box\n.       @param confidence a vector of float that will be updated with the confidence the classifier has for the selected bounding box"},

    {NULL,          NULL}
};

// Converter (text_TextDetectorCNN)

template<>
struct PyOpenCV_Converter< Ptr<cv::text::TextDetectorCNN> >
{
    static PyObject* from(const Ptr<cv::text::TextDetectorCNN>& r)
    {
        return pyopencv_text_TextDetectorCNN_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::text::TextDetectorCNN>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::text::TextDetectorCNN> * dst_;
        if (pyopencv_text_TextDetectorCNN_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::text::TextDetectorCNN> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_BoostDesc (Generic)
//================================================================================

// GetSet (xfeatures2d_BoostDesc)



// Methods (xfeatures2d_BoostDesc)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int desc=BoostDesc::BINBOOST_256;
    bool use_scale_orientation=true;
    float scale_factor=6.25f;
    Ptr<BoostDesc> retval;

    const char* keywords[] = { "desc", "use_scale_orientation", "scale_factor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ibf:xfeatures2d_BoostDesc.create", (char**)keywords, &desc, &use_scale_orientation, &scale_factor) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::BoostDesc::create(desc, use_scale_orientation, scale_factor));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_getScaleFactor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::BoostDesc> * self1 = 0;
    if (!pyopencv_xfeatures2d_BoostDesc_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_BoostDesc' or its derivative)");
    Ptr<cv::xfeatures2d::BoostDesc> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScaleFactor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_getUseScaleOrientation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::BoostDesc> * self1 = 0;
    if (!pyopencv_xfeatures2d_BoostDesc_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_BoostDesc' or its derivative)");
    Ptr<cv::xfeatures2d::BoostDesc> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseScaleOrientation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_setScaleFactor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::BoostDesc> * self1 = 0;
    if (!pyopencv_xfeatures2d_BoostDesc_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_BoostDesc' or its derivative)");
    Ptr<cv::xfeatures2d::BoostDesc> _self_ = *(self1);
    float scale_factor=0.f;

    const char* keywords[] = { "scale_factor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_BoostDesc.setScaleFactor", (char**)keywords, &scale_factor) )
    {
        ERRWRAP2(_self_->setScaleFactor(scale_factor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_setUseScaleOrientation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::BoostDesc> * self1 = 0;
    if (!pyopencv_xfeatures2d_BoostDesc_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_BoostDesc' or its derivative)");
    Ptr<cv::xfeatures2d::BoostDesc> _self_ = *(self1);
    bool use_scale_orientation=0;

    const char* keywords[] = { "use_scale_orientation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:xfeatures2d_BoostDesc.setUseScaleOrientation", (char**)keywords, &use_scale_orientation) )
    {
        ERRWRAP2(_self_->setUseScaleOrientation(use_scale_orientation));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (xfeatures2d_BoostDesc)

static PyGetSetDef pyopencv_xfeatures2d_BoostDesc_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_BoostDesc_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_create_static, METH_STATIC), "create([, desc[, use_scale_orientation[, scale_factor]]]) -> retval\n."},
    {"getScaleFactor", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_getScaleFactor, 0), "getScaleFactor() -> retval\n."},
    {"getUseScaleOrientation", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_getUseScaleOrientation, 0), "getUseScaleOrientation() -> retval\n."},
    {"setScaleFactor", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_setScaleFactor, 0), "setScaleFactor(scale_factor) -> None\n."},
    {"setUseScaleOrientation", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_BoostDesc_setUseScaleOrientation, 0), "setUseScaleOrientation(use_scale_orientation) -> None\n."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_BoostDesc)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::BoostDesc> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::BoostDesc>& r)
    {
        return pyopencv_xfeatures2d_BoostDesc_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::BoostDesc>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::BoostDesc> * dst_;
        if (pyopencv_xfeatures2d_BoostDesc_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::BoostDesc> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_BriefDescriptorExtractor (Generic)
//================================================================================

// GetSet (xfeatures2d_BriefDescriptorExtractor)



// Methods (xfeatures2d_BriefDescriptorExtractor)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_BriefDescriptorExtractor_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int bytes=32;
    bool use_orientation=false;
    Ptr<BriefDescriptorExtractor> retval;

    const char* keywords[] = { "bytes", "use_orientation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ib:xfeatures2d_BriefDescriptorExtractor.create", (char**)keywords, &bytes, &use_orientation) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::BriefDescriptorExtractor::create(bytes, use_orientation));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (xfeatures2d_BriefDescriptorExtractor)

static PyGetSetDef pyopencv_xfeatures2d_BriefDescriptorExtractor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_BriefDescriptorExtractor_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_BriefDescriptorExtractor_create_static, METH_STATIC), "create([, bytes[, use_orientation]]) -> retval\n."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_BriefDescriptorExtractor)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::BriefDescriptorExtractor> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::BriefDescriptorExtractor>& r)
    {
        return pyopencv_xfeatures2d_BriefDescriptorExtractor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::BriefDescriptorExtractor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::BriefDescriptorExtractor> * dst_;
        if (pyopencv_xfeatures2d_BriefDescriptorExtractor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::BriefDescriptorExtractor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_DAISY (Generic)
//================================================================================

// GetSet (xfeatures2d_DAISY)



// Methods (xfeatures2d_DAISY)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_DAISY_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    {
    float radius=15;
    int q_radius=3;
    int q_theta=8;
    int q_hist=8;
    PyObject* pyobj_norm = NULL;
    DAISY_NormalizationType norm=DAISY::NRM_NONE;
    PyObject* pyobj_H = NULL;
    Mat H;
    bool interpolation=true;
    bool use_orientation=false;
    Ptr<DAISY> retval;

    const char* keywords[] = { "radius", "q_radius", "q_theta", "q_hist", "norm", "H", "interpolation", "use_orientation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|fiiiOObb:xfeatures2d_DAISY.create", (char**)keywords, &radius, &q_radius, &q_theta, &q_hist, &pyobj_norm, &pyobj_H, &interpolation, &use_orientation) &&
        pyopencv_to(pyobj_norm, norm, ArgInfo("norm", 0)) &&
        pyopencv_to(pyobj_H, H, ArgInfo("H", 0)) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::DAISY::create(radius, q_radius, q_theta, q_hist, norm, H, interpolation, use_orientation));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    float radius=15;
    int q_radius=3;
    int q_theta=8;
    int q_hist=8;
    PyObject* pyobj_norm = NULL;
    DAISY_NormalizationType norm=DAISY::NRM_NONE;
    PyObject* pyobj_H = NULL;
    UMat H;
    bool interpolation=true;
    bool use_orientation=false;
    Ptr<DAISY> retval;

    const char* keywords[] = { "radius", "q_radius", "q_theta", "q_hist", "norm", "H", "interpolation", "use_orientation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|fiiiOObb:xfeatures2d_DAISY.create", (char**)keywords, &radius, &q_radius, &q_theta, &q_hist, &pyobj_norm, &pyobj_H, &interpolation, &use_orientation) &&
        pyopencv_to(pyobj_norm, norm, ArgInfo("norm", 0)) &&
        pyopencv_to(pyobj_H, H, ArgInfo("H", 0)) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::DAISY::create(radius, q_radius, q_theta, q_hist, norm, H, interpolation, use_orientation));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}



// Tables (xfeatures2d_DAISY)

static PyGetSetDef pyopencv_xfeatures2d_DAISY_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_DAISY_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_DAISY_create_static, METH_STATIC), "create([, radius[, q_radius[, q_theta[, q_hist[, norm[, H[, interpolation[, use_orientation]]]]]]]]) -> retval\n."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_DAISY)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::DAISY> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::DAISY>& r)
    {
        return pyopencv_xfeatures2d_DAISY_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::DAISY>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::DAISY> * dst_;
        if (pyopencv_xfeatures2d_DAISY_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::DAISY> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_FREAK (Generic)
//================================================================================

// GetSet (xfeatures2d_FREAK)



// Methods (xfeatures2d_FREAK)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_FREAK_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    bool orientationNormalized=true;
    bool scaleNormalized=true;
    float patternScale=22.0f;
    int nOctaves=4;
    PyObject* pyobj_selectedPairs = NULL;
    vector_int selectedPairs=std::vector<int>();
    Ptr<FREAK> retval;

    const char* keywords[] = { "orientationNormalized", "scaleNormalized", "patternScale", "nOctaves", "selectedPairs", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|bbfiO:xfeatures2d_FREAK.create", (char**)keywords, &orientationNormalized, &scaleNormalized, &patternScale, &nOctaves, &pyobj_selectedPairs) &&
        pyopencv_to(pyobj_selectedPairs, selectedPairs, ArgInfo("selectedPairs", 0)) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::FREAK::create(orientationNormalized, scaleNormalized, patternScale, nOctaves, selectedPairs));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (xfeatures2d_FREAK)

static PyGetSetDef pyopencv_xfeatures2d_FREAK_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_FREAK_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_FREAK_create_static, METH_STATIC), "create([, orientationNormalized[, scaleNormalized[, patternScale[, nOctaves[, selectedPairs]]]]]) -> retval\n.   @param orientationNormalized Enable orientation normalization.\n.       @param scaleNormalized Enable scale normalization.\n.       @param patternScale Scaling of the description pattern.\n.       @param nOctaves Number of octaves covered by the detected keypoints.\n.       @param selectedPairs (Optional) user defined selected pairs indexes,"},

    {NULL,          NULL}
};

// Converter (xfeatures2d_FREAK)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::FREAK> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::FREAK>& r)
    {
        return pyopencv_xfeatures2d_FREAK_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::FREAK>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::FREAK> * dst_;
        if (pyopencv_xfeatures2d_FREAK_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::FREAK> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_HarrisLaplaceFeatureDetector (Generic)
//================================================================================

// GetSet (xfeatures2d_HarrisLaplaceFeatureDetector)



// Methods (xfeatures2d_HarrisLaplaceFeatureDetector)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_HarrisLaplaceFeatureDetector_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int numOctaves=6;
    float corn_thresh=0.01f;
    float DOG_thresh=0.01f;
    int maxCorners=5000;
    int num_layers=4;
    Ptr<HarrisLaplaceFeatureDetector> retval;

    const char* keywords[] = { "numOctaves", "corn_thresh", "DOG_thresh", "maxCorners", "num_layers", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iffii:xfeatures2d_HarrisLaplaceFeatureDetector.create", (char**)keywords, &numOctaves, &corn_thresh, &DOG_thresh, &maxCorners, &num_layers) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::HarrisLaplaceFeatureDetector::create(numOctaves, corn_thresh, DOG_thresh, maxCorners, num_layers));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (xfeatures2d_HarrisLaplaceFeatureDetector)

static PyGetSetDef pyopencv_xfeatures2d_HarrisLaplaceFeatureDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_HarrisLaplaceFeatureDetector_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_HarrisLaplaceFeatureDetector_create_static, METH_STATIC), "create([, numOctaves[, corn_thresh[, DOG_thresh[, maxCorners[, num_layers]]]]]) -> retval\n.   * @brief Creates a new implementation instance.\n.        *\n.        * @param numOctaves the number of octaves in the scale-space pyramid\n.        * @param corn_thresh the threshold for the Harris cornerness measure\n.        * @param DOG_thresh the threshold for the Difference-of-Gaussians scale selection\n.        * @param maxCorners the maximum number of corners to consider\n.        * @param num_layers the number of intermediate scales per octave"},

    {NULL,          NULL}
};

// Converter (xfeatures2d_HarrisLaplaceFeatureDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::HarrisLaplaceFeatureDetector> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::HarrisLaplaceFeatureDetector>& r)
    {
        return pyopencv_xfeatures2d_HarrisLaplaceFeatureDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::HarrisLaplaceFeatureDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::HarrisLaplaceFeatureDetector> * dst_;
        if (pyopencv_xfeatures2d_HarrisLaplaceFeatureDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::HarrisLaplaceFeatureDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_LATCH (Generic)
//================================================================================

// GetSet (xfeatures2d_LATCH)



// Methods (xfeatures2d_LATCH)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_LATCH_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int bytes=32;
    bool rotationInvariance=true;
    int half_ssd_size=3;
    double sigma=2.0;
    Ptr<LATCH> retval;

    const char* keywords[] = { "bytes", "rotationInvariance", "half_ssd_size", "sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ibid:xfeatures2d_LATCH.create", (char**)keywords, &bytes, &rotationInvariance, &half_ssd_size, &sigma) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::LATCH::create(bytes, rotationInvariance, half_ssd_size, sigma));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (xfeatures2d_LATCH)

static PyGetSetDef pyopencv_xfeatures2d_LATCH_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_LATCH_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_LATCH_create_static, METH_STATIC), "create([, bytes[, rotationInvariance[, half_ssd_size[, sigma]]]]) -> retval\n."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_LATCH)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::LATCH> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::LATCH>& r)
    {
        return pyopencv_xfeatures2d_LATCH_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::LATCH>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::LATCH> * dst_;
        if (pyopencv_xfeatures2d_LATCH_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::LATCH> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_LUCID (Generic)
//================================================================================

// GetSet (xfeatures2d_LUCID)



// Methods (xfeatures2d_LUCID)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_LUCID_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int lucid_kernel=1;
    int blur_kernel=2;
    Ptr<LUCID> retval;

    const char* keywords[] = { "lucid_kernel", "blur_kernel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ii:xfeatures2d_LUCID.create", (char**)keywords, &lucid_kernel, &blur_kernel) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::LUCID::create(lucid_kernel, blur_kernel));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (xfeatures2d_LUCID)

static PyGetSetDef pyopencv_xfeatures2d_LUCID_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_LUCID_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_LUCID_create_static, METH_STATIC), "create([, lucid_kernel[, blur_kernel]]) -> retval\n.   * @param lucid_kernel kernel for descriptor construction, where 1=3x3, 2=5x5, 3=7x7 and so forth\n.        * @param blur_kernel kernel for blurring image prior to descriptor construction, where 1=3x3, 2=5x5, 3=7x7 and so forth"},

    {NULL,          NULL}
};

// Converter (xfeatures2d_LUCID)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::LUCID> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::LUCID>& r)
    {
        return pyopencv_xfeatures2d_LUCID_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::LUCID>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::LUCID> * dst_;
        if (pyopencv_xfeatures2d_LUCID_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::LUCID> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_MSDDetector (Generic)
//================================================================================

// GetSet (xfeatures2d_MSDDetector)



// Methods (xfeatures2d_MSDDetector)



// Tables (xfeatures2d_MSDDetector)

static PyGetSetDef pyopencv_xfeatures2d_MSDDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_MSDDetector_methods[] =
{

    {NULL,          NULL}
};

// Converter (xfeatures2d_MSDDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::MSDDetector> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::MSDDetector>& r)
    {
        return pyopencv_xfeatures2d_MSDDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::MSDDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::MSDDetector> * dst_;
        if (pyopencv_xfeatures2d_MSDDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::MSDDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_PCTSignatures (Generic)
//================================================================================

// GetSet (xfeatures2d_PCTSignatures)



// Methods (xfeatures2d_PCTSignatures)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_computeSignature(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    PyObject* pyobj_signature = NULL;
    Mat signature;

    const char* keywords[] = { "image", "signature", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:xfeatures2d_PCTSignatures.computeSignature", (char**)keywords, &pyobj_image, &pyobj_signature) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_signature, signature, ArgInfo("signature", 1)) )
    {
        ERRWRAP2(_self_->computeSignature(image, signature));
        return pyopencv_from(signature);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    PyObject* pyobj_signature = NULL;
    UMat signature;

    const char* keywords[] = { "image", "signature", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:xfeatures2d_PCTSignatures.computeSignature", (char**)keywords, &pyobj_image, &pyobj_signature) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 0)) &&
        pyopencv_to(pyobj_signature, signature, ArgInfo("signature", 1)) )
    {
        ERRWRAP2(_self_->computeSignature(image, signature));
        return pyopencv_from(signature);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_computeSignatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_signatures = NULL;
    vector_Mat signatures;

    const char* keywords[] = { "images", "signatures", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:xfeatures2d_PCTSignatures.computeSignatures", (char**)keywords, &pyobj_images, &pyobj_signatures) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_signatures, signatures, ArgInfo("signatures", 0)) )
    {
        ERRWRAP2(_self_->computeSignatures(images, signatures));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_images = NULL;
    vector_Mat images;
    PyObject* pyobj_signatures = NULL;
    vector_Mat signatures;

    const char* keywords[] = { "images", "signatures", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:xfeatures2d_PCTSignatures.computeSignatures", (char**)keywords, &pyobj_images, &pyobj_signatures) &&
        pyopencv_to(pyobj_images, images, ArgInfo("images", 0)) &&
        pyopencv_to(pyobj_signatures, signatures, ArgInfo("signatures", 0)) )
    {
        ERRWRAP2(_self_->computeSignatures(images, signatures));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    {
    int initSampleCount=2000;
    int initSeedCount=400;
    int pointDistribution=0;
    Ptr<PCTSignatures> retval;

    const char* keywords[] = { "initSampleCount", "initSeedCount", "pointDistribution", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iii:xfeatures2d_PCTSignatures.create", (char**)keywords, &initSampleCount, &initSeedCount, &pointDistribution) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::PCTSignatures::create(initSampleCount, initSeedCount, pointDistribution));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_initSamplingPoints = NULL;
    vector_Point2f initSamplingPoints;
    int initSeedCount=0;
    Ptr<PCTSignatures> retval;

    const char* keywords[] = { "initSamplingPoints", "initSeedCount", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oi:xfeatures2d_PCTSignatures.create", (char**)keywords, &pyobj_initSamplingPoints, &initSeedCount) &&
        pyopencv_to(pyobj_initSamplingPoints, initSamplingPoints, ArgInfo("initSamplingPoints", 0)) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::PCTSignatures::create(initSamplingPoints, initSeedCount));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_initSamplingPoints = NULL;
    vector_Point2f initSamplingPoints;
    PyObject* pyobj_initClusterSeedIndexes = NULL;
    vector_int initClusterSeedIndexes;
    Ptr<PCTSignatures> retval;

    const char* keywords[] = { "initSamplingPoints", "initClusterSeedIndexes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:xfeatures2d_PCTSignatures.create", (char**)keywords, &pyobj_initSamplingPoints, &pyobj_initClusterSeedIndexes) &&
        pyopencv_to(pyobj_initSamplingPoints, initSamplingPoints, ArgInfo("initSamplingPoints", 0)) &&
        pyopencv_to(pyobj_initClusterSeedIndexes, initClusterSeedIndexes, ArgInfo("initClusterSeedIndexes", 0)) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::PCTSignatures::create(initSamplingPoints, initClusterSeedIndexes));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_drawSignature_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    {
    PyObject* pyobj_source = NULL;
    Mat source;
    PyObject* pyobj_signature = NULL;
    Mat signature;
    PyObject* pyobj_result = NULL;
    Mat result;
    float radiusToShorterSideRatio=1.0 / 8;
    int borderThickness=1;

    const char* keywords[] = { "source", "signature", "result", "radiusToShorterSideRatio", "borderThickness", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Ofi:xfeatures2d_PCTSignatures.drawSignature", (char**)keywords, &pyobj_source, &pyobj_signature, &pyobj_result, &radiusToShorterSideRatio, &borderThickness) &&
        pyopencv_to(pyobj_source, source, ArgInfo("source", 0)) &&
        pyopencv_to(pyobj_signature, signature, ArgInfo("signature", 0)) &&
        pyopencv_to(pyobj_result, result, ArgInfo("result", 1)) )
    {
        ERRWRAP2(cv::xfeatures2d::PCTSignatures::drawSignature(source, signature, result, radiusToShorterSideRatio, borderThickness));
        return pyopencv_from(result);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_source = NULL;
    UMat source;
    PyObject* pyobj_signature = NULL;
    UMat signature;
    PyObject* pyobj_result = NULL;
    UMat result;
    float radiusToShorterSideRatio=1.0 / 8;
    int borderThickness=1;

    const char* keywords[] = { "source", "signature", "result", "radiusToShorterSideRatio", "borderThickness", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Ofi:xfeatures2d_PCTSignatures.drawSignature", (char**)keywords, &pyobj_source, &pyobj_signature, &pyobj_result, &radiusToShorterSideRatio, &borderThickness) &&
        pyopencv_to(pyobj_source, source, ArgInfo("source", 0)) &&
        pyopencv_to(pyobj_signature, signature, ArgInfo("signature", 0)) &&
        pyopencv_to(pyobj_result, result, ArgInfo("result", 1)) )
    {
        ERRWRAP2(cv::xfeatures2d::PCTSignatures::drawSignature(source, signature, result, radiusToShorterSideRatio, borderThickness));
        return pyopencv_from(result);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_generateInitPoints_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    PyObject* pyobj_initPoints = NULL;
    vector_Point2f initPoints;
    int count=0;
    int pointDistribution=0;

    const char* keywords[] = { "initPoints", "count", "pointDistribution", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Oii:xfeatures2d_PCTSignatures.generateInitPoints", (char**)keywords, &pyobj_initPoints, &count, &pointDistribution) &&
        pyopencv_to(pyobj_initPoints, initPoints, ArgInfo("initPoints", 0)) )
    {
        ERRWRAP2(cv::xfeatures2d::PCTSignatures::generateInitPoints(initPoints, count, pointDistribution));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getClusterMinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getClusterMinSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getDistanceFunction(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDistanceFunction());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getDropThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDropThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getGrayscaleBits(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGrayscaleBits());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getInitSeedCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInitSeedCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getInitSeedIndexes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    std::vector<int> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInitSeedIndexes());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getIterationCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getIterationCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getJoiningDistance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getJoiningDistance());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getMaxClustersCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxClustersCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getSampleCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSampleCount());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getSamplingPoints(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    std::vector<Point2f> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSamplingPoints());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightA(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeightA());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightB(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeightB());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightContrast(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeightContrast());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightEntropy(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeightEntropy());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightL(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeightL());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightX(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeightX());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightY(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWeightY());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWindowRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getWindowRadius());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setClusterMinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int clusterMinSize=0;

    const char* keywords[] = { "clusterMinSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xfeatures2d_PCTSignatures.setClusterMinSize", (char**)keywords, &clusterMinSize) )
    {
        ERRWRAP2(_self_->setClusterMinSize(clusterMinSize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setDistanceFunction(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int distanceFunction=0;

    const char* keywords[] = { "distanceFunction", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xfeatures2d_PCTSignatures.setDistanceFunction", (char**)keywords, &distanceFunction) )
    {
        ERRWRAP2(_self_->setDistanceFunction(distanceFunction));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setDropThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float dropThreshold=0.f;

    const char* keywords[] = { "dropThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setDropThreshold", (char**)keywords, &dropThreshold) )
    {
        ERRWRAP2(_self_->setDropThreshold(dropThreshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setGrayscaleBits(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int grayscaleBits=0;

    const char* keywords[] = { "grayscaleBits", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xfeatures2d_PCTSignatures.setGrayscaleBits", (char**)keywords, &grayscaleBits) )
    {
        ERRWRAP2(_self_->setGrayscaleBits(grayscaleBits));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setInitSeedIndexes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    PyObject* pyobj_initSeedIndexes = NULL;
    vector_int initSeedIndexes;

    const char* keywords[] = { "initSeedIndexes", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:xfeatures2d_PCTSignatures.setInitSeedIndexes", (char**)keywords, &pyobj_initSeedIndexes) &&
        pyopencv_to(pyobj_initSeedIndexes, initSeedIndexes, ArgInfo("initSeedIndexes", 0)) )
    {
        ERRWRAP2(_self_->setInitSeedIndexes(initSeedIndexes));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setIterationCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int iterationCount=0;

    const char* keywords[] = { "iterationCount", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xfeatures2d_PCTSignatures.setIterationCount", (char**)keywords, &iterationCount) )
    {
        ERRWRAP2(_self_->setIterationCount(iterationCount));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setJoiningDistance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float joiningDistance=0.f;

    const char* keywords[] = { "joiningDistance", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setJoiningDistance", (char**)keywords, &joiningDistance) )
    {
        ERRWRAP2(_self_->setJoiningDistance(joiningDistance));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setMaxClustersCount(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int maxClustersCount=0;

    const char* keywords[] = { "maxClustersCount", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xfeatures2d_PCTSignatures.setMaxClustersCount", (char**)keywords, &maxClustersCount) )
    {
        ERRWRAP2(_self_->setMaxClustersCount(maxClustersCount));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setSamplingPoints(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    PyObject* pyobj_samplingPoints = NULL;
    vector_Point2f samplingPoints;

    const char* keywords[] = { "samplingPoints", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:xfeatures2d_PCTSignatures.setSamplingPoints", (char**)keywords, &pyobj_samplingPoints) &&
        pyopencv_to(pyobj_samplingPoints, samplingPoints, ArgInfo("samplingPoints", 0)) )
    {
        ERRWRAP2(_self_->setSamplingPoints(samplingPoints));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setTranslation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int idx=0;
    float value=0.f;

    const char* keywords[] = { "idx", "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "if:xfeatures2d_PCTSignatures.setTranslation", (char**)keywords, &idx, &value) )
    {
        ERRWRAP2(_self_->setTranslation(idx, value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setTranslations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    PyObject* pyobj_translations = NULL;
    vector_float translations;

    const char* keywords[] = { "translations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:xfeatures2d_PCTSignatures.setTranslations", (char**)keywords, &pyobj_translations) &&
        pyopencv_to(pyobj_translations, translations, ArgInfo("translations", 0)) )
    {
        ERRWRAP2(_self_->setTranslations(translations));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeight(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int idx=0;
    float value=0.f;

    const char* keywords[] = { "idx", "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "if:xfeatures2d_PCTSignatures.setWeight", (char**)keywords, &idx, &value) )
    {
        ERRWRAP2(_self_->setWeight(idx, value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightA(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float weight=0.f;

    const char* keywords[] = { "weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setWeightA", (char**)keywords, &weight) )
    {
        ERRWRAP2(_self_->setWeightA(weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightB(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float weight=0.f;

    const char* keywords[] = { "weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setWeightB", (char**)keywords, &weight) )
    {
        ERRWRAP2(_self_->setWeightB(weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightContrast(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float weight=0.f;

    const char* keywords[] = { "weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setWeightContrast", (char**)keywords, &weight) )
    {
        ERRWRAP2(_self_->setWeightContrast(weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightEntropy(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float weight=0.f;

    const char* keywords[] = { "weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setWeightEntropy", (char**)keywords, &weight) )
    {
        ERRWRAP2(_self_->setWeightEntropy(weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightL(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float weight=0.f;

    const char* keywords[] = { "weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setWeightL", (char**)keywords, &weight) )
    {
        ERRWRAP2(_self_->setWeightL(weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightX(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float weight=0.f;

    const char* keywords[] = { "weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setWeightX", (char**)keywords, &weight) )
    {
        ERRWRAP2(_self_->setWeightX(weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightY(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    float weight=0.f;

    const char* keywords[] = { "weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_PCTSignatures.setWeightY", (char**)keywords, &weight) )
    {
        ERRWRAP2(_self_->setWeightY(weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeights(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    PyObject* pyobj_weights = NULL;
    vector_float weights;

    const char* keywords[] = { "weights", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:xfeatures2d_PCTSignatures.setWeights", (char**)keywords, &pyobj_weights) &&
        pyopencv_to(pyobj_weights, weights, ArgInfo("weights", 0)) )
    {
        ERRWRAP2(_self_->setWeights(weights));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWindowRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignatures> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignatures_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignatures' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignatures> _self_ = *(self1);
    int radius=0;

    const char* keywords[] = { "radius", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xfeatures2d_PCTSignatures.setWindowRadius", (char**)keywords, &radius) )
    {
        ERRWRAP2(_self_->setWindowRadius(radius));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (xfeatures2d_PCTSignatures)

static PyGetSetDef pyopencv_xfeatures2d_PCTSignatures_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_PCTSignatures_methods[] =
{
    {"computeSignature", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_computeSignature, 0), "computeSignature(image[, signature]) -> signature\n.   * @brief Computes signature of given image.\n.       * @param image Input image of CV_8U type.\n.       * @param signature Output computed signature."},
    {"computeSignatures", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_computeSignatures, 0), "computeSignatures(images, signatures) -> None\n.   * @brief Computes signatures for multiple images in parallel.\n.       * @param images Vector of input images of CV_8U type.\n.       * @param signatures Vector of computed signatures."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_create_static, METH_STATIC), "create([, initSampleCount[, initSeedCount[, pointDistribution]]]) -> retval\n.   * @brief Creates PCTSignatures algorithm using sample and seed count.\n.       *       It generates its own sets of sampling points and clusterization seed indexes.\n.       * @param initSampleCount Number of points used for image sampling.\n.       * @param initSeedCount Number of initial clusterization seeds.\n.       *       Must be lower or equal to initSampleCount\n.       * @param pointDistribution Distribution of generated points. Default: UNIFORM.\n.       *       Available: UNIFORM, REGULAR, NORMAL.\n.       * @return Created algorithm.\n\n\n\ncreate(initSamplingPoints, initSeedCount) -> retval\n.   * @brief Creates PCTSignatures algorithm using pre-generated sampling points\n.       *       and number of clusterization seeds. It uses the provided\n.       *       sampling points and generates its own clusterization seed indexes.\n.       * @param initSamplingPoints Sampling points used in image sampling.\n.       * @param initSeedCount Number of initial clusterization seeds.\n.       *       Must be lower or equal to initSamplingPoints.size().\n.       * @return Created algorithm.\n\n\n\ncreate(initSamplingPoints, initClusterSeedIndexes) -> retval\n.   * @brief Creates PCTSignatures algorithm using pre-generated sampling points\n.       *       and clusterization seeds indexes.\n.       * @param initSamplingPoints Sampling points used in image sampling.\n.       * @param initClusterSeedIndexes Indexes of initial clusterization seeds.\n.       *       Its size must be lower or equal to initSamplingPoints.size().\n.       * @return Created algorithm."},
    {"drawSignature", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_drawSignature_static, METH_STATIC), "drawSignature(source, signature[, result[, radiusToShorterSideRatio[, borderThickness]]]) -> result\n.   * @brief Draws signature in the source image and outputs the result.\n.       *       Signatures are visualized as a circle\n.       *       with radius based on signature weight\n.       *       and color based on signature color.\n.       *       Contrast and entropy are not visualized.\n.       * @param source Source image.\n.       * @param signature Image signature.\n.       * @param result Output result.\n.       * @param radiusToShorterSideRatio Determines maximal radius of signature in the output image.\n.       * @param borderThickness Border thickness of the visualized signature."},
    {"generateInitPoints", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_generateInitPoints_static, METH_STATIC), "generateInitPoints(initPoints, count, pointDistribution) -> None\n.   * @brief Generates initial sampling points according to selected point distribution.\n.       * @param initPoints Output vector where the generated points will be saved.\n.       * @param count Number of points to generate.\n.       * @param pointDistribution Point distribution selector.\n.       *       Available: UNIFORM, REGULAR, NORMAL.\n.       * @note Generated coordinates are in range [0..1)"},
    {"getClusterMinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getClusterMinSize, 0), "getClusterMinSize() -> retval\n.   * @brief This parameter multiplied by the index of iteration gives lower limit for cluster size.\n.       *       Clusters containing fewer points than specified by the limit have their centroid dismissed\n.       *       and points are reassigned."},
    {"getDistanceFunction", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getDistanceFunction, 0), "getDistanceFunction() -> retval\n.   * @brief Distance function selector used for measuring distance between two points in k-means."},
    {"getDropThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getDropThreshold, 0), "getDropThreshold() -> retval\n.   * @brief Remove centroids in k-means whose weight is lesser or equal to given threshold."},
    {"getGrayscaleBits", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getGrayscaleBits, 0), "getGrayscaleBits() -> retval\n.   * @brief Color resolution of the greyscale bitmap represented in allocated bits\n.       *       (i.e., value 4 means that 16 shades of grey are used).\n.       *       The greyscale bitmap is used for computing contrast and entropy values."},
    {"getInitSeedCount", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getInitSeedCount, 0), "getInitSeedCount() -> retval\n.   * @brief Number of initial seeds (initial number of clusters) for the k-means algorithm."},
    {"getInitSeedIndexes", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getInitSeedIndexes, 0), "getInitSeedIndexes() -> retval\n.   * @brief Initial seeds (initial number of clusters) for the k-means algorithm."},
    {"getIterationCount", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getIterationCount, 0), "getIterationCount() -> retval\n.   * @brief Number of iterations of the k-means clustering.\n.       *       We use fixed number of iterations, since the modified clustering is pruning clusters\n.       *       (not iteratively refining k clusters)."},
    {"getJoiningDistance", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getJoiningDistance, 0), "getJoiningDistance() -> retval\n.   * @brief Threshold euclidean distance between two centroids.\n.       *       If two cluster centers are closer than this distance,\n.       *       one of the centroid is dismissed and points are reassigned."},
    {"getMaxClustersCount", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getMaxClustersCount, 0), "getMaxClustersCount() -> retval\n.   * @brief Maximal number of generated clusters. If the number is exceeded,\n.       *       the clusters are sorted by their weights and the smallest clusters are cropped."},
    {"getSampleCount", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getSampleCount, 0), "getSampleCount() -> retval\n.   * @brief Number of initial samples taken from the image."},
    {"getSamplingPoints", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getSamplingPoints, 0), "getSamplingPoints() -> retval\n.   * @brief Initial samples taken from the image.\n.       *       These sampled features become the input for clustering."},
    {"getWeightA", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightA, 0), "getWeightA() -> retval\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"getWeightB", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightB, 0), "getWeightB() -> retval\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"getWeightContrast", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightContrast, 0), "getWeightContrast() -> retval\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"getWeightEntropy", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightEntropy, 0), "getWeightEntropy() -> retval\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"getWeightL", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightL, 0), "getWeightL() -> retval\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"getWeightX", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightX, 0), "getWeightX() -> retval\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"getWeightY", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWeightY, 0), "getWeightY() -> retval\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"getWindowRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_getWindowRadius, 0), "getWindowRadius() -> retval\n.   * @brief Size of the texture sampling window used to compute contrast and entropy\n.       *       (center of the window is always in the pixel selected by x,y coordinates\n.       *       of the corresponding feature sample)."},
    {"setClusterMinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setClusterMinSize, 0), "setClusterMinSize(clusterMinSize) -> None\n.   * @brief This parameter multiplied by the index of iteration gives lower limit for cluster size.\n.       *       Clusters containing fewer points than specified by the limit have their centroid dismissed\n.       *       and points are reassigned."},
    {"setDistanceFunction", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setDistanceFunction, 0), "setDistanceFunction(distanceFunction) -> None\n.   * @brief Distance function selector used for measuring distance between two points in k-means.\n.       *       Available: L0_25, L0_5, L1, L2, L2SQUARED, L5, L_INFINITY."},
    {"setDropThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setDropThreshold, 0), "setDropThreshold(dropThreshold) -> None\n.   * @brief Remove centroids in k-means whose weight is lesser or equal to given threshold."},
    {"setGrayscaleBits", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setGrayscaleBits, 0), "setGrayscaleBits(grayscaleBits) -> None\n.   * @brief Color resolution of the greyscale bitmap represented in allocated bits\n.       *       (i.e., value 4 means that 16 shades of grey are used).\n.       *       The greyscale bitmap is used for computing contrast and entropy values."},
    {"setInitSeedIndexes", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setInitSeedIndexes, 0), "setInitSeedIndexes(initSeedIndexes) -> None\n.   * @brief Initial seed indexes for the k-means algorithm."},
    {"setIterationCount", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setIterationCount, 0), "setIterationCount(iterationCount) -> None\n.   * @brief Number of iterations of the k-means clustering.\n.       *       We use fixed number of iterations, since the modified clustering is pruning clusters\n.       *       (not iteratively refining k clusters)."},
    {"setJoiningDistance", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setJoiningDistance, 0), "setJoiningDistance(joiningDistance) -> None\n.   * @brief Threshold euclidean distance between two centroids.\n.       *       If two cluster centers are closer than this distance,\n.       *       one of the centroid is dismissed and points are reassigned."},
    {"setMaxClustersCount", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setMaxClustersCount, 0), "setMaxClustersCount(maxClustersCount) -> None\n.   * @brief Maximal number of generated clusters. If the number is exceeded,\n.       *       the clusters are sorted by their weights and the smallest clusters are cropped."},
    {"setSamplingPoints", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setSamplingPoints, 0), "setSamplingPoints(samplingPoints) -> None\n.   * @brief Sets sampling points used to sample the input image.\n.       * @param samplingPoints Vector of sampling points in range [0..1)\n.       * @note Number of sampling points must be greater or equal to clusterization seed count."},
    {"setTranslation", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setTranslation, 0), "setTranslation(idx, value) -> None\n.   * @brief Translations of the individual axes of the feature space.\n.       * @param idx ID of the translation\n.       * @param value Value of the translation\n.       * @note\n.       *       WEIGHT_IDX = 0;\n.       *       X_IDX = 1;\n.       *       Y_IDX = 2;\n.       *       L_IDX = 3;\n.       *       A_IDX = 4;\n.       *       B_IDX = 5;\n.       *       CONTRAST_IDX = 6;\n.       *       ENTROPY_IDX = 7;"},
    {"setTranslations", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setTranslations, 0), "setTranslations(translations) -> None\n.   * @brief Translations of the individual axes of the feature space.\n.       * @param translations Values of all translations.\n.       * @note\n.       *       WEIGHT_IDX = 0;\n.       *       X_IDX = 1;\n.       *       Y_IDX = 2;\n.       *       L_IDX = 3;\n.       *       A_IDX = 4;\n.       *       B_IDX = 5;\n.       *       CONTRAST_IDX = 6;\n.       *       ENTROPY_IDX = 7;"},
    {"setWeight", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeight, 0), "setWeight(idx, value) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space.\n.       * @param idx ID of the weight\n.       * @param value Value of the weight\n.       * @note\n.       *       WEIGHT_IDX = 0;\n.       *       X_IDX = 1;\n.       *       Y_IDX = 2;\n.       *       L_IDX = 3;\n.       *       A_IDX = 4;\n.       *       B_IDX = 5;\n.       *       CONTRAST_IDX = 6;\n.       *       ENTROPY_IDX = 7;"},
    {"setWeightA", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightA, 0), "setWeightA(weight) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"setWeightB", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightB, 0), "setWeightB(weight) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"setWeightContrast", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightContrast, 0), "setWeightContrast(weight) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"setWeightEntropy", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightEntropy, 0), "setWeightEntropy(weight) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"setWeightL", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightL, 0), "setWeightL(weight) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"setWeightX", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightX, 0), "setWeightX(weight) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"setWeightY", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeightY, 0), "setWeightY(weight) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space\n.       *       (x,y = position; L,a,b = color in CIE Lab space; c = contrast. e = entropy)"},
    {"setWeights", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWeights, 0), "setWeights(weights) -> None\n.   * @brief Weights (multiplicative constants) that linearly stretch individual axes of the feature space.\n.       * @param weights Values of all weights.\n.       * @note\n.       *       WEIGHT_IDX = 0;\n.       *       X_IDX = 1;\n.       *       Y_IDX = 2;\n.       *       L_IDX = 3;\n.       *       A_IDX = 4;\n.       *       B_IDX = 5;\n.       *       CONTRAST_IDX = 6;\n.       *       ENTROPY_IDX = 7;"},
    {"setWindowRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignatures_setWindowRadius, 0), "setWindowRadius(radius) -> None\n.   * @brief Size of the texture sampling window used to compute contrast and entropy\n.       *       (center of the window is always in the pixel selected by x,y coordinates\n.       *       of the corresponding feature sample)."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_PCTSignatures)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::PCTSignatures> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::PCTSignatures>& r)
    {
        return pyopencv_xfeatures2d_PCTSignatures_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::PCTSignatures>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::PCTSignatures> * dst_;
        if (pyopencv_xfeatures2d_PCTSignatures_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::PCTSignatures> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_PCTSignaturesSQFD (Generic)
//================================================================================

// GetSet (xfeatures2d_PCTSignaturesSQFD)



// Methods (xfeatures2d_PCTSignaturesSQFD)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistance(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignaturesSQFD> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignaturesSQFD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignaturesSQFD' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignaturesSQFD> _self_ = *(self1);
    {
    PyObject* pyobj__signature0 = NULL;
    Mat _signature0;
    PyObject* pyobj__signature1 = NULL;
    Mat _signature1;
    float retval;

    const char* keywords[] = { "_signature0", "_signature1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:xfeatures2d_PCTSignaturesSQFD.computeQuadraticFormDistance", (char**)keywords, &pyobj__signature0, &pyobj__signature1) &&
        pyopencv_to(pyobj__signature0, _signature0, ArgInfo("_signature0", 0)) &&
        pyopencv_to(pyobj__signature1, _signature1, ArgInfo("_signature1", 0)) )
    {
        ERRWRAP2(retval = _self_->computeQuadraticFormDistance(_signature0, _signature1));
        return pyopencv_from(retval);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__signature0 = NULL;
    UMat _signature0;
    PyObject* pyobj__signature1 = NULL;
    UMat _signature1;
    float retval;

    const char* keywords[] = { "_signature0", "_signature1", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO:xfeatures2d_PCTSignaturesSQFD.computeQuadraticFormDistance", (char**)keywords, &pyobj__signature0, &pyobj__signature1) &&
        pyopencv_to(pyobj__signature0, _signature0, ArgInfo("_signature0", 0)) &&
        pyopencv_to(pyobj__signature1, _signature1, ArgInfo("_signature1", 0)) )
    {
        ERRWRAP2(retval = _self_->computeQuadraticFormDistance(_signature0, _signature1));
        return pyopencv_from(retval);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistances(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::PCTSignaturesSQFD> * self1 = 0;
    if (!pyopencv_xfeatures2d_PCTSignaturesSQFD_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_PCTSignaturesSQFD' or its derivative)");
    Ptr<cv::xfeatures2d::PCTSignaturesSQFD> _self_ = *(self1);
    {
    PyObject* pyobj_sourceSignature = NULL;
    Mat sourceSignature;
    PyObject* pyobj_imageSignatures = NULL;
    vector_Mat imageSignatures;
    PyObject* pyobj_distances = NULL;
    vector_float distances;

    const char* keywords[] = { "sourceSignature", "imageSignatures", "distances", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:xfeatures2d_PCTSignaturesSQFD.computeQuadraticFormDistances", (char**)keywords, &pyobj_sourceSignature, &pyobj_imageSignatures, &pyobj_distances) &&
        pyopencv_to(pyobj_sourceSignature, sourceSignature, ArgInfo("sourceSignature", 0)) &&
        pyopencv_to(pyobj_imageSignatures, imageSignatures, ArgInfo("imageSignatures", 0)) &&
        pyopencv_to(pyobj_distances, distances, ArgInfo("distances", 0)) )
    {
        ERRWRAP2(_self_->computeQuadraticFormDistances(sourceSignature, imageSignatures, distances));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_sourceSignature = NULL;
    Mat sourceSignature;
    PyObject* pyobj_imageSignatures = NULL;
    vector_Mat imageSignatures;
    PyObject* pyobj_distances = NULL;
    vector_float distances;

    const char* keywords[] = { "sourceSignature", "imageSignatures", "distances", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO:xfeatures2d_PCTSignaturesSQFD.computeQuadraticFormDistances", (char**)keywords, &pyobj_sourceSignature, &pyobj_imageSignatures, &pyobj_distances) &&
        pyopencv_to(pyobj_sourceSignature, sourceSignature, ArgInfo("sourceSignature", 0)) &&
        pyopencv_to(pyobj_imageSignatures, imageSignatures, ArgInfo("imageSignatures", 0)) &&
        pyopencv_to(pyobj_distances, distances, ArgInfo("distances", 0)) )
    {
        ERRWRAP2(_self_->computeQuadraticFormDistances(sourceSignature, imageSignatures, distances));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignaturesSQFD_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int distanceFunction=3;
    int similarityFunction=2;
    float similarityParameter=1.0f;
    Ptr<PCTSignaturesSQFD> retval;

    const char* keywords[] = { "distanceFunction", "similarityFunction", "similarityParameter", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iif:xfeatures2d_PCTSignaturesSQFD.create", (char**)keywords, &distanceFunction, &similarityFunction, &similarityParameter) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::PCTSignaturesSQFD::create(distanceFunction, similarityFunction, similarityParameter));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (xfeatures2d_PCTSignaturesSQFD)

static PyGetSetDef pyopencv_xfeatures2d_PCTSignaturesSQFD_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_PCTSignaturesSQFD_methods[] =
{
    {"computeQuadraticFormDistance", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistance, 0), "computeQuadraticFormDistance(_signature0, _signature1) -> retval\n.   * @brief Computes Signature Quadratic Form Distance of two signatures.\n.       * @param _signature0 The first signature.\n.       * @param _signature1 The second signature."},
    {"computeQuadraticFormDistances", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistances, 0), "computeQuadraticFormDistances(sourceSignature, imageSignatures, distances) -> None\n.   * @brief Computes Signature Quadratic Form Distance between the reference signature\n.       *       and each of the other image signatures.\n.       * @param sourceSignature The signature to measure distance of other signatures from.\n.       * @param imageSignatures Vector of signatures to measure distance from the source signature.\n.       * @param distances Output vector of measured distances."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_PCTSignaturesSQFD_create_static, METH_STATIC), "create([, distanceFunction[, similarityFunction[, similarityParameter]]]) -> retval\n.   * @brief Creates the algorithm instance using selected distance function,\n.       *       similarity function and similarity function parameter.\n.       * @param distanceFunction Distance function selector. Default: L2\n.       *       Available: L0_25, L0_5, L1, L2, L2SQUARED, L5, L_INFINITY\n.       * @param similarityFunction Similarity function selector. Default: HEURISTIC\n.       *       Available: MINUS, GAUSSIAN, HEURISTIC\n.       * @param similarityParameter Parameter of the similarity function."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_PCTSignaturesSQFD)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::PCTSignaturesSQFD> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::PCTSignaturesSQFD>& r)
    {
        return pyopencv_xfeatures2d_PCTSignaturesSQFD_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::PCTSignaturesSQFD>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::PCTSignaturesSQFD> * dst_;
        if (pyopencv_xfeatures2d_PCTSignaturesSQFD_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::PCTSignaturesSQFD> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_SIFT (Generic)
//================================================================================

// GetSet (xfeatures2d_SIFT)



// Methods (xfeatures2d_SIFT)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SIFT_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int nfeatures=0;
    int nOctaveLayers=3;
    double contrastThreshold=0.04;
    double edgeThreshold=10;
    double sigma=1.6;
    Ptr<SIFT> retval;

    const char* keywords[] = { "nfeatures", "nOctaveLayers", "contrastThreshold", "edgeThreshold", "sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iiddd:xfeatures2d_SIFT.create", (char**)keywords, &nfeatures, &nOctaveLayers, &contrastThreshold, &edgeThreshold, &sigma) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::SIFT::create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (xfeatures2d_SIFT)

static PyGetSetDef pyopencv_xfeatures2d_SIFT_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_SIFT_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SIFT_create_static, METH_STATIC), "create([, nfeatures[, nOctaveLayers[, contrastThreshold[, edgeThreshold[, sigma]]]]]) -> retval\n.   @param nfeatures The number of best features to retain. The features are ranked by their scores\n.       (measured in SIFT algorithm as the local contrast)\n.   \n.       @param nOctaveLayers The number of layers in each octave. 3 is the value used in D. Lowe paper. The\n.       number of octaves is computed automatically from the image resolution.\n.   \n.       @param contrastThreshold The contrast threshold used to filter out weak features in semi-uniform\n.       (low-contrast) regions. The larger the threshold, the less features are produced by the detector.\n.   \n.       @param edgeThreshold The threshold used to filter out edge-like features. Note that the its meaning\n.       is different from the contrastThreshold, i.e. the larger the edgeThreshold, the less features are\n.       filtered out (more features are retained).\n.   \n.       @param sigma The sigma of the Gaussian applied to the input image at the octave \\#0. If your image\n.       is captured with a weak camera with soft lenses, you might want to reduce the number."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_SIFT)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::SIFT> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::SIFT>& r)
    {
        return pyopencv_xfeatures2d_SIFT_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::SIFT>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::SIFT> * dst_;
        if (pyopencv_xfeatures2d_SIFT_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::SIFT> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_SURF (Generic)
//================================================================================

// GetSet (xfeatures2d_SURF)



// Methods (xfeatures2d_SURF)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    double hessianThreshold=100;
    int nOctaves=4;
    int nOctaveLayers=3;
    bool extended=false;
    bool upright=false;
    Ptr<SURF> retval;

    const char* keywords[] = { "hessianThreshold", "nOctaves", "nOctaveLayers", "extended", "upright", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|diibb:xfeatures2d_SURF.create", (char**)keywords, &hessianThreshold, &nOctaves, &nOctaveLayers, &extended, &upright) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::SURF::create(hessianThreshold, nOctaves, nOctaveLayers, extended, upright));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getExtended(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getExtended());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getHessianThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getHessianThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getNOctaveLayers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNOctaveLayers());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getNOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNOctaves());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getUpright(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUpright());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setExtended(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    bool extended=0;

    const char* keywords[] = { "extended", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:xfeatures2d_SURF.setExtended", (char**)keywords, &extended) )
    {
        ERRWRAP2(_self_->setExtended(extended));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setHessianThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    double hessianThreshold=0;

    const char* keywords[] = { "hessianThreshold", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:xfeatures2d_SURF.setHessianThreshold", (char**)keywords, &hessianThreshold) )
    {
        ERRWRAP2(_self_->setHessianThreshold(hessianThreshold));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setNOctaveLayers(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    int nOctaveLayers=0;

    const char* keywords[] = { "nOctaveLayers", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xfeatures2d_SURF.setNOctaveLayers", (char**)keywords, &nOctaveLayers) )
    {
        ERRWRAP2(_self_->setNOctaveLayers(nOctaveLayers));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setNOctaves(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    int nOctaves=0;

    const char* keywords[] = { "nOctaves", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xfeatures2d_SURF.setNOctaves", (char**)keywords, &nOctaves) )
    {
        ERRWRAP2(_self_->setNOctaves(nOctaves));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setUpright(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::SURF> * self1 = 0;
    if (!pyopencv_xfeatures2d_SURF_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_SURF' or its derivative)");
    Ptr<cv::xfeatures2d::SURF> _self_ = *(self1);
    bool upright=0;

    const char* keywords[] = { "upright", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:xfeatures2d_SURF.setUpright", (char**)keywords, &upright) )
    {
        ERRWRAP2(_self_->setUpright(upright));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (xfeatures2d_SURF)

static PyGetSetDef pyopencv_xfeatures2d_SURF_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_SURF_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_create_static, METH_STATIC), "create([, hessianThreshold[, nOctaves[, nOctaveLayers[, extended[, upright]]]]]) -> retval\n.   @param hessianThreshold Threshold for hessian keypoint detector used in SURF.\n.       @param nOctaves Number of pyramid octaves the keypoint detector will use.\n.       @param nOctaveLayers Number of octave layers within each octave.\n.       @param extended Extended descriptor flag (true - use extended 128-element descriptors; false - use\n.       64-element descriptors).\n.       @param upright Up-right or rotated features flag (true - do not compute orientation of features;\n.       false - compute orientation)."},
    {"getExtended", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getExtended, 0), "getExtended() -> retval\n."},
    {"getHessianThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getHessianThreshold, 0), "getHessianThreshold() -> retval\n."},
    {"getNOctaveLayers", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getNOctaveLayers, 0), "getNOctaveLayers() -> retval\n."},
    {"getNOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getNOctaves, 0), "getNOctaves() -> retval\n."},
    {"getUpright", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_getUpright, 0), "getUpright() -> retval\n."},
    {"setExtended", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setExtended, 0), "setExtended(extended) -> None\n."},
    {"setHessianThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setHessianThreshold, 0), "setHessianThreshold(hessianThreshold) -> None\n."},
    {"setNOctaveLayers", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setNOctaveLayers, 0), "setNOctaveLayers(nOctaveLayers) -> None\n."},
    {"setNOctaves", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setNOctaves, 0), "setNOctaves(nOctaves) -> None\n."},
    {"setUpright", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_SURF_setUpright, 0), "setUpright(upright) -> None\n."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_SURF)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::SURF> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::SURF>& r)
    {
        return pyopencv_xfeatures2d_SURF_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::SURF>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::SURF> * dst_;
        if (pyopencv_xfeatures2d_SURF_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::SURF> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_StarDetector (Generic)
//================================================================================

// GetSet (xfeatures2d_StarDetector)



// Methods (xfeatures2d_StarDetector)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_StarDetector_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int maxSize=45;
    int responseThreshold=30;
    int lineThresholdProjected=10;
    int lineThresholdBinarized=8;
    int suppressNonmaxSize=5;
    Ptr<StarDetector> retval;

    const char* keywords[] = { "maxSize", "responseThreshold", "lineThresholdProjected", "lineThresholdBinarized", "suppressNonmaxSize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iiiii:xfeatures2d_StarDetector.create", (char**)keywords, &maxSize, &responseThreshold, &lineThresholdProjected, &lineThresholdBinarized, &suppressNonmaxSize) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::StarDetector::create(maxSize, responseThreshold, lineThresholdProjected, lineThresholdBinarized, suppressNonmaxSize));
        return pyopencv_from(retval);
    }

    return NULL;
}



// Tables (xfeatures2d_StarDetector)

static PyGetSetDef pyopencv_xfeatures2d_StarDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_StarDetector_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_StarDetector_create_static, METH_STATIC), "create([, maxSize[, responseThreshold[, lineThresholdProjected[, lineThresholdBinarized[, suppressNonmaxSize]]]]]) -> retval\n."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_StarDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::StarDetector> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::StarDetector>& r)
    {
        return pyopencv_xfeatures2d_StarDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::StarDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::StarDetector> * dst_;
        if (pyopencv_xfeatures2d_StarDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::StarDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xfeatures2d_VGG (Generic)
//================================================================================

// GetSet (xfeatures2d_VGG)



// Methods (xfeatures2d_VGG)

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;

    int desc=VGG::VGG_120;
    float isigma=1.4f;
    bool img_normalize=true;
    bool use_scale_orientation=true;
    float scale_factor=6.25f;
    bool dsc_normalize=false;
    Ptr<VGG> retval;

    const char* keywords[] = { "desc", "isigma", "img_normalize", "use_scale_orientation", "scale_factor", "dsc_normalize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|ifbbfb:xfeatures2d_VGG.create", (char**)keywords, &desc, &isigma, &img_normalize, &use_scale_orientation, &scale_factor, &dsc_normalize) )
    {
        ERRWRAP2(retval = cv::xfeatures2d::VGG::create(desc, isigma, img_normalize, use_scale_orientation, scale_factor, dsc_normalize));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getScaleFactor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getScaleFactor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getUseNormalizeDescriptor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseNormalizeDescriptor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getUseNormalizeImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseNormalizeImage());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getUseScaleOrientation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUseScaleOrientation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setScaleFactor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    float scale_factor=0.f;

    const char* keywords[] = { "scale_factor", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_VGG.setScaleFactor", (char**)keywords, &scale_factor) )
    {
        ERRWRAP2(_self_->setScaleFactor(scale_factor));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    float isigma=0.f;

    const char* keywords[] = { "isigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xfeatures2d_VGG.setSigma", (char**)keywords, &isigma) )
    {
        ERRWRAP2(_self_->setSigma(isigma));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setUseNormalizeDescriptor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    bool dsc_normalize=0;

    const char* keywords[] = { "dsc_normalize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:xfeatures2d_VGG.setUseNormalizeDescriptor", (char**)keywords, &dsc_normalize) )
    {
        ERRWRAP2(_self_->setUseNormalizeDescriptor(dsc_normalize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setUseNormalizeImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    bool img_normalize=0;

    const char* keywords[] = { "img_normalize", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:xfeatures2d_VGG.setUseNormalizeImage", (char**)keywords, &img_normalize) )
    {
        ERRWRAP2(_self_->setUseNormalizeImage(img_normalize));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setUseScaleOrientation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xfeatures2d;


    Ptr<cv::xfeatures2d::VGG> * self1 = 0;
    if (!pyopencv_xfeatures2d_VGG_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xfeatures2d_VGG' or its derivative)");
    Ptr<cv::xfeatures2d::VGG> _self_ = *(self1);
    bool use_scale_orientation=0;

    const char* keywords[] = { "use_scale_orientation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:xfeatures2d_VGG.setUseScaleOrientation", (char**)keywords, &use_scale_orientation) )
    {
        ERRWRAP2(_self_->setUseScaleOrientation(use_scale_orientation));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (xfeatures2d_VGG)

static PyGetSetDef pyopencv_xfeatures2d_VGG_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xfeatures2d_VGG_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_create_static, METH_STATIC), "create([, desc[, isigma[, img_normalize[, use_scale_orientation[, scale_factor[, dsc_normalize]]]]]]) -> retval\n."},
    {"getScaleFactor", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getScaleFactor, 0), "getScaleFactor() -> retval\n."},
    {"getSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getSigma, 0), "getSigma() -> retval\n."},
    {"getUseNormalizeDescriptor", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getUseNormalizeDescriptor, 0), "getUseNormalizeDescriptor() -> retval\n."},
    {"getUseNormalizeImage", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getUseNormalizeImage, 0), "getUseNormalizeImage() -> retval\n."},
    {"getUseScaleOrientation", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_getUseScaleOrientation, 0), "getUseScaleOrientation() -> retval\n."},
    {"setScaleFactor", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setScaleFactor, 0), "setScaleFactor(scale_factor) -> None\n."},
    {"setSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setSigma, 0), "setSigma(isigma) -> None\n."},
    {"setUseNormalizeDescriptor", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setUseNormalizeDescriptor, 0), "setUseNormalizeDescriptor(dsc_normalize) -> None\n."},
    {"setUseNormalizeImage", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setUseNormalizeImage, 0), "setUseNormalizeImage(img_normalize) -> None\n."},
    {"setUseScaleOrientation", CV_PY_FN_WITH_KW_(pyopencv_cv_xfeatures2d_xfeatures2d_VGG_setUseScaleOrientation, 0), "setUseScaleOrientation(use_scale_orientation) -> None\n."},

    {NULL,          NULL}
};

// Converter (xfeatures2d_VGG)

template<>
struct PyOpenCV_Converter< Ptr<cv::xfeatures2d::VGG> >
{
    static PyObject* from(const Ptr<cv::xfeatures2d::VGG>& r)
    {
        return pyopencv_xfeatures2d_VGG_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xfeatures2d::VGG>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xfeatures2d::VGG> * dst_;
        if (pyopencv_xfeatures2d_VGG_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xfeatures2d::VGG> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_AdaptiveManifoldFilter (Generic)
//================================================================================

// GetSet (ximgproc_AdaptiveManifoldFilter)



// Methods (ximgproc_AdaptiveManifoldFilter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_AdaptiveManifoldFilter_collectGarbage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::AdaptiveManifoldFilter> * self1 = 0;
    if (!pyopencv_ximgproc_AdaptiveManifoldFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_AdaptiveManifoldFilter' or its derivative)");
    Ptr<cv::ximgproc::AdaptiveManifoldFilter> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->collectGarbage());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_AdaptiveManifoldFilter_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;

    Ptr<AdaptiveManifoldFilter> retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = cv::ximgproc::AdaptiveManifoldFilter::create());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_AdaptiveManifoldFilter_filter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::AdaptiveManifoldFilter> * self1 = 0;
    if (!pyopencv_ximgproc_AdaptiveManifoldFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_AdaptiveManifoldFilter' or its derivative)");
    Ptr<cv::ximgproc::AdaptiveManifoldFilter> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_joint = NULL;
    Mat joint;

    const char* keywords[] = { "src", "dst", "joint", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:ximgproc_AdaptiveManifoldFilter.filter", (char**)keywords, &pyobj_src, &pyobj_dst, &pyobj_joint) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_joint, joint, ArgInfo("joint", 0)) )
    {
        ERRWRAP2(_self_->filter(src, dst, joint));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_joint = NULL;
    UMat joint;

    const char* keywords[] = { "src", "dst", "joint", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|OO:ximgproc_AdaptiveManifoldFilter.filter", (char**)keywords, &pyobj_src, &pyobj_dst, &pyobj_joint) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) &&
        pyopencv_to(pyobj_joint, joint, ArgInfo("joint", 0)) )
    {
        ERRWRAP2(_self_->filter(src, dst, joint));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (ximgproc_AdaptiveManifoldFilter)

static PyGetSetDef pyopencv_ximgproc_AdaptiveManifoldFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_AdaptiveManifoldFilter_methods[] =
{
    {"collectGarbage", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_AdaptiveManifoldFilter_collectGarbage, 0), "collectGarbage() -> None\n."},
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_AdaptiveManifoldFilter_create_static, METH_STATIC), "create() -> retval\n."},
    {"filter", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_AdaptiveManifoldFilter_filter, 0), "filter(src[, dst[, joint]]) -> dst\n.   @brief Apply high-dimensional filtering using adaptive manifolds.\n.   \n.       @param src filtering image with any numbers of channels.\n.   \n.       @param dst output image.\n.   \n.       @param joint optional joint (also called as guided) image with any numbers of channels."},

    {NULL,          NULL}
};

// Converter (ximgproc_AdaptiveManifoldFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::AdaptiveManifoldFilter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::AdaptiveManifoldFilter>& r)
    {
        return pyopencv_ximgproc_AdaptiveManifoldFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::AdaptiveManifoldFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::AdaptiveManifoldFilter> * dst_;
        if (pyopencv_ximgproc_AdaptiveManifoldFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::AdaptiveManifoldFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_ContourFitting (Generic)
//================================================================================

// GetSet (ximgproc_ContourFitting)



// Methods (ximgproc_ContourFitting)

static PyObject* pyopencv_cv_ximgproc_ximgproc_ContourFitting_estimateTransformation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::ContourFitting> * self1 = 0;
    if (!pyopencv_ximgproc_ContourFitting_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_ContourFitting' or its derivative)");
    Ptr<cv::ximgproc::ContourFitting> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    PyObject* pyobj_alphaPhiST = NULL;
    Mat alphaPhiST;
    double dist;
    bool fdContour=false;

    const char* keywords[] = { "src", "dst", "alphaPhiST", "fdContour", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Ob:ximgproc_ContourFitting.estimateTransformation", (char**)keywords, &pyobj_src, &pyobj_dst, &pyobj_alphaPhiST, &fdContour) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 0)) &&
        pyopencv_to(pyobj_alphaPhiST, alphaPhiST, ArgInfo("alphaPhiST", 1)) )
    {
        ERRWRAP2(_self_->estimateTransformation(src, dst, alphaPhiST, dist, fdContour));
        return Py_BuildValue("(NN)", pyopencv_from(alphaPhiST), pyopencv_from(dist));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    PyObject* pyobj_alphaPhiST = NULL;
    UMat alphaPhiST;
    double dist;
    bool fdContour=false;

    const char* keywords[] = { "src", "dst", "alphaPhiST", "fdContour", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Ob:ximgproc_ContourFitting.estimateTransformation", (char**)keywords, &pyobj_src, &pyobj_dst, &pyobj_alphaPhiST, &fdContour) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 0)) &&
        pyopencv_to(pyobj_alphaPhiST, alphaPhiST, ArgInfo("alphaPhiST", 1)) )
    {
        ERRWRAP2(_self_->estimateTransformation(src, dst, alphaPhiST, dist, fdContour));
        return Py_BuildValue("(NN)", pyopencv_from(alphaPhiST), pyopencv_from(dist));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_ContourFitting_getCtrSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::ContourFitting> * self1 = 0;
    if (!pyopencv_ximgproc_ContourFitting_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_ContourFitting' or its derivative)");
    Ptr<cv::ximgproc::ContourFitting> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getCtrSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_ContourFitting_getFDSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::ContourFitting> * self1 = 0;
    if (!pyopencv_ximgproc_ContourFitting_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_ContourFitting' or its derivative)");
    Ptr<cv::ximgproc::ContourFitting> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFDSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_ContourFitting_setCtrSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::ContourFitting> * self1 = 0;
    if (!pyopencv_ximgproc_ContourFitting_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_ContourFitting' or its derivative)");
    Ptr<cv::ximgproc::ContourFitting> _self_ = *(self1);
    int n=0;

    const char* keywords[] = { "n", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ximgproc_ContourFitting.setCtrSize", (char**)keywords, &n) )
    {
        ERRWRAP2(_self_->setCtrSize(n));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_ContourFitting_setFDSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::ContourFitting> * self1 = 0;
    if (!pyopencv_ximgproc_ContourFitting_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_ContourFitting' or its derivative)");
    Ptr<cv::ximgproc::ContourFitting> _self_ = *(self1);
    int n=0;

    const char* keywords[] = { "n", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ximgproc_ContourFitting.setFDSize", (char**)keywords, &n) )
    {
        ERRWRAP2(_self_->setFDSize(n));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_ContourFitting)

static PyGetSetDef pyopencv_ximgproc_ContourFitting_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_ContourFitting_methods[] =
{
    {"estimateTransformation", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_ContourFitting_estimateTransformation, 0), "estimateTransformation(src, dst[, alphaPhiST[, fdContour]]) -> alphaPhiST, dist\n.   @brief Fit two closed curves using fourier descriptors. More details in @cite PersoonFu1977 and @cite BergerRaghunathan1998\n.   \n.           @param src Contour defining first shape.\n.           @param dst Contour defining second shape (Target).\n.           @param alphaPhiST : \\f$ \\alpha \\f$=alphaPhiST(0,0), \\f$ \\phi \\f$=alphaPhiST(0,1) (in radian), s=alphaPhiST(0,2), Tx=alphaPhiST(0,3), Ty=alphaPhiST(0,4) rotation center\n.           @param dist distance between src and dst after matching.\n.           @param fdContour false then src and dst are contours and true src and dst are fourier descriptors."},
    {"getCtrSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_ContourFitting_getCtrSize, 0), "getCtrSize() -> retval\n.   @returns number of fourier descriptors"},
    {"getFDSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_ContourFitting_getFDSize, 0), "getFDSize() -> retval\n.   @returns number of fourier descriptors used for optimal curve matching"},
    {"setCtrSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_ContourFitting_setCtrSize, 0), "setCtrSize(n) -> None\n.   @brief set number of Fourier descriptors used in estimateTransformation\n.   \n.           @param n number of Fourier descriptors equal to number of contour points after resampling."},
    {"setFDSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_ContourFitting_setFDSize, 0), "setFDSize(n) -> None\n.   @brief set number of Fourier descriptors when estimateTransformation used vector<Point>\n.   \n.           @param n number of fourier descriptors used for optimal curve matching."},

    {NULL,          NULL}
};

// Converter (ximgproc_ContourFitting)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::ContourFitting> >
{
    static PyObject* from(const Ptr<cv::ximgproc::ContourFitting>& r)
    {
        return pyopencv_ximgproc_ContourFitting_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::ContourFitting>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::ContourFitting> * dst_;
        if (pyopencv_ximgproc_ContourFitting_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::ContourFitting> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_DTFilter (Generic)
//================================================================================

// GetSet (ximgproc_DTFilter)



// Methods (ximgproc_DTFilter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_DTFilter_filter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DTFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DTFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DTFilter' or its derivative)");
    Ptr<cv::ximgproc::DTFilter> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    int dDepth=-1;

    const char* keywords[] = { "src", "dst", "dDepth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ximgproc_DTFilter.filter", (char**)keywords, &pyobj_src, &pyobj_dst, &dDepth) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->filter(src, dst, dDepth));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    int dDepth=-1;

    const char* keywords[] = { "src", "dst", "dDepth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ximgproc_DTFilter.filter", (char**)keywords, &pyobj_src, &pyobj_dst, &dDepth) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->filter(src, dst, dDepth));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (ximgproc_DTFilter)

static PyGetSetDef pyopencv_ximgproc_DTFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_DTFilter_methods[] =
{
    {"filter", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DTFilter_filter, 0), "filter(src[, dst[, dDepth]]) -> dst\n.   @brief Produce domain transform filtering operation on source image.\n.   \n.       @param src filtering image with unsigned 8-bit or floating-point 32-bit depth and up to 4 channels.\n.   \n.       @param dst destination image.\n.   \n.       @param dDepth optional depth of the output image. dDepth can be set to -1, which will be equivalent\n.       to src.depth()."},

    {NULL,          NULL}
};

// Converter (ximgproc_DTFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::DTFilter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::DTFilter>& r)
    {
        return pyopencv_ximgproc_DTFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::DTFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::DTFilter> * dst_;
        if (pyopencv_ximgproc_DTFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::DTFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_DisparityFilter (Generic)
//================================================================================

// GetSet (ximgproc_DisparityFilter)



// Methods (ximgproc_DisparityFilter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityFilter_filter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityFilter> _self_ = *(self1);
    {
    PyObject* pyobj_disparity_map_left = NULL;
    Mat disparity_map_left;
    PyObject* pyobj_left_view = NULL;
    Mat left_view;
    PyObject* pyobj_filtered_disparity_map = NULL;
    Mat filtered_disparity_map;
    PyObject* pyobj_disparity_map_right = NULL;
    Mat disparity_map_right;
    PyObject* pyobj_ROI = NULL;
    Rect ROI;
    PyObject* pyobj_right_view = NULL;
    Mat right_view;

    const char* keywords[] = { "disparity_map_left", "left_view", "filtered_disparity_map", "disparity_map_right", "ROI", "right_view", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OOOO:ximgproc_DisparityFilter.filter", (char**)keywords, &pyobj_disparity_map_left, &pyobj_left_view, &pyobj_filtered_disparity_map, &pyobj_disparity_map_right, &pyobj_ROI, &pyobj_right_view) &&
        pyopencv_to(pyobj_disparity_map_left, disparity_map_left, ArgInfo("disparity_map_left", 0)) &&
        pyopencv_to(pyobj_left_view, left_view, ArgInfo("left_view", 0)) &&
        pyopencv_to(pyobj_filtered_disparity_map, filtered_disparity_map, ArgInfo("filtered_disparity_map", 1)) &&
        pyopencv_to(pyobj_disparity_map_right, disparity_map_right, ArgInfo("disparity_map_right", 0)) &&
        pyopencv_to(pyobj_ROI, ROI, ArgInfo("ROI", 0)) &&
        pyopencv_to(pyobj_right_view, right_view, ArgInfo("right_view", 0)) )
    {
        ERRWRAP2(_self_->filter(disparity_map_left, left_view, filtered_disparity_map, disparity_map_right, ROI, right_view));
        return pyopencv_from(filtered_disparity_map);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_disparity_map_left = NULL;
    UMat disparity_map_left;
    PyObject* pyobj_left_view = NULL;
    UMat left_view;
    PyObject* pyobj_filtered_disparity_map = NULL;
    UMat filtered_disparity_map;
    PyObject* pyobj_disparity_map_right = NULL;
    UMat disparity_map_right;
    PyObject* pyobj_ROI = NULL;
    Rect ROI;
    PyObject* pyobj_right_view = NULL;
    UMat right_view;

    const char* keywords[] = { "disparity_map_left", "left_view", "filtered_disparity_map", "disparity_map_right", "ROI", "right_view", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|OOOO:ximgproc_DisparityFilter.filter", (char**)keywords, &pyobj_disparity_map_left, &pyobj_left_view, &pyobj_filtered_disparity_map, &pyobj_disparity_map_right, &pyobj_ROI, &pyobj_right_view) &&
        pyopencv_to(pyobj_disparity_map_left, disparity_map_left, ArgInfo("disparity_map_left", 0)) &&
        pyopencv_to(pyobj_left_view, left_view, ArgInfo("left_view", 0)) &&
        pyopencv_to(pyobj_filtered_disparity_map, filtered_disparity_map, ArgInfo("filtered_disparity_map", 1)) &&
        pyopencv_to(pyobj_disparity_map_right, disparity_map_right, ArgInfo("disparity_map_right", 0)) &&
        pyopencv_to(pyobj_ROI, ROI, ArgInfo("ROI", 0)) &&
        pyopencv_to(pyobj_right_view, right_view, ArgInfo("right_view", 0)) )
    {
        ERRWRAP2(_self_->filter(disparity_map_left, left_view, filtered_disparity_map, disparity_map_right, ROI, right_view));
        return pyopencv_from(filtered_disparity_map);
    }
    }

    return NULL;
}



// Tables (ximgproc_DisparityFilter)

static PyGetSetDef pyopencv_ximgproc_DisparityFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_DisparityFilter_methods[] =
{
    {"filter", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityFilter_filter, 0), "filter(disparity_map_left, left_view[, filtered_disparity_map[, disparity_map_right[, ROI[, right_view]]]]) -> filtered_disparity_map\n.   @brief Apply filtering to the disparity map.\n.   \n.       @param disparity_map_left disparity map of the left view, 1 channel, CV_16S type. Implicitly assumes that disparity\n.       values are scaled by 16 (one-pixel disparity corresponds to the value of 16 in the disparity map). Disparity map\n.       can have any resolution, it will be automatically resized to fit left_view resolution.\n.   \n.       @param left_view left view of the original stereo-pair to guide the filtering process, 8-bit single-channel\n.       or three-channel image.\n.   \n.       @param filtered_disparity_map output disparity map.\n.   \n.       @param disparity_map_right optional argument, some implementations might also use the disparity map\n.       of the right view to compute confidence maps, for instance.\n.   \n.       @param ROI region of the disparity map to filter. Optional, usually it should be set automatically.\n.   \n.       @param right_view optional argument, some implementations might also use the right view of the original\n.       stereo-pair."},

    {NULL,          NULL}
};

// Converter (ximgproc_DisparityFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::DisparityFilter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::DisparityFilter>& r)
    {
        return pyopencv_ximgproc_DisparityFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::DisparityFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::DisparityFilter> * dst_;
        if (pyopencv_ximgproc_DisparityFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::DisparityFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_DisparityWLSFilter (Generic)
//================================================================================

// GetSet (ximgproc_DisparityWLSFilter)



// Methods (ximgproc_DisparityWLSFilter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getConfidenceMap(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    Mat retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getConfidenceMap());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getDepthDiscontinuityRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getDepthDiscontinuityRadius());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getLRCthresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLRCthresh());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLambda());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getROI(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    Rect retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getROI());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getSigmaColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigmaColor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_setDepthDiscontinuityRadius(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    int _disc_radius=0;

    const char* keywords[] = { "_disc_radius", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ximgproc_DisparityWLSFilter.setDepthDiscontinuityRadius", (char**)keywords, &_disc_radius) )
    {
        ERRWRAP2(_self_->setDepthDiscontinuityRadius(_disc_radius));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_setLRCthresh(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    int _LRC_thresh=0;

    const char* keywords[] = { "_LRC_thresh", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ximgproc_DisparityWLSFilter.setLRCthresh", (char**)keywords, &_LRC_thresh) )
    {
        ERRWRAP2(_self_->setLRCthresh(_LRC_thresh));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_setLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    double _lambda=0;

    const char* keywords[] = { "_lambda", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ximgproc_DisparityWLSFilter.setLambda", (char**)keywords, &_lambda) )
    {
        ERRWRAP2(_self_->setLambda(_lambda));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_setSigmaColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::DisparityWLSFilter> * self1 = 0;
    if (!pyopencv_ximgproc_DisparityWLSFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_DisparityWLSFilter' or its derivative)");
    Ptr<cv::ximgproc::DisparityWLSFilter> _self_ = *(self1);
    double _sigma_color=0;

    const char* keywords[] = { "_sigma_color", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ximgproc_DisparityWLSFilter.setSigmaColor", (char**)keywords, &_sigma_color) )
    {
        ERRWRAP2(_self_->setSigmaColor(_sigma_color));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_DisparityWLSFilter)

static PyGetSetDef pyopencv_ximgproc_DisparityWLSFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_DisparityWLSFilter_methods[] =
{
    {"getConfidenceMap", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getConfidenceMap, 0), "getConfidenceMap() -> retval\n.   @brief Get the confidence map that was used in the last filter call. It is a CV_32F one-channel image\n.       with values ranging from 0.0 (totally untrusted regions of the raw disparity map) to 255.0 (regions containing\n.       correct disparity values with a high degree of confidence)."},
    {"getDepthDiscontinuityRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getDepthDiscontinuityRadius, 0), "getDepthDiscontinuityRadius() -> retval\n.   @brief DepthDiscontinuityRadius is a parameter used in confidence computation. It defines the size of\n.       low-confidence regions around depth discontinuities."},
    {"getLRCthresh", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getLRCthresh, 0), "getLRCthresh() -> retval\n.   @brief LRCthresh is a threshold of disparity difference used in left-right-consistency check during\n.       confidence map computation. The default value of 24 (1.5 pixels) is virtually always good enough."},
    {"getLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getLambda, 0), "getLambda() -> retval\n.   @brief Lambda is a parameter defining the amount of regularization during filtering. Larger values force\n.       filtered disparity map edges to adhere more to source image edges. Typical value is 8000."},
    {"getROI", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getROI, 0), "getROI() -> retval\n.   @brief Get the ROI used in the last filter call"},
    {"getSigmaColor", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_getSigmaColor, 0), "getSigmaColor() -> retval\n.   @brief SigmaColor is a parameter defining how sensitive the filtering process is to source image edges.\n.       Large values can lead to disparity leakage through low-contrast edges. Small values can make the filter too\n.       sensitive to noise and textures in the source image. Typical values range from 0.8 to 2.0."},
    {"setDepthDiscontinuityRadius", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_setDepthDiscontinuityRadius, 0), "setDepthDiscontinuityRadius(_disc_radius) -> None\n.   @see getDepthDiscontinuityRadius"},
    {"setLRCthresh", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_setLRCthresh, 0), "setLRCthresh(_LRC_thresh) -> None\n.   @see getLRCthresh"},
    {"setLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_setLambda, 0), "setLambda(_lambda) -> None\n.   @see getLambda"},
    {"setSigmaColor", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_DisparityWLSFilter_setSigmaColor, 0), "setSigmaColor(_sigma_color) -> None\n.   @see getSigmaColor"},

    {NULL,          NULL}
};

// Converter (ximgproc_DisparityWLSFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::DisparityWLSFilter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::DisparityWLSFilter>& r)
    {
        return pyopencv_ximgproc_DisparityWLSFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::DisparityWLSFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::DisparityWLSFilter> * dst_;
        if (pyopencv_ximgproc_DisparityWLSFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::DisparityWLSFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_EdgeAwareInterpolator (Generic)
//================================================================================

// GetSet (ximgproc_EdgeAwareInterpolator)



// Methods (ximgproc_EdgeAwareInterpolator)

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getFGSLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFGSLambda());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getFGSSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getFGSSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getK());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getLambda());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getUsePostProcessing(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    bool retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getUsePostProcessing());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setFGSLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    float _lambda=0.f;

    const char* keywords[] = { "_lambda", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeAwareInterpolator.setFGSLambda", (char**)keywords, &_lambda) )
    {
        ERRWRAP2(_self_->setFGSLambda(_lambda));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setFGSSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    float _sigma=0.f;

    const char* keywords[] = { "_sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeAwareInterpolator.setFGSSigma", (char**)keywords, &_sigma) )
    {
        ERRWRAP2(_self_->setFGSSigma(_sigma));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    int _k=0;

    const char* keywords[] = { "_k", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ximgproc_EdgeAwareInterpolator.setK", (char**)keywords, &_k) )
    {
        ERRWRAP2(_self_->setK(_k));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setLambda(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    float _lambda=0.f;

    const char* keywords[] = { "_lambda", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeAwareInterpolator.setLambda", (char**)keywords, &_lambda) )
    {
        ERRWRAP2(_self_->setLambda(_lambda));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    float _sigma=0.f;

    const char* keywords[] = { "_sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeAwareInterpolator.setSigma", (char**)keywords, &_sigma) )
    {
        ERRWRAP2(_self_->setSigma(_sigma));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setUsePostProcessing(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeAwareInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeAwareInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeAwareInterpolator' or its derivative)");
    Ptr<cv::ximgproc::EdgeAwareInterpolator> _self_ = *(self1);
    bool _use_post_proc=0;

    const char* keywords[] = { "_use_post_proc", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "b:ximgproc_EdgeAwareInterpolator.setUsePostProcessing", (char**)keywords, &_use_post_proc) )
    {
        ERRWRAP2(_self_->setUsePostProcessing(_use_post_proc));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_EdgeAwareInterpolator)

static PyGetSetDef pyopencv_ximgproc_EdgeAwareInterpolator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_EdgeAwareInterpolator_methods[] =
{
    {"getFGSLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getFGSLambda, 0), "getFGSLambda() -> retval\n.   @see setFGSLambda"},
    {"getFGSSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getFGSSigma, 0), "getFGSSigma() -> retval\n.   @see setFGSLambda"},
    {"getK", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getK, 0), "getK() -> retval\n.   @see setK"},
    {"getLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getLambda, 0), "getLambda() -> retval\n.   @see setLambda"},
    {"getSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getSigma, 0), "getSigma() -> retval\n.   @see setSigma"},
    {"getUsePostProcessing", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_getUsePostProcessing, 0), "getUsePostProcessing() -> retval\n.   @see setUsePostProcessing"},
    {"setFGSLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setFGSLambda, 0), "setFGSLambda(_lambda) -> None\n.   @brief Sets the respective fastGlobalSmootherFilter() parameter."},
    {"setFGSSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setFGSSigma, 0), "setFGSSigma(_sigma) -> None\n.   @see setFGSLambda"},
    {"setK", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setK, 0), "setK(_k) -> None\n.   @brief K is a number of nearest-neighbor matches considered, when fitting a locally affine\n.       model. Usually it should be around 128. However, lower values would make the interpolation\n.       noticeably faster."},
    {"setLambda", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setLambda, 0), "setLambda(_lambda) -> None\n.   @brief Lambda is a parameter defining the weight of the edge-aware term in geodesic distance,\n.       should be in the range of 0 to 1000."},
    {"setSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setSigma, 0), "setSigma(_sigma) -> None\n.   @brief Sigma is a parameter defining how fast the weights decrease in the locally-weighted affine\n.       fitting. Higher values can help preserve fine details, lower values can help to get rid of noise in the\n.       output flow."},
    {"setUsePostProcessing", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeAwareInterpolator_setUsePostProcessing, 0), "setUsePostProcessing(_use_post_proc) -> None\n.   @brief Sets whether the fastGlobalSmootherFilter() post-processing is employed. It is turned on by\n.       default."},

    {NULL,          NULL}
};

// Converter (ximgproc_EdgeAwareInterpolator)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::EdgeAwareInterpolator> >
{
    static PyObject* from(const Ptr<cv::ximgproc::EdgeAwareInterpolator>& r)
    {
        return pyopencv_ximgproc_EdgeAwareInterpolator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::EdgeAwareInterpolator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::EdgeAwareInterpolator> * dst_;
        if (pyopencv_ximgproc_EdgeAwareInterpolator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::EdgeAwareInterpolator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_EdgeBoxes (Generic)
//================================================================================

// GetSet (ximgproc_EdgeBoxes)



// Methods (ximgproc_EdgeBoxes)

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getAlpha(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getAlpha());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getBeta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getBeta());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getBoundingBoxes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    {
    PyObject* pyobj_edge_map = NULL;
    Mat edge_map;
    PyObject* pyobj_orientation_map = NULL;
    Mat orientation_map;
    vector_Rect boxes;
    PyObject* pyobj_scores = NULL;
    Mat scores;

    const char* keywords[] = { "edge_map", "orientation_map", "scores", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:ximgproc_EdgeBoxes.getBoundingBoxes", (char**)keywords, &pyobj_edge_map, &pyobj_orientation_map, &pyobj_scores) &&
        pyopencv_to(pyobj_edge_map, edge_map, ArgInfo("edge_map", 0)) &&
        pyopencv_to(pyobj_orientation_map, orientation_map, ArgInfo("orientation_map", 0)) &&
        pyopencv_to(pyobj_scores, scores, ArgInfo("scores", 1)) )
    {
        ERRWRAP2(_self_->getBoundingBoxes(edge_map, orientation_map, boxes, scores));
        return Py_BuildValue("(NN)", pyopencv_from(boxes), pyopencv_from(scores));
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_edge_map = NULL;
    UMat edge_map;
    PyObject* pyobj_orientation_map = NULL;
    UMat orientation_map;
    vector_Rect boxes;
    PyObject* pyobj_scores = NULL;
    UMat scores;

    const char* keywords[] = { "edge_map", "orientation_map", "scores", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:ximgproc_EdgeBoxes.getBoundingBoxes", (char**)keywords, &pyobj_edge_map, &pyobj_orientation_map, &pyobj_scores) &&
        pyopencv_to(pyobj_edge_map, edge_map, ArgInfo("edge_map", 0)) &&
        pyopencv_to(pyobj_orientation_map, orientation_map, ArgInfo("orientation_map", 0)) &&
        pyopencv_to(pyobj_scores, scores, ArgInfo("scores", 1)) )
    {
        ERRWRAP2(_self_->getBoundingBoxes(edge_map, orientation_map, boxes, scores));
        return Py_BuildValue("(NN)", pyopencv_from(boxes), pyopencv_from(scores));
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getClusterMinMag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getClusterMinMag());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getEdgeMergeThr(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEdgeMergeThr());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getEdgeMinMag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEdgeMinMag());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getEta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getEta());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getGamma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getKappa(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getKappa());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getMaxAspectRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxAspectRatio());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getMaxBoxes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMaxBoxes());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getMinBoxArea(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinBoxArea());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getMinScore(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinScore());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setAlpha(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setAlpha", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setAlpha(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setBeta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setBeta", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setBeta(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setClusterMinMag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setClusterMinMag", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setClusterMinMag(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setEdgeMergeThr(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setEdgeMergeThr", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setEdgeMergeThr(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setEdgeMinMag(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setEdgeMinMag", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setEdgeMinMag(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setEta(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setEta", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setEta(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setGamma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setGamma", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setGamma(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setKappa(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setKappa", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setKappa(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setMaxAspectRatio(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setMaxAspectRatio", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setMaxAspectRatio(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setMaxBoxes(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    int value=0;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ximgproc_EdgeBoxes.setMaxBoxes", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setMaxBoxes(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setMinBoxArea(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setMinBoxArea", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setMinBoxArea(value));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setMinScore(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::EdgeBoxes> * self1 = 0;
    if (!pyopencv_ximgproc_EdgeBoxes_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_EdgeBoxes' or its derivative)");
    Ptr<cv::ximgproc::EdgeBoxes> _self_ = *(self1);
    float value=0.f;

    const char* keywords[] = { "value", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_EdgeBoxes.setMinScore", (char**)keywords, &value) )
    {
        ERRWRAP2(_self_->setMinScore(value));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_EdgeBoxes)

static PyGetSetDef pyopencv_ximgproc_EdgeBoxes_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_EdgeBoxes_methods[] =
{
    {"getAlpha", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getAlpha, 0), "getAlpha() -> retval\n.   @brief Returns the step size of sliding window search."},
    {"getBeta", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getBeta, 0), "getBeta() -> retval\n.   @brief Returns the nms threshold for object proposals."},
    {"getBoundingBoxes", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getBoundingBoxes, 0), "getBoundingBoxes(edge_map, orientation_map[, scores]) -> boxes, scores\n.   @brief Returns array containing proposal boxes.\n.   \n.       @param edge_map edge image.\n.       @param orientation_map orientation map.\n.       @param boxes proposal boxes.\n.       @param scores of the proposal boxes, provided a vector of float types."},
    {"getClusterMinMag", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getClusterMinMag, 0), "getClusterMinMag() -> retval\n.   @brief Returns the cluster min magnitude."},
    {"getEdgeMergeThr", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getEdgeMergeThr, 0), "getEdgeMergeThr() -> retval\n.   @brief Returns the edge merge threshold."},
    {"getEdgeMinMag", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getEdgeMinMag, 0), "getEdgeMinMag() -> retval\n.   @brief Returns the edge min magnitude."},
    {"getEta", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getEta, 0), "getEta() -> retval\n.   @brief Returns adaptation rate for nms threshold."},
    {"getGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getGamma, 0), "getGamma() -> retval\n.   @brief Returns the affinity sensitivity."},
    {"getKappa", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getKappa, 0), "getKappa() -> retval\n.   @brief Returns the scale sensitivity."},
    {"getMaxAspectRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getMaxAspectRatio, 0), "getMaxAspectRatio() -> retval\n.   @brief Returns the max aspect ratio of boxes."},
    {"getMaxBoxes", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getMaxBoxes, 0), "getMaxBoxes() -> retval\n.   @brief Returns the max number of boxes to detect."},
    {"getMinBoxArea", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getMinBoxArea, 0), "getMinBoxArea() -> retval\n.   @brief Returns the minimum area of boxes."},
    {"getMinScore", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_getMinScore, 0), "getMinScore() -> retval\n.   @brief Returns the min score of boxes to detect."},
    {"setAlpha", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setAlpha, 0), "setAlpha(value) -> None\n.   @brief Sets the step size of sliding window search."},
    {"setBeta", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setBeta, 0), "setBeta(value) -> None\n.   @brief Sets the nms threshold for object proposals."},
    {"setClusterMinMag", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setClusterMinMag, 0), "setClusterMinMag(value) -> None\n.   @brief Sets the cluster min magnitude."},
    {"setEdgeMergeThr", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setEdgeMergeThr, 0), "setEdgeMergeThr(value) -> None\n.   @brief Sets the edge merge threshold."},
    {"setEdgeMinMag", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setEdgeMinMag, 0), "setEdgeMinMag(value) -> None\n.   @brief Sets the edge min magnitude."},
    {"setEta", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setEta, 0), "setEta(value) -> None\n.   @brief Sets the adaptation rate for nms threshold."},
    {"setGamma", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setGamma, 0), "setGamma(value) -> None\n.   @brief Sets the affinity sensitivity"},
    {"setKappa", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setKappa, 0), "setKappa(value) -> None\n.   @brief Sets the scale sensitivity."},
    {"setMaxAspectRatio", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setMaxAspectRatio, 0), "setMaxAspectRatio(value) -> None\n.   @brief Sets the max aspect ratio of boxes."},
    {"setMaxBoxes", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setMaxBoxes, 0), "setMaxBoxes(value) -> None\n.   @brief Sets max number of boxes to detect."},
    {"setMinBoxArea", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setMinBoxArea, 0), "setMinBoxArea(value) -> None\n.   @brief Sets the minimum area of boxes."},
    {"setMinScore", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_EdgeBoxes_setMinScore, 0), "setMinScore(value) -> None\n.   @brief Sets the min score of boxes to detect."},

    {NULL,          NULL}
};

// Converter (ximgproc_EdgeBoxes)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::EdgeBoxes> >
{
    static PyObject* from(const Ptr<cv::ximgproc::EdgeBoxes>& r)
    {
        return pyopencv_ximgproc_EdgeBoxes_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::EdgeBoxes>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::EdgeBoxes> * dst_;
        if (pyopencv_ximgproc_EdgeBoxes_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::EdgeBoxes> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_FastBilateralSolverFilter (Generic)
//================================================================================

// GetSet (ximgproc_FastBilateralSolverFilter)



// Methods (ximgproc_FastBilateralSolverFilter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_FastBilateralSolverFilter_filter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::FastBilateralSolverFilter> * self1 = 0;
    if (!pyopencv_ximgproc_FastBilateralSolverFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_FastBilateralSolverFilter' or its derivative)");
    Ptr<cv::ximgproc::FastBilateralSolverFilter> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_confidence = NULL;
    Mat confidence;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "confidence", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:ximgproc_FastBilateralSolverFilter.filter", (char**)keywords, &pyobj_src, &pyobj_confidence, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->filter(src, confidence, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_confidence = NULL;
    UMat confidence;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "confidence", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|O:ximgproc_FastBilateralSolverFilter.filter", (char**)keywords, &pyobj_src, &pyobj_confidence, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->filter(src, confidence, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (ximgproc_FastBilateralSolverFilter)

static PyGetSetDef pyopencv_ximgproc_FastBilateralSolverFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_FastBilateralSolverFilter_methods[] =
{
    {"filter", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_FastBilateralSolverFilter_filter, 0), "filter(src, confidence[, dst]) -> dst\n.   @brief Apply smoothing operation to the source image.\n.   \n.       @param src source image for filtering with unsigned 8-bit or signed 16-bit or floating-point 32-bit depth and up to 3 channels.\n.   \n.       @param confidence confidence image with unsigned 8-bit or floating-point 32-bit confidence and 1 channel.\n.   \n.       @param dst destination image.\n.   \n.       @note Confidence images with CV_8U depth are expected to in [0, 255] and CV_32F in [0, 1] range."},

    {NULL,          NULL}
};

// Converter (ximgproc_FastBilateralSolverFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::FastBilateralSolverFilter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::FastBilateralSolverFilter>& r)
    {
        return pyopencv_ximgproc_FastBilateralSolverFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::FastBilateralSolverFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::FastBilateralSolverFilter> * dst_;
        if (pyopencv_ximgproc_FastBilateralSolverFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::FastBilateralSolverFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_FastGlobalSmootherFilter (Generic)
//================================================================================

// GetSet (ximgproc_FastGlobalSmootherFilter)



// Methods (ximgproc_FastGlobalSmootherFilter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_FastGlobalSmootherFilter_filter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::FastGlobalSmootherFilter> * self1 = 0;
    if (!pyopencv_ximgproc_FastGlobalSmootherFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_FastGlobalSmootherFilter' or its derivative)");
    Ptr<cv::ximgproc::FastGlobalSmootherFilter> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_FastGlobalSmootherFilter.filter", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->filter(src, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_FastGlobalSmootherFilter.filter", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->filter(src, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (ximgproc_FastGlobalSmootherFilter)

static PyGetSetDef pyopencv_ximgproc_FastGlobalSmootherFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_FastGlobalSmootherFilter_methods[] =
{
    {"filter", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_FastGlobalSmootherFilter_filter, 0), "filter(src[, dst]) -> dst\n.   @brief Apply smoothing operation to the source image.\n.   \n.       @param src source image for filtering with unsigned 8-bit or signed 16-bit or floating-point 32-bit depth and up to 4 channels.\n.   \n.       @param dst destination image."},

    {NULL,          NULL}
};

// Converter (ximgproc_FastGlobalSmootherFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::FastGlobalSmootherFilter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::FastGlobalSmootherFilter>& r)
    {
        return pyopencv_ximgproc_FastGlobalSmootherFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::FastGlobalSmootherFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::FastGlobalSmootherFilter> * dst_;
        if (pyopencv_ximgproc_FastGlobalSmootherFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::FastGlobalSmootherFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_FastLineDetector (Generic)
//================================================================================

// GetSet (ximgproc_FastLineDetector)



// Methods (ximgproc_FastLineDetector)

static PyObject* pyopencv_cv_ximgproc_ximgproc_FastLineDetector_detect(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::FastLineDetector> * self1 = 0;
    if (!pyopencv_ximgproc_FastLineDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_FastLineDetector' or its derivative)");
    Ptr<cv::ximgproc::FastLineDetector> _self_ = *(self1);
    {
    PyObject* pyobj__image = NULL;
    Mat _image;
    PyObject* pyobj__lines = NULL;
    Mat _lines;

    const char* keywords[] = { "_image", "_lines", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_FastLineDetector.detect", (char**)keywords, &pyobj__image, &pyobj__lines) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 0)) &&
        pyopencv_to(pyobj__lines, _lines, ArgInfo("_lines", 1)) )
    {
        ERRWRAP2(_self_->detect(_image, _lines));
        return pyopencv_from(_lines);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__image = NULL;
    UMat _image;
    PyObject* pyobj__lines = NULL;
    UMat _lines;

    const char* keywords[] = { "_image", "_lines", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_FastLineDetector.detect", (char**)keywords, &pyobj__image, &pyobj__lines) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 0)) &&
        pyopencv_to(pyobj__lines, _lines, ArgInfo("_lines", 1)) )
    {
        ERRWRAP2(_self_->detect(_image, _lines));
        return pyopencv_from(_lines);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_FastLineDetector_drawSegments(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::FastLineDetector> * self1 = 0;
    if (!pyopencv_ximgproc_FastLineDetector_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_FastLineDetector' or its derivative)");
    Ptr<cv::ximgproc::FastLineDetector> _self_ = *(self1);
    {
    PyObject* pyobj__image = NULL;
    Mat _image;
    PyObject* pyobj_lines = NULL;
    Mat lines;
    bool draw_arrow=false;

    const char* keywords[] = { "_image", "lines", "draw_arrow", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|b:ximgproc_FastLineDetector.drawSegments", (char**)keywords, &pyobj__image, &pyobj_lines, &draw_arrow) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 1)) &&
        pyopencv_to(pyobj_lines, lines, ArgInfo("lines", 0)) )
    {
        ERRWRAP2(_self_->drawSegments(_image, lines, draw_arrow));
        return pyopencv_from(_image);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__image = NULL;
    UMat _image;
    PyObject* pyobj_lines = NULL;
    UMat lines;
    bool draw_arrow=false;

    const char* keywords[] = { "_image", "lines", "draw_arrow", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|b:ximgproc_FastLineDetector.drawSegments", (char**)keywords, &pyobj__image, &pyobj_lines, &draw_arrow) &&
        pyopencv_to(pyobj__image, _image, ArgInfo("_image", 1)) &&
        pyopencv_to(pyobj_lines, lines, ArgInfo("lines", 0)) )
    {
        ERRWRAP2(_self_->drawSegments(_image, lines, draw_arrow));
        return pyopencv_from(_image);
    }
    }

    return NULL;
}



// Tables (ximgproc_FastLineDetector)

static PyGetSetDef pyopencv_ximgproc_FastLineDetector_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_FastLineDetector_methods[] =
{
    {"detect", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_FastLineDetector_detect, 0), "detect(_image[, _lines]) -> _lines\n.   @brief Finds lines in the input image.\n.         This is the output of the default parameters of the algorithm on the above\n.         shown image.\n.   \n.         ![image](pics/corridor_fld.jpg)\n.   \n.         @param _image A grayscale (CV_8UC1) input image. If only a roi needs to be\n.         selected, use: `fld_ptr-\\>detect(image(roi), lines, ...);\n.         lines += Scalar(roi.x, roi.y, roi.x, roi.y);`\n.         @param _lines A vector of Vec4f elements specifying the beginning\n.         and ending point of a line.  Where Vec4f is (x1, y1, x2, y2), point\n.         1 is the start, point 2 - end. Returned lines are directed so that the\n.         brighter side is on their left."},
    {"drawSegments", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_FastLineDetector_drawSegments, 0), "drawSegments(_image, lines[, draw_arrow]) -> _image\n.   @brief Draws the line segments on a given image.\n.         @param _image The image, where the lines will be drawn. Should be bigger\n.         or equal to the image, where the lines were found.\n.         @param lines A vector of the lines that needed to be drawn.\n.         @param draw_arrow If true, arrow heads will be drawn."},

    {NULL,          NULL}
};

// Converter (ximgproc_FastLineDetector)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::FastLineDetector> >
{
    static PyObject* from(const Ptr<cv::ximgproc::FastLineDetector>& r)
    {
        return pyopencv_ximgproc_FastLineDetector_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::FastLineDetector>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::FastLineDetector> * dst_;
        if (pyopencv_ximgproc_FastLineDetector_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::FastLineDetector> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_GuidedFilter (Generic)
//================================================================================

// GetSet (ximgproc_GuidedFilter)



// Methods (ximgproc_GuidedFilter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_GuidedFilter_filter(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::GuidedFilter> * self1 = 0;
    if (!pyopencv_ximgproc_GuidedFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_GuidedFilter' or its derivative)");
    Ptr<cv::ximgproc::GuidedFilter> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;
    int dDepth=-1;

    const char* keywords[] = { "src", "dst", "dDepth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ximgproc_GuidedFilter.filter", (char**)keywords, &pyobj_src, &pyobj_dst, &dDepth) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->filter(src, dst, dDepth));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;
    int dDepth=-1;

    const char* keywords[] = { "src", "dst", "dDepth", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|Oi:ximgproc_GuidedFilter.filter", (char**)keywords, &pyobj_src, &pyobj_dst, &dDepth) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->filter(src, dst, dDepth));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (ximgproc_GuidedFilter)

static PyGetSetDef pyopencv_ximgproc_GuidedFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_GuidedFilter_methods[] =
{
    {"filter", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_GuidedFilter_filter, 0), "filter(src[, dst[, dDepth]]) -> dst\n.   @brief Apply Guided Filter to the filtering image.\n.   \n.       @param src filtering image with any numbers of channels.\n.   \n.       @param dst output image.\n.   \n.       @param dDepth optional depth of the output image. dDepth can be set to -1, which will be equivalent\n.       to src.depth()."},

    {NULL,          NULL}
};

// Converter (ximgproc_GuidedFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::GuidedFilter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::GuidedFilter>& r)
    {
        return pyopencv_ximgproc_GuidedFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::GuidedFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::GuidedFilter> * dst_;
        if (pyopencv_ximgproc_GuidedFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::GuidedFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_RFFeatureGetter (Generic)
//================================================================================

// GetSet (ximgproc_RFFeatureGetter)



// Methods (ximgproc_RFFeatureGetter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_RFFeatureGetter_getFeatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::RFFeatureGetter> * self1 = 0;
    if (!pyopencv_ximgproc_RFFeatureGetter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_RFFeatureGetter' or its derivative)");
    Ptr<cv::ximgproc::RFFeatureGetter> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_features = NULL;
    Mat features;
    int gnrmRad=0;
    int gsmthRad=0;
    int shrink=0;
    int outNum=0;
    int gradNum=0;

    const char* keywords[] = { "src", "features", "gnrmRad", "gsmthRad", "shrink", "outNum", "gradNum", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOiiiii:ximgproc_RFFeatureGetter.getFeatures", (char**)keywords, &pyobj_src, &pyobj_features, &gnrmRad, &gsmthRad, &shrink, &outNum, &gradNum) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) )
    {
        ERRWRAP2(_self_->getFeatures(src, features, gnrmRad, gsmthRad, shrink, outNum, gradNum));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_features = NULL;
    Mat features;
    int gnrmRad=0;
    int gsmthRad=0;
    int shrink=0;
    int outNum=0;
    int gradNum=0;

    const char* keywords[] = { "src", "features", "gnrmRad", "gsmthRad", "shrink", "outNum", "gradNum", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOiiiii:ximgproc_RFFeatureGetter.getFeatures", (char**)keywords, &pyobj_src, &pyobj_features, &gnrmRad, &gsmthRad, &shrink, &outNum, &gradNum) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_features, features, ArgInfo("features", 0)) )
    {
        ERRWRAP2(_self_->getFeatures(src, features, gnrmRad, gsmthRad, shrink, outNum, gradNum));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (ximgproc_RFFeatureGetter)

static PyGetSetDef pyopencv_ximgproc_RFFeatureGetter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_RFFeatureGetter_methods[] =
{
    {"getFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_RFFeatureGetter_getFeatures, 0), "getFeatures(src, features, gnrmRad, gsmthRad, shrink, outNum, gradNum) -> None\n."},

    {NULL,          NULL}
};

// Converter (ximgproc_RFFeatureGetter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::RFFeatureGetter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::RFFeatureGetter>& r)
    {
        return pyopencv_ximgproc_RFFeatureGetter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::RFFeatureGetter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::RFFeatureGetter> * dst_;
        if (pyopencv_ximgproc_RFFeatureGetter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::RFFeatureGetter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_RidgeDetectionFilter (Generic)
//================================================================================

// GetSet (ximgproc_RidgeDetectionFilter)



// Methods (ximgproc_RidgeDetectionFilter)

static PyObject* pyopencv_cv_ximgproc_ximgproc_RidgeDetectionFilter_create_static(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;

    int ddepth=CV_32FC1;
    int dx=1;
    int dy=1;
    int ksize=3;
    int out_dtype=CV_8UC1;
    double scale=1;
    double delta=0;
    int borderType=BORDER_DEFAULT;
    Ptr<RidgeDetectionFilter> retval;

    const char* keywords[] = { "ddepth", "dx", "dy", "ksize", "out_dtype", "scale", "delta", "borderType", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iiiiiddi:ximgproc_RidgeDetectionFilter.create", (char**)keywords, &ddepth, &dx, &dy, &ksize, &out_dtype, &scale, &delta, &borderType) )
    {
        ERRWRAP2(retval = cv::ximgproc::RidgeDetectionFilter::create(ddepth, dx, dy, ksize, out_dtype, scale, delta, borderType));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_RidgeDetectionFilter_getRidgeFilteredImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::RidgeDetectionFilter> * self1 = 0;
    if (!pyopencv_ximgproc_RidgeDetectionFilter_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_RidgeDetectionFilter' or its derivative)");
    Ptr<cv::ximgproc::RidgeDetectionFilter> _self_ = *(self1);
    {
    PyObject* pyobj__img = NULL;
    Mat _img;
    PyObject* pyobj_out = NULL;
    Mat out;

    const char* keywords[] = { "_img", "out", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_RidgeDetectionFilter.getRidgeFilteredImage", (char**)keywords, &pyobj__img, &pyobj_out) &&
        pyopencv_to(pyobj__img, _img, ArgInfo("_img", 0)) &&
        pyopencv_to(pyobj_out, out, ArgInfo("out", 1)) )
    {
        ERRWRAP2(_self_->getRidgeFilteredImage(_img, out));
        return pyopencv_from(out);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__img = NULL;
    UMat _img;
    PyObject* pyobj_out = NULL;
    UMat out;

    const char* keywords[] = { "_img", "out", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_RidgeDetectionFilter.getRidgeFilteredImage", (char**)keywords, &pyobj__img, &pyobj_out) &&
        pyopencv_to(pyobj__img, _img, ArgInfo("_img", 0)) &&
        pyopencv_to(pyobj_out, out, ArgInfo("out", 1)) )
    {
        ERRWRAP2(_self_->getRidgeFilteredImage(_img, out));
        return pyopencv_from(out);
    }
    }

    return NULL;
}



// Tables (ximgproc_RidgeDetectionFilter)

static PyGetSetDef pyopencv_ximgproc_RidgeDetectionFilter_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_RidgeDetectionFilter_methods[] =
{
    {"create", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_RidgeDetectionFilter_create_static, METH_STATIC), "create([, ddepth[, dx[, dy[, ksize[, out_dtype[, scale[, delta[, borderType]]]]]]]]) -> retval\n.   @brief Create pointer to the Ridge detection filter.\n.       @param ddepth  Specifies output image depth. Defualt is CV_32FC1\n.       @param dx Order of derivative x, default is 1\n.       @param dy  Order of derivative y, default is 1\n.       @param ksize Sobel kernel size , default is 3\n.       @param out_dtype Converted format for output, default is CV_8UC1\n.       @param scale Optional scale value for derivative values, default is 1\n.       @param delta  Optional bias added to output, default is 0\n.       @param borderType Pixel extrapolation method, default is BORDER_DEFAULT\n.       @see Sobel, threshold, getStructuringElement, morphologyEx.( for additional refinement)"},
    {"getRidgeFilteredImage", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_RidgeDetectionFilter_getRidgeFilteredImage, 0), "getRidgeFilteredImage(_img[, out]) -> out\n.   @brief Apply Ridge detection filter on input image.\n.       @param _img InputArray as supported by Sobel. img can be 1-Channel or 3-Channels.\n.       @param out OutputAray of structure as RidgeDetectionFilter::ddepth. Output image with ridges."},

    {NULL,          NULL}
};

// Converter (ximgproc_RidgeDetectionFilter)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::RidgeDetectionFilter> >
{
    static PyObject* from(const Ptr<cv::ximgproc::RidgeDetectionFilter>& r)
    {
        return pyopencv_ximgproc_RidgeDetectionFilter_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::RidgeDetectionFilter>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::RidgeDetectionFilter> * dst_;
        if (pyopencv_ximgproc_RidgeDetectionFilter_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::RidgeDetectionFilter> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_SparseMatchInterpolator (Generic)
//================================================================================

// GetSet (ximgproc_SparseMatchInterpolator)



// Methods (ximgproc_SparseMatchInterpolator)

static PyObject* pyopencv_cv_ximgproc_ximgproc_SparseMatchInterpolator_interpolate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SparseMatchInterpolator> * self1 = 0;
    if (!pyopencv_ximgproc_SparseMatchInterpolator_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SparseMatchInterpolator' or its derivative)");
    Ptr<cv::ximgproc::SparseMatchInterpolator> _self_ = *(self1);
    {
    PyObject* pyobj_from_image = NULL;
    Mat from_image;
    PyObject* pyobj_from_points = NULL;
    Mat from_points;
    PyObject* pyobj_to_image = NULL;
    Mat to_image;
    PyObject* pyobj_to_points = NULL;
    Mat to_points;
    PyObject* pyobj_dense_flow = NULL;
    Mat dense_flow;

    const char* keywords[] = { "from_image", "from_points", "to_image", "to_points", "dense_flow", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:ximgproc_SparseMatchInterpolator.interpolate", (char**)keywords, &pyobj_from_image, &pyobj_from_points, &pyobj_to_image, &pyobj_to_points, &pyobj_dense_flow) &&
        pyopencv_to(pyobj_from_image, from_image, ArgInfo("from_image", 0)) &&
        pyopencv_to(pyobj_from_points, from_points, ArgInfo("from_points", 0)) &&
        pyopencv_to(pyobj_to_image, to_image, ArgInfo("to_image", 0)) &&
        pyopencv_to(pyobj_to_points, to_points, ArgInfo("to_points", 0)) &&
        pyopencv_to(pyobj_dense_flow, dense_flow, ArgInfo("dense_flow", 1)) )
    {
        ERRWRAP2(_self_->interpolate(from_image, from_points, to_image, to_points, dense_flow));
        return pyopencv_from(dense_flow);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_from_image = NULL;
    UMat from_image;
    PyObject* pyobj_from_points = NULL;
    UMat from_points;
    PyObject* pyobj_to_image = NULL;
    UMat to_image;
    PyObject* pyobj_to_points = NULL;
    UMat to_points;
    PyObject* pyobj_dense_flow = NULL;
    UMat dense_flow;

    const char* keywords[] = { "from_image", "from_points", "to_image", "to_points", "dense_flow", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:ximgproc_SparseMatchInterpolator.interpolate", (char**)keywords, &pyobj_from_image, &pyobj_from_points, &pyobj_to_image, &pyobj_to_points, &pyobj_dense_flow) &&
        pyopencv_to(pyobj_from_image, from_image, ArgInfo("from_image", 0)) &&
        pyopencv_to(pyobj_from_points, from_points, ArgInfo("from_points", 0)) &&
        pyopencv_to(pyobj_to_image, to_image, ArgInfo("to_image", 0)) &&
        pyopencv_to(pyobj_to_points, to_points, ArgInfo("to_points", 0)) &&
        pyopencv_to(pyobj_dense_flow, dense_flow, ArgInfo("dense_flow", 1)) )
    {
        ERRWRAP2(_self_->interpolate(from_image, from_points, to_image, to_points, dense_flow));
        return pyopencv_from(dense_flow);
    }
    }

    return NULL;
}



// Tables (ximgproc_SparseMatchInterpolator)

static PyGetSetDef pyopencv_ximgproc_SparseMatchInterpolator_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_SparseMatchInterpolator_methods[] =
{
    {"interpolate", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SparseMatchInterpolator_interpolate, 0), "interpolate(from_image, from_points, to_image, to_points[, dense_flow]) -> dense_flow\n.   @brief Interpolate input sparse matches.\n.   \n.       @param from_image first of the two matched images, 8-bit single-channel or three-channel.\n.   \n.       @param from_points points of the from_image for which there are correspondences in the\n.       to_image (Point2f vector, size shouldn't exceed 32767)\n.   \n.       @param to_image second of the two matched images, 8-bit single-channel or three-channel.\n.   \n.       @param to_points points in the to_image corresponding to from_points\n.       (Point2f vector, size shouldn't exceed 32767)\n.   \n.       @param dense_flow output dense matching (two-channel CV_32F image)"},

    {NULL,          NULL}
};

// Converter (ximgproc_SparseMatchInterpolator)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::SparseMatchInterpolator> >
{
    static PyObject* from(const Ptr<cv::ximgproc::SparseMatchInterpolator>& r)
    {
        return pyopencv_ximgproc_SparseMatchInterpolator_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::SparseMatchInterpolator>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::SparseMatchInterpolator> * dst_;
        if (pyopencv_ximgproc_SparseMatchInterpolator_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::SparseMatchInterpolator> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_StructuredEdgeDetection (Generic)
//================================================================================

// GetSet (ximgproc_StructuredEdgeDetection)



// Methods (ximgproc_StructuredEdgeDetection)

static PyObject* pyopencv_cv_ximgproc_ximgproc_StructuredEdgeDetection_computeOrientation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::StructuredEdgeDetection> * self1 = 0;
    if (!pyopencv_ximgproc_StructuredEdgeDetection_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_StructuredEdgeDetection' or its derivative)");
    Ptr<cv::ximgproc::StructuredEdgeDetection> _self_ = *(self1);
    {
    PyObject* pyobj__src = NULL;
    Mat _src;
    PyObject* pyobj__dst = NULL;
    Mat _dst;

    const char* keywords[] = { "_src", "_dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_StructuredEdgeDetection.computeOrientation", (char**)keywords, &pyobj__src, &pyobj__dst) &&
        pyopencv_to(pyobj__src, _src, ArgInfo("_src", 0)) &&
        pyopencv_to(pyobj__dst, _dst, ArgInfo("_dst", 1)) )
    {
        ERRWRAP2(_self_->computeOrientation(_src, _dst));
        return pyopencv_from(_dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__src = NULL;
    UMat _src;
    PyObject* pyobj__dst = NULL;
    UMat _dst;

    const char* keywords[] = { "_src", "_dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_StructuredEdgeDetection.computeOrientation", (char**)keywords, &pyobj__src, &pyobj__dst) &&
        pyopencv_to(pyobj__src, _src, ArgInfo("_src", 0)) &&
        pyopencv_to(pyobj__dst, _dst, ArgInfo("_dst", 1)) )
    {
        ERRWRAP2(_self_->computeOrientation(_src, _dst));
        return pyopencv_from(_dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_StructuredEdgeDetection_detectEdges(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::StructuredEdgeDetection> * self1 = 0;
    if (!pyopencv_ximgproc_StructuredEdgeDetection_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_StructuredEdgeDetection' or its derivative)");
    Ptr<cv::ximgproc::StructuredEdgeDetection> _self_ = *(self1);
    {
    PyObject* pyobj__src = NULL;
    Mat _src;
    PyObject* pyobj__dst = NULL;
    Mat _dst;

    const char* keywords[] = { "_src", "_dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_StructuredEdgeDetection.detectEdges", (char**)keywords, &pyobj__src, &pyobj__dst) &&
        pyopencv_to(pyobj__src, _src, ArgInfo("_src", 0)) &&
        pyopencv_to(pyobj__dst, _dst, ArgInfo("_dst", 1)) )
    {
        ERRWRAP2(_self_->detectEdges(_src, _dst));
        return pyopencv_from(_dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj__src = NULL;
    UMat _src;
    PyObject* pyobj__dst = NULL;
    UMat _dst;

    const char* keywords[] = { "_src", "_dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_StructuredEdgeDetection.detectEdges", (char**)keywords, &pyobj__src, &pyobj__dst) &&
        pyopencv_to(pyobj__src, _src, ArgInfo("_src", 0)) &&
        pyopencv_to(pyobj__dst, _dst, ArgInfo("_dst", 1)) )
    {
        ERRWRAP2(_self_->detectEdges(_src, _dst));
        return pyopencv_from(_dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_StructuredEdgeDetection_edgesNms(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::StructuredEdgeDetection> * self1 = 0;
    if (!pyopencv_ximgproc_StructuredEdgeDetection_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_StructuredEdgeDetection' or its derivative)");
    Ptr<cv::ximgproc::StructuredEdgeDetection> _self_ = *(self1);
    {
    PyObject* pyobj_edge_image = NULL;
    Mat edge_image;
    PyObject* pyobj_orientation_image = NULL;
    Mat orientation_image;
    PyObject* pyobj__dst = NULL;
    Mat _dst;
    int r=2;
    int s=0;
    float m=1;
    bool isParallel=true;

    const char* keywords[] = { "edge_image", "orientation_image", "_dst", "r", "s", "m", "isParallel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Oiifb:ximgproc_StructuredEdgeDetection.edgesNms", (char**)keywords, &pyobj_edge_image, &pyobj_orientation_image, &pyobj__dst, &r, &s, &m, &isParallel) &&
        pyopencv_to(pyobj_edge_image, edge_image, ArgInfo("edge_image", 0)) &&
        pyopencv_to(pyobj_orientation_image, orientation_image, ArgInfo("orientation_image", 0)) &&
        pyopencv_to(pyobj__dst, _dst, ArgInfo("_dst", 1)) )
    {
        ERRWRAP2(_self_->edgesNms(edge_image, orientation_image, _dst, r, s, m, isParallel));
        return pyopencv_from(_dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_edge_image = NULL;
    UMat edge_image;
    PyObject* pyobj_orientation_image = NULL;
    UMat orientation_image;
    PyObject* pyobj__dst = NULL;
    UMat _dst;
    int r=2;
    int s=0;
    float m=1;
    bool isParallel=true;

    const char* keywords[] = { "edge_image", "orientation_image", "_dst", "r", "s", "m", "isParallel", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OO|Oiifb:ximgproc_StructuredEdgeDetection.edgesNms", (char**)keywords, &pyobj_edge_image, &pyobj_orientation_image, &pyobj__dst, &r, &s, &m, &isParallel) &&
        pyopencv_to(pyobj_edge_image, edge_image, ArgInfo("edge_image", 0)) &&
        pyopencv_to(pyobj_orientation_image, orientation_image, ArgInfo("orientation_image", 0)) &&
        pyopencv_to(pyobj__dst, _dst, ArgInfo("_dst", 1)) )
    {
        ERRWRAP2(_self_->edgesNms(edge_image, orientation_image, _dst, r, s, m, isParallel));
        return pyopencv_from(_dst);
    }
    }

    return NULL;
}



// Tables (ximgproc_StructuredEdgeDetection)

static PyGetSetDef pyopencv_ximgproc_StructuredEdgeDetection_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_StructuredEdgeDetection_methods[] =
{
    {"computeOrientation", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_StructuredEdgeDetection_computeOrientation, 0), "computeOrientation(_src[, _dst]) -> _dst\n.   @brief The function computes orientation from edge image.\n.   \n.       @param _src edge image.\n.       @param _dst orientation image."},
    {"detectEdges", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_StructuredEdgeDetection_detectEdges, 0), "detectEdges(_src[, _dst]) -> _dst\n.   @brief The function detects edges in src and draw them to dst.\n.   \n.       The algorithm underlies this function is much more robust to texture presence, than common\n.       approaches, e.g. Sobel\n.       @param _src source image (RGB, float, in [0;1]) to detect edges\n.       @param _dst destination image (grayscale, float, in [0;1]) where edges are drawn\n.       @sa Sobel, Canny"},
    {"edgesNms", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_StructuredEdgeDetection_edgesNms, 0), "edgesNms(edge_image, orientation_image[, _dst[, r[, s[, m[, isParallel]]]]]) -> _dst\n.   @brief The function edgenms in edge image and suppress edges where edge is stronger in orthogonal direction.\n.   \n.       @param edge_image edge image from detectEdges function.\n.       @param orientation_image orientation image from computeOrientation function.\n.       @param _dst suppressed image (grayscale, float, in [0;1])\n.       @param r radius for NMS suppression.\n.       @param s radius for boundary suppression.\n.       @param m multiplier for conservative suppression.\n.       @param isParallel enables/disables parallel computing."},

    {NULL,          NULL}
};

// Converter (ximgproc_StructuredEdgeDetection)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::StructuredEdgeDetection> >
{
    static PyObject* from(const Ptr<cv::ximgproc::StructuredEdgeDetection>& r)
    {
        return pyopencv_ximgproc_StructuredEdgeDetection_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::StructuredEdgeDetection>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::StructuredEdgeDetection> * dst_;
        if (pyopencv_ximgproc_StructuredEdgeDetection_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::StructuredEdgeDetection> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_SuperpixelLSC (Generic)
//================================================================================

// GetSet (ximgproc_SuperpixelLSC)



// Methods (ximgproc_SuperpixelLSC)

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_enforceLabelConnectivity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelLSC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelLSC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelLSC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelLSC> _self_ = *(self1);
    int min_element_size=20;

    const char* keywords[] = { "min_element_size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:ximgproc_SuperpixelLSC.enforceLabelConnectivity", (char**)keywords, &min_element_size) )
    {
        ERRWRAP2(_self_->enforceLabelConnectivity(min_element_size));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_getLabelContourMask(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelLSC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelLSC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelLSC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelLSC> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    bool thick_line=true;

    const char* keywords[] = { "image", "thick_line", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Ob:ximgproc_SuperpixelLSC.getLabelContourMask", (char**)keywords, &pyobj_image, &thick_line) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(_self_->getLabelContourMask(image, thick_line));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    bool thick_line=true;

    const char* keywords[] = { "image", "thick_line", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Ob:ximgproc_SuperpixelLSC.getLabelContourMask", (char**)keywords, &pyobj_image, &thick_line) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(_self_->getLabelContourMask(image, thick_line));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_getLabels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelLSC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelLSC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelLSC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelLSC> _self_ = *(self1);
    {
    PyObject* pyobj_labels_out = NULL;
    Mat labels_out;

    const char* keywords[] = { "labels_out", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:ximgproc_SuperpixelLSC.getLabels", (char**)keywords, &pyobj_labels_out) &&
        pyopencv_to(pyobj_labels_out, labels_out, ArgInfo("labels_out", 1)) )
    {
        ERRWRAP2(_self_->getLabels(labels_out));
        return pyopencv_from(labels_out);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_labels_out = NULL;
    UMat labels_out;

    const char* keywords[] = { "labels_out", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:ximgproc_SuperpixelLSC.getLabels", (char**)keywords, &pyobj_labels_out) &&
        pyopencv_to(pyobj_labels_out, labels_out, ArgInfo("labels_out", 1)) )
    {
        ERRWRAP2(_self_->getLabels(labels_out));
        return pyopencv_from(labels_out);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_getNumberOfSuperpixels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelLSC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelLSC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelLSC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelLSC> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumberOfSuperpixels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_iterate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelLSC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelLSC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelLSC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelLSC> _self_ = *(self1);
    int num_iterations=10;

    const char* keywords[] = { "num_iterations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:ximgproc_SuperpixelLSC.iterate", (char**)keywords, &num_iterations) )
    {
        ERRWRAP2(_self_->iterate(num_iterations));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_SuperpixelLSC)

static PyGetSetDef pyopencv_ximgproc_SuperpixelLSC_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_SuperpixelLSC_methods[] =
{
    {"enforceLabelConnectivity", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_enforceLabelConnectivity, 0), "enforceLabelConnectivity([, min_element_size]) -> None\n.   @brief Enforce label connectivity.\n.   \n.       @param min_element_size The minimum element size in percents that should be absorbed into a bigger\n.       superpixel. Given resulted average superpixel size valid value should be in 0-100 range, 25 means\n.       that less then a quarter sized superpixel should be absorbed, this is default.\n.   \n.       The function merge component that is too small, assigning the previously found adjacent label\n.       to this component. Calling this function may change the final number of superpixels."},
    {"getLabelContourMask", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_getLabelContourMask, 0), "getLabelContourMask([, image[, thick_line]]) -> image\n.   @brief Returns the mask of the superpixel segmentation stored in SuperpixelLSC object.\n.   \n.       @param image Return: CV_8U1 image mask where -1 indicates that the pixel is a superpixel border,\n.       and 0 otherwise.\n.   \n.       @param thick_line If false, the border is only one pixel wide, otherwise all pixels at the border\n.       are masked.\n.   \n.       The function return the boundaries of the superpixel segmentation."},
    {"getLabels", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_getLabels, 0), "getLabels([, labels_out]) -> labels_out\n.   @brief Returns the segmentation labeling of the image.\n.   \n.       Each label represents a superpixel, and each pixel is assigned to one superpixel label.\n.   \n.       @param labels_out Return: A CV_32SC1 integer array containing the labels of the superpixel\n.       segmentation. The labels are in the range [0, getNumberOfSuperpixels()].\n.   \n.       The function returns an image with the labels of the superpixel segmentation. The labels are in\n.       the range [0, getNumberOfSuperpixels()]."},
    {"getNumberOfSuperpixels", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_getNumberOfSuperpixels, 0), "getNumberOfSuperpixels() -> retval\n.   @brief Calculates the actual amount of superpixels on a given segmentation computed\n.       and stored in SuperpixelLSC object."},
    {"iterate", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelLSC_iterate, 0), "iterate([, num_iterations]) -> None\n.   @brief Calculates the superpixel segmentation on a given image with the initialized\n.       parameters in the SuperpixelLSC object.\n.   \n.       This function can be called again without the need of initializing the algorithm with\n.       createSuperpixelLSC(). This save the computational cost of allocating memory for all the\n.       structures of the algorithm.\n.   \n.       @param num_iterations Number of iterations. Higher number improves the result.\n.   \n.       The function computes the superpixels segmentation of an image with the parameters initialized\n.       with the function createSuperpixelLSC(). The algorithms starts from a grid of superpixels and\n.       then refines the boundaries by proposing updates of edges boundaries."},

    {NULL,          NULL}
};

// Converter (ximgproc_SuperpixelLSC)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::SuperpixelLSC> >
{
    static PyObject* from(const Ptr<cv::ximgproc::SuperpixelLSC>& r)
    {
        return pyopencv_ximgproc_SuperpixelLSC_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::SuperpixelLSC>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::SuperpixelLSC> * dst_;
        if (pyopencv_ximgproc_SuperpixelLSC_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::SuperpixelLSC> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_SuperpixelSEEDS (Generic)
//================================================================================

// GetSet (ximgproc_SuperpixelSEEDS)



// Methods (ximgproc_SuperpixelSEEDS)

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSEEDS_getLabelContourMask(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSEEDS> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSEEDS_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSEEDS' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSEEDS> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    bool thick_line=false;

    const char* keywords[] = { "image", "thick_line", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Ob:ximgproc_SuperpixelSEEDS.getLabelContourMask", (char**)keywords, &pyobj_image, &thick_line) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(_self_->getLabelContourMask(image, thick_line));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    bool thick_line=false;

    const char* keywords[] = { "image", "thick_line", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Ob:ximgproc_SuperpixelSEEDS.getLabelContourMask", (char**)keywords, &pyobj_image, &thick_line) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(_self_->getLabelContourMask(image, thick_line));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSEEDS_getLabels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSEEDS> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSEEDS_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSEEDS' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSEEDS> _self_ = *(self1);
    {
    PyObject* pyobj_labels_out = NULL;
    Mat labels_out;

    const char* keywords[] = { "labels_out", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:ximgproc_SuperpixelSEEDS.getLabels", (char**)keywords, &pyobj_labels_out) &&
        pyopencv_to(pyobj_labels_out, labels_out, ArgInfo("labels_out", 1)) )
    {
        ERRWRAP2(_self_->getLabels(labels_out));
        return pyopencv_from(labels_out);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_labels_out = NULL;
    UMat labels_out;

    const char* keywords[] = { "labels_out", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:ximgproc_SuperpixelSEEDS.getLabels", (char**)keywords, &pyobj_labels_out) &&
        pyopencv_to(pyobj_labels_out, labels_out, ArgInfo("labels_out", 1)) )
    {
        ERRWRAP2(_self_->getLabels(labels_out));
        return pyopencv_from(labels_out);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSEEDS_getNumberOfSuperpixels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSEEDS> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSEEDS_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSEEDS' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSEEDS> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumberOfSuperpixels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSEEDS_iterate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSEEDS> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSEEDS_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSEEDS' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSEEDS> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    int num_iterations=4;

    const char* keywords[] = { "img", "num_iterations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:ximgproc_SuperpixelSEEDS.iterate", (char**)keywords, &pyobj_img, &num_iterations) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(_self_->iterate(img, num_iterations));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    int num_iterations=4;

    const char* keywords[] = { "img", "num_iterations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|i:ximgproc_SuperpixelSEEDS.iterate", (char**)keywords, &pyobj_img, &num_iterations) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(_self_->iterate(img, num_iterations));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (ximgproc_SuperpixelSEEDS)

static PyGetSetDef pyopencv_ximgproc_SuperpixelSEEDS_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_SuperpixelSEEDS_methods[] =
{
    {"getLabelContourMask", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSEEDS_getLabelContourMask, 0), "getLabelContourMask([, image[, thick_line]]) -> image\n.   @brief Returns the mask of the superpixel segmentation stored in SuperpixelSEEDS object.\n.   \n.       @param image Return: CV_8UC1 image mask where -1 indicates that the pixel is a superpixel border,\n.       and 0 otherwise.\n.   \n.       @param thick_line If false, the border is only one pixel wide, otherwise all pixels at the border\n.       are masked.\n.   \n.       The function return the boundaries of the superpixel segmentation.\n.   \n.       @note\n.          -   (Python) A demo on how to generate superpixels in images from the webcam can be found at\n.               opencv_source_code/samples/python2/seeds.py\n.           -   (cpp) A demo on how to generate superpixels in images from the webcam can be found at\n.               opencv_source_code/modules/ximgproc/samples/seeds.cpp. By adding a file image as a command\n.               line argument, the static image will be used instead of the webcam.\n.           -   It will show a window with the video from the webcam with the superpixel boundaries marked\n.               in red (see below). Use Space to switch between different output modes. At the top of the\n.               window there are 4 sliders, from which the user can change on-the-fly the number of\n.               superpixels, the number of block levels, the strength of the boundary prior term to modify\n.               the shape, and the number of iterations at pixel level. This is useful to play with the\n.               parameters and set them to the user convenience. In the console the frame-rate of the\n.               algorithm is indicated.\n.   \n.       ![image](pics/superpixels_demo.png)"},
    {"getLabels", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSEEDS_getLabels, 0), "getLabels([, labels_out]) -> labels_out\n.   @brief Returns the segmentation labeling of the image.\n.   \n.       Each label represents a superpixel, and each pixel is assigned to one superpixel label.\n.   \n.       @param labels_out Return: A CV_32UC1 integer array containing the labels of the superpixel\n.       segmentation. The labels are in the range [0, getNumberOfSuperpixels()].\n.   \n.       The function returns an image with ssthe labels of the superpixel segmentation. The labels are in\n.       the range [0, getNumberOfSuperpixels()]."},
    {"getNumberOfSuperpixels", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSEEDS_getNumberOfSuperpixels, 0), "getNumberOfSuperpixels() -> retval\n.   @brief Calculates the superpixel segmentation on a given image stored in SuperpixelSEEDS object.\n.   \n.       The function computes the superpixels segmentation of an image with the parameters initialized\n.       with the function createSuperpixelSEEDS()."},
    {"iterate", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSEEDS_iterate, 0), "iterate(img[, num_iterations]) -> None\n.   @brief Calculates the superpixel segmentation on a given image with the initialized\n.       parameters in the SuperpixelSEEDS object.\n.   \n.       This function can be called again for other images without the need of initializing the\n.       algorithm with createSuperpixelSEEDS(). This save the computational cost of allocating memory\n.       for all the structures of the algorithm.\n.   \n.       @param img Input image. Supported formats: CV_8U, CV_16U, CV_32F. Image size & number of\n.       channels must match with the initialized image size & channels with the function\n.       createSuperpixelSEEDS(). It should be in HSV or Lab color space. Lab is a bit better, but also\n.       slower.\n.   \n.       @param num_iterations Number of pixel level iterations. Higher number improves the result.\n.   \n.       The function computes the superpixels segmentation of an image with the parameters initialized\n.       with the function createSuperpixelSEEDS(). The algorithms starts from a grid of superpixels and\n.       then refines the boundaries by proposing updates of blocks of pixels that lie at the boundaries\n.       from large to smaller size, finalizing with proposing pixel updates. An illustrative example\n.       can be seen below.\n.   \n.       ![image](pics/superpixels_blocks2.png)"},

    {NULL,          NULL}
};

// Converter (ximgproc_SuperpixelSEEDS)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::SuperpixelSEEDS> >
{
    static PyObject* from(const Ptr<cv::ximgproc::SuperpixelSEEDS>& r)
    {
        return pyopencv_ximgproc_SuperpixelSEEDS_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::SuperpixelSEEDS>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::SuperpixelSEEDS> * dst_;
        if (pyopencv_ximgproc_SuperpixelSEEDS_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::SuperpixelSEEDS> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_SuperpixelSLIC (Generic)
//================================================================================

// GetSet (ximgproc_SuperpixelSLIC)



// Methods (ximgproc_SuperpixelSLIC)

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_enforceLabelConnectivity(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSLIC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSLIC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSLIC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSLIC> _self_ = *(self1);
    int min_element_size=25;

    const char* keywords[] = { "min_element_size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:ximgproc_SuperpixelSLIC.enforceLabelConnectivity", (char**)keywords, &min_element_size) )
    {
        ERRWRAP2(_self_->enforceLabelConnectivity(min_element_size));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_getLabelContourMask(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSLIC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSLIC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSLIC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSLIC> _self_ = *(self1);
    {
    PyObject* pyobj_image = NULL;
    Mat image;
    bool thick_line=true;

    const char* keywords[] = { "image", "thick_line", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Ob:ximgproc_SuperpixelSLIC.getLabelContourMask", (char**)keywords, &pyobj_image, &thick_line) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(_self_->getLabelContourMask(image, thick_line));
        return pyopencv_from(image);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_image = NULL;
    UMat image;
    bool thick_line=true;

    const char* keywords[] = { "image", "thick_line", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|Ob:ximgproc_SuperpixelSLIC.getLabelContourMask", (char**)keywords, &pyobj_image, &thick_line) &&
        pyopencv_to(pyobj_image, image, ArgInfo("image", 1)) )
    {
        ERRWRAP2(_self_->getLabelContourMask(image, thick_line));
        return pyopencv_from(image);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_getLabels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSLIC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSLIC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSLIC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSLIC> _self_ = *(self1);
    {
    PyObject* pyobj_labels_out = NULL;
    Mat labels_out;

    const char* keywords[] = { "labels_out", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:ximgproc_SuperpixelSLIC.getLabels", (char**)keywords, &pyobj_labels_out) &&
        pyopencv_to(pyobj_labels_out, labels_out, ArgInfo("labels_out", 1)) )
    {
        ERRWRAP2(_self_->getLabels(labels_out));
        return pyopencv_from(labels_out);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_labels_out = NULL;
    UMat labels_out;

    const char* keywords[] = { "labels_out", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|O:ximgproc_SuperpixelSLIC.getLabels", (char**)keywords, &pyobj_labels_out) &&
        pyopencv_to(pyobj_labels_out, labels_out, ArgInfo("labels_out", 1)) )
    {
        ERRWRAP2(_self_->getLabels(labels_out));
        return pyopencv_from(labels_out);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_getNumberOfSuperpixels(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSLIC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSLIC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSLIC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSLIC> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getNumberOfSuperpixels());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_iterate(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc;


    Ptr<cv::ximgproc::SuperpixelSLIC> * self1 = 0;
    if (!pyopencv_ximgproc_SuperpixelSLIC_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_SuperpixelSLIC' or its derivative)");
    Ptr<cv::ximgproc::SuperpixelSLIC> _self_ = *(self1);
    int num_iterations=10;

    const char* keywords[] = { "num_iterations", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|i:ximgproc_SuperpixelSLIC.iterate", (char**)keywords, &num_iterations) )
    {
        ERRWRAP2(_self_->iterate(num_iterations));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_SuperpixelSLIC)

static PyGetSetDef pyopencv_ximgproc_SuperpixelSLIC_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_SuperpixelSLIC_methods[] =
{
    {"enforceLabelConnectivity", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_enforceLabelConnectivity, 0), "enforceLabelConnectivity([, min_element_size]) -> None\n.   @brief Enforce label connectivity.\n.   \n.       @param min_element_size The minimum element size in percents that should be absorbed into a bigger\n.       superpixel. Given resulted average superpixel size valid value should be in 0-100 range, 25 means\n.       that less then a quarter sized superpixel should be absorbed, this is default.\n.   \n.       The function merge component that is too small, assigning the previously found adjacent label\n.       to this component. Calling this function may change the final number of superpixels."},
    {"getLabelContourMask", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_getLabelContourMask, 0), "getLabelContourMask([, image[, thick_line]]) -> image\n.   @brief Returns the mask of the superpixel segmentation stored in SuperpixelSLIC object.\n.   \n.       @param image Return: CV_8U1 image mask where -1 indicates that the pixel is a superpixel border,\n.       and 0 otherwise.\n.   \n.       @param thick_line If false, the border is only one pixel wide, otherwise all pixels at the border\n.       are masked.\n.   \n.       The function return the boundaries of the superpixel segmentation."},
    {"getLabels", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_getLabels, 0), "getLabels([, labels_out]) -> labels_out\n.   @brief Returns the segmentation labeling of the image.\n.   \n.       Each label represents a superpixel, and each pixel is assigned to one superpixel label.\n.   \n.       @param labels_out Return: A CV_32SC1 integer array containing the labels of the superpixel\n.       segmentation. The labels are in the range [0, getNumberOfSuperpixels()].\n.   \n.       The function returns an image with the labels of the superpixel segmentation. The labels are in\n.       the range [0, getNumberOfSuperpixels()]."},
    {"getNumberOfSuperpixels", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_getNumberOfSuperpixels, 0), "getNumberOfSuperpixels() -> retval\n.   @brief Calculates the actual amount of superpixels on a given segmentation computed\n.       and stored in SuperpixelSLIC object."},
    {"iterate", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_ximgproc_SuperpixelSLIC_iterate, 0), "iterate([, num_iterations]) -> None\n.   @brief Calculates the superpixel segmentation on a given image with the initialized\n.       parameters in the SuperpixelSLIC object.\n.   \n.       This function can be called again without the need of initializing the algorithm with\n.       createSuperpixelSLIC(). This save the computational cost of allocating memory for all the\n.       structures of the algorithm.\n.   \n.       @param num_iterations Number of iterations. Higher number improves the result.\n.   \n.       The function computes the superpixels segmentation of an image with the parameters initialized\n.       with the function createSuperpixelSLIC(). The algorithms starts from a grid of superpixels and\n.       then refines the boundaries by proposing updates of edges boundaries."},

    {NULL,          NULL}
};

// Converter (ximgproc_SuperpixelSLIC)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::SuperpixelSLIC> >
{
    static PyObject* from(const Ptr<cv::ximgproc::SuperpixelSLIC>& r)
    {
        return pyopencv_ximgproc_SuperpixelSLIC_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::SuperpixelSLIC>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::SuperpixelSLIC> * dst_;
        if (pyopencv_ximgproc_SuperpixelSLIC_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::SuperpixelSLIC> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_segmentation_GraphSegmentation (Generic)
//================================================================================

// GetSet (ximgproc_segmentation_GraphSegmentation)



// Methods (ximgproc_segmentation_GraphSegmentation)

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_getK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::GraphSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_GraphSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_GraphSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::GraphSegmentation> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getK());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_getMinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::GraphSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_GraphSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_GraphSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::GraphSegmentation> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getMinSize());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_getSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::GraphSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_GraphSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_GraphSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::GraphSegmentation> _self_ = *(self1);
    double retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigma());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_processImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::GraphSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_GraphSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_GraphSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::GraphSegmentation> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_segmentation_GraphSegmentation.processImage", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->processImage(src, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:ximgproc_segmentation_GraphSegmentation.processImage", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->processImage(src, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_setK(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::GraphSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_GraphSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_GraphSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::GraphSegmentation> _self_ = *(self1);
    float k=0.f;

    const char* keywords[] = { "k", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:ximgproc_segmentation_GraphSegmentation.setK", (char**)keywords, &k) )
    {
        ERRWRAP2(_self_->setK(k));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_setMinSize(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::GraphSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_GraphSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_GraphSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::GraphSegmentation> _self_ = *(self1);
    int min_size=0;

    const char* keywords[] = { "min_size", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:ximgproc_segmentation_GraphSegmentation.setMinSize", (char**)keywords, &min_size) )
    {
        ERRWRAP2(_self_->setMinSize(min_size));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_setSigma(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::GraphSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_GraphSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_GraphSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::GraphSegmentation> _self_ = *(self1);
    double sigma=0;

    const char* keywords[] = { "sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "d:ximgproc_segmentation_GraphSegmentation.setSigma", (char**)keywords, &sigma) )
    {
        ERRWRAP2(_self_->setSigma(sigma));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_segmentation_GraphSegmentation)

static PyGetSetDef pyopencv_ximgproc_segmentation_GraphSegmentation_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_segmentation_GraphSegmentation_methods[] =
{
    {"getK", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_getK, 0), "getK() -> retval\n."},
    {"getMinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_getMinSize, 0), "getMinSize() -> retval\n."},
    {"getSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_getSigma, 0), "getSigma() -> retval\n."},
    {"processImage", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_processImage, 0), "processImage(src[, dst]) -> dst\n.   @brief Segment an image and store output in dst\n.                                   @param src The input image. Any number of channel (1 (Eg: Gray), 3 (Eg: RGB), 4 (Eg: RGB-D)) can be provided\n.                                   @param dst The output segmentation. It's a CV_32SC1 Mat with the same number of cols and rows as input image, with an unique, sequential, id for each pixel."},
    {"setK", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_setK, 0), "setK(k) -> None\n."},
    {"setMinSize", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_setMinSize, 0), "setMinSize(min_size) -> None\n."},
    {"setSigma", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_GraphSegmentation_setSigma, 0), "setSigma(sigma) -> None\n."},

    {NULL,          NULL}
};

// Converter (ximgproc_segmentation_GraphSegmentation)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::segmentation::GraphSegmentation> >
{
    static PyObject* from(const Ptr<cv::ximgproc::segmentation::GraphSegmentation>& r)
    {
        return pyopencv_ximgproc_segmentation_GraphSegmentation_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::segmentation::GraphSegmentation>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::segmentation::GraphSegmentation> * dst_;
        if (pyopencv_ximgproc_segmentation_GraphSegmentation_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::segmentation::GraphSegmentation> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_segmentation_SelectiveSearchSegmentation (Generic)
//================================================================================

// GetSet (ximgproc_segmentation_SelectiveSearchSegmentation)



// Methods (ximgproc_segmentation_SelectiveSearchSegmentation)

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_addGraphSegmentation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);
    PyObject* pyobj_g = NULL;
    Ptr<GraphSegmentation> g;

    const char* keywords[] = { "g", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ximgproc_segmentation_SelectiveSearchSegmentation.addGraphSegmentation", (char**)keywords, &pyobj_g) &&
        pyopencv_to(pyobj_g, g, ArgInfo("g", 0)) )
    {
        ERRWRAP2(_self_->addGraphSegmentation(g));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_addImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;

    const char* keywords[] = { "img", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ximgproc_segmentation_SelectiveSearchSegmentation.addImage", (char**)keywords, &pyobj_img) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(_self_->addImage(img));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;

    const char* keywords[] = { "img", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ximgproc_segmentation_SelectiveSearchSegmentation.addImage", (char**)keywords, &pyobj_img) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(_self_->addImage(img));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_addStrategy(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);
    PyObject* pyobj_s = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s;

    const char* keywords[] = { "s", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ximgproc_segmentation_SelectiveSearchSegmentation.addStrategy", (char**)keywords, &pyobj_s) &&
        pyopencv_to(pyobj_s, s, ArgInfo("s", 0)) )
    {
        ERRWRAP2(_self_->addStrategy(s));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_clearGraphSegmentations(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clearGraphSegmentations());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_clearImages(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clearImages());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_clearStrategies(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clearStrategies());
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_process(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);
    vector_Rect rects;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->process(rects));
        return pyopencv_from(rects);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_setBaseImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;

    const char* keywords[] = { "img", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ximgproc_segmentation_SelectiveSearchSegmentation.setBaseImage", (char**)keywords, &pyobj_img) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(_self_->setBaseImage(img));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;

    const char* keywords[] = { "img", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O:ximgproc_segmentation_SelectiveSearchSegmentation.setBaseImage", (char**)keywords, &pyobj_img) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) )
    {
        ERRWRAP2(_self_->setBaseImage(img));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchFast(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);
    int base_k=150;
    int inc_k=150;
    float sigma=0.8f;

    const char* keywords[] = { "base_k", "inc_k", "sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iif:ximgproc_segmentation_SelectiveSearchSegmentation.switchToSelectiveSearchFast", (char**)keywords, &base_k, &inc_k, &sigma) )
    {
        ERRWRAP2(_self_->switchToSelectiveSearchFast(base_k, inc_k, sigma));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchQuality(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);
    int base_k=150;
    int inc_k=150;
    float sigma=0.8f;

    const char* keywords[] = { "base_k", "inc_k", "sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|iif:ximgproc_segmentation_SelectiveSearchSegmentation.switchToSelectiveSearchQuality", (char**)keywords, &base_k, &inc_k, &sigma) )
    {
        ERRWRAP2(_self_->switchToSelectiveSearchQuality(base_k, inc_k, sigma));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSingleStrategy(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentation' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> _self_ = *(self1);
    int k=200;
    float sigma=0.8f;

    const char* keywords[] = { "k", "sigma", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "|if:ximgproc_segmentation_SelectiveSearchSegmentation.switchToSingleStrategy", (char**)keywords, &k, &sigma) )
    {
        ERRWRAP2(_self_->switchToSingleStrategy(k, sigma));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_segmentation_SelectiveSearchSegmentation)

static PyGetSetDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_methods[] =
{
    {"addGraphSegmentation", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_addGraphSegmentation, 0), "addGraphSegmentation(g) -> None\n.   @brief Add a new graph segmentation in the list of graph segementations to process.\n.                                   @param g The graph segmentation"},
    {"addImage", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_addImage, 0), "addImage(img) -> None\n.   @brief Add a new image in the list of images to process.\n.                                   @param img The image"},
    {"addStrategy", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_addStrategy, 0), "addStrategy(s) -> None\n.   @brief Add a new strategy in the list of strategy to process.\n.                                   @param s The strategy"},
    {"clearGraphSegmentations", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_clearGraphSegmentations, 0), "clearGraphSegmentations() -> None\n.   @brief Clear the list of graph segmentations to process;"},
    {"clearImages", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_clearImages, 0), "clearImages() -> None\n.   @brief Clear the list of images to process"},
    {"clearStrategies", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_clearStrategies, 0), "clearStrategies() -> None\n.   @brief Clear the list of strategy to process;"},
    {"process", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_process, 0), "process() -> rects\n.   @brief Based on all images, graph segmentations and stragies, computes all possible rects and return them\n.                                   @param rects The list of rects. The first ones are more relevents than the lasts ones."},
    {"setBaseImage", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_setBaseImage, 0), "setBaseImage(img) -> None\n.   @brief Set a image used by switch* functions to initialize the class\n.                                   @param img The image"},
    {"switchToSelectiveSearchFast", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchFast, 0), "switchToSelectiveSearchFast([, base_k[, inc_k[, sigma]]]) -> None\n.   @brief Initialize the class with the 'Selective search fast' parameters describled in @cite uijlings2013selective.\n.                                   @param base_k The k parameter for the first graph segmentation\n.                                   @param inc_k The increment of the k parameter for all graph segmentations\n.                                   @param sigma The sigma parameter for the graph segmentation"},
    {"switchToSelectiveSearchQuality", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchQuality, 0), "switchToSelectiveSearchQuality([, base_k[, inc_k[, sigma]]]) -> None\n.   @brief Initialize the class with the 'Selective search fast' parameters describled in @cite uijlings2013selective.\n.                                   @param base_k The k parameter for the first graph segmentation\n.                                   @param inc_k The increment of the k parameter for all graph segmentations\n.                                   @param sigma The sigma parameter for the graph segmentation"},
    {"switchToSingleStrategy", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSingleStrategy, 0), "switchToSingleStrategy([, k[, sigma]]) -> None\n.   @brief Initialize the class with the 'Single stragegy' parameters describled in @cite uijlings2013selective.\n.                                   @param k The k parameter for the graph segmentation\n.                                   @param sigma The sigma parameter for the graph segmentation"},

    {NULL,          NULL}
};

// Converter (ximgproc_segmentation_SelectiveSearchSegmentation)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> >
{
    static PyObject* from(const Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation>& r)
    {
        return pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> * dst_;
        if (pyopencv_ximgproc_segmentation_SelectiveSearchSegmentation_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentation> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_segmentation_SelectiveSearchSegmentationStrategy (Generic)
//================================================================================

// GetSet (ximgproc_segmentation_SelectiveSearchSegmentationStrategy)



// Methods (ximgproc_segmentation_SelectiveSearchSegmentationStrategy)

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_get(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentationStrategy' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> _self_ = *(self1);
    int r1=0;
    int r2=0;
    float retval;

    const char* keywords[] = { "r1", "r2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:ximgproc_segmentation_SelectiveSearchSegmentationStrategy.get", (char**)keywords, &r1, &r2) )
    {
        ERRWRAP2(retval = _self_->get(r1, r2));
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_merge(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentationStrategy' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> _self_ = *(self1);
    int r1=0;
    int r2=0;

    const char* keywords[] = { "r1", "r2", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "ii:ximgproc_segmentation_SelectiveSearchSegmentationStrategy.merge", (char**)keywords, &r1, &r2) )
    {
        ERRWRAP2(_self_->merge(r1, r2));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_setImage(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentationStrategy' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> _self_ = *(self1);
    {
    PyObject* pyobj_img = NULL;
    Mat img;
    PyObject* pyobj_regions = NULL;
    Mat regions;
    PyObject* pyobj_sizes = NULL;
    Mat sizes;
    int image_id=-1;

    const char* keywords[] = { "img", "regions", "sizes", "image_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|i:ximgproc_segmentation_SelectiveSearchSegmentationStrategy.setImage", (char**)keywords, &pyobj_img, &pyobj_regions, &pyobj_sizes, &image_id) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_regions, regions, ArgInfo("regions", 0)) &&
        pyopencv_to(pyobj_sizes, sizes, ArgInfo("sizes", 0)) )
    {
        ERRWRAP2(_self_->setImage(img, regions, sizes, image_id));
        Py_RETURN_NONE;
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_img = NULL;
    UMat img;
    PyObject* pyobj_regions = NULL;
    UMat regions;
    PyObject* pyobj_sizes = NULL;
    UMat sizes;
    int image_id=-1;

    const char* keywords[] = { "img", "regions", "sizes", "image_id", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "OOO|i:ximgproc_segmentation_SelectiveSearchSegmentationStrategy.setImage", (char**)keywords, &pyobj_img, &pyobj_regions, &pyobj_sizes, &image_id) &&
        pyopencv_to(pyobj_img, img, ArgInfo("img", 0)) &&
        pyopencv_to(pyobj_regions, regions, ArgInfo("regions", 0)) &&
        pyopencv_to(pyobj_sizes, sizes, ArgInfo("sizes", 0)) )
    {
        ERRWRAP2(_self_->setImage(img, regions, sizes, image_id));
        Py_RETURN_NONE;
    }
    }

    return NULL;
}



// Tables (ximgproc_segmentation_SelectiveSearchSegmentationStrategy)

static PyGetSetDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_methods[] =
{
    {"get", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_get, 0), "get(r1, r2) -> retval\n.   @brief Return the score between two regions (between 0 and 1)\n.                                   @param r1 The first region\n.                                   @param r2 The second region"},
    {"merge", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_merge, 0), "merge(r1, r2) -> None\n.   @brief Inform the strategy that two regions will be merged\n.                                   @param r1 The first region\n.                                   @param r2 The second region"},
    {"setImage", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_setImage, 0), "setImage(img, regions, sizes[, image_id]) -> None\n.   @brief Set a initial image, with a segementation.\n.                                   @param img The input image. Any number of channel can be provided\n.                                   @param regions A segementation of the image. The parameter must be the same size of img.\n.                                   @param sizes The sizes of different regions\n.                                   @param image_id If not set to -1, try to cache pre-computations. If the same set og (img, regions, size) is used, the image_id need to be the same."},

    {NULL,          NULL}
};

// Converter (ximgproc_segmentation_SelectiveSearchSegmentationStrategy)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> >
{
    static PyObject* from(const Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy>& r)
    {
        return pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> * dst_;
        if (pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor (Generic)
//================================================================================

// GetSet (ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor)



// Methods (ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor)



// Tables (ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor)

static PyGetSetDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor_methods[] =
{

    {NULL,          NULL}
};

// Converter (ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor> >
{
    static PyObject* from(const Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor>& r)
    {
        return pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor> * dst_;
        if (pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyColor> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill (Generic)
//================================================================================

// GetSet (ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill)



// Methods (ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill)



// Tables (ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill)

static PyGetSetDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill_methods[] =
{

    {NULL,          NULL}
};

// Converter (ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill> >
{
    static PyObject* from(const Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill>& r)
    {
        return pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill> * dst_;
        if (pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyFill> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple (Generic)
//================================================================================

// GetSet (ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple)



// Methods (ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple)

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_addStrategy(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple> _self_ = *(self1);
    PyObject* pyobj_g = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> g;
    float weight=0.f;

    const char* keywords[] = { "g", "weight", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "Of:ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple.addStrategy", (char**)keywords, &pyobj_g, &weight) &&
        pyopencv_to(pyobj_g, g, ArgInfo("g", 0)) )
    {
        ERRWRAP2(_self_->addStrategy(g, weight));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_clearStrategies(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::ximgproc::segmentation;


    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple> * self1 = 0;
    if (!pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple' or its derivative)");
    Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple> _self_ = *(self1);

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(_self_->clearStrategies());
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple)

static PyGetSetDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_methods[] =
{
    {"addStrategy", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_addStrategy, 0), "addStrategy(g, weight) -> None\n.   @brief Add a new sub-strategy\n.                                   @param g The strategy\n.                                   @param weight The weight of the strategy"},
    {"clearStrategies", CV_PY_FN_WITH_KW_(pyopencv_cv_ximgproc_segmentation_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_clearStrategies, 0), "clearStrategies() -> None\n.   @brief Remove all sub-strategies"},

    {NULL,          NULL}
};

// Converter (ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple> >
{
    static PyObject* from(const Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple>& r)
    {
        return pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple> * dst_;
        if (pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyMultiple> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_segmentation_SelectiveSearchSegmentationStrategySize (Generic)
//================================================================================

// GetSet (ximgproc_segmentation_SelectiveSearchSegmentationStrategySize)



// Methods (ximgproc_segmentation_SelectiveSearchSegmentationStrategySize)



// Tables (ximgproc_segmentation_SelectiveSearchSegmentationStrategySize)

static PyGetSetDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySize_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySize_methods[] =
{

    {NULL,          NULL}
};

// Converter (ximgproc_segmentation_SelectiveSearchSegmentationStrategySize)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize> >
{
    static PyObject* from(const Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize>& r)
    {
        return pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySize_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize> * dst_;
        if (pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySize_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategySize> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture (Generic)
//================================================================================

// GetSet (ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture)



// Methods (ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture)



// Tables (ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture)

static PyGetSetDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture_methods[] =
{

    {NULL,          NULL}
};

// Converter (ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture)

template<>
struct PyOpenCV_Converter< Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture> >
{
    static PyObject* from(const Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture>& r)
    {
        return pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture> * dst_;
        if (pyopencv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategyTexture> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xphoto_GrayworldWB (Generic)
//================================================================================

// GetSet (xphoto_GrayworldWB)



// Methods (xphoto_GrayworldWB)

static PyObject* pyopencv_cv_xphoto_xphoto_GrayworldWB_getSaturationThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::GrayworldWB> * self1 = 0;
    if (!pyopencv_xphoto_GrayworldWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_GrayworldWB' or its derivative)");
    Ptr<cv::xphoto::GrayworldWB> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSaturationThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_GrayworldWB_setSaturationThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::GrayworldWB> * self1 = 0;
    if (!pyopencv_xphoto_GrayworldWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_GrayworldWB' or its derivative)");
    Ptr<cv::xphoto::GrayworldWB> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_GrayworldWB.setSaturationThreshold", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setSaturationThreshold(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (xphoto_GrayworldWB)

static PyGetSetDef pyopencv_xphoto_GrayworldWB_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xphoto_GrayworldWB_methods[] =
{
    {"getSaturationThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_GrayworldWB_getSaturationThreshold, 0), "getSaturationThreshold() -> retval\n.   @brief Maximum saturation for a pixel to be included in the\n.           gray-world assumption\n.   @see setSaturationThreshold"},
    {"setSaturationThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_GrayworldWB_setSaturationThreshold, 0), "setSaturationThreshold(val) -> None\n.   @copybrief getSaturationThreshold @see getSaturationThreshold"},

    {NULL,          NULL}
};

// Converter (xphoto_GrayworldWB)

template<>
struct PyOpenCV_Converter< Ptr<cv::xphoto::GrayworldWB> >
{
    static PyObject* from(const Ptr<cv::xphoto::GrayworldWB>& r)
    {
        return pyopencv_xphoto_GrayworldWB_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xphoto::GrayworldWB>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xphoto::GrayworldWB> * dst_;
        if (pyopencv_xphoto_GrayworldWB_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xphoto::GrayworldWB> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xphoto_LearningBasedWB (Generic)
//================================================================================

// GetSet (xphoto_LearningBasedWB)



// Methods (xphoto_LearningBasedWB)

static PyObject* pyopencv_cv_xphoto_xphoto_LearningBasedWB_extractSimpleFeatures(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::LearningBasedWB> * self1 = 0;
    if (!pyopencv_xphoto_LearningBasedWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_LearningBasedWB' or its derivative)");
    Ptr<cv::xphoto::LearningBasedWB> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:xphoto_LearningBasedWB.extractSimpleFeatures", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->extractSimpleFeatures(src, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:xphoto_LearningBasedWB.extractSimpleFeatures", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->extractSimpleFeatures(src, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_LearningBasedWB_getHistBinNum(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::LearningBasedWB> * self1 = 0;
    if (!pyopencv_xphoto_LearningBasedWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_LearningBasedWB' or its derivative)");
    Ptr<cv::xphoto::LearningBasedWB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getHistBinNum());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_LearningBasedWB_getRangeMaxVal(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::LearningBasedWB> * self1 = 0;
    if (!pyopencv_xphoto_LearningBasedWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_LearningBasedWB' or its derivative)");
    Ptr<cv::xphoto::LearningBasedWB> _self_ = *(self1);
    int retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getRangeMaxVal());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_LearningBasedWB_getSaturationThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::LearningBasedWB> * self1 = 0;
    if (!pyopencv_xphoto_LearningBasedWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_LearningBasedWB' or its derivative)");
    Ptr<cv::xphoto::LearningBasedWB> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSaturationThreshold());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_LearningBasedWB_setHistBinNum(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::LearningBasedWB> * self1 = 0;
    if (!pyopencv_xphoto_LearningBasedWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_LearningBasedWB' or its derivative)");
    Ptr<cv::xphoto::LearningBasedWB> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xphoto_LearningBasedWB.setHistBinNum", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setHistBinNum(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_LearningBasedWB_setRangeMaxVal(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::LearningBasedWB> * self1 = 0;
    if (!pyopencv_xphoto_LearningBasedWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_LearningBasedWB' or its derivative)");
    Ptr<cv::xphoto::LearningBasedWB> _self_ = *(self1);
    int val=0;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "i:xphoto_LearningBasedWB.setRangeMaxVal", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setRangeMaxVal(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_LearningBasedWB_setSaturationThreshold(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::LearningBasedWB> * self1 = 0;
    if (!pyopencv_xphoto_LearningBasedWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_LearningBasedWB' or its derivative)");
    Ptr<cv::xphoto::LearningBasedWB> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_LearningBasedWB.setSaturationThreshold", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setSaturationThreshold(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (xphoto_LearningBasedWB)

static PyGetSetDef pyopencv_xphoto_LearningBasedWB_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xphoto_LearningBasedWB_methods[] =
{
    {"extractSimpleFeatures", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_LearningBasedWB_extractSimpleFeatures, 0), "extractSimpleFeatures(src[, dst]) -> dst\n.   @brief Implements the feature extraction part of the algorithm.\n.   \n.       In accordance with @cite Cheng2015 , computes the following features for the input image:\n.       1. Chromaticity of an average (R,G,B) tuple\n.       2. Chromaticity of the brightest (R,G,B) tuple (while ignoring saturated pixels)\n.       3. Chromaticity of the dominant (R,G,B) tuple (the one that has the highest value in the RGB histogram)\n.       4. Mode of the chromaticity palette, that is constructed by taking 300 most common colors according to\n.          the RGB histogram and projecting them on the chromaticity plane. Mode is the most high-density point\n.          of the palette, which is computed by a straightforward fixed-bandwidth kernel density estimator with\n.          a Epanechnikov kernel function.\n.   \n.       @param src Input three-channel image (BGR color space is assumed).\n.       @param dst An array of four (r,g) chromaticity tuples corresponding to the features listed above."},
    {"getHistBinNum", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_LearningBasedWB_getHistBinNum, 0), "getHistBinNum() -> retval\n.   @brief Defines the size of one dimension of a three-dimensional RGB histogram that is used internally\n.           by the algorithm. It often makes sense to increase the number of bins for images with higher bit depth\n.           (e.g. 256 bins for a 12 bit image).\n.   @see setHistBinNum"},
    {"getRangeMaxVal", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_LearningBasedWB_getRangeMaxVal, 0), "getRangeMaxVal() -> retval\n.   @brief Maximum possible value of the input image (e.g. 255 for 8 bit images,\n.                  4095 for 12 bit images)\n.   @see setRangeMaxVal"},
    {"getSaturationThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_LearningBasedWB_getSaturationThreshold, 0), "getSaturationThreshold() -> retval\n.   @brief Threshold that is used to determine saturated pixels, i.e. pixels where at least one of the\n.           channels exceeds \\f$\\texttt{saturation_threshold}\\times\\texttt{range_max_val}\\f$ are ignored.\n.   @see setSaturationThreshold"},
    {"setHistBinNum", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_LearningBasedWB_setHistBinNum, 0), "setHistBinNum(val) -> None\n.   @copybrief getHistBinNum @see getHistBinNum"},
    {"setRangeMaxVal", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_LearningBasedWB_setRangeMaxVal, 0), "setRangeMaxVal(val) -> None\n.   @copybrief getRangeMaxVal @see getRangeMaxVal"},
    {"setSaturationThreshold", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_LearningBasedWB_setSaturationThreshold, 0), "setSaturationThreshold(val) -> None\n.   @copybrief getSaturationThreshold @see getSaturationThreshold"},

    {NULL,          NULL}
};

// Converter (xphoto_LearningBasedWB)

template<>
struct PyOpenCV_Converter< Ptr<cv::xphoto::LearningBasedWB> >
{
    static PyObject* from(const Ptr<cv::xphoto::LearningBasedWB>& r)
    {
        return pyopencv_xphoto_LearningBasedWB_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xphoto::LearningBasedWB>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xphoto::LearningBasedWB> * dst_;
        if (pyopencv_xphoto_LearningBasedWB_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xphoto::LearningBasedWB> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xphoto_SimpleWB (Generic)
//================================================================================

// GetSet (xphoto_SimpleWB)



// Methods (xphoto_SimpleWB)

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_getInputMax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInputMax());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_getInputMin(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getInputMin());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_getOutputMax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getOutputMax());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_getOutputMin(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getOutputMin());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_getP(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getP());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_setInputMax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_SimpleWB.setInputMax", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setInputMax(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_setInputMin(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_SimpleWB.setInputMin", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setInputMin(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_setOutputMax(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_SimpleWB.setOutputMax", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setOutputMax(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_setOutputMin(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_SimpleWB.setOutputMin", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setOutputMin(val));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_SimpleWB_setP(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::SimpleWB> * self1 = 0;
    if (!pyopencv_xphoto_SimpleWB_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_SimpleWB' or its derivative)");
    Ptr<cv::xphoto::SimpleWB> _self_ = *(self1);
    float val=0.f;

    const char* keywords[] = { "val", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_SimpleWB.setP", (char**)keywords, &val) )
    {
        ERRWRAP2(_self_->setP(val));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (xphoto_SimpleWB)

static PyGetSetDef pyopencv_xphoto_SimpleWB_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xphoto_SimpleWB_methods[] =
{
    {"getInputMax", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_getInputMax, 0), "getInputMax() -> retval\n.   @brief Input image range maximum value\n.   @see setInputMax"},
    {"getInputMin", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_getInputMin, 0), "getInputMin() -> retval\n.   @brief Input image range minimum value\n.   @see setInputMin"},
    {"getOutputMax", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_getOutputMax, 0), "getOutputMax() -> retval\n.   @brief Output image range maximum value\n.   @see setOutputMax"},
    {"getOutputMin", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_getOutputMin, 0), "getOutputMin() -> retval\n.   @brief Output image range minimum value\n.   @see setOutputMin"},
    {"getP", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_getP, 0), "getP() -> retval\n.   @brief Percent of top/bottom values to ignore\n.   @see setP"},
    {"setInputMax", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_setInputMax, 0), "setInputMax(val) -> None\n.   @copybrief getInputMax @see getInputMax"},
    {"setInputMin", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_setInputMin, 0), "setInputMin(val) -> None\n.   @copybrief getInputMin @see getInputMin"},
    {"setOutputMax", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_setOutputMax, 0), "setOutputMax(val) -> None\n.   @copybrief getOutputMax @see getOutputMax"},
    {"setOutputMin", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_setOutputMin, 0), "setOutputMin(val) -> None\n.   @copybrief getOutputMin @see getOutputMin"},
    {"setP", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_SimpleWB_setP, 0), "setP(val) -> None\n.   @copybrief getP @see getP"},

    {NULL,          NULL}
};

// Converter (xphoto_SimpleWB)

template<>
struct PyOpenCV_Converter< Ptr<cv::xphoto::SimpleWB> >
{
    static PyObject* from(const Ptr<cv::xphoto::SimpleWB>& r)
    {
        return pyopencv_xphoto_SimpleWB_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xphoto::SimpleWB>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xphoto::SimpleWB> * dst_;
        if (pyopencv_xphoto_SimpleWB_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xphoto::SimpleWB> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xphoto_TonemapDurand (Generic)
//================================================================================

// GetSet (xphoto_TonemapDurand)



// Methods (xphoto_TonemapDurand)

static PyObject* pyopencv_cv_xphoto_xphoto_TonemapDurand_getContrast(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::TonemapDurand> * self1 = 0;
    if (!pyopencv_xphoto_TonemapDurand_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_TonemapDurand' or its derivative)");
    Ptr<cv::xphoto::TonemapDurand> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getContrast());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_TonemapDurand_getSaturation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::TonemapDurand> * self1 = 0;
    if (!pyopencv_xphoto_TonemapDurand_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_TonemapDurand' or its derivative)");
    Ptr<cv::xphoto::TonemapDurand> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSaturation());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_TonemapDurand_getSigmaColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::TonemapDurand> * self1 = 0;
    if (!pyopencv_xphoto_TonemapDurand_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_TonemapDurand' or its derivative)");
    Ptr<cv::xphoto::TonemapDurand> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigmaColor());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_TonemapDurand_getSigmaSpace(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::TonemapDurand> * self1 = 0;
    if (!pyopencv_xphoto_TonemapDurand_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_TonemapDurand' or its derivative)");
    Ptr<cv::xphoto::TonemapDurand> _self_ = *(self1);
    float retval;

    if(PyObject_Size(args) == 0 && (!kw || PyObject_Size(kw) == 0))
    {
        ERRWRAP2(retval = _self_->getSigmaSpace());
        return pyopencv_from(retval);
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_TonemapDurand_setContrast(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::TonemapDurand> * self1 = 0;
    if (!pyopencv_xphoto_TonemapDurand_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_TonemapDurand' or its derivative)");
    Ptr<cv::xphoto::TonemapDurand> _self_ = *(self1);
    float contrast=0.f;

    const char* keywords[] = { "contrast", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_TonemapDurand.setContrast", (char**)keywords, &contrast) )
    {
        ERRWRAP2(_self_->setContrast(contrast));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_TonemapDurand_setSaturation(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::TonemapDurand> * self1 = 0;
    if (!pyopencv_xphoto_TonemapDurand_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_TonemapDurand' or its derivative)");
    Ptr<cv::xphoto::TonemapDurand> _self_ = *(self1);
    float saturation=0.f;

    const char* keywords[] = { "saturation", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_TonemapDurand.setSaturation", (char**)keywords, &saturation) )
    {
        ERRWRAP2(_self_->setSaturation(saturation));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_TonemapDurand_setSigmaColor(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::TonemapDurand> * self1 = 0;
    if (!pyopencv_xphoto_TonemapDurand_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_TonemapDurand' or its derivative)");
    Ptr<cv::xphoto::TonemapDurand> _self_ = *(self1);
    float sigma_color=0.f;

    const char* keywords[] = { "sigma_color", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_TonemapDurand.setSigmaColor", (char**)keywords, &sigma_color) )
    {
        ERRWRAP2(_self_->setSigmaColor(sigma_color));
        Py_RETURN_NONE;
    }

    return NULL;
}

static PyObject* pyopencv_cv_xphoto_xphoto_TonemapDurand_setSigmaSpace(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::TonemapDurand> * self1 = 0;
    if (!pyopencv_xphoto_TonemapDurand_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_TonemapDurand' or its derivative)");
    Ptr<cv::xphoto::TonemapDurand> _self_ = *(self1);
    float sigma_space=0.f;

    const char* keywords[] = { "sigma_space", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "f:xphoto_TonemapDurand.setSigmaSpace", (char**)keywords, &sigma_space) )
    {
        ERRWRAP2(_self_->setSigmaSpace(sigma_space));
        Py_RETURN_NONE;
    }

    return NULL;
}



// Tables (xphoto_TonemapDurand)

static PyGetSetDef pyopencv_xphoto_TonemapDurand_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xphoto_TonemapDurand_methods[] =
{
    {"getContrast", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_TonemapDurand_getContrast, 0), "getContrast() -> retval\n."},
    {"getSaturation", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_TonemapDurand_getSaturation, 0), "getSaturation() -> retval\n."},
    {"getSigmaColor", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_TonemapDurand_getSigmaColor, 0), "getSigmaColor() -> retval\n."},
    {"getSigmaSpace", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_TonemapDurand_getSigmaSpace, 0), "getSigmaSpace() -> retval\n."},
    {"setContrast", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_TonemapDurand_setContrast, 0), "setContrast(contrast) -> None\n."},
    {"setSaturation", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_TonemapDurand_setSaturation, 0), "setSaturation(saturation) -> None\n."},
    {"setSigmaColor", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_TonemapDurand_setSigmaColor, 0), "setSigmaColor(sigma_color) -> None\n."},
    {"setSigmaSpace", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_TonemapDurand_setSigmaSpace, 0), "setSigmaSpace(sigma_space) -> None\n."},

    {NULL,          NULL}
};

// Converter (xphoto_TonemapDurand)

template<>
struct PyOpenCV_Converter< Ptr<cv::xphoto::TonemapDurand> >
{
    static PyObject* from(const Ptr<cv::xphoto::TonemapDurand>& r)
    {
        return pyopencv_xphoto_TonemapDurand_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xphoto::TonemapDurand>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xphoto::TonemapDurand> * dst_;
        if (pyopencv_xphoto_TonemapDurand_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xphoto::TonemapDurand> for argument '%%s'", name);
        return false;
    }
};

//================================================================================
// xphoto_WhiteBalancer (Generic)
//================================================================================

// GetSet (xphoto_WhiteBalancer)



// Methods (xphoto_WhiteBalancer)

static PyObject* pyopencv_cv_xphoto_xphoto_WhiteBalancer_balanceWhite(PyObject* self, PyObject* args, PyObject* kw)
{
    using namespace cv::xphoto;


    Ptr<cv::xphoto::WhiteBalancer> * self1 = 0;
    if (!pyopencv_xphoto_WhiteBalancer_getp(self, self1))
        return failmsgp("Incorrect type of self (must be 'xphoto_WhiteBalancer' or its derivative)");
    Ptr<cv::xphoto::WhiteBalancer> _self_ = *(self1);
    {
    PyObject* pyobj_src = NULL;
    Mat src;
    PyObject* pyobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:xphoto_WhiteBalancer.balanceWhite", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->balanceWhite(src, dst));
        return pyopencv_from(dst);
    }
    }
    PyErr_Clear();

    {
    PyObject* pyobj_src = NULL;
    UMat src;
    PyObject* pyobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if( PyArg_ParseTupleAndKeywords(args, kw, "O|O:xphoto_WhiteBalancer.balanceWhite", (char**)keywords, &pyobj_src, &pyobj_dst) &&
        pyopencv_to(pyobj_src, src, ArgInfo("src", 0)) &&
        pyopencv_to(pyobj_dst, dst, ArgInfo("dst", 1)) )
    {
        ERRWRAP2(_self_->balanceWhite(src, dst));
        return pyopencv_from(dst);
    }
    }

    return NULL;
}



// Tables (xphoto_WhiteBalancer)

static PyGetSetDef pyopencv_xphoto_WhiteBalancer_getseters[] =
{
    {NULL}  /* Sentinel */
};

static PyMethodDef pyopencv_xphoto_WhiteBalancer_methods[] =
{
    {"balanceWhite", CV_PY_FN_WITH_KW_(pyopencv_cv_xphoto_xphoto_WhiteBalancer_balanceWhite, 0), "balanceWhite(src[, dst]) -> dst\n.   @brief Applies white balancing to the input image\n.   \n.       @param src Input image\n.       @param dst White balancing result\n.       @sa cvtColor, equalizeHist"},

    {NULL,          NULL}
};

// Converter (xphoto_WhiteBalancer)

template<>
struct PyOpenCV_Converter< Ptr<cv::xphoto::WhiteBalancer> >
{
    static PyObject* from(const Ptr<cv::xphoto::WhiteBalancer>& r)
    {
        return pyopencv_xphoto_WhiteBalancer_Instance(r);
    }
    static bool to(PyObject* src, Ptr<cv::xphoto::WhiteBalancer>& dst, const char* name)
    {
        if(!src || src == Py_None)
            return true;
        Ptr<cv::xphoto::WhiteBalancer> * dst_;
        if (pyopencv_xphoto_WhiteBalancer_getp(src, dst_))
        {
            dst = *dst_;
            return true;
        }
        
        failmsg("Expected Ptr<cv::xphoto::WhiteBalancer> for argument '%%s'", name);
        return false;
    }
};

